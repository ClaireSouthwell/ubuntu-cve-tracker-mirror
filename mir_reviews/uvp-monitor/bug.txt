I reviewed uvp-monitor/ version 288eea690ffe61f189ea51b13c77c6bb465953ec
as checked out from https://github.com/UVP-Tools/UVP-Tools.git . This
should not be considered a full security audit but rather a quick gauge of
maintainability.

- disk.c: strAdd(), strMInux(), strMulti() are extremely complicated. Why
  aren't they strtoll(A) + or - or * strtoll(B)? They could be ~ten lines
  long with much simpler error handling.
- disk.c: unitTransfer() is extremely complicated. Why isn't it strtoll()
  with a division? It could be ~ten lines long with much simpler error
  handling.
- disk.c: openPipe() and openFile() serve only to make it harder to review
  code.
- disk.c: freePath() performs redundant non-NULL checks; free(NULL) is
  specified to take no action. freePath() could be three lines long, or
  even removed entirely, since it is used four times, once incorrectly.
- disk.c: isCorrectDev() skips SAS drives?
- disk.c: getDmParentNode() uses getDiskNameFromPartName() to populate the
  disk name from the part name. These two buffers are different sizes. The
  code assumes that there will be no more than ten alphabetic characters
  in the name, without any checks at all. How will this handle e.g.
  /dev/nvme0n1p2
- netinfo.c: GetIpv6Flux() calls getVifData() repeatedly which re-walks
  the same string over and over again. This seems appropriate for
  sscanf(3) instead, to capture all values once using a standard C library
  function?
- netinfo.c: GetIpv4VifGateway() has shell command line injection flaw via
  ifname parameter
- netinfo.c: Inet6Rresolve() passes the size of a source string to the
  strncpy_s() routines rather than the size of the destination buffer. It
  doesn't currently look like a security issue but it could become one.
- cpuinfo.c: hardcodes a maximum number of CPUs of only 64! It's possible
  for end consumers to order 384 core systems.
- xenctlmon.c: condition() is useless
- xenctlmon.c: do_time_sync() is brutal -- it jumps the clock by entire
  seconds rather than skewing time as ntpd would
- xenctlmon.c: do_cp_version_files() should not rely upon
  snprintf_s() to build the command string when all inputs are known at
  compile time, C's string concatenation is better. Also, this should
  probably be re-written to use C native API. Or thrown away entirely to
  perform updates via the installed system's native updates.
- xenctlmon.c: do_tools_watch_proc() wakes up every five seconds to
  perform hypercalls, memory allocations, string searches, directory and
  file operations, and command executions. In every VM on a system with
  thousands of VMs?
- xenctlmon.c: set_tip_message() uses snprintf_s() in order to build
  strings from contents that are completely known at compile time. C's
  string concatenation is better.
- xenstore_common.c: openxenstore() uses fcntl(.. FD_CLOEXEC); modern Linux
  allows setting this directly in the open(2) call.
- xenstore_common.c: write_to_xenstore() fd_pre and fd_aft looks like an
  attempt to deal with race conditions in the daemon:
  - multiple threads working simultaneously
  - no concurrency controls to ensure atomic use of xenstore writes
  - this can be solved either by
    - undoing all the threading or
    - by adding a new communication thread that all the other threads use
      to talk with xenstore or
    - adding pthread_cond_*() functions to ensure the xenstore interface
      is used by only one tool at a time or
    - set up the xenstore interface so it's ready to be used by the other
      threads before they start (see pthread_once), and then re-design all
      uses of xenstore to use only atomic operations.

Many functions use void *handle parameters and cast the handle in every
function body. This allows type-punning bugs to thrive. Use strong types.

Many functions use "if (NULL == foo) return false;" kinds of guards.
Should these instead issue asserts() so that error condtions can be
discovered and repaied?

