#!/usr/bin/env python

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2005-2012 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, re, sys, cve_lib, time
import optparse

import source_map
source = source_map.load()

def pkg_in_rel(pkg,rel):
    if rel in ['upstream']:
        return True
    if not source.has_key(rel):
        return False
    return source[rel].has_key(pkg)

releases = ['upstream'] + cve_lib.releases

max_file_size = 10 * 1024 * 1024  # 10MB
cvedir = cve_lib.active_dir
boilerplates = cvedir

parser = optparse.OptionParser()
parser.add_option("-p", "--package", dest="pkgs", help="Package name and optional version where package is fixed (with optional Ubuntu release and version in that release)", metavar="NAME[,VERSION[,RELEASE,RELEASE_VERSION]]", action="append")
parser.add_option("-b", "--bug-url", dest="bug_urls", help="Bug references", metavar="URL", action="append")
parser.add_option("-r", "--reference-url", dest="ref_urls", help="URL references", metavar="URL", action="append")
parser.add_option("-c", "--cve", dest="cve", help="CVE entry", metavar="CVE-YYYY-NNNN")
parser.add_option("-e", "--embargoed", dest="embargoed", help="This is an embargoed entry", action="store_true")
parser.add_option("-y", "--yes", dest="autoconfirm", help="Do not ask for confirmation", action="store_true")
parser.add_option("-P", "--public", help="Record date the CVE went public", metavar="YYYY-MM-DD")
(options, args) = parser.parse_args()

def update_cve(cve, pkgname, fixed_in=None, fixed_in_release=None, fixed_in_release_version=None):
    '''Update an existing CVE file'''
    file = open(os.path.join(cvedir, cve), "r")
    lines =  file.read(max_file_size).split('\n')
    file.close()

    skipped = []
    added_lines = ""

    for line in lines:
        for r in releases:
            if r == cve_lib.devel_release:
                r = 'devel'
            if not re.match(r'^' + r + ".*:", line):
                continue
            tmp = line.split(':')
            match = "%s_%s" % (r, pkgname)
            if match == tmp[0]:
                skipped.append(r)

    if len(skipped) == 0:
        added_lines += '\nPatches_' + pkgname + ':\n'

    higher_not_affected = False
    for release in releases:
        r = release
        if r == cve_lib.devel_release:
            r = 'devel'

        if r in skipped:
             os.write(sys.stderr.fileno(), "skipping '" + pkgname + "' for " + r + " (already included)\n")
        else:
            # skip eol_releases releases
            if r in cve_lib.eol_releases:
                continue
            state = "needs-triage"
            if not pkg_in_rel(pkgname,release):
                state = "DNE"
            elif r == 'upstream' and fixed_in != None:
                state = "released (%s)" % fixed_in
            elif fixed_in_release_version and r == fixed_in_release:
                state = "not-affected (%s)" % fixed_in_release_version
                higher_not_affected = True
            elif higher_not_affected:
                state = "not-affected"
            added_lines += '%s_%s: %s\n' % (r, pkgname, state)

    if len(releases) == len(skipped):
        os.write(sys.stdout.fileno(), "\nNothing to add!\n")
        return

    # If we have things to add, then make sure we update lts_unsupported on them
    if added_lines == "":
        # Nothing added, just update the whole CVE in place
        cve_lib.lts_unsupported(source, os.path.join(cvedir, cve), pkgname)
        return
    else:
        # Update the added lines only
        added_lines = cve_lib.lts_unsupported(source, os.path.join(cvedir, cve), pkgname, added_lines)

    if not options.autoconfirm:
        os.write(sys.stdout.fileno(), "\n" + added_lines)
        os.write(sys.stdout.fileno(), "\nAppend the above to " + os.path.join(cvedir, cve) + " (y|N)? ")
        ans = sys.stdin.readline().lower()
        os.write(sys.stdout.fileno(), "\n")

    if options.autoconfirm or ans.startswith("y"):
        file = open(os.path.join(cvedir, cve), "a")
        file.write(added_lines)
        file.close()
    else:
        os.write(sys.stdout.fileno(), "Aborted\n")

def create_cve(cve, pkgname, fixed_in=None, fixed_in_release=None, fixed_in_release_version=None):
    '''Create a new CVE file'''
    src = os.path.join(boilerplates, '00boilerplate')
    if os.path.exists(src + "." + pkgname):
        src = src + "." + pkgname
    boiler = open(src, "r")
    lines =  boiler.read(max_file_size).splitlines()
    boiler.close()

    cand_pat = re.compile(r'^Candidate:')
    ref_pat = re.compile(r'^References:')
    bugs_pat = re.compile(r'^Bugs:')
    pkg_pat = re.compile(r'^#[a-z]+_PKG')
    patch_pat = re.compile(r'^#Patches_PKG')

    contents = ""
    higher_not_affected = False
    for line in lines:
        if (cand_pat.search(line)):
            contents += line + os.path.basename(cve) + '\n'
        elif line.startswith('PublicDate:'):
            if options.public:
                contents += "PublicDate: %s\n" % options.public
            else:
                # default to today-- this will be refreshed by check-cves
                contents += "PublicDate: %s\n" % time.strftime("%Y-%m-%d", time.gmtime())
        elif (patch_pat.search(line)):
            contents += '\nPatches_' + pkgname + ':\n'
        elif (pkg_pat.search(line)):
            for release in releases:
                r = release
                # skip eol_releases releases
                if r in cve_lib.eol_releases:
                    continue
                if r == cve_lib.devel_release:
                    r = 'devel'
                rel_pat = re.compile(r)
                if (rel_pat.search(line)):
                    state = "needs-triage"
                    if not pkg_in_rel(pkgname,release):
                        state = "DNE"
                    elif r == 'upstream' and fixed_in != None:
                        state = "released (%s)" % fixed_in
                    elif fixed_in_release_version and r == fixed_in_release:
                        state = "not-affected (%s)" % fixed_in_release_version
                        higher_not_affected = True
                    elif higher_not_affected:
                        state = "not-affected"
                    contents += "%s_%s: %s\n" % (r, pkgname, state)
        elif ref_pat.search(line):
            if not re.search(r'N', cve):
                contents += line + "\n http://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve + "\n"
            else:
                contents += line + "\n"
            if options.ref_urls:
                for i in options.ref_urls:
                   contents += " %s\n" % i
        elif options.bug_urls and bugs_pat.search(line):
            contents += line
            for i in options.bug_urls:
                contents += "\n %s\n" % i
        else:
            contents += line + '\n'

    contents = cve_lib.lts_unsupported(source, os.path.join(cvedir, cve), pkgname, contents)
    if not options.autoconfirm:
        os.write(sys.stdout.fileno(), contents)
        os.write(sys.stdout.fileno(), "\nWrite the above to " + os.path.join(cvedir, cve) + " (y|N)? ")
        ans = sys.stdin.readline().lower()
        os.write(sys.stdout.fileno(), "\n")

    if options.autoconfirm or ans.startswith("y"):
        newfile = open(os.path.join(cvedir, cve), 'w')
        newfile.write(contents)
        newfile.close()
    else:
        os.write(sys.stdout.fileno(), "Aborted\n")



if not options.pkgs:
    parser.print_help()
    sys.exit(1)

if not options.cve:
    parser.print_help()
    sys.exit(1)

cve = options.cve
pkgs = options.pkgs
pat = re.compile(r'^CVE-\d\d\d\d-[N\d][N\d][N\d][N\d]$')

if options.embargoed:
    cvedir = cve_lib.embargoed_dir
    pat = re.compile(r'^[\w-]*$')

    if not os.path.islink(cvedir):
        os.write(sys.stderr.fileno(), "embargoed/ is not a symlink. Aborting!\n")
        sys.exit(1)


if not pat.search(cve):
    if options.embargoed:
        os.write(sys.stderr.fileno(), "Bad embargoed entry.  Should be alphanumerics and dashes\n")
    else:
        os.write(sys.stderr.fileno(), "Bad CVE entry.  Should be CVE-XXXX-XXXX\n")
    sys.exit(1)

# more here
pat = re.compile(r'\s')
for p in pkgs:
    tmp_p = p.split(',')
    pkgname = tmp_p[0]
    fixed_in = None
    if len(tmp_p) > 1:
        fixed_in = tmp_p[1]
    fixed_in_release = None
    fixed_in_release_version = None
    if len(tmp_p) > 3:
        fixed_in_release = tmp_p[2]
        fixed_in_release_version = tmp_p[3]

    if pat.search(pkgname):
        os.write(sys.stderr.fileno(), "Bad package name\n")
        sys.exit(1)

    if not os.path.isfile(os.path.join(boilerplates, "00boilerplate")):
        os.write(sys.stderr.fileno(), "Could not find 00boilerplate in " + cvedir + "\n")
        sys.exit(1)

    if (os.path.isfile(os.path.join(cvedir, cve))):
        if not options.autoconfirm:
            os.write(sys.stdout.fileno(), "Found existing " + cve + "...\n\n")
        update_cve(cve, pkgname, fixed_in, fixed_in_release, fixed_in_release_version)
    else:
        if not options.autoconfirm:
            os.write(sys.stdout.fileno(), "Creating new " + cve + "...\n\n")
        create_cve(cve, pkgname, fixed_in, fixed_in_release, fixed_in_release_version)

sys.exit(0)
