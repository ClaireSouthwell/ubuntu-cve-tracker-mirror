#!/usr/bin/python
#  Copyright (C) 2015 Canonical Ltd.
#  Authors: Jamie Strandboge <jamie@ubuntu.com>
#
#  This script is distributed under the terms and conditions of the GNU General
#  Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
#  for details.

import cve_lib
import optparse
import source_map
import sys

class MyParser(optparse.OptionParser):
    def format_epilog(self, formatter):
        return self.epilog

usage = "Usage: %prog [options] SRC[/[-]VERSION] ..."
epilog = '''
Examples:
  # List all packages that are built using glibc for all releases:
  $ ./scripts/%(prog)s glibc
  ...
  glibc (2.19-10ubuntu2)             vivid          main       aide
  glibc (2.19-10ubuntu2)             wily           main       aide

  # List all packages that are built using glibc in vivid
  $ ./scripts/%(prog)s --release=vivid glibc
  ...
  glibc (2.19-10ubuntu2)             vivid          main       aide
  glibc (2.21-0ubuntu4)              vivid-updates  universe   qemu-user-static

  # List all packages that are built using golang 2:1.2-2ubuntu3
  $ ./scripts/%(prog)s golang/2:1.2-2ubuntu3
  ...
  golang (2:1.2-2ubuntu3)            trusty         universe   golang-metrics-dev
  golang (2:1.2-2ubuntu3)            vivid          universe   golang-metrics-dev

  # List all packages that are built using golang before 2:1.2-2ubuntu3
  $ ./scripts/%(prog)s golang/-2:1.2-2ubuntu3
  ...
  golang (2:1.1.2-2ubuntu1)          trusty         universe   golang-codesearch-dev
  golang (2:1.1.2-2ubuntu1)          vivid          universe   codesearch
''' % ({'prog': 'report-built-using.py'})

parser = MyParser(usage=usage, epilog=epilog)
parser.add_option("--release",
                  help="Show packages for specified release",
                  metavar="RELEASE")
parser.add_option("--component",
                  help="Show packages for specified component",
                  metavar="COMPONENT")
parser.add_option("--all",
                  help="Show all packages that use Built-Using",
                  default=False,
                  action='store_true')
(opt, args) = parser.parse_args()

if len(args) == 0 and not opt.all:
    print >>sys.stderr, "ERROR: must supply source package name(s)"
    sys.exit(1)

if opt.all and len(args) > 0:
    print >>sys.stderr, "ERROR: do not specify packages with --all"
    sys.exit(1)

pmap = source_map.load(data_type='packages')
releases = cve_lib.releases

for eol in cve_lib.eol_releases:
    if eol in releases:
        releases.remove(eol)

if opt.release:
    releases = [opt.release]

# Build this up only once
built_using = dict()
for rel in pmap.keys():
    if rel not in releases:
        continue

    for pkg in pmap[rel]:
        if 'built-using' in pmap[rel][pkg]:
            # Built-Using for a binary in the Packages file lists the
            # originating source package of the embedded binary
            section = pmap[rel][pkg]['section']
            if opt.component and section != opt.component:
                continue

            pocket = rel
            if pmap[rel][pkg]['pocket'] != '':
                pocket += "-%s" % pmap[rel][pkg]['pocket']

            for (s, c, v) in map(lambda x: x.split(' ', 3),
                                 pmap[rel][pkg]['built-using']):
                v = v.rstrip(')')
                if s not in built_using:
                    built_using[s] = dict()
                if v not in built_using[s]:
                    built_using[s][v] = dict()
                if section not in built_using[s][v]:
                    built_using[s][v][section] = dict()
                if pocket not in built_using[s][v][section]:
                    built_using[s][v][section][pocket] = []
                if pkg not in built_using[s][v][section][pocket]:
                    built_using[s][v][section][pocket].append(
                        (pkg, pmap[rel][pkg]['version']))

source_format = '%-35s'
pocket_format = '%-15s'
component_format = '%-11s'
usedby_format = '%-35s'

out = ""

packages = args
if opt.all:
    packages = sorted(built_using.keys())

for src in packages:
    src_version = None
    lessthan = False
    if '/' in src:
        src, src_version = src.split('/', 2)
        if src_version.startswith('-'):
            lessthan = True
            src_version = src_version.lstrip('-')
    if src in built_using:
        for version in sorted(built_using[src]):
            if src_version is not None:
                if lessthan:
                   if source_map.version_compare(version, src_version) >= 0:
                        print >> sys.stderr, "Skipping %s >= %s" % (version, src_version)
                        continue
                elif src_version != version:
                    continue
            for section in sorted(built_using[src][version]):
                for pocket in sorted(built_using[src][version][section]):
                    for s, v in sorted(
                            built_using[src][version][section][pocket]):
                        out += source_format % ("%s (%s) " % (src, version))
                        out += pocket_format % pocket
                        out += component_format % section
                        out += usedby_format % s
                        out += '\n'

if out != '':
    header = source_format % "Source (version)"
    header += pocket_format % "Pocket"
    header += component_format % "Component"
    header += usedby_format % "Used by"
    header += "\n" + "-" * 78
    print header
    print out,
