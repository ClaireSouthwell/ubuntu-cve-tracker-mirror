#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import glob, sys, os

# common to all scripts
releases      = ['dapper','edgy','feisty','gutsy','hardy','intrepid']
eol_releases  = ['edgy']
devel_release = 'intrepid'

EXIT_FAIL = 1
EXIT_OKAY = 0

def drop_dup_release(cve,rel):
    output = file(cve+".new",'w')
    saw = set()
    for line in file(cve).readlines():
        if line.startswith('%s_' % (rel)):
            pkg = line.split('_')[1].split(':')[0]
            if not pkg in saw:
                output.write(line)
                saw.add(pkg)
        else:
            output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def clone_release(cve,pkg,oldrel,newrel):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if line.startswith('%s_%s:' % (oldrel,pkg)):
            newline = line.replace('%s_%s:'%(oldrel,pkg),'%s_%s:'%(newrel,pkg),1)
            output.write(newline)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def update_state(cve,pkg,rel,state,notes):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if line.startswith('%s_%s:' % (rel, pkg)):
            line = '%s_%s: %s (%s)\n' % (rel, pkg, state, notes)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def add_reference(cve,url):
    output = file(cve+".new",'w')
    in_references = False
    for line in file(cve).readlines():
        if in_references and not line.startswith(' '):
            output.write(' ' + url + '\n')
            in_references = False
        elif not in_references and line.startswith('References:'):
            in_references = True
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def update_description(cve,desc):
    desc = desc.rstrip()
    # Description is a multi-line entry -- it must start with a newline
    if not desc.startswith('\n'):
        desc = '\n' + desc
    output = file(cve+".new",'w')
    skip = 0
    for line in file(cve).readlines():
        if skip and line.startswith(' '):
            continue
        skip = 0
        if line.startswith('Description:'):
            prefix = 'Description:'
            for descline in desc.split('\n'):
                output.write('%s%s\n' % (prefix,descline))
                prefix = ' '
            skip = 1
            continue
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def load_cve(cve):
    '''Loads a given CVE into:
       dict( fields...
             'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
           )
    '''

    msg = ''
    code = EXIT_OKAY

    data = dict()
    affected = dict()
    upstream = None
    lastfield = None
    fields_seen = []
    for line in file(cve).readlines():
        line = line.rstrip()

        # Ignore blank/commented lines
        if len(line) == 0 or line.startswith('#'):
            continue
        if line.startswith(' '):
            data[lastfield] += '\n%s' % (line[1:])
            continue

        try:
            field, value = line.split(':',1)
        except ValueError, e:
            msg += "%s: bad line '%s' (%s)\n" % (cve, line, e)
            code = EXIT_FAIL
            continue

        lastfield = field = field.strip()
        if field in fields_seen:
            msg += "%s: repeated field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            fields_seen.append(field)
        value = value.strip()
        if field == 'Candidate':
            data.setdefault(field,value)
            if value != "" and not value.startswith('CVE-') and not value.startswith('UEM-') and not value.startswith('EMB-'):
                msg += "%s: unknown Candidate '%s' (must be /(CVE|UEM|EMB)-/)\n" % (cve, value)
                code = EXIT_FAIL
        elif field == 'Priority':
            data.setdefault(field,value)
            if not value in ['untriaged','negligible','low','medium','high','critical']:
                msg += "%s: unknown Priority '%s'\n" % (cve, value)
                code = EXIT_FAIL
        elif 'Patches_' in field:
            try:
                foo, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with 'Patches_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            data.setdefault(field,value)
        elif '_' in field:
            try:
                release, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with '_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            if not release in releases + ['upstream', 'devel'] and not release in eol_releases:
                msg += "%s: bad release '%s'\n" % (cve, release)
                code = EXIT_FAIL
                continue
            try:
                info = value.split(' ',1)
            except ValueError:
                msg += "%s: missing state for '%s': '%s'\n" % (cve, field, value)
                code = EXIT_FAIL
                continue
            state = info[0]
            if state == '':
                state = 'needs-triage'

            if len(info) < 2:
                notes = ""
            else:
                notes = info[1].strip()
            if notes.startswith('('):
                notes = notes[1:]
            if notes.endswith(')'):
                notes = notes[:-1]

            # Work-around for old-style of only recording released versions
            if notes == '' and state[0] in ('0123456789'):
                notes = state
                state = 'released'

            if state not in ['needs-triage','needed','pending','released','deferred','DNE','ignored','not-affected']:
                msg += "%s: %s_%s has unknown state: '%s'\n" % (cve, release, pkg, state)
                code = EXIT_FAIL

            affected.setdefault(pkg,dict())
            affected[pkg].setdefault(release,[state,notes])
        elif field == 'upstream':
            if value != "":
                upstream = value
        elif not field in ['References','Description','Ubuntu-Description','Notes','Bugs','Assigned-to','CoordinatedReleaseDate','Discovered-by']:
            msg += "%s: unknown field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            data.setdefault(field,value)

    # verify/fix missing upstreams listed for each pkg
    pkgs = sorted(affected.keys())
    # this check isn't safe due to the "ignored" cves.
    if False and len(pkgs) == 0:
            msg += "%s: no packages affected?!\n" % (cve)
            code = EXIT_FAIL
    if len(pkgs) > 1 and upstream != None:
            msg += "%s: single upstream defined when multiple pkgs listed (%s)\n" % (cve, " ".join(pkgs))
            code = EXIT_FAIL
    if not (len(pkgs) == 1 and upstream != None):
        append = ''
        for pkg in pkgs:
            if not 'upstream' in affected[pkg].keys():
                append += 'upstream_%s: \n' % (pkg)
        if append != '':
            msg += "%s: adding missing 'upstream' for: %s\n" % (cve, ", ".join(pkgs))
            file(cve,'a').write(append)

    data['pkgs'] = affected
        
    if code != EXIT_OKAY:
        raise ValueError, msg.strip()
    return data
