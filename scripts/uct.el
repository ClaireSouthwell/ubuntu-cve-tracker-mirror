;;; uct -- Emacs interface to the Ubuntu CVE tracker

;;; Commentary:

;;; Code:
(require 'cl-lib)
(require 'subr-x)
(require 'cve-mode)

(defgroup uct nil
  "UCT for Emacs"
  :group 'applications)

(defconst uct-directories '("active" "embargoed" "ignored" "retired"))

(defconst uct-cve-regex cve-mode-cve-id-regexp)

(defvar uct-cves nil)

(defvar uct-description-regexp "")

(defvar uct-supported-releases '(trusty xenial bionic cosmic devel))

(defvar uct-selected-sources '(active embargoed))

(defvar uct-selected-statuses '(needs-triage needed deferred pending))

(defvar uct-selected-packages nil)

(defconst uct-base-path
  (file-name-directory
   (directory-file-name
    (file-name-directory
     (file-truename
      (expand-file-name
       (or load-file-name buffer-file-name)))))))

(cl-defstruct (cve (:constructor cve-create)
                   (:copier nil))
  (id nil :read-only t)
  (description nil :read-only t)
  (priority nil :read-only t)
  (package nil :read-only t)
  (status nil :read-only t)
  (file nil :read-only t))

(defun cve-source (cve)
  "Return the source for CVE."
  (intern (car
           (last
            (split-string
             (directory-file-name
              (file-name-directory
               (cve-file cve)))
             "/")))))

(defun uct--flatten (l)
  "Flatten list L."
  (cond ((null l) l)
        ((listp l) (append (uct--flatten (car l)) (uct--flatten (cdr l))))
        (t (list l))))

(defun uct-load-cves-from-file (file)
  "Load all CVEs from FILE and return `cve' objects or nil on error."
  (let (id description priority packages)
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (save-excursion
        (if (re-search-forward (concat "^Candidate: *" uct-cve-regex) nil t)
            (setq id (intern (match-string 1)))
          (error "%s does not appear to be a valid CVE" file)))
      (save-excursion
        (setq description
              (if (re-search-forward "^Description: *" nil t)
                  (let ((start (point))
                        (end (progn
                               (re-search-forward "^[A-Z]")
                               (forward-line -1)
                               (end-of-line)
                               (point))))
                    ;; unify all whitespace for spaces
                    (replace-regexp-in-string
                     "\\s-+" " "
                     (string-trim (buffer-substring-no-properties start end))))
                "")))
      (save-excursion
        (if (re-search-forward cve-mode-priority-regexp nil t)
            (setq priority (intern (match-string 1)))
          (setq priority '-)))
      (while (re-search-forward cve-mode-releases-regexp nil t)
        (let* ((release (intern (match-string 2)))
               (package (intern (match-string 3)))
               (status (intern (or (match-string 5) "untriaged")))
               (entry (assoc package packages))
               (statuses (cdr entry)))
          (if entry
              (setf (cdr entry)
                    (add-to-list 'statuses `(,release . ,status)))
            (add-to-list 'packages `(,package . ,statuses)))))
      (mapcar #'(lambda (pkg)
                  (cve-create :id id
                              :description description
                              :priority priority
                              :package (car pkg)
                              :status (cdr pkg)
                              :file file))
              packages))))

(defun uct-find-cves (dir)
  "Return all CVEs found in DIR."
  (let* ((cves nil)
         (i 0)
         (files (directory-files dir t uct-cve-regex))
         (progress (make-progress-reporter
                    (format "Loading CVEs from %s..." dir) 1 (length files))))
    (dolist (file files)
      (cl-incf i)
      (progress-reporter-update progress i)
      (dolist (cve (uct--flatten (uct-load-cves-from-file file)))
        (push cve cves)))
    (progress-reporter-done progress)
    cves))

(defface uct-list-face-cve-active
  '((t :inherit font-lock-function-name-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-cve-embargoed
  '((t :inherit error))
  "Face used on the status of CVEs.")

(defface uct-list-face-cve-retired
  '((t :inherit font-lock-comment-face))
  "Face used on the status of CVEs.")

(defun uct-list--face-for-cve (cve)
  "Return face for CVE."
  (let ((dir (file-name-base
              (directory-file-name
               (file-name-directory (cve-file cve))))))
    (pcase dir
      (`"active" 'uct-list-face-cve-active)
      (`"embargoed" 'uct-list-face-cve-embargoed)
      (`"retired" 'uct-list-face-cve-retired)
      (_ 'font-lock-warning-face))))

(defface uct-list-face-priority-critical
  '((t :inherit error))
  "Face used on the status of CVEs.")

(defface uct-list-face-priority-high
  '((t :inherit font-lock-warning-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-priority-medium
  '((t :inherit default))
  "Face used on the status of CVEs.")

(defface uct-list-face-priority-low
  '((t :inherit font-lock-comment-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-priority-negligible
  '((t :inherit font-lock-comment-face))
  "Face used on the status of CVEs.")

(defun uct-list--face-for-priority (priority)
  "Return face for PRIORITY."
  (pcase priority
    (`critical 'uct-list-face-priority-critical)
    (`high 'uct-list-face-priority-high)
    (`medium 'uct-list-face-priority-medium)
    (`low 'uct-list-face-priority-low)
    (`negligible 'uct-list-face-priority-negligible)
    (_ 'font-lock-warning-face)))

(defface uct-list-face-status-dne
  '((t :inherit font-lock-comment-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-not-affected
  '((t :inherit font-lock-comment-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-needs-triage
  '((t :inherit default))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-needed
  '((t :inherit font-lock-warning-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-deferred
  '((t :inherit font-lock-builtin-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-pending
  '((t :inherit font-lock-function-name-face))
  "Face used on the status of CVEs.")

(defface uct-list-face-status-released
  '((t :inherit font-lock-keyword-face))
  "Face used on the status of CVEs.")

(defun uct-list--face-for-status (status)
  "Return face for STATUS."
  (pcase status
    (`DNE 'uct-list-face-status-dne)
    (`not-affected 'uct-list-face-status-not-affected)
    (`needs-triage 'uct-list-face-status-needs-triage)
    (`needed 'uct-list-face-status-needed)
    (`deferred 'uct-list-face-status-deferred)
    (`pending 'uct-list-face-status-released)
    (`released 'uct-list-face-status-released)
    (_ 'font-lock-warning-face)))

(defun uct-list-load-entry (&optional button)
  "Load a CVE from the CVE list.
If optional arg BUTTON is non-nil, describe it's associated CVE."
  (interactive)
   (unless (derived-mode-p 'uct-list-mode)
     (error "The current buffer is not in UCT List Mode"))
   (let ((cve (if button (button-get button 'cve)
               (tabulated-list-get-id))))
    (if cve
        (find-file-other-window (cve-file cve))
      (user-error "No CVE here"))))

(defun uct-list--list-entry (cve)
  "Return a CVE entry suitable for `tabulated-list-entries'.
CVE is a `cve' object."
  (list cve
        `[(,(symbol-name (cve-id cve))
           face ,(uct-list--face-for-cve cve)
           follow-link t
           cve ,cve
           action uct-list-load-entry)
          ,(symbol-name (cve-package cve))
          ,(propertize (symbol-name (cve-priority cve))
                       'font-lock-face
                       (uct-list--face-for-priority (cve-priority cve)))
          ,@(mapcar #'(lambda (release)
                        (let ((status (or (cdr (assoc release (cve-status cve))) '-)))
                          (propertize (symbol-name status)
                                      'font-lock-face
                                      (uct-list--face-for-status status))))
                    uct-supported-releases)
          ,(propertize (cve-description cve)
                       'font-lock-face 'font-lock-string-face)]))

(defun uct-list--status-selected (cve)
  "Whether CVE has any status listed in `uct-selected-statuses'."
  (cl-notevery #'null
             (mapcar #'(lambda (release)
                         (let ((status (or (cdr (assoc release (cve-status cve))) '-)))
                           (memq status uct-selected-statuses)))
                     uct-supported-releases)))

(defun uct-list--visible (cve)
  "Whether CVE should be visible in list or not."
  (and
   (or (null uct-selected-packages)
       (member (cve-package cve) uct-selected-packages))
   (or (null uct-selected-sources)
       (member (cve-source cve) uct-selected-sources))
   (or (null uct-selected-statuses)
       (uct-list--status-selected cve))
   (string-match-p uct-description-regexp (cve-description cve))))

(defun uct-list-refresh ()
  "Refresh the list of CVEs from `uct-directories'."
  (interactive)
  (unless (derived-mode-p 'uct-list-mode)
    (error "The current buffer is not in UCT List Mode"))
  (tabulated-list-init-header)
  ;; don't try and mapcar as run out of stack depth - accumulate and
  ;; process
  (let (entries)
    (unless uct-cves
      (message "Loading CVEs from %s..." (mapconcat #'identity uct-directories ", "))
      (dolist (dir (mapcar #'(lambda (d) (expand-file-name d uct-base-path))
                           uct-directories))
        (dolist (cve (uct-find-cves dir))
          (push cve uct-cves))))
    (dolist (cve uct-cves)
      (when (uct-list--visible cve)
        (push (uct-list--list-entry cve) entries)))
    (setq tabulated-list-entries entries))
  (setq mode-name (concat "CVEs"
                          (when (> (length uct-description-regexp) 0)
                            (concat "\"" uct-description-regexp "\""))
                          (when uct-selected-statuses
                                     (concat "{"
                                             (mapconcat #'symbol-name uct-selected-statuses ", " )
                                             "}"))
                          (when uct-selected-sources
                                     (concat "["
                                             (mapconcat #'symbol-name uct-selected-sources ", " )
                                             "]"))
                          (when uct-selected-packages
                                     (concat "("
                                             (mapconcat #'symbol-name uct-selected-packages ", " )
                                             ")")))))

(defun uct-list--id-predicate (A B)
  "Sort predicate for CVE on ID between A and B."
  (string< (cve-id (car A)) (cve-id (car B))))

(defvar uct-list--priorities '(negligible low medium high critical))

(defun uct-list--priority-predicate (A B)
  "Sort predicate for CVE priority between A and B."
  (< (or (cl-position (cve-priority (car A)) uct-list--priorities) -1)
     (or (cl-position (cve-priority (car B)) uct-list--priorities) -1)))

(defun uct-list--get-packages ()
  "Return the list of packages from the current list of CVEs."
  (let (packages)
    (dolist (cve uct-cves)
      (let ((package (cve-package cve)))
        (unless (member package packages)
          (push package packages))))
    packages))

(defun uct-list--prompt-for-items (prompt items)
  "PROMPT user for a list of ITEMS."
  (let ((chosen nil)
        (item))
    (while
        (progn
          (setq item (completing-read prompt
                                     ;; don't offer the same item more
                                     ;; than once
                                     items
                                     #'(lambda (p) (not (member p chosen)))
                                     nil))
          ;; stop if empty string selected
          (not (string-match-p "^\\s-*$" item)))
      (cl-pushnew (intern item) chosen))
    ;; reverse as cl-pushnew adds to head
    (reverse chosen)))

(defun uct-list-filter-by-packages (&optional packages)
  "Filter the list of CVEs to only those affecting PACKAGES."
  (interactive
   (list (uct-list--prompt-for-items "Packages: " (uct-list--get-packages))))
  (unless (derived-mode-p 'uct-list-mode)
    (error "The current buffer is not in UCT List Mode"))
  (unless (listp packages)
    (user-error "PACKAGES should be a list of packages to filter"))
  (setq uct-selected-packages packages)
  (tabulated-list-revert))

(defun uct-list-filter-by-this-package ()
  "Filter the list of CVEs to only the package affecting the current line CVE."
  (interactive)
   (unless (derived-mode-p 'uct-list-mode)
     (error "The current buffer is not in UCT List Mode"))
  (let ((cve (tabulated-list-get-id)))
    (if cve (uct-list-filter-by-packages (list (cve-package cve))))))

(defun uct-list-filter-by-sources (&optional sources)
  "Filter the list of CVEs to only those affecting SOURCES."
  (interactive
   (list (uct-list--prompt-for-items "Sources: " uct-directories)))
   (unless (derived-mode-p 'uct-list-mode)
     (error "The current buffer is not in UCT List Mode"))
   (unless (listp sources)
     (user-error "SOURCES should be a list of sources to filter"))
   (setq uct-selected-sources sources)
  (tabulated-list-revert))

(defun uct-list-filter-by-statuses (&optional statuses)
  "Filter the list of CVEs to only those with a status in STATUSES."
  (interactive
   (list (uct-list--prompt-for-items "Statuses: "
                                     '(DNE not-affected needs-triage needed deferred pending released))))
   (unless (derived-mode-p 'uct-list-mode)
     (error "The current buffer is not in UCT List Mode"))
   (unless (listp statuses)
     (user-error "STATUSES should be a list of statuses to filter"))
   (setq uct-selected-statuses statuses)
  (tabulated-list-revert))

(defun uct-list-filter-by-description (&optional regexp)
  "Filter the list of CVEs to only those with a description matching REGEXP."
  (interactive
   (list (read-string "Regexp: " uct-description-regexp)))
  (unless (derived-mode-p 'uct-list-mode)
    (error "The current buffer is not in UCT List Mode"))
  (setq uct-description-regexp regexp)
  (tabulated-list-revert))

(defvar uct-list-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map tabulated-list-mode-map)
    (define-key map "\C-m" 'uct-list-load-entry)
    (define-key map "r" 'uct-list-refresh)
    (define-key map "p" 'uct-list-filter-by-packages)
    (define-key map "P" 'uct-list-filter-by-this-package)
    (define-key map "s" 'uct-list-filter-by-statuses)
    (define-key map "d" 'uct-list-filter-by-sources)
    (define-key map "/" 'uct-list-filter-by-description)
    map)
  "Local keymap for `uct-list-mode' buffers.")

;;;###autoload
(define-derived-mode uct-list-mode tabulated-list-mode "CVEs"
  "Major mode for browsing CVEs.
\\<uct-list-mode-map>
\\{uct-list-mode-map}"
  (setq tabulated-list-format `[("CVE" 17 uct-list--id-predicate)
                                ("Package" 18 t)
                                ("Priority" 10 uct-list--priority-predicate)
                                ,@(mapcar #'(lambda (release)
                                              (list (symbol-name release) 12 nil))
                                          uct-supported-releases)
                                ("Description" 0 nil)])
  (setq tabulated-list-sort-key (cons "CVE" nil))
  (add-hook 'tabulated-list-revert-hook #'uct-list-refresh nil t)
  (tabulated-list-init-header))

;;;###autoload
(defun uct ()
  "Display list of CVEs."
  (interactive)
  (let ((buffer (get-buffer-create "*UCT*")))
    (with-current-buffer buffer
      (uct-list-mode)
      (uct-list-refresh)
      (message "Displaying CVEs...")
      (tabulated-list-print))
    (switch-to-buffer buffer)))

;;;###autoload
(defun uct-cve-at-point ()
  "Return the CVE at point or nil if none found."
  (let ((cve (thing-at-point 'symbol t)))
    (when (or (null cve) (not (string-match uct-cve-regex cve)))
      (save-excursion
        (let ((end (save-excursion (forward-line) (point))))
          (backward-word)
          (if (re-search-forward uct-cve-regex end t)
              (setq cve (substring-no-properties (match-string 1)))
            (setq cve nil)))))
    cve))

;;;###autoload
(defun uct-find-cve (&optional cve)
  "Open the specified CVE file from UCT (or if no CVE use the one at point)."
  (interactive (list (or (uct-cve-at-point) (read-string "CVE: "))))
  (let ((dirs '("active" "retired" "ignored" "embargoed")))
    (when (and cve (string-match uct-cve-regex cve))
      (let ((cve-file (car (cl-remove-if #'null
                                         (mapcar #'(lambda (dir)
                                                     (let ((file (format "%s/%s/%s" uct-base-path dir cve)))
                                                       (when (file-exists-p file)
                                                         file)))
                                                 dirs)))))
        (if cve-file
            (find-file-other-window cve-file)
          (user-error "Unable to find %s in UCT" cve))))))

(provide 'uct)
;;; uct.el ends here
