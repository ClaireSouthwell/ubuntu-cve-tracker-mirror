Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./src/ip.cpp:51:    //  Setting this option result in sane behaviour when exec() functions

== memory_management() ==
./src/curve_server.cpp:57:    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);
./src/curve_server.cpp:139:    memcpy (message_nonce, "CurveZMQMESSAGES", 16);
./src/curve_server.cpp:146:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));
./src/curve_server.cpp:151:    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,
./src/curve_server.cpp:154:    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));
./src/curve_server.cpp:169:    memcpy (message, "\x07MESSAGE", 8);
./src/curve_server.cpp:170:    memcpy (message + 8, message_nonce + 16, 8);
./src/curve_server.cpp:171:    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:202:    memcpy (message_nonce, "CurveZMQMESSAGEC", 16);
./src/curve_server.cpp:203:    memcpy (message_nonce + 16, message + 8, 8);
./src/curve_server.cpp:213:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));
./src/curve_server.cpp:216:    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));
./src/curve_server.cpp:220:    memcpy (message_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:236:        memcpy (msg_->data (),
./src/curve_server.cpp:304:    memcpy (cn_client, hello + 80, 32);
./src/curve_server.cpp:310:    memcpy (hello_nonce, "CurveZMQHELLO---", 16);
./src/curve_server.cpp:311:    memcpy (hello_nonce + 16, hello + 112, 8);
./src/curve_server.cpp:315:    memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);
./src/curve_server.cpp:340:    memcpy (cookie_nonce, "COOKIE--", 8);
./src/curve_server.cpp:345:    memcpy (cookie_plaintext + crypto_secretbox_ZEROBYTES,
./src/curve_server.cpp:347:    memcpy (cookie_plaintext + crypto_secretbox_ZEROBYTES + 32,
./src/curve_server.cpp:365:    memcpy (welcome_nonce, "WELCOME-", 8);
./src/curve_server.cpp:370:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES, cn_public, 32);
./src/curve_server.cpp:371:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES + 32,
./src/curve_server.cpp:373:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES + 48,
./src/curve_server.cpp:386:    memcpy (welcome, "\x07WELCOME", 8);
./src/curve_server.cpp:387:    memcpy (welcome + 8, welcome_nonce + 8, 16);
./src/curve_server.cpp:388:    memcpy (welcome + 24, welcome_ciphertext + crypto_box_BOXZEROBYTES, 144);
./src/curve_server.cpp:416:    memcpy (cookie_box + crypto_secretbox_BOXZEROBYTES, initiate + 25, 80);
./src/curve_server.cpp:418:    memcpy (cookie_nonce, "COOKIE--", 8);
./src/curve_server.cpp:419:    memcpy (cookie_nonce + 8, initiate + 9, 16);
./src/curve_server.cpp:448:    memcpy (initiate_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:451:    memcpy (initiate_nonce, "CurveZMQINITIATE", 16);
./src/curve_server.cpp:452:    memcpy (initiate_nonce + 16, initiate + 105, 8);
./src/curve_server.cpp:472:    memcpy (vouch_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:475:    memcpy (vouch_nonce, "VOUCH---", 8);
./src/curve_server.cpp:476:    memcpy (vouch_nonce + 8,
./src/curve_server.cpp:545:    memcpy (ready_nonce, "CurveZMQREADY---", 16);
./src/curve_server.cpp:557:    memcpy (ready, "\x05READY", 6);
./src/curve_server.cpp:559:    memcpy (ready + 6, ready_nonce + 16, 8);
./src/curve_server.cpp:561:    memcpy (ready + 14, ready_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:575:    memcpy (msg_data, "\5ERROR", 6);
./src/curve_server.cpp:577:    memcpy (msg_data + 7, status_code.c_str (), status_code.length ());
./src/curve_server.cpp:596:    memcpy (msg.data (), "1.0", 3);
./src/curve_server.cpp:604:    memcpy (msg.data (), "1", 1);
./src/curve_server.cpp:612:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/curve_server.cpp:620:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/curve_server.cpp:628:    memcpy (msg.data (), options.identity, options.identity_size);
./src/curve_server.cpp:636:    memcpy (msg.data (), "CURVE", 5);
./src/curve_server.cpp:644:    memcpy (msg.data (), key, crypto_box_PUBLICKEYBYTES);
./src/gssapi_mechanism_base.cpp:84:    uint8_t *plaintext_buffer = static_cast <uint8_t *>(malloc(msg_->size ()+1));
./src/gssapi_mechanism_base.cpp:86:    memcpy (plaintext_buffer+1, msg_->data(), msg_->size());
./src/gssapi_mechanism_base.cpp:107:    memcpy (ptr, "\x07MESSAGE", 8);
./src/gssapi_mechanism_base.cpp:115:    memcpy (ptr, wrapped.value, wrapped.length);
./src/gssapi_mechanism_base.cpp:153:    wrapped.value = static_cast <char *> (malloc (alloc_length));
./src/gssapi_mechanism_base.cpp:156:        memcpy(wrapped.value, ptr, wrapped.length);
./src/gssapi_mechanism_base.cpp:181:    memcpy (msg_->data (), static_cast <char *> (plaintext.value)+1, plaintext.length-1);
./src/gssapi_mechanism_base.cpp:207:    memcpy (ptr, "\x08INITIATE", 9);
./src/gssapi_mechanism_base.cpp:215:    memcpy (ptr, token_value_, token_length_);
./src/gssapi_mechanism_base.cpp:250:    *token_value_ = static_cast <char *> (malloc (token_length_ ? token_length_ : 1));
./src/gssapi_mechanism_base.cpp:253:        memcpy(*token_value_, ptr, token_length_);
./src/gssapi_mechanism_base.cpp:268:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/gssapi_mechanism_base.cpp:274:    memcpy (ptr, "\x05READY", 6);
./src/gssapi_mechanism_base.cpp:290:    memcpy (msg_->data (), command_buffer, command_size);
./src/mechanism.cpp:56:    memcpy (msg_->data (), identity.data (), identity.size ());
./src/mechanism.cpp:88:    memcpy (ptr, name, name_len);
./src/mechanism.cpp:93:    memcpy (ptr, value, value_len);
./src/xsub.cpp:233:    memcpy (data + 1, data_, size_);
./src/plain_server.cpp:219:    memcpy (msg_->data (), "\x07WELCOME", 8);
./src/plain_server.cpp:242:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/plain_server.cpp:248:    memcpy (ptr, "\x05READY", 6);
./src/plain_server.cpp:265:    memcpy (msg_->data (), command_buffer, command_size);
./src/plain_server.cpp:277:    memcpy (msg_data, "\5ERROR", 6);
./src/plain_server.cpp:279:    memcpy (msg_data + 7, status_code.c_str (), status_code.length ());
./src/plain_server.cpp:299:    memcpy (msg.data (), "1.0", 3);
./src/plain_server.cpp:307:    memcpy (msg.data (), "1", 1);
./src/plain_server.cpp:315:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/plain_server.cpp:323:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/plain_server.cpp:331:    memcpy (msg.data (), options.identity, options.identity_size);
./src/plain_server.cpp:339:    memcpy (msg.data (), "PLAIN", 5);
./src/plain_server.cpp:347:    memcpy (msg.data (), username.c_str (), username.length ());
./src/plain_server.cpp:355:    memcpy (msg.data (), password.c_str (), password.length ());
./src/mtrie.cpp:107:                malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:280:        next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:367:                next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:383:                next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/gssapi_client.cpp:55:    service_name = static_cast <char *>(malloc(service_size+1));
./src/gssapi_client.cpp:57:    memcpy(service_name, options_.gss_service_principal.c_str(), service_size+1 );
./src/gssapi_client.cpp:63:        principal_name = static_cast <char *>(malloc(principal_size+1));
./src/gssapi_client.cpp:65:        memcpy(principal_name, options_.gss_principal.c_str(), principal_size+1 );
./src/signaler.cpp:461:        unsigned char *dummy = (unsigned char *) malloc (dummy_size);
./src/msg.cpp:83:            (content_t*) malloc (sizeof (content_t) + size_);
./src/msg.cpp:119:        u.lmsg.content = (content_t*) malloc (sizeof (content_t));
./src/curve_client.cpp:52:    memcpy (public_key, options_.curve_public_key, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:53:    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);
./src/curve_client.cpp:54:    memcpy (server_key, options_.curve_server_key, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:135:    memcpy (message_nonce, "CurveZMQMESSAGEC", 16);
./src/curve_client.cpp:140:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));
./src/curve_client.cpp:145:    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,
./src/curve_client.cpp:148:    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));
./src/curve_client.cpp:163:    memcpy (message, "\x07MESSAGE", 8);
./src/curve_client.cpp:164:    memcpy (message + 8, message_nonce + 16, 8);
./src/curve_client.cpp:165:    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:192:    memcpy (message_nonce, "CurveZMQMESSAGES", 16);
./src/curve_client.cpp:193:    memcpy (message_nonce + 16, message + 8, 8);
./src/curve_client.cpp:203:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));
./src/curve_client.cpp:206:    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));
./src/curve_client.cpp:210:    memcpy (message_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:226:        memcpy (msg_->data (),
./src/curve_client.cpp:257:    memcpy (hello_nonce, "CurveZMQHELLO---", 16);
./src/curve_client.cpp:273:    memcpy (hello, "\x05HELLO", 6);
./src/curve_client.cpp:275:    memcpy (hello + 6, "\1\0", 2);
./src/curve_client.cpp:279:    memcpy (hello + 80, cn_public, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:281:    memcpy (hello + 112, hello_nonce + 16, 8);
./src/curve_client.cpp:283:    memcpy (hello + 120, hello_box + crypto_box_BOXZEROBYTES, 80);
./src/curve_client.cpp:304:    memcpy (welcome_box + crypto_box_BOXZEROBYTES, msg_data + 24, 144);
./src/curve_client.cpp:306:    memcpy (welcome_nonce, "WELCOME-", 8);
./src/curve_client.cpp:307:    memcpy (welcome_nonce + 8, msg_data + 8, 16);
./src/curve_client.cpp:317:    memcpy (cn_server, welcome_plaintext + crypto_box_ZEROBYTES, 32);
./src/curve_client.cpp:318:    memcpy (cn_cookie, welcome_plaintext + crypto_box_ZEROBYTES + 32, 16 + 80);
./src/curve_client.cpp:337:    memcpy (vouch_plaintext + crypto_box_ZEROBYTES, cn_public, 32);
./src/curve_client.cpp:338:    memcpy (vouch_plaintext + crypto_box_ZEROBYTES + 32, server_key, 32);
./src/curve_client.cpp:340:    memcpy (vouch_nonce, "VOUCH---", 8);
./src/curve_client.cpp:356:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES,
./src/curve_client.cpp:358:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 32,
./src/curve_client.cpp:360:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 48,
./src/curve_client.cpp:378:    memcpy (initiate_nonce, "CurveZMQINITIATE", 16);
./src/curve_client.cpp:391:    memcpy (initiate, "\x08INITIATE", 9);
./src/curve_client.cpp:393:    memcpy (initiate + 9, cn_cookie, 96);
./src/curve_client.cpp:395:    memcpy (initiate + 105, initiate_nonce + 16, 8);
./src/curve_client.cpp:397:    memcpy (initiate + 113, initiate_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:419:    memcpy (ready_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:422:    memcpy (ready_nonce, "CurveZMQREADY---", 16);
./src/curve_client.cpp:423:    memcpy (ready_nonce + 16, msg_data + 6, 8);
./src/trie.cpp:90:                malloc (sizeof (trie_t*) * count);
./src/trie.cpp:227:                next.table = (trie_t**) malloc (sizeof (trie_t*) * count);
./src/trie.cpp:252:                next.table = (trie_t**) malloc (sizeof (trie_t*) * count);
./src/stream.cpp:230:    memcpy (msg_->data (), identity.data (), identity.size ());
./src/stream.cpp:264:    memcpy (prefetched_id.data (), identity.data (), identity.size ());
./src/stream.cpp:298:        memcpy (options.identity, identity.data (), identity.size ());
./src/pgm_sender.cpp:72:    out_buffer = (unsigned char*) malloc (out_buffer_size);
./src/tcp_address.cpp:74:    char *ifr = (char*) malloc (ifr_size);
./src/tcp_address.cpp:159:            memcpy (&source_address, &ifr.ifr_addr,
./src/tcp_address.cpp:163:            memcpy (&address, &ifr.ifr_addr,
./src/tcp_address.cpp:204:                memcpy (&source_address, ifp->ifa_addr,
./src/tcp_address.cpp:208:                memcpy (&address, ifp->ifa_addr,
./src/tcp_address.cpp:255:        memcpy (&ip6_addr.sin6_addr, &in6addr_any, sizeof in6addr_any);
./src/tcp_address.cpp:257:        memcpy (out_addr, &ip6_addr, out_addrlen);
./src/tcp_address.cpp:265:        memcpy (out_addr, &ip4_addr, out_addrlen);
./src/tcp_address.cpp:271:            memcpy (&source_address, out_addr, out_addrlen);
./src/tcp_address.cpp:273:            memcpy (&address, out_addr, out_addrlen);
./src/tcp_address.cpp:325:        memcpy (&source_address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:327:        memcpy (&address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:386:        memcpy (&source_address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:388:        memcpy (&address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:410:        memcpy (&address.ipv4, sa, sizeof address.ipv4);
./src/tcp_address.cpp:413:        memcpy (&address.ipv6, sa, sizeof address.ipv6);
./src/gssapi_server.cpp:62:        principal_name = static_cast <char *>(malloc(principal_size+1));
./src/gssapi_server.cpp:64:        memcpy(principal_name, options_.gss_principal.c_str(), principal_size+1 );
./src/gssapi_server.cpp:169:    memcpy (msg.data (), "1.0", 3);
./src/gssapi_server.cpp:177:    memcpy (msg.data (), "1", 1);
./src/gssapi_server.cpp:185:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/gssapi_server.cpp:193:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/gssapi_server.cpp:201:    memcpy (msg.data (), options.identity, options.identity_size);
./src/gssapi_server.cpp:209:    memcpy (msg.data (), "GSSAPI", 6);
./src/gssapi_server.cpp:220:    memcpy (msg.data (), principal.value, principal.length);
./src/null_mechanism.cpp:95:        memcpy (msg_data, "\5ERROR", 6);
./src/null_mechanism.cpp:97:        memcpy (msg_data + 7, status_code, sizeof status_code);
./src/null_mechanism.cpp:102:    unsigned char *const command_buffer = (unsigned char *) malloc (512);
./src/null_mechanism.cpp:108:    memcpy (ptr, "\5READY", 6);
./src/null_mechanism.cpp:124:    memcpy (msg_->data (), command_buffer, command_size);
./src/null_mechanism.cpp:233:    memcpy (msg.data (), "1.0", 3);
./src/null_mechanism.cpp:241:    memcpy (msg.data (), "1", 1);
./src/null_mechanism.cpp:249:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/null_mechanism.cpp:257:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/null_mechanism.cpp:265:    memcpy (msg.data (), options.identity, options.identity_size);
./src/null_mechanism.cpp:273:    memcpy (msg.data (), "NULL", 4);
./src/null_mechanism.cpp:342:    memcpy (status_code, msg [3].data (), sizeof status_code);
./src/ctx.cpp:274:        slots = (mailbox_t **) malloc (sizeof (mailbox_t*) * slot_count);
./src/ctx.cpp:554:        memcpy (id.data (), bind_options.identity, bind_options.identity_size);
./src/zmq_utils.cpp:61:    uint64_t *watch = (uint64_t*) malloc (sizeof (uint64_t));
./src/plain_client.cpp:131:    memcpy (ptr, "\x05HELLO", 6);
./src/plain_client.cpp:135:    memcpy (ptr, username.c_str (), username.length ());
./src/plain_client.cpp:139:    memcpy (ptr, password.c_str (), password.length ());
./src/plain_client.cpp:162:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/plain_client.cpp:168:    memcpy (ptr, "\x08INITIATE", 9);
./src/plain_client.cpp:185:    memcpy (msg_->data (), command_buffer, command_size);
./src/select.cpp:171:        memcpy (&readfds, &source_set_in, sizeof source_set_in);
./src/select.cpp:172:        memcpy (&writefds, &source_set_out, sizeof source_set_out);
./src/select.cpp:173:        memcpy (&exceptfds, &source_set_err, sizeof source_set_err);
./src/tipc_address.cpp:50:        memcpy (&address, sa, sa_len);
./src/raw_decoder.cpp:47:    buffer = (unsigned char *) malloc (bufsize);
./src/raw_decoder.cpp:70:    memcpy (in_progress.data (), data_, size_);
./src/socket_base.cpp:347:        strcpy (static_cast <char *> (optval_), last_endpoint.c_str ());
./src/socket_base.cpp:526:            memcpy (id.data (), options.identity, options.identity_size);
./src/socket_base.cpp:541:                memcpy (id.data (), options.identity, options.identity_size);
./src/socket_base.cpp:553:                memcpy (id.data (), peer.options.identity, peer.options.identity_size);
./src/socket_base.cpp:1361:        memcpy (zmq_msg_data (&msg), addr_.c_str (), addr_.size ());
./src/sub.cpp:65:    memcpy (data + 1, optval_, optvallen_);
./src/stream_engine.cpp:544:                        memcpy (outpos + outsize, "NULL", 4);
./src/stream_engine.cpp:547:                        memcpy (outpos + outsize, "PLAIN", 5);
./src/stream_engine.cpp:550:                        memcpy (outpos + outsize, "GSSAPI", 6);
./src/stream_engine.cpp:553:                        memcpy (outpos + outsize, "CURVE", 5);
./src/stream_engine.cpp:592:        memcpy (tx_msg.data (), options.identity, options.identity_size);
./src/stream_engine.cpp:723:        memcpy (msg_->data (), options.identity, options.identity_size);
./src/stream_engine.cpp:873:        memcpy (msg.data (), credential.data (), credential.size ());
./src/socks.cpp:163:        memcpy (ptr, &sockaddr_in->sin_addr, 4);
./src/socks.cpp:171:        memcpy (ptr, &sockaddr_in6->sin6_addr, 16);
./src/socks.cpp:177:        memcpy (ptr, req.hostname.c_str (), req.hostname.size ());
./src/ipc_address.cpp:50:        memcpy(&address, sa, sa_len);
./src/ipc_address.cpp:69:    strcpy (address.sun_path, path_);
./src/zmq.cpp:368:    memcpy (zmq_msg_data (&msg), buf_, len_);
./src/zmq.cpp:435:        memcpy (zmq_msg_data (&msg), a_[i].iov_base, a_[i].iov_len);
./src/zmq.cpp:492:    memcpy (buf_, zmq_msg_data (&msg), to_copy);
./src/zmq.cpp:547:        a_[i].iov_base = static_cast<char *> (malloc(a_[i].iov_len));
./src/zmq.cpp:552:        memcpy(a_[i].iov_base,static_cast<char *> (zmq_msg_data (&msg)),
./src/zmq.cpp:711:        pollfds = (pollfd*) malloc (nitems_ * sizeof (pollfd));
./src/zmq.cpp:931:            memcpy (&inset, &pollset_in, sizeof (fd_set));
./src/zmq.cpp:932:            memcpy (&outset, &pollset_out, sizeof (fd_set));
./src/zmq.cpp:933:            memcpy (&errset, &pollset_err, sizeof (fd_set));
./src/options.cpp:111:                memcpy (identity, optval_, identity_size);
./src/options.cpp:386:                memcpy (curve_public_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:400:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:410:                memcpy (curve_secret_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:424:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:434:                memcpy (curve_server_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:450:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:562:                memcpy (optval_, identity, identity_size);
./src/options.cpp:690:                memcpy (optval_, socks_proxy_address.c_str (), socks_proxy_address.size () + 1);
./src/options.cpp:740:                memcpy (optval_, plain_username.c_str (), plain_username.size () + 1);
./src/options.cpp:748:                memcpy (optval_, plain_password.c_str (), plain_password.size () + 1);
./src/options.cpp:756:                memcpy (optval_, zap_domain.c_str (), zap_domain.size () + 1);
./src/options.cpp:773:                memcpy (optval_, curve_public_key, CURVE_KEYSIZE);
./src/options.cpp:785:                memcpy (optval_, curve_secret_key, CURVE_KEYSIZE);
./src/options.cpp:797:                memcpy (optval_, curve_server_key, CURVE_KEYSIZE);
./src/options.cpp:826:                memcpy (optval_, gss_principal.c_str (), gss_principal.size () + 1);
./src/options.cpp:834:                memcpy (optval_, gss_service_principal.c_str (), gss_service_principal.size () + 1);
./src/pgm_socket.cpp:92:    memcpy (network, network_, port_delim - network_);
./src/pgm_socket.cpp:301:        memcpy (&sa6, &res->ai_recv_addrs[0].gsr_group, sizeof (sa6));
./src/pgm_socket.cpp:378:        pgm_msgv = (pgm_msgv_t*) malloc (sizeof (pgm_msgv_t) * pgm_msgv_len);
./src/xpub.cpp:178:    memcpy (msg_->data (),
./src/xpub.cpp:203:            memcpy (&unsub [1], data_, size_);
./src/router.cpp:328:        memcpy (msg_->data (), identity.data (), identity.size ());
./src/router.cpp:377:    memcpy (prefetched_id.data (), identity.data (), identity.size ());
./src/socks_connecter.cpp:154:                stream_engine_t *engine = new (std::nothrow)
./src/socks_connecter.cpp:307:    proxy_addr->resolved.tcp_addr = new (std::nothrow) tcp_address_t ();
./src/kqueue.cpp:94:    poll_entry_t *pe = new (std::nothrow) poll_entry_t;
./src/mtrie.cpp:84:            pipes = new (std::nothrow) pipes_t;
./src/mtrie.cpp:143:            next.node = new (std::nothrow) mtrie_t;
./src/mtrie.cpp:151:            next.table [c - min] = new (std::nothrow) mtrie_t;
./src/session_base.cpp:54:        s = new (std::nothrow) req_session_t (io_thread_, active_,
./src/session_base.cpp:68:        s = new (std::nothrow) session_base_t (io_thread_, active_,
./src/session_base.cpp:515:            address_t *proxy_address = new (std::nothrow)
./src/session_base.cpp:525:            tcp_connecter_t *connecter = new (std::nothrow)
./src/session_base.cpp:535:        ipc_connecter_t *connecter = new (std::nothrow) ipc_connecter_t (
./src/session_base.cpp:544:        tipc_connecter_t *connecter = new (std::nothrow) tipc_connecter_t (
./src/session_base.cpp:569:            pgm_sender_t *pgm_sender = new (std::nothrow) pgm_sender_t (
./src/session_base.cpp:581:            pgm_receiver_t *pgm_receiver = new (std::nothrow) pgm_receiver_t (
./src/session_base.cpp:603:            norm_engine_t* norm_sender = new (std::nothrow) norm_engine_t(io_thread, options);
./src/session_base.cpp:614:            norm_engine_t* norm_receiver = new (std::nothrow) norm_engine_t (io_thread, options);
./src/trie.cpp:127:            next.node = new (std::nothrow) trie_t;
./src/trie.cpp:136:            next.table [c - min] = new (std::nothrow) trie_t;
./src/pipe.cpp:50:        upipe1 = new (std::nothrow) upipe_conflate_t ();
./src/pipe.cpp:52:        upipe1 = new (std::nothrow) upipe_normal_t ();
./src/pipe.cpp:57:        upipe2 = new (std::nothrow) upipe_conflate_t ();
./src/pipe.cpp:59:        upipe2 = new (std::nothrow) upipe_normal_t ();
./src/pipe.cpp:62:    pipes_ [0] = new (std::nothrow) pipe_t (parents_ [0], upipe1, upipe2,
./src/pipe.cpp:65:    pipes_ [1] = new (std::nothrow) pipe_t (parents_ [1], upipe2, upipe1,
./src/pipe.cpp:496:        inpipe = new (std::nothrow)
./src/pipe.cpp:499:        inpipe = new (std::nothrow)
./src/pgm_receiver.cpp:237:            it->second.decoder = new (std::nothrow)
./src/tcp_connecter.cpp:141:    stream_engine_t *engine = new (std::nothrow)
./src/tcp_connecter.cpp:224:    addr->resolved.tcp_addr = new (std::nothrow) tcp_address_t ();
./src/tipc_connecter.cpp:124:    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
./src/io_thread.cpp:40:    poller = new (std::nothrow) poller_t (*ctx_);
./src/norm_engine.cpp:416:            rxState = new NormRxStreamState(object, options.maxmsgsize);
./src/norm_engine.cpp:599:    zmq_decoder = new (std::nothrow) v2_decoder_t (in_batch_size, max_msg_size);
./src/tcp_listener.cpp:108:    stream_engine_t *engine = new (std::nothrow)
./src/ctx.cpp:281:        reaper = new (std::nothrow) reaper_t (this, reaper_tid);
./src/ctx.cpp:288:            io_thread_t *io_thread = new (std::nothrow) io_thread_t (this, i);
./src/zmq_utils.cpp:77:    zmq::thread_t* thread = new zmq::thread_t;
./src/ipc_listener.cpp:107:    stream_engine_t *engine = new (std::nothrow)
./src/socket_base.cpp:96:            s = new (std::nothrow) pair_t (parent_, tid_, sid_);
./src/socket_base.cpp:99:            s = new (std::nothrow) pub_t (parent_, tid_, sid_);
./src/socket_base.cpp:102:            s = new (std::nothrow) sub_t (parent_, tid_, sid_);
./src/socket_base.cpp:105:            s = new (std::nothrow) req_t (parent_, tid_, sid_);
./src/socket_base.cpp:108:            s = new (std::nothrow) rep_t (parent_, tid_, sid_);
./src/socket_base.cpp:111:            s = new (std::nothrow) dealer_t (parent_, tid_, sid_);
./src/socket_base.cpp:114:            s = new (std::nothrow) router_t (parent_, tid_, sid_);
./src/socket_base.cpp:117:            s = new (std::nothrow) pull_t (parent_, tid_, sid_);
./src/socket_base.cpp:120:            s = new (std::nothrow) push_t (parent_, tid_, sid_);
./src/socket_base.cpp:123:            s = new (std::nothrow) xpub_t (parent_, tid_, sid_);
./src/socket_base.cpp:126:            s = new (std::nothrow) xsub_t (parent_, tid_, sid_);
./src/socket_base.cpp:129:            s = new (std::nothrow) stream_t (parent_, tid_, sid_);
./src/socket_base.cpp:398:        tcp_listener_t *listener = new (std::nothrow) tcp_listener_t (
./src/socket_base.cpp:417:        ipc_listener_t *listener = new (std::nothrow) ipc_listener_t (
./src/socket_base.cpp:436:         tipc_listener_t *listener = new (std::nothrow) tipc_listener_t (
./src/socket_base.cpp:594:    address_t *paddr = new (std::nothrow) address_t (protocol, address);
./src/socket_base.cpp:639:        paddr->resolved.ipc_addr = new (std::nothrow) ipc_address_t ();
./src/socket_base.cpp:665:        paddr->resolved.tipc_addr = new (std::nothrow) tipc_address_t ();
./src/socket_base.cpp:778:            tcp_address_t *tcp_addr = new (std::nothrow) tcp_address_t ();
./src/stream_engine.cpp:208:        encoder = new (std::nothrow) raw_encoder_t (out_batch_size);
./src/stream_engine.cpp:211:        decoder = new (std::nothrow) raw_decoder_t (in_batch_size);
./src/stream_engine.cpp:226:            metadata = new (std::nothrow) metadata_t (properties);
./src/stream_engine.cpp:575:        encoder = new (std::nothrow) v1_encoder_t (out_batch_size);
./src/stream_engine.cpp:578:        decoder = new (std::nothrow) v1_decoder_t (in_batch_size, options.maxmsgsize);
./src/stream_engine.cpp:622:        encoder = new (std::nothrow) v1_encoder_t (
./src/stream_engine.cpp:626:        decoder = new (std::nothrow) v1_decoder_t (
./src/stream_engine.cpp:638:        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);
./src/stream_engine.cpp:641:        decoder = new (std::nothrow) v2_decoder_t (
./src/stream_engine.cpp:646:        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);
./src/stream_engine.cpp:649:        decoder = new (std::nothrow) v2_decoder_t (
./src/stream_engine.cpp:655:            mechanism = new (std::nothrow)
./src/stream_engine.cpp:663:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:666:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:675:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:678:                mechanism = new (std::nothrow) curve_client_t (options);
./src/stream_engine.cpp:687:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:690:                mechanism = new (std::nothrow) gssapi_client_t (options);
./src/stream_engine.cpp:844:        metadata = new (std::nothrow) metadata_t (properties);
./src/tipc_listener.cpp:92:    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
./src/zmq.cpp:155:    zmq::ctx_t *ctx = new (std::nothrow) zmq::ctx_t;
./src/epoll.cpp:65:    poll_entry_t *pe = new (std::nothrow) poll_entry_t;
./src/ipc_connecter.cpp:125:    stream_engine_t *engine = new (std::nothrow)
./src/reaper.cpp:39:    poller = new (std::nothrow) poller_t (*ctx_);

== files() ==
./src/curve_server.cpp:318:    int rc = crypto_box_open (hello_plaintext, hello_box,
./src/curve_server.cpp:421:    int rc = crypto_secretbox_open (cookie_plaintext, cookie_box,
./src/curve_server.cpp:455:    rc = crypto_box_open (initiate_plaintext, initiate_box,
./src/curve_server.cpp:479:    rc = crypto_box_open (vouch_plaintext, vouch_box,
./src/curve_client.cpp:309:    int rc = crypto_box_open (welcome_plaintext, welcome_box,
./src/devpoll.cpp:52:    devpoll_fd = open ("/dev/poll", O_RDWR);
./src/tcp_connecter.cpp:164:    const int rc = open ();
./src/tcp_connecter.cpp:214:int zmq::tcp_connecter_t::open ()
./src/tipc_connecter.cpp:146:    int rc = open ();
./src/tipc_connecter.cpp:200:int zmq::tipc_connecter_t::open ()
./src/ipc_connecter.cpp:148:    int rc = open ();
./src/ipc_connecter.cpp:202:int zmq::ipc_connecter_t::open ()
./tweetnacl/src/tweetnacl.c:264:int crypto_secretbox_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *k)
./tweetnacl/src/tweetnacl.c:479:  return crypto_secretbox_open(m,c,d,n,k);
./tweetnacl/src/tweetnacl.c:489:int crypto_box_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *y,const u8 *x)
./tweetnacl/src/tweetnacl.c:788:int crypto_sign_open(u8 *m,u64 *mlen,const u8 *sm,u64 n,const u8 *pk)
./tweetnacl/src/tweetnacl_base.h:43:int crypto_box_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *y,const u8 *x);
./tweetnacl/src/tweetnacl_base.h:46:int crypto_secretbox_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *k);
./tweetnacl/src/tweetnacl.h:43:extern int crypto_box_curve25519xsalsa20poly1305_tweet_open(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *,const unsigned char *);
./tweetnacl/src/tweetnacl.h:190:extern int crypto_secretbox_xsalsa20poly1305_tweet_open(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *);
./tweetnacl/src/tweetnacl.h:213:extern int crypto_sign_ed25519_tweet_open(unsigned char *,unsigned long long *,const unsigned char *,unsigned long long,const unsigned char *);
./tweetnacl/contrib/randombytes/devurandom.c:16:      fd = open("/dev/urandom",O_RDONLY);

== logging() ==
./src/socks_connecter.cpp:116:            error ();
./src/socks_connecter.cpp:122:                 error ();
./src/socks_connecter.cpp:127:                     error ();
./src/socks_connecter.cpp:142:            error ();
./src/socks_connecter.cpp:148:                error ();
./src/socks_connecter.cpp:173:        error ();
./src/socks_connecter.cpp:185:            error ();
./src/socks_connecter.cpp:197:            error ();
./src/socks_connecter.cpp:209:            error ();
./src/socks_connecter.cpp:266:void zmq::socks_connecter_t::error ()
./src/curve_server.cpp:93:            rc = produce_error (msg_);
./src/curve_server.cpp:569:int zmq::curve_server_t::produce_error (msg_t *msg_) const
./src/curve_server.cpp:590:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:598:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:606:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:614:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:622:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:630:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:638:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:645:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:661:        rc = session->read_zap_msg (&msg [i]);
./src/gssapi_mechanism_base.cpp:73:int zmq::gssapi_mechanism_base_t::encode_message (msg_t *msg_)
./src/gssapi_mechanism_base.cpp:123:int zmq::gssapi_mechanism_base_t::decode_message (msg_t *msg_)
./src/gssapi_mechanism_base.cpp:294:        return encode_message (msg_);
./src/gssapi_mechanism_base.cpp:302:        const int rc = decode_message (msg_);
./src/xsub.cpp:37:    has_message (false),
./src/plain_server.cpp:73:            rc = produce_error (msg_);
./src/plain_server.cpp:271:int zmq::plain_server_t::produce_error (msg_t *msg_) const
./src/plain_server.cpp:293:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:301:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:309:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:317:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:325:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:333:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:341:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:349:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:356:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:372:        rc = session->read_zap_msg (&msg [i]);
./src/session_base.cpp:124:int zmq::session_base_t::pull_msg (msg_t *msg_)
./src/session_base.cpp:136:int zmq::session_base_t::push_msg (msg_t *msg_)
./src/session_base.cpp:148:int zmq::session_base_t::read_zap_msg (msg_t *msg_)
./src/session_base.cpp:163:int zmq::session_base_t::write_zap_msg (msg_t *msg_)
./src/session_base.cpp:205:        rc = pull_msg (&msg);
./src/session_base.cpp:391:void zmq::session_base_t::engine_error (
./src/gssapi_client.cpp:151:      return encode_message (msg_);
./src/gssapi_client.cpp:161:      return decode_message (msg_);
./src/msg.cpp:48://  Check whether the sizes of public representation of the message (zmq_msg_t)
./src/msg.cpp:49://  and private representation of the message (zmq::msg_t) match.
./src/msg.cpp:336:bool zmq::msg_t::is_cmsg ()
./src/curve_client.cpp:110:        rc = process_error (msg_data, msg_size);
./src/curve_client.cpp:442:int zmq::curve_client_t::process_error (
./src/stream.cpp:104:        //  If we have malformed message (prefix with no subsequent message)
./src/pgm_sender.cpp:187:            int rc = session->pull_msg (&msg);
./src/pgm_sender.cpp:191:            encoder.load_msg (&msg);
./src/pgm_receiver.cpp:130:    int rc = session->push_msg (it->second.decoder->msg ());
./src/pgm_receiver.cpp:278:        rc = session->push_msg (decoder->msg ());
./src/pgm_receiver.cpp:301:    while (session->pull_msg (&msg) == 0)
./src/gssapi_server.cpp:163:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:171:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:179:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:187:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:195:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:203:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:211:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:221:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:238:        rc = session->read_zap_msg (&msg [i]);
./src/gssapi_server.cpp:301:      return encode_message (msg_);
./src/gssapi_server.cpp:311:      return decode_message (msg_);
./src/norm_engine.cpp:16:   tx_first_msg(true), tx_more_bit(false), 
./src/norm_engine.cpp:290:                if (-1 == zmq_session->pull_msg(&tx_msg))
./src/norm_engine.cpp:296:                zmq_encoder.load_msg(&tx_msg);
./src/norm_engine.cpp:458:                case -1: // decoding error (shouldn't happen w/ NORM, but ...)
./src/norm_engine.cpp:539:                int rc = zmq_session->push_msg(msg);
./src/norm_engine.cpp:649:                // decoder error (reset decoder and state variables)
./src/null_mechanism.cpp:227:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:235:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:243:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:251:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:259:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:267:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:274:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:290:        rc = session->read_zap_msg (&msg [i]);
./src/plain_client.cpp:87:        rc = process_error (cmd_data, data_size);
./src/plain_client.cpp:204:int zmq::plain_client_t::process_error (
./src/socket_base.cpp:1357:        zmq_sendmsg (monitor_socket, &msg, ZMQ_SNDMORE);
./src/socket_base.cpp:1362:        zmq_sendmsg (monitor_socket, &msg, 0);
./src/tcp.cpp:162:    //  we'll get an error (this may happen during the speculative write).
./src/tcp.cpp:215:    //  we'll get an error (this may happen during the speculative read).
./src/stream_engine.cpp:98:    next_msg (&stream_engine_t::identity_msg),
./src/stream_engine.cpp:99:    process_msg (&stream_engine_t::process_identity_msg),
./src/stream_engine.cpp:100:    io_error (false),
./src/stream_engine.cpp:313:            error (connection_error);
./src/stream_engine.cpp:318:                error (connection_error);
./src/stream_engine.cpp:336:        rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:345:            error (protocol_error);
./src/stream_engine.cpp:376:            encoder->load_msg (&tx_msg);
./src/stream_engine.cpp:441:    int rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:446:            error (protocol_error);
./src/stream_engine.cpp:458:        rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:467:        error (connection_error);
./src/stream_engine.cpp:470:        error (protocol_error);
./src/stream_engine.cpp:490:            error (connection_error);
./src/stream_engine.cpp:495:                error (connection_error);
./src/stream_engine.cpp:571:           error (protocol_error);
./src/stream_engine.cpp:593:        encoder->load_msg (&tx_msg);
./src/stream_engine.cpp:618:           error (protocol_error);
./src/stream_engine.cpp:634:           error (protocol_error);
./src/stream_engine.cpp:695:            error (protocol_error);
./src/stream_engine.cpp:718:int zmq::stream_engine_t::identity_msg (msg_t *msg_)
./src/stream_engine.cpp:728:int zmq::stream_engine_t::process_identity_msg (msg_t *msg_)
./src/stream_engine.cpp:732:        int rc = session->push_msg (msg_);
./src/stream_engine.cpp:796:        error (protocol_error);
./src/stream_engine.cpp:810:        const int rc = session->push_msg (&identity);
./src/stream_engine.cpp:849:    return session->pull_msg (msg_);
./src/stream_engine.cpp:854:    return session->push_msg (msg_);
./src/stream_engine.cpp:875:        rc = session->push_msg (&msg);
./src/stream_engine.cpp:890:    if (session->pull_msg (msg_) == -1)
./src/stream_engine.cpp:905:    if (session->push_msg (msg_) == -1) {
./src/stream_engine.cpp:915:    const int rc = session->push_msg (msg_);
./src/stream_engine.cpp:921:int zmq::stream_engine_t::write_subscription_msg (msg_t *msg_)
./src/stream_engine.cpp:930:    rc = session->push_msg (&subscription);
./src/stream_engine.cpp:938:void zmq::stream_engine_t::error (error_reason_t reason)
./src/stream_engine.cpp:951:    session->engine_error (reason);
./src/stream_engine.cpp:972:    error (timeout_error);
./src/req.cpp:263:int zmq::req_session_t::push_msg (msg_t *msg_)
./src/req.cpp:269:            return session_base_t::push_msg (msg_);
./src/req.cpp:274:            return session_base_t::push_msg (msg_);
./src/req.cpp:277:            return session_base_t::push_msg (msg_);
./src/err.cpp:66:        return strerror (errno_);
./src/err.cpp:89:const char *zmq::wsa_error()
./src/err.cpp:210:void zmq::win_error (char *buffer_, size_t buffer_size_)
./src/zmq.cpp:100:const char *zmq_strerror (int errnum_)
./src/zmq.cpp:343:s_sendmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:353:int zmq_sendmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:371:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:397:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:438:        rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:454:s_recvmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:463:int zmq_recvmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:480:    int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:536:        int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:590:    int result = s_sendmsg (s, msg_, flags_);
./src/zmq.cpp:601:    int result = s_recvmsg (s, msg_, flags_);
./src/zmq.cpp:644:            return (((zmq::msg_t*) msg_)->is_cmsg ()) ||
./src/router.cpp:195:        //  If we have malformed message (prefix with no subsequent message)
./perf/remote_lat.cpp:61:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:67:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:73:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:79:        printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:87:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_lat.cpp:89:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:92:        rc = zmq_recvmsg (s, &msg, 0);
./perf/remote_lat.cpp:94:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:107:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:119:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:125:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:57:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:63:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:69:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:75:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:80:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:82:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:89:        rc = zmq_sendmsg (s, &msg, 0);
./perf/local_lat.cpp:91:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:98:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:106:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:112:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:64:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:70:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:78:            printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:85:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:87:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:92:            printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:99:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:137:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:143:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:149:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:163:        printf ("error in pthread_create: %s\n", zmq_strerror (rc));
./perf/inproc_thr.cpp:170:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:177:    rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:179:        printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:190:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:192:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:207:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:225:        printf ("error in pthread_join: %s\n", zmq_strerror (rc));
./perf/inproc_thr.cpp:232:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:238:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:58:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:64:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:73:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:80:            printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:83:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_thr.cpp:85:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:90:            printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:97:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:103:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:60:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:66:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:75:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:81:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:85:    rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:87:        printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:98:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:100:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:115:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:130:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:136:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:62:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:68:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:74:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:79:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:81:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:84:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:86:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:93:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:99:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:136:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:142:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:148:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:162:        printf ("error in pthread_create: %s\n", zmq_strerror (rc));
./perf/inproc_lat.cpp:169:        printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:180:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:182:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:185:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:187:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:200:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:220:        printf ("error in pthread_join: %s\n", zmq_strerror (rc));
./perf/inproc_lat.cpp:229:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:235:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./builds/msvc/errno.cpp:12:char* strerror(int errno)
./include/zmq.h:169:ZMQ_EXPORT const char *zmq_strerror (int errnum);
./include/zmq.h:414:ZMQ_EXPORT int zmq_sendmsg (void *s, zmq_msg_t *msg, int flags);
./include/zmq.h:415:ZMQ_EXPORT int zmq_recvmsg (void *s, zmq_msg_t *msg, int flags);

== environment() ==

== privileged() ==
./src/tcp_address.cpp:69:    int rc = ioctl (fd, SIOCGLIFNUM, (char*) &ifn);
./src/tcp_address.cpp:83:    rc = ioctl (fd, SIOCGLIFCONF, (char*) &ifc);
./src/tcp_address.cpp:92:            rc = ioctl (fd, SIOCGLIFADDR, (char*) ifrp);
./src/tcp_address.cpp:144:    const int rc = ioctl (sd, SIOCGIFADDR, (caddr_t) &ifr, sizeof ifr);
./src/devpoll.cpp:175:        int n = ioctl (devpoll_fd, DP_POLL, &poll_req);
./src/ip.cpp:91:    int rc = ioctl (s_, FIONBIO, &nonblock);

== networking() ==
./src/socks_connecter.cpp:321:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/socks_connecter.cpp:332:    if (tcp_addr->family () == AF_INET6)
./src/signaler.cpp:401:    listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:417:    addr.sin_family = AF_INET;
./src/signaler.cpp:422:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:522:    //  Whilst OpenVMS supports socketpair - it maps to AF_INET only.  Further,
./src/signaler.cpp:530:    lcladdr.sin_family = AF_INET;
./src/signaler.cpp:534:    int listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:555:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:577:    int rc = socketpair (AF_UNIX, SOCK_STREAM, 0, sv);
./src/tcp_address.cpp:62:    const int fd = open_socket (AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:67:    ifn.lifn_family = AF_INET;
./src/tcp_address.cpp:79:    ifc.lifc_family = AF_INET;
./src/tcp_address.cpp:86:    //  Find the interface with the specified name and AF_INET family.
./src/tcp_address.cpp:94:            if (ifrp->lifr_addr.ss_family == AF_INET) {
./src/tcp_address.cpp:135:    const int sd = open_socket (ipv6_ ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:155:    if ((family == AF_INET || (ipv6_ && family == AF_INET6))
./src/tcp_address.cpp:160:                    (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:164:                    (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:201:        if ((family == AF_INET || (ipv6_ && family == AF_INET6))
./src/tcp_address.cpp:205:                        (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:209:                        (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:254:        ip6_addr.sin6_family = AF_INET6;
./src/tcp_address.cpp:262:        ip4_addr.sin_family = AF_INET;
./src/tcp_address.cpp:294:    req.ai_family = ipv6_? AF_INET6: AF_INET;
./src/tcp_address.cpp:297:    req.ai_socktype = SOCK_STREAM;
./src/tcp_address.cpp:309:    if (req.ai_family == AF_INET6)
./src/tcp_address.cpp:347:    req.ai_family = ipv6_? AF_INET6: AF_INET;
./src/tcp_address.cpp:351:    req.ai_socktype = SOCK_STREAM;
./src/tcp_address.cpp:359:    if (req.ai_family == AF_INET6)
./src/tcp_address.cpp:409:    if (sa->sa_family == AF_INET && sa_len >= (socklen_t) sizeof address.ipv4)
./src/tcp_address.cpp:412:    if (sa->sa_family == AF_INET6 && sa_len >= (socklen_t) sizeof address.ipv6)
./src/tcp_address.cpp:476:        if (source_address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:482:        if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:493:    if (address.generic.sa_family != AF_INET
./src/tcp_address.cpp:494:    &&  address.generic.sa_family != AF_INET6) {
./src/tcp_address.cpp:508:    if (address.generic.sa_family == AF_INET6) {
./src/tcp_address.cpp:528:    if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:541:    if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:597:        if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:609:            (address.generic.sa_family == AF_INET6 && mask > 128) ||
./src/tcp_address.cpp:610:            (address.generic.sa_family != AF_INET6 && mask > 32)
./src/tcp_address.cpp:623:    if (address.generic.sa_family != AF_INET
./src/tcp_address.cpp:624:    &&  address.generic.sa_family != AF_INET6) {
./src/tcp_address.cpp:640:    if (address.generic.sa_family == AF_INET6) {
./src/tcp_address.cpp:665:        if (ss->sa_family == AF_INET6) {
./src/tcp_connecter.cpp:237:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:240:    if (s == zmq::retired_fd && tcp_addr->family () == AF_INET6
./src/tcp_connecter.cpp:250:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:265:    if (tcp_addr->family () == AF_INET6)
./src/tipc_connecter.cpp:205:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tcp_listener.cpp:169:    s = open_socket (address.family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:172:    if (s == zmq::retired_fd && address.family () == AF_INET6
./src/tcp_listener.cpp:178:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:198:    if (address.family () == AF_INET6)
./src/ipc_listener.cpp:171:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ip.cpp:53:#if defined ZMQ_HAVE_SOCK_CLOEXEC
./src/ip.cpp:54:    type_ |= SOCK_CLOEXEC;
./src/ip.cpp:66:    //  If there's no SOCK_CLOEXEC, let's try the second best option. Note that
./src/ip.cpp:69:#if !defined ZMQ_HAVE_SOCK_CLOEXEC && defined FD_CLOEXEC
./src/tipc_address.cpp:49:    if (sa->sa_family == AF_TIPC)
./src/tipc_address.cpp:68:        address.family = AF_TIPC;
./src/tipc_address.cpp:84:    address.family = AF_TIPC;
./src/tipc_address.cpp:95:    if (address.family != AF_TIPC) {
./src/stream_engine.cpp:119:    if (family == PF_UNIX) {
./src/stream_engine.cpp:130:    if (family == PF_UNIX) {
./src/socks.cpp:159:    if (rc == 0 && res->ai_family == AF_INET) {
./src/socks.cpp:167:    if (rc == 0 && res->ai_family == AF_INET6) {
./src/tipc_listener.cpp:132:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/ipc_address.cpp:49:    if (sa->sa_family == AF_UNIX)
./src/ipc_address.cpp:68:    address.sun_family = AF_UNIX;
./src/ipc_address.cpp:78:    if (address.sun_family != AF_UNIX) {
./src/pgm_socket.cpp:98:    hints.ai_family = AF_UNSPEC;
./src/pgm_socket.cpp:150:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_UDP,
./src/pgm_socket.cpp:178:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_PGM,
./src/pgm_socket.cpp:299:    if (AF_INET6 == sa_family) {
./src/pgm_socket.cpp:351:		if (AF_INET6 != sa_family)
./src/ipc_connecter.cpp:207:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/lb.cpp:103:        if (pipes [current]->write (msg_))
./src/lb.cpp:149:        if (pipes [current]->check_write ())
./src/fq.cpp:98:        bool fetched = pipes [current]->read (msg_);
./src/fq.cpp:144:        if (pipes [current]->check_read ())
./src/socks_connecter.cpp:69:    socket = session->get_socket ();
./src/socks_connecter.cpp:83:        initiate_connect ();
./src/socks_connecter.cpp:219:void zmq::socks_connecter_t::initiate_connect ()
./src/socks_connecter.cpp:263:    initiate_connect ();
./src/socks_connecter.cpp:321:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/socks_connecter.cpp:339:    // Set the socket to non-blocking mode so that we get async connect().
./src/socks_connecter.cpp:340:    unblock_socket (s);
./src/socks_connecter.cpp:354:        rc = ::bind (s, tcp_addr->src_addr (), tcp_addr->src_addrlen ());
./src/socks_connecter.cpp:362:    rc = ::connect (s, tcp_addr->addr (), tcp_addr->addrlen ());
./src/socks_connecter.cpp:432:    tune_tcp_socket (s);
./src/socks_connecter.cpp:443:    const int rc = closesocket (s);
./src/curve_server.cpp:502:    rc = session->zap_connect ();
./src/object.cpp:77:        process_activate_read ();
./src/object.cpp:81:        process_activate_write (cmd_.args.activate_write.msgs_read);
./src/object.cpp:104:        process_bind (cmd_.args.bind.pipe);
./src/object.cpp:183:void zmq::object_t::destroy_socket (socket_base_t *socket_)
./src/object.cpp:185:    ctx->destroy_socket (socket_);
./src/object.cpp:188:zmq::io_thread_t *zmq::object_t::choose_io_thread (uint64_t affinity_)
./src/object.cpp:190:    return ctx->choose_io_thread (affinity_);
./src/object.cpp:237:void zmq::object_t::send_bind (own_t *destination_, pipe_t *pipe_,
./src/object.cpp:250:void zmq::object_t::send_activate_read (pipe_t *destination_)
./src/object.cpp:258:void zmq::object_t::send_activate_write (pipe_t *destination_,
./src/object.cpp:373:void zmq::object_t::process_bind (pipe_t *)
./src/object.cpp:378:void zmq::object_t::process_activate_read ()
./src/object.cpp:383:void zmq::object_t::process_activate_write (uint64_t)
./src/xsub.cpp:236:    bool sent = pipe->write (&msg);
./src/poll.cpp:120:    ctx.start_thread (worker, worker_routine, this);
./src/plain_server.cpp:195:    int rc = session->zap_connect ();
./src/kqueue.cpp:158:    ctx.start_thread (worker, worker_routine, this);
./src/session_base.cpp:90:    socket (socket_),
./src/session_base.cpp:91:    io_thread (io_thread_),
./src/session_base.cpp:126:    if (!pipe || !pipe->read (msg_)) {
./src/session_base.cpp:138:    if (pipe && pipe->write (msg_)) {
./src/session_base.cpp:155:    if (!zap_pipe->read (msg_)) {
./src/session_base.cpp:170:    const bool ok = zap_pipe->write (msg_);
./src/session_base.cpp:259:        pipe->check_read ();
./src/session_base.cpp:288:zmq::socket_base_t *zmq::session_base_t::get_socket ()
./src/session_base.cpp:299:int zmq::session_base_t::zap_connect ()
./src/session_base.cpp:328:    send_bind (peer.socket, new_pipes [1], false);
./src/session_base.cpp:336:        bool ok = zap_pipe->write (&id);
./src/session_base.cpp:382:        send_bind (socket, pipes [1]);
./src/session_base.cpp:409:                reconnect ();
./src/session_base.cpp:420:        pipe->check_read ();
./src/session_base.cpp:423:        zap_pipe->check_read ();
./src/session_base.cpp:458:            pipe->check_read ();
./src/session_base.cpp:477:void zmq::session_base_t::reconnect ()
./src/session_base.cpp:508:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/signaler.cpp:128:        unblock_socket (w);
./src/signaler.cpp:129:        unblock_socket (r);
./src/signaler.cpp:148:        rc = closesocket (w);
./src/signaler.cpp:150:        rc = closesocket (r);
./src/signaler.cpp:176:    ssize_t sz = write (w, &inc, sizeof (inc));
./src/signaler.cpp:281:    ssize_t sz = read (r, &dummy, sizeof (dummy));
./src/signaler.cpp:288:        ssize_t sz2 = write (w, &inc, sizeof (inc));
./src/signaler.cpp:401:    listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:422:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:437:    rc = bind (listener, (const struct sockaddr*) &addr, sizeof addr);
./src/signaler.cpp:447:        rc = listen (listener, 1);
./src/signaler.cpp:451:        rc = connect (*w_, (struct sockaddr*) &addr, sizeof addr);
./src/signaler.cpp:484:    closesocket (listener);
./src/signaler.cpp:511:            rc = closesocket (*w_);
./src/signaler.cpp:534:    int listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:544:    rc = bind (listener, (struct sockaddr*) &lcladdr, sizeof lcladdr);
./src/signaler.cpp:552:    rc = listen (listener, 1);
./src/signaler.cpp:555:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:564:    rc = connect (*w_, (struct sockaddr*) &lcladdr, sizeof lcladdr);
./src/mailbox.cpp:38:    const bool ok = cpipe.read (NULL);
./src/mailbox.cpp:61:    cpipe.write (cmd_, false);
./src/mailbox.cpp:72:        if (cpipe.read (cmd_))
./src/mailbox.cpp:93:    const bool ok = cpipe.read (cmd_);
./src/stream.cpp:116:                if (!current_out->check_write ()) {
./src/stream.cpp:160:        bool ok = current_out->write (msg_);
./src/pgm_sender.cpp:55:    pgm_socket (false, options_),
./src/dealer.cpp:57:        rc = pipe_->write (&probe_msg_);
./src/tcp_address.cpp:62:    const int fd = open_socket (AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:135:    const int sd = open_socket (ipv6_ ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
./src/devpoll.cpp:65:    ssize_t rc = write (devpoll_fd, &pfd, sizeof pfd);
./src/devpoll.cpp:139:    ctx.start_thread (worker, worker_routine, this);
./src/pipe.cpp:84:    msgs_read (0),
./src/pipe.cpp:86:    peers_msgs_read (0),
./src/pipe.cpp:128:bool zmq::pipe_t::check_read ()
./src/pipe.cpp:136:    if (!inpipe->check_read ()) {
./src/pipe.cpp:145:        bool ok = inpipe->read (&msg);
./src/pipe.cpp:154:bool zmq::pipe_t::read (msg_t *msg_)
./src/pipe.cpp:162:    if (!inpipe->read (msg_)) {
./src/pipe.cpp:186:        send_activate_write (peer, msgs_read);
./src/pipe.cpp:191:bool zmq::pipe_t::check_write ()
./src/pipe.cpp:206:bool zmq::pipe_t::write (msg_t *msg_)
./src/pipe.cpp:208:    if (unlikely (!check_write ()))
./src/pipe.cpp:213:    outpipe->write (*msg_, more);
./src/pipe.cpp:225:        while (outpipe->unwrite (&msg)) {
./src/pipe.cpp:240:        send_activate_read (peer);
./src/pipe.cpp:243:void zmq::pipe_t::process_activate_read ()
./src/pipe.cpp:251:void zmq::pipe_t::process_activate_write (uint64_t msgs_read_)
./src/pipe.cpp:269:    while (outpipe->read (&msg)) {
./src/pipe.cpp:353:        while (inpipe->read (&msg)) {
./src/pipe.cpp:432:        outpipe->write (msg, false);
./src/pgm_receiver.cpp:51:    pgm_socket (true, options_),
./src/gssapi_server.cpp:128:        int rc = session->zap_connect ();
./src/tcp_connecter.cpp:77:    socket = session->get_socket ();
./src/tcp_connecter.cpp:126:    const fd_t fd = connect ();
./src/tcp_connecter.cpp:134:    tune_tcp_socket (fd);
./src/tcp_connecter.cpp:237:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:250:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:272:    // Set the socket to non-blocking mode so that we get async connect().
./src/tcp_connecter.cpp:273:    unblock_socket (s);
./src/tcp_connecter.cpp:287:        rc = ::bind (s, tcp_addr->src_addr (), tcp_addr->src_addrlen ());
./src/tcp_connecter.cpp:293:    rc = ::connect (s, tcp_addr->addr (), tcp_addr->addrlen ());
./src/tcp_connecter.cpp:314:zmq::fd_t zmq::tcp_connecter_t::connect ()
./src/tcp_connecter.cpp:374:    const int rc = closesocket (s);
./src/tipc_connecter.cpp:67:    socket = session-> get_socket();
./src/tipc_connecter.cpp:113:    fd_t fd = connect ();
./src/tipc_connecter.cpp:205:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tipc_connecter.cpp:210:    unblock_socket (s);
./src/tipc_connecter.cpp:212:    int rc = ::connect (
./src/tipc_connecter.cpp:239:zmq::fd_t zmq::tipc_connecter_t::connect ()
./src/null_mechanism.cpp:62:    &&  session->zap_connect () == 0)
./src/thread.cpp:55:    descriptor = (HANDLE) CreateThread (NULL, 0,
./src/tcp_listener.cpp:67:    socket (socket_)
./src/tcp_listener.cpp:101:    tune_tcp_socket (fd);
./src/tcp_listener.cpp:114:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/tcp_listener.cpp:131:    int rc = closesocket (s);
./src/tcp_listener.cpp:169:    s = open_socket (address.family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:178:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:225:    rc = bind (s, address.addr (), address.addrlen ());
./src/tcp_listener.cpp:237:    rc = listen (s, options.backlog);
./src/tcp_listener.cpp:314:            int rc = closesocket (sock);
./src/ctx.cpp:58:int clipped_maxsocket(int max_requested)
./src/ctx.cpp:74:    max_sockets (clipped_maxsocket (ZMQ_MAX_SOCKETS_DFLT)),
./src/ctx.cpp:127:        zmq::socket_base_t *s = create_socket (ZMQ_PAIR);
./src/ctx.cpp:128:        s->bind (p->first.c_str ());
./src/ctx.cpp:204:    &&  optval_ >= 1 && optval_ == clipped_maxsocket (optval_)) {
./src/ctx.cpp:247:        rc = clipped_maxsocket (65535);
./src/ctx.cpp:261:zmq::socket_base_t *zmq::ctx_t::create_socket (int type_)
./src/ctx.cpp:338:void zmq::ctx_t::destroy_socket (class socket_base_t *socket_)
./src/ctx.cpp:363:void zmq::ctx_t::start_thread (thread_t &thread_, thread_fn *tfn_, void *arg_) const
./src/ctx.cpp:374:zmq::io_thread_t *zmq::ctx_t::choose_io_thread (uint64_t affinity_)
./src/ctx.cpp:514:        const bool ok = pending_connection_.bind_pipe->read (&msg);
./src/ctx.cpp:548:        pending_connection_.connect_pipe->send_bind (bind_socket_, pending_connection_.bind_pipe, false);
./src/ctx.cpp:556:        bool written = pending_connection_.bind_pipe->write (&id);
./src/pair.cpp:88:    if (!pipe || !pipe->write (msg_)) {
./src/pair.cpp:109:    if (!pipe || !pipe->read (msg_)) {
./src/pair.cpp:127:    return pipe->check_read ();
./src/pair.cpp:135:    return pipe->check_write ();
./src/ipc_listener.cpp:72:    socket (socket_)
./src/ipc_listener.cpp:113:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/ipc_listener.cpp:171:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ipc_listener.cpp:178:    rc = bind (s, address.addr (), address.addrlen ());
./src/ipc_listener.cpp:186:    rc = listen (s, options.backlog);
./src/select.cpp:150:    ctx.start_thread (worker, worker_routine, this);
./src/ip.cpp:49:zmq::fd_t zmq::open_socket (int domain_, int type_, int protocol_)
./src/ip.cpp:57:    fd_t s = socket (domain_, type_, protocol_);
./src/ip.cpp:83:void zmq::unblock_socket (fd_t s_)
./src/ip.cpp:87:    int rc = ioctlsocket (s_, FIONBIO, &nonblock);
./src/socket_base.cpp:152:    monitor_socket (NULL),
./src/socket_base.cpp:355:int zmq::socket_base_t::bind (const char *addr_)
./src/socket_base.cpp:386:        return connect (addr_);
./src/socket_base.cpp:391:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/socket_base.cpp:458:int zmq::socket_base_t::connect (const char *addr_)
./src/socket_base.cpp:528:            bool written = new_pipes [0]->write (&id);
./src/socket_base.cpp:543:                bool written = new_pipes [0]->write (&id);
./src/socket_base.cpp:555:                bool written = new_pipes [1]->write (&id);
./src/socket_base.cpp:563:            send_bind (peer.socket, new_pipes [1], false);
./src/socket_base.cpp:588:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/socket_base.cpp:1076:void zmq::socket_base_t::process_bind (pipe_t *pipe_)
./src/socket_base.cpp:1178:        destroy_socket (this);
./src/socket_base.cpp:1260:    monitor_socket = zmq_socket (get_ctx (), ZMQ_PAIR);
./src/socket_base.cpp:1271:    rc = zmq_bind (monitor_socket, addr_);
./src/socket_base.cpp:1357:        zmq_sendmsg (monitor_socket, &msg, ZMQ_SNDMORE);
./src/socket_base.cpp:1362:        zmq_sendmsg (monitor_socket, &msg, 0);
./src/dist.cpp:157:            if(!write (pipes [i], msg_))
./src/dist.cpp:173:        if (!write (pipes [i], msg_)) {
./src/dist.cpp:191:bool zmq::dist_t::write (pipe_t *pipe_, msg_t *msg_)
./src/dist.cpp:193:    if (!pipe_->write (msg_)) {
./src/tcp.cpp:49:void zmq::tune_tcp_socket (fd_t s_)
./src/tcp.cpp:155:int zmq::tcp_write (fd_t s_, const void *data_, size_t size_)
./src/tcp.cpp:208:int zmq::tcp_read (fd_t s_, void *data_, size_t size_)
./src/stream_engine.cpp:93:    greeting_bytes_read (0),
./src/stream_engine.cpp:106:    socket (NULL)
./src/stream_engine.cpp:112:    unblock_socket (s);
./src/stream_engine.cpp:160:        int rc = closesocket (s);
./src/stream_engine.cpp:199:    socket = session-> get_socket ();
./src/stream_engine.cpp:311:        const int rc = tcp_read (s, inpos, bufsize);
./src/stream_engine.cpp:398:    const int nbytes = tcp_write (s, outpos, outsize);
./src/stream_engine.cpp:487:        const int n = tcp_read (s, greeting_recv + greeting_bytes_read,
./src/socks.cpp:78:    const int rc = tcp_write (
./src/socks.cpp:100:    : bytes_read (0)
./src/socks.cpp:106:    const int rc = tcp_read (fd_, buf + bytes_read, 2 - bytes_read);
./src/socks.cpp:193:    const int rc = tcp_write (
./src/socks.cpp:216:    : bytes_read (0)
./src/socks.cpp:237:    const int rc = tcp_read (fd_, buf + bytes_read, n);
./src/tipc_listener.cpp:57:    socket (socket_)
./src/tipc_listener.cpp:97:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/tipc_listener.cpp:132:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tipc_listener.cpp:139:    rc = bind (s, address.addr (), address.addrlen ());
./src/tipc_listener.cpp:144:    rc = listen (s, options.backlog);
./src/zmq.cpp:243:void *zmq_socket (void *ctx_, int type_)
./src/zmq.cpp:250:    zmq::socket_base_t *s = ctx->create_socket (type_);
./src/zmq.cpp:298:int zmq_bind (void *s_, const char *addr_)
./src/zmq.cpp:305:    int result = s->bind (addr_);
./src/zmq.cpp:309:int zmq_connect (void *s_, const char *addr_)
./src/zmq.cpp:316:    int result = s->connect (addr_);
./src/zmq.cpp:320:int zmq_unbind (void *s_, const char *addr_)
./src/zmq.cpp:330:int zmq_disconnect (void *s_, const char *addr_)
./src/zmq.cpp:343:s_sendmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:353:int zmq_sendmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:371:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:397:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:438:        rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:454:s_recvmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:463:int zmq_recvmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:480:    int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:536:        int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:590:    int result = s_sendmsg (s, msg_, flags_);
./src/zmq.cpp:601:    int result = s_recvmsg (s, msg_, flags_);
./src/epoll.cpp:132:    ctx.start_thread (worker, worker_routine, this);
./src/pgm_socket.cpp:150:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_UDP,
./src/pgm_socket.cpp:178:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_PGM,
./src/pgm_socket.cpp:362:    if (!pgm_connect (sock, &pgm_error)) {
./src/ipc_connecter.cpp:68:    socket = session-> get_socket();
./src/ipc_connecter.cpp:114:    fd_t fd = connect ();
./src/ipc_connecter.cpp:207:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ipc_connecter.cpp:212:    unblock_socket (s);
./src/ipc_connecter.cpp:215:    int rc = ::connect (
./src/ipc_connecter.cpp:244:zmq::fd_t zmq::ipc_connecter_t::connect ()
./src/xpub.cpp:69:    while (pipe_->read (&sub)) {
./src/router.cpp:79:        rc = pipe_->write (&probe_msg_);
./src/router.cpp:210:                if (!current_out->check_write ()) {
./src/router.cpp:258:        bool ok = current_out->write (msg_);
./src/router.cpp:424:        ok = pipe_->read (&msg);
./perf/remote_lat.cpp:65:    s = zmq_socket (ctx, ZMQ_REQ);
./perf/remote_lat.cpp:71:    rc = zmq_connect (s, connect_to);
./perf/remote_lat.cpp:87:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_lat.cpp:92:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:61:    s = zmq_socket (ctx, ZMQ_REP);
./perf/local_lat.cpp:67:    rc = zmq_bind (s, bind_to);
./perf/local_lat.cpp:80:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:89:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:62:    s = zmq_socket (ctx_, ZMQ_PUSH);
./perf/inproc_thr.cpp:68:    rc = zmq_connect (s, "inproc://thr_test");
./perf/inproc_thr.cpp:85:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:141:    s = zmq_socket (ctx, ZMQ_PULL);
./perf/inproc_thr.cpp:147:    rc = zmq_bind (s, "inproc://thr_test");
./perf/inproc_thr.cpp:177:    rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:190:        rc = zmq_recvmsg (s, &msg, 0);
./perf/remote_thr.cpp:62:    s = zmq_socket (ctx, ZMQ_PUSH);
./perf/remote_thr.cpp:71:    rc = zmq_connect (s, connect_to);
./perf/remote_thr.cpp:83:        rc = zmq_sendmsg (s, &msg, 0);
./perf/local_thr.cpp:64:    s = zmq_socket (ctx, ZMQ_PULL);
./perf/local_thr.cpp:73:    rc = zmq_bind (s, bind_to);
./perf/local_thr.cpp:85:    rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:98:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:60:    s = zmq_socket (ctx_, ZMQ_REP);
./perf/inproc_lat.cpp:66:    rc = zmq_connect (s, "inproc://lat_test");
./perf/inproc_lat.cpp:79:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:84:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:140:    s = zmq_socket (ctx, ZMQ_REQ);
./perf/inproc_lat.cpp:146:    rc = zmq_bind (s, "inproc://lat_test");
./perf/inproc_lat.cpp:180:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:185:        rc = zmq_recvmsg (s, &msg, 0);
./builds/zos/test_fork.cpp:45:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./builds/zos/test_fork.cpp:47:    int rc = zmq_bind (pull, address);
./builds/zos/test_fork.cpp:60:        void *push = zmq_socket (child_ctx, ZMQ_PUSH);
./builds/zos/test_fork.cpp:62:        rc = zmq_connect (push, address);
./include/zmq.h:353:ZMQ_EXPORT void *zmq_socket (void *, int type);
./include/zmq.h:359:ZMQ_EXPORT int zmq_bind (void *s, const char *addr);
./include/zmq.h:360:ZMQ_EXPORT int zmq_connect (void *s, const char *addr);
./include/zmq.h:361:ZMQ_EXPORT int zmq_unbind (void *s, const char *addr);
./include/zmq.h:362:ZMQ_EXPORT int zmq_disconnect (void *s, const char *addr);
./include/zmq.h:414:ZMQ_EXPORT int zmq_sendmsg (void *s, zmq_msg_t *msg, int flags);
./include/zmq.h:415:ZMQ_EXPORT int zmq_recvmsg (void *s, zmq_msg_t *msg, int flags);
./tweetnacl/contrib/randombytes/devurandom.c:25:    i = read(fd,x,i);

== encryption ==
./src/tcp_address.cpp:500:    //  https://github.com/zeromq/libzmq/commit/1824574f9b5a8ce786853320e3ea09fe1f822bc4
./tests/test_issue_566.cpp:35://  Fixed by https://github.com/zeromq/libzmq/commit/be25cf.

== sql() ==

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/gssapi_mechanism_base.cpp:51:    /// FIXME remove? in_buf (),
./src/gssapi_mechanism_base.cpp:151:    // TODO: instead of malloc/memcpy, can we just do: wrapped.value = ptr;
./src/xsub.cpp:143:    //  TODO: This can result in infinite loop in the case of continuous
./src/xsub.cpp:183:    //  TODO: This can result in infinite loop in the case of continuous
./src/session_base.cpp:454:        //  TODO: Should this go into pipe_t::terminate ?
./src/trie.cpp:147:    //  TODO: Shouldn't an error be reported if the key does not exist?
./src/mailbox.cpp:45:    //  TODO: Retrieve and deallocate commands inside the cpipe.
./src/stream.cpp:106:        //  TODO: The connections should be killed instead.
./src/tcp_address.cpp:58:    //  TODO: Unused parameter, IPv6 support not implemented for Solaris.
./src/pgm_receiver.cpp:168:    //  TODO: This loop can effectively block other engines in the same I/O
./src/io_thread.cpp:75:    //  TODO: Do we want to limit number of commands I/O thread can
./src/tcp_listener.cpp:95:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/ipc_listener.cpp:100:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/ipc_listener.cpp:151:        char buffer [12] = "2134XXXXXX";
./src/socket_base.cpp:478:        //  TODO: inproc connect is specific with respect to creating pipes
./src/tipc_listener.cpp:85:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/tipc_listener.cpp:183:    /*FIXME Accept filters?*/
./src/req.cpp:158:        // TODO: Failing this check should also close the connection with the peer!
./src/req.cpp:190:    //  TODO: Duplicates should be removed here.
./src/err.cpp:92:    //  TODO: This is not a generic way to handle this...
./src/err.cpp:101:    //  TODO:  It seems that list of Windows socket errors is longer than this.
./src/zmq.cpp:413:// TODO: this function has no man page
./src/zmq.cpp:490:    //  TODO: Build in a notification mechanism to report the overflows.
./src/zmq.cpp:514:// TODO: this function has no man page
./src/options.cpp:382:            //  TODO: refactor repeated code for these three options
./src/router.cpp:197:        //  TODO: The connections should be killed instead.
./src/router.cpp:365:    //  TODO: handle the situation when the peer changes its identity.

== unsafe input mechanisms ==
./src/zmq.cpp:662:const char *zmq_msg_gets (zmq_msg_t *msg_, const char *property_)
./include/zmq.h:226:ZMQ_EXPORT const char *zmq_msg_gets (zmq_msg_t *msg, const char *property);

