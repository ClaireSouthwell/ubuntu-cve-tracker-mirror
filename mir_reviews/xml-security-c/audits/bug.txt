Hello, I reviewed xml-security-c 1.7.3-1 as checked into Ubuntu Xenial
as part of the request to add xml-security-c to Ubuntu main. While this
shouldn't be considered a security audit, rather just a quick gauge
of maintainability, I found enough issues that may be exploitable and
other issues that represent significant risks that I wanted to contact
the Apache security team directly.

Here's the notes I've collected.

safeBuffer feels extremely confused -- a "buffer type" is set via
non-mandatory field which allows possibilities of type confusion attacks
-- and the checks are haphazard -- sometimes it is checked before use,
sometimes set after use, and no clear method naming exists to indicate
which is which. Maybe the different types should have different classes
to prevent type confusion. The 'string' class should probably use
std::string, because these hand-rolled functions look like significant
risks.

The hackish "doubles size" in checkAndExpand() is the only thing keeping
the rest of this file from being trivially exploitable. It's fairly sloppy
code. I'd hate to rely upon allocating twice as memory as needed in order
to avoid the usual raft of memory handling errors.

- safeBuffer::checkAndExpand() doubles size without checking for integer
  overflow.
- safeBuffer::checkAndExpand() doubles size -- which may be a signed
  'long' type if xerces-c's autoconf generates that configuration -- and
  thus may invoke undefined behaviour.
- safeBuffer::sbStrncpyIn(const char * inStr, xsecsize_t n) fails to
  NUL terminate the buffer if n is less than strlen(inStr);
- safeBuffer::sbStrncatIn(const char * inStr, xsecsize_t n) fails to NUL
  terminate the buffer if n < strlen(inStr)
- safeBuffer::sbMemcpyOut() doesn't validate that 'n' is valid for buffer.
- safeBuffer::sbStrinsIn(const char * inStr, xsecsize_t offset) doesn't
  validate that offset + il + (bl - offset + 1) is within buffer.
- safeBuffer::safeBuffer(xsecsize_t initialSize) does not initialize
  m_bufferType
- safeBuffer::sbMemshift(xsecsize_t toOffset, xsecsize_t fromOffset,
  xsecsize_t len) does not validate that the len is valid for the buffer,
  how does it handle shrinking? growing? How is this thing useful?
- safeBuffer::sbStrcatIn(const char * inStr) does not check that
  strlen(buffer) + strlen(inStr) doesn't overflow
- safeBuffer::sbStrcatIn(const safeBuffer & inStr) does not check that
  strlen((char *) buffer) + strlen((char *) inStr.buffer) + 2 doesn't
  overflow

The hand-rolled HTTP 1.0-ish implementation looks very primitive and
probably should be replaced entirely with a good HTTP client library. (At
least, if supporting HTTP queries in this library is even a good idea --
I wouldn't expect or want a signature check to potentially read files
off the filesystem or remote servers.)

- XSECBinHTTPURIInputStream allocates char fBuffer[4000].
  XSECBinHTTPURIInputStream::getSocketHandle() writes a path, query,
  fragment, and hostname into it without checking for overflow.
- XSECBinHTTPURIInputStream::getSocketHandle() may copy data from beyond
  the end of fBuffer into redirectBuf[].

- xlatHexDigit() does not error on unexpected inputs

- loadX509() leaks 'f'

- winutils/XSECSOAPRequestorSimpleWin32.cpp
  unixutils/XSECBinHTTPURIInputStream.cpp
  use inet_addr() rather than getaddrinfo(); this seems unlikely to
  support ipv6 addresses well.


I've also been running American Fuzzy Lop against the xsec-checksig tool.
I think all it's found so far are malformed URL exceptions. While these
may not be real issues they complicate fuzzing and I wouldn't expect
a signature verification tool to abort for something as minor as a
malformed URL.

I'll send along a set of crashers eventually; if all the fuzzers ever find
is malformed URL exceptions, I won't bother you with them.

Thanks
