#!/usr/bin/python

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader
import shutil, subprocess
import unittest
import optparse
import cve_lib

# Pull in package details
import source_map
source = source_map.load()

# load settings, if any
cve_lib.read_config()

parser = optparse.OptionParser()
parser.add_option("-r", "--report", help="Just report CVEs that need checking", action="store_true")
parser.add_option("-v", "--verbose", help="Report verbose XML details", action="store_true")
parser.add_option("-k", "--known", help="Only report CVEs already known", action="store_true")
parser.add_option("-R", "--refresh", help="Refresh CVE descriptions", action="store_true")
parser.add_option("", "--test", help="Run regression tests", action="store_true")
(opt, args) = parser.parse_args()

destdir = "."


ignore_strings = ["** REJECT **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS",
    "Apple QuickTime", "Cisco", "ActiveX", "Joomla!"]

###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def subtract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)


###################

def wordwrap(text, width):
    """
    A word-wrap function that preserves existing line breaks
    and most spaces in the text. Expects that existing line
    breaks are posix newlines (\n).
    """
    return reduce(lambda line, word, width=width: '%s%s%s' %
                  (line,
                   ' \n'[(len(line)-line.rfind('\n')-1
                         + len(word.split('\n',1)[0]
                              ) >= width)],
                   word),
                  text.split(' ')
                 )

def _wrap_desc(desc):
    return wordwrap(desc,75).replace(' \n','\n')

def add_CVE_to_tracker(cve, info, package):
    src = '%s/active/00boilerplate'%(destdir)
    if os.path.exists(src + "." + package):
        src = src + "." + package
    dst = '%s/active/%s'%(destdir,cve)
    template = file(src).readlines()
    cve_file = file(dst,'w')
    for line in template:
        line = line.rstrip()
        if line.startswith('Candidate:'):
            print >>cve_file, 'Candidate: %s'%(cve)
        elif info['public'] and line.startswith('PublicDate:'):
            print >>cve_file, 'PublicDate: %s'%(info['public'])
        elif line.startswith('References:'):
            print >>cve_file, 'References:\n http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s'%(cve)
        elif not line.startswith('#'):
            print >>cve_file, line

        if line.startswith('Description:'):
            for desc_line in _wrap_desc(info['desc']).split('\n'):
                print >>cve_file, " %s" % (desc_line)
    cve_file.close()
    return dst

class PercentageFile(object):
    def __init__(self, filename):
        self.size = os.stat(filename)[6]
        self.delivered = 0
        self.f = file(filename)

    def read(self, size=None):
        if size is None:
            data = self.f.read()
        else:
            data = self.f.read(size)

        print >>sys.stdout, '%d%% (%d/%d)\r' % ( (self.delivered * 100) / self.size, self.delivered, self.size ),
        sys.stdout.flush()

        self.delivered += len(data)
        return data

###################

class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore=[]):
        # For per-hit processing
        self.curr_cve = None
        self.curr_desc = None
        self.curr_desc_ready = False
        self.curr_refs = []
        self.curr_chars = ""
        self.ignore = ignore
        self.num_ignored = 0
        self.num_added = 0
        self.num_skipped = 0
        self.curr_public = None

        # For long-term (human) processing
        self.cve_list = []
        self.cve_data = dict()
        self.saved_ignore_reason = ""
        self.saved_package = ""
        self.debian = None

        # File-type detection
        self.use_nvd = None

        # Load debian CVE states, if configured
        if cve_lib.config.has_key('secure_testing_path'):
            self.debian = cve_lib.load_debian_cves(cve_lib.config['secure_testing_path']+'/data/CVE/list')


    def printReport(self):
        print "\n %4d CVEs added" % self.num_added
        print " %4d CVEs ignored" % self.num_ignored
        print " %4d CVEs skipped" % self.num_skipped
        print "---------------------------"
        print "%5d total CVEs triaged" % (self.num_added + self.num_ignored)

    def startElement(self, name, attrs):
        # NVD items
        if name == "entry":
            # Detect broken XML
            if self.use_nvd != None and self.use_nvd == False:
                raise KeyError, "saw 'entry' in Mitre XML"
            self.use_nvd = True
            self.curr_cve = attrs['name']
            self.curr_public = attrs['published']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
            self.curr_desc_ready = False
        if name == "descript":
            self.curr_chars = ""
            if attrs['source'] == 'cve':
                self.curr_desc_ready = True
        # Mitre items
        if name == "item":
            # Detect broken XML
            if self.use_nvd != None and self.use_nvd == True:
                raise KeyError, "saw 'item' in NVD XML"
            self.use_nvd = False
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
        if name == "desc" and self.use_nvd == False:
            self.curr_chars = ""

        # Common
        if name == "ref":
            self.curr_chars = ""
            self.curr_url = None
            self.curr_source = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']
            if attrs.has_key('source'):
                self.curr_source = attrs['source']

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        # NVD items
        if name == "descript" and self.curr_desc_ready:
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
            self.curr_desc_ready = False
        if name == "entry":
            self.handle_cve()
        # Mitre items
        if name == "desc" and not self.use_nvd:
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
        if name == "item":
            self.handle_cve()
        # Common
        if name == "ref":
            self.curr_refs += [(self.curr_source,self.curr_chars.encode("ascii", "replace"),self.curr_url)]

    def handle_cve(self):
        # Skip CVEs we know about already
        if self.curr_cve in self.ignore:
            return

        # Skip stuff older than 2005
        if int(self.curr_cve.split("-")[1]) < 2005:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        if self.curr_cve in self.cve_list:
            print >>sys.stderr, "Aborting: saw %s twice!" % (self.curr_cve)

        self.cve_list += [self.curr_cve]
        self.cve_data.setdefault(self.curr_cve,dict())
        self.cve_data[self.curr_cve].setdefault('desc',self.curr_desc)
        self.cve_data[self.curr_cve].setdefault('public',self.curr_public)
        self.cve_data[self.curr_cve].setdefault('refs',[]+self.curr_refs)

    def cves(self):
        return self.cve_list

    def get_ignore_suggestion(self, text):
        '''Try to find a reasonable suggestion for the user.'''
        suggestion = ""

        first_sentence = re.split(r'\. ', text)[0]
        phrases = re.split(r' in ', first_sentence)

        # default to the last phrase
        suggestion = phrases[-1]

        # grab the first phrase with something that may be a version number
        for p in phrases:
            if re.search(r'\s+[0-9]+', p):
                suggestion = p
                break

        # try to find a good suggestion from the phrase (ie suggest 'Linux
        # kernel' from 'the Linux kernel before 2.6.27')
        suggestion = re.split(r'\s+[0-9]', suggestion)[0]
        suggestion = re.sub(r'^\s*[tT]he\s+', '', suggestion)
        suggestion = re.sub(r'\s+before\s*$', '', suggestion)

        # If "in" was found, drop everything after common verbs
        if len(phrases)>1:
            suggestion = re.sub(r'\s+(has|creates)($|\s+.*)', '', suggestion)

        # if the phrase is too long, truncate it to max_length, but make
        # sure we don't have a partial word at the end
        max_length = 64
        if len(suggestion) > max_length:
            suggestion = suggestion[:max_length]
            suggestion = re.sub(r'\s+\w+$', '', suggestion)

        return suggestion

    def human_process_cve(self, cve):

        # Check if this was once an embargoed issue
        if cve in EmbargoList:
            print '**!!** no longer embargoed **!!**'
            print '==========================details from embargo entry=========================='
            print file(os.path.join('embargoed',cve)).read().rstrip()
            print '=================================end details=================================='
        # Display CVE information
        if self.cve_data[cve]['public']:
            print ' Published: %s' % (self.cve_data[cve]['public'])
        for ref in self.cve_data[cve]['refs']:
            print ' %s: %s' % (ref[0],ref[1]),
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                print ' %s' % (ref[2]),
            print
        print '%s' % (self.cve_data[cve]['desc'])
        if self.debian and self.debian.has_key(cve):
            print 'Debian CVE Tracker: %s' % (self.debian[cve]['state'])
            if len(self.debian[cve]['note']):
                print "\t" + "\n\t".join(self.debian[cve]['note'])
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append(self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append(self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append(self.debian[cve]['pkgs'][pkg]['note'])
                print "  Debian: %s: %s (%s)" % (pkg,self.debian[cve]['pkgs'][pkg]['state'],"; ".join(info))
                # Display version and component details for Ubuntu's pkg
                answer = source_map.madison(source, pkg)
                for name in sorted(answer.keys()):
                    for pkg in sorted(answer[name].keys()):
                        print '    Ubuntu: %s | %s | %s' % (pkg, answer[name][pkg], name)

        response = 'skip'
        reason = ""
        package = ""
        # Skip CVEs that are obviously not about Ubuntu
        for s in ignore_strings:
            if self.cve_data[cve]['desc'].find(s) >= 0 and self.cve_data[cve]['desc'].find("Linux") < 0:
                response = 'ignore'
                reason = s
        # Default to Debian state, if available
        if self.debian and self.debian.has_key(cve) and self.debian[cve]['state']:
            if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                response = 'ignore'
                reason = self.debian[cve]['state'].split(':',1)[1].lstrip()
            if self.debian[cve]['state'] == 'FOUND':
                response = 'add'
                package = " ".join(self.debian[cve]['pkgs'])

        info = ''
        while info == "" or not info[0] in ['i','a','s','q']:
            print 'A)dd to tracker, I)gnore forever, S)kip for now, or Q)uit? [%s] ' % (response),
            info = sys.stdin.readline().strip().lower()
            if info == "":
                info = response

        if info.startswith('q'):
            self.printReport()
            sys.exit(0)
        elif info.startswith('a'):
            self.num_added += 1
            info = ""
            while info == "":
                print 'Package(s) affected? ',
                if package == "":
                    package = self.saved_package
                if package != "":
                    print '[%s] ' % (package),
                info = sys.stdin.readline().strip()
                if info == '':
                    info = package
                self.saved_package = info
            # Add to tracker from 00boilerplate
            dst = add_CVE_to_tracker(cve,self.cve_data[cve], info)
            # Tack on package
            cmd = ['./scripts/active_edit','-c',cve]
            for pkg in info.split():
                cmd += ['-p',pkg]
            cmd += ['--yes']
            subprocess.call(cmd)
            # Spawn editor
            editor = os.getenv('EDITOR','vi')
            subprocess.call([editor,dst])
        elif info.startswith('i'):
            self.num_ignored += 1

            info = ""
            while info == "":
                print 'Reason to be ignored?'

                suggestion = self.get_ignore_suggestion(self.cve_data[cve]['desc'])
                print '   a) %s' % (suggestion)

                if reason == "" and self.saved_ignore_reason != "":
                    reason = self.saved_ignore_reason
                if reason != "":
                    print '   b) %s' % (reason)
                print ' > ',

                info = sys.stdin.readline().strip()
                if info == "a":
                    reason = suggestion
                    info = reason
                elif info == "b":
                    info = reason
                elif len(info) < 3: # Fat fingers
                    print '\nError: Reason must be at least 3 characters long!\n'
                    info = ""
            self.saved_ignore_reason = info
            self.cve_resolved_ignore(cve, info)

        elif info.startswith('s'):
            self.num_skipped += 1
        print ''

    def cve_resolved_ignore(self, cve, reason):
        # Append to ignore list
        file('%s/ignored/not-for-us.txt'%(destdir),'a').write('%s # %s\n'%(cve,reason))

class CheckCVETest(unittest.TestCase):
    def test_get_ignore_suggestion(self):
        '''"Ignore" suggestion text extraction'''

        # Re-use the global handler
        h = handler

        self.assertEquals("Courier-Authlib", h.get_ignore_suggestion('''SQL injection vulnerability in authpgsqllib.c in Courier-Authlib before 0.62.0, when a non-Latin locale Postgres database is used, allows remote attackers to execute arbitrary SQL commands via query parameters containing apostrophes.'''))

        self.assertEquals("KDE", h.get_ignore_suggestion('''HTMLTokenizer::scriptHandler in Konqueror in KDE 3.5.9 and 3.5.10 allows remote attackers to cause a denial of service (application crash) via an invalid document.load call that triggers use of a deleted object.  NOTE: some of these details are obtained from third party information.'''))

        self.assertEquals("Sun Solaris", h.get_ignore_suggestion('''The name service cache daemon (nscd) in Sun Solaris 10 and OpenSolaris snv_50 through snv_104 does not properly check permissions, which allows local users to gain privileges and obtain sensitive information via unspecified vectors.'''))

        self.assertEquals("Linux kernel", h.get_ignore_suggestion('''libata in the Linux kernel before 2.6.27.9 does not set minimum timeouts for SG_IO requests, which allows local users to cause a denial of service (Programmed I/O mode on drives) via multiple simultaneous invocations of an unspecified test program.'''))

        self.assertEquals("iGaming", h.get_ignore_suggestion('''Multiple SQL injection vulnerabilities in iGaming 1.5 and earlier allow remote attackers to execute arbitrary SQL commands via the browse parameter to (1) previews.php and (2) reviews.php, and the (3) id parameter to index.php in a viewarticle action.'''))

        self.assertEquals("PHP iCalendar", h.get_ignore_suggestion('''PHP iCalendar 2.24 and earlier allows remote attackers to bypass authentication by setting the phpicalendar and phpicalendar_login cookies to 1.'
'''))

        self.assertEquals("** TEST CVE ** This candidate has been reserved by an", h.get_ignore_suggestion('''** TEST CVE ** This candidate has been reserved by an organization or individual that will use it when announcing a new security problem.  When the candidate has been publicized, the details for this candidate will be provided.'''))

        self.assertEquals("Sun OpenSolaris", h.get_ignore_suggestion('''Unspecified vulnerability in the root/boot archive tool in Sun OpenSolaris has unknown impact and local attack vectors, related to a "Temporary file vulnerability," aka Bug ID 6653455.'''))

        self.assertEquals("Red Hat Certificate System", h.get_ignore_suggestion('''Red Hat Certificate System 7.2 uses world-readable permissions for password.conf and unspecified other configuration files, which allows local users to discover passwords by reading these files.'''))

        self.assertEquals("Microsoft Internet Explorer", h.get_ignore_suggestion('''An unspecified function in the JavaScript implementation in Microsoft Internet Explorer creates and exposes a "temporary footprint" when there is a current login to a web site, which makes it easier for remote attackers to trick a user into acting upon a spoofed pop-up message, aka an "in-session phishing attack." NOTE: as of 20090116, the only disclosure is a vague pre-advisory with no actionable information. However, because it is from a well-known researcher, it is being assigned a CVE identifier for tracking purposes.'''))


# CVEIgnoreList is a list of all CVEs we know about already.  These will be
# ignored when checking MITRE for new CVEs
CVEIgnoreList  = cve_lib.parse_CVEs_from_uri(destdir + "/ignored/not-for-us.txt")
CVEKnownList   = []
CVEKnownList += [cve for cve in os.listdir(destdir + "/ignored/") if cve.startswith('CVE-')]
CVEKnownList += [cve for cve in os.listdir(destdir + "/retired/") if cve.startswith('CVE-')]
(ActiveList, EmbargoList) = cve_lib.get_cve_list()
CVEKnownList += [cve for cve in ActiveList if cve not in EmbargoList]

if not opt.refresh:
    CVEIgnoreList += CVEKnownList

if opt.known:
    for cve in sorted(CVEIgnoreList):
        print cve
    sys.exit(0)

parser = xml.sax.make_parser()
handler = CVEHandler(CVEIgnoreList)
parser.setContentHandler(handler)

if opt.test:
    suite = unittest.TestSuite()
    suite.addTest(unittest.TestLoader().loadTestsFromTestCase(CheckCVETest))
    unittest.TextTestRunner(verbosity=2).run(suite)
    sys.exit(0)

if len(args) == 0:
    args.append("http://cve.mitre.org/cve/downloads/allitems.xml")

for uri in args:
    print >>sys.stderr, 'Loading %s ...'%(uri)
    if '://' in uri:
        readable = urllib.urlopen(uri)
    else:
        readable = PercentageFile(uri)
    parser.parse(readable)
    print ''

if opt.refresh:
    for cve in sorted(CVEKnownList):

        # Get new information from the XML
        desc = None
        public = None
        try:
            desc = _wrap_desc(handler.cve_data[cve]['desc'].strip())
            public = handler.cve_data[cve]['public']
        except:
            if opt.verbose:
                print >>sys.stderr, '%s not listed in XML' % (cve)

        # Find the on-disk CVE file
        cvefile = ""
        for status in ['active','retired','ignored']:
            check = '%s/%s/%s' % (destdir, status, cve)
            if os.path.exists(check):
                cvefile = check
                break
        if cvefile == "":
            print >>sys.stderr, 'local dirs missing %s?!' % (cve)
            continue

        # Load CVE
        try:
            data = cve_lib.load_cve(cvefile)
        except ValueError, e:
            print >>sys.stderr, e
            continue

        # Set defaults for required fields if no XML value exists
        if not data.has_key('PublicDate') and not public:
            public = "unknown"

        updated = False
        # Update description if it needs it
        if desc:
            if data['Description'].strip() != desc:
                cve_lib.update_description(cvefile,desc)
                updated = True
        # Update Publication Date if it needs it
        if public:
            if not data.has_key('PublicDate') or (data.has_key('PublicDate') and data['PublicDate'] != public):
                cve_lib.update_field(cvefile,'PublicDate',public)
                updated = True

        # Add CVE Reference, if it's missing
        if data.has_key('References') and re.match('^CVE-\d+-\d+$',cve):
            mitre_ref = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
            if not mitre_ref in data['References']:
                cve_lib.add_reference(cvefile,mitre_ref)
                updated = True

        if updated:
            print >>sys.stderr, "Refreshed %s" % (cvefile)
    sys.exit(0)

new_cves = handler.cves()
max = len(new_cves)
count = 0
for cve in new_cves:
    count += 1

    if opt.report:
        print cve
        continue

    print '\n***********************************************************************'
    print ' %s    (%d/%d: %d%%)' % (cve, count, max, (count * 100 / max))
    print ' http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve)
    print '***********************************************************************'
    handler.human_process_cve(cve)

handler.printReport()
