Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./module/zfs/zfs_ctldir.c:1022:	char *argv[] = { "/bin/sh", "-c", NULL, NULL };
./module/zfs/zfs_ctldir.c:1069:	char *argv[] = { "/bin/sh", "-c", NULL, NULL };
./module/zfs/vdev_disk.c:161:		char *argv[] = { "/bin/sh", "-c", NULL, NULL };
./module/zfs/dsl_dataset.c:3120: * a snapshot before new, in new's filesystem (or its origin).  If not then
./module/zfs/zfs_ctldir.c:62: * share the same zfs_sb_t as the head filesystem (what '.zfs' lives under).
./module/zfs/zfs_vfsops.c:1849:	register_filesystem(&zpl_fs_type);
./module/zfs/zfs_vfsops.c:1856:	unregister_filesystem(&zpl_fs_type);
./module/zfs/spa.c:2545:				    "system (host: %s hostid: 0x%lx). See: "
./module/zfs/dsl_dir.c:738: * Check if adding additional child filesystem(s) would exceed any filesystem
./cmd/zpios/zpios_util.c:144:	rc = regexec(&re, string, (size_t) 0, NULL, 0);
./cmd/zed/zed.c:87: * and are automatically removed during an execve().  As such, this must
./cmd/zed/zed_exec.c:31: * Create an environment string array for passing to execve() using the
./cmd/zed/zed_exec.c:115:		execle(path, prog, NULL, env);
./cmd/zed/zed_file.h:33:int zed_file_close_on_exec(int fd);
./cmd/zed/zed_file.c:198:zed_file_close_on_exec(int fd)
./cmd/ztest/ztest.c:5411:	fp = popen(zdb, "r");
./cmd/ztest/ztest.c:6239:		(void) execv(cmd, emptyargv);
./include/sys/zil.h:340: *    is immediately written into the file system (using dmu_sync),
./lib/libnvpair/libnvpair.c:986:				if (regexec(value_regex, val,
./lib/libnvpair/libnvpair.c:1003:				if (regexec(value_regex, val_array[ai],
./lib/libzfs/libzfs_util.c:673:		(void) execvp(path, argv);
./lib/libzfs/libzfs_sendrecv.c:1207:dump_filesystem(zfs_handle_t *zhp, void *arg)
./lib/libzfs/libzfs_sendrecv.c:1281:		return (dump_filesystem(rzhp, sdd));
./lib/libzfs/libzfs_sendrecv.c:1352:		err = dump_filesystem(zhp, sdd);
./lib/libzfs/libzfs_sendrecv.c:2940:		 * be creating a new filesystem (either from a full backup, or
./lib/libzfs/libzfs_sendrecv.c:3127:	 * Mount the target filesystem (if created).  Also mount any
./lib/libshare/nfs.c:709:	rc = execlp("/usr/sbin/exportfs", "exportfs", "-v", NULL);

== memory_management() ==
./module/zpios/pios.c:116:		rc = vsprintf(info->info_head, format, adx);
./module/zpios/pios.c:144:	obj = dmu_object_alloc(os, DMU_OT_UINT64_OTHER, 0, DMU_OT_NONE, 0, tx);
./module/zpios/pios.c:546:	 * It's OK to vmem_alloc() this memory because it will be copied
./module/zpios/pios.c:553:	buf = (char *)vmem_alloc(chunk_size, KM_SLEEP);
./module/zpios/pios.c:931:	info = (zpios_info_t *)kmem_alloc(sizeof (*info), KM_SLEEP);
./module/zpios/pios.c:938:	    (char *) vmem_alloc(ZPIOS_INFO_BUFFER_SIZE, KM_SLEEP);
./module/zpios/pios.c:994:		buf = (char *)vmem_alloc(size, KM_SLEEP);
./module/zpios/pios.c:1003:		memcpy(buf, info->info_buffer, min);
./module/zpios/pios.c:1068:	kcmd = kmem_alloc(sizeof (zpios_cmd_t), KM_SLEEP);
./module/zpios/pios.c:1070:		zpios_print(file, "Unable to kmem_alloc() %ld byte for "
./module/zpios/pios.c:1091:		data = (void *)vmem_alloc(kcmd->cmd_data_size, KM_SLEEP);
./module/zpios/pios.c:1093:			zpios_print(file, "Unable to vmem_alloc() %ld "
./module/zcommon/zprop_common.c:178:	order = kmem_alloc(size, KM_SLEEP);
./module/zcommon/zprop_common.c:180:	if ((order = malloc(size)) == NULL)
./module/nvpair/nvpair_alloc_spl.c:34:	return (vmem_alloc(size, KM_SLEEP));
./module/nvpair/nvpair_alloc_spl.c:40:	return (vmem_alloc(size, KM_PUSHPAGE));
./module/nvpair/nvpair_alloc_spl.c:46:	return (kmem_alloc(size, KM_NOSLEEP));
./module/nvpair/nvpair_alloc_spl.c:58:	nv_alloc_sleep_spl,	/* nv_ao_alloc() */
./module/nvpair/nvpair_alloc_spl.c:66:	nv_alloc_pushpage_spl,	/* nv_ao_alloc() */
./module/nvpair/nvpair_alloc_spl.c:74:	nv_alloc_nosleep_spl,	/* nv_ao_alloc() */
./module/nvpair/fnvpair.c:51:fnvlist_alloc(void)
./module/nvpair/fnvpair.c:54:	VERIFY0(nvlist_alloc(&nvl, NV_UNIQUE_NAME, KM_SLEEP));
./module/nvpair/nvpair.c:174:nvlist_lookup_nv_alloc(nvlist_t *nvl)
./module/nvpair/nvpair.c:191:	if ((buf = nva->nva_ops->nv_ao_alloc(nva, size)) != NULL)
./module/nvpair/nvpair.c:215:nv_priv_alloc(nv_alloc_t *nva)
./module/nvpair/nvpair.c:220:	 * nv_mem_alloc() cannot called here because it needs the priv
./module/nvpair/nvpair.c:223:	if ((priv = nva->nva_ops->nv_ao_alloc(nva, sizeof (nvpriv_t))) == NULL)
./module/nvpair/nvpair.c:266:nvlist_nv_alloc(int kmflag)
./module/nvpair/nvpair.c:286:nvlist_alloc(nvlist_t **nvlp, uint_t nvflag, int kmflag)
./module/nvpair/nvpair.c:288:	return (nvlist_xalloc(nvlp, nvflag, nvlist_nv_alloc(kmflag)));
./module/nvpair/nvpair.c:299:	if ((priv = nv_priv_alloc(nva)) == NULL)
./module/nvpair/nvpair.c:317:nvp_buf_alloc(nvlist_t *nvl, size_t len)
./module/nvpair/nvpair.c:618:	return (nvlist_xdup(nvl, nvlp, nvlist_nv_alloc(kmflag)));
./module/nvpair/nvpair.c:916:	if ((nvp = nvp_buf_alloc(nvl, nvp_sz)) == NULL)
./module/nvpair/nvpair.c:2091:		if ((nvp = nvp_buf_alloc(nvl, nvsize)) == NULL)
./module/nvpair/nvpair.c:2352:	    nvlist_nv_alloc(kmflag)));
./module/nvpair/nvpair.c:2408:	return (nvlist_xunpack(buf, buflen, nvlp, nvlist_nv_alloc(kmflag)));
./module/nvpair/nvpair_alloc_fixed.c:84:nv_fixed_alloc(nv_alloc_t *nva, size_t size)
./module/nvpair/nvpair_alloc_fixed.c:115:	nv_fixed_alloc,	/* nv_ao_alloc() */
./module/zfs/zfs_fuid.c:133:		packed = kmem_alloc(fuid_size, KM_SLEEP);
./module/zfs/zfs_fuid.c:151:			domnode = kmem_alloc(sizeof (fuid_domain_t), KM_SLEEP);
./module/zfs/zfs_fuid.c:247:		zsb->z_fuid_obj = dmu_object_alloc(zsb->z_os,
./module/zfs/zfs_fuid.c:255:	VERIFY(nvlist_alloc(&nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_fuid.c:258:	fuids = kmem_alloc(numnodes * sizeof (void *), KM_SLEEP);
./module/zfs/zfs_fuid.c:261:		VERIFY(nvlist_alloc(&fuids[i], NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_fuid.c:274:	packed = kmem_alloc(nvsize, KM_SLEEP);
./module/zfs/zfs_fuid.c:342:		domnode = kmem_alloc(sizeof (fuid_domain_t), KM_SLEEP);
./module/zfs/zfs_fuid.c:443:		*fuidpp = zfs_fuid_info_alloc();
./module/zfs/zfs_fuid.c:462:		fuid_domain = kmem_alloc(sizeof (zfs_fuid_domain_t), KM_SLEEP);
./module/zfs/zfs_fuid.c:476:		fuid = kmem_alloc(sizeof (zfs_fuid_t), KM_SLEEP);
./module/zfs/zfs_fuid.c:669:zfs_fuid_info_alloc(void)
./module/zfs/dmu.c:801:			(void) memcpy(buf, (char *)db->db_data + bufoff, tocpy);
./module/zfs/dmu.c:843:		(void) memcpy((char *)db->db_data + bufoff, buf, tocpy);
./module/zfs/dmu.c:1087:			memcpy(arg_buf + offset, bv_buf, tocpy);
./module/zfs/dmu.c:1089:			memcpy(bv_buf, arg_buf + offset, tocpy);
./module/zfs/dmu.c:1621:	dsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);
./module/zfs/dmu.c:1774:	dsa = kmem_alloc(sizeof (dmu_sync_arg_t), KM_SLEEP);
./module/zfs/dmu_traverse.c:129:	zilog = zil_alloc(spa_get_dsl(td->td_spa)->dp_meta_objset, zh);
./module/zfs/dmu_traverse.c:286:		czb = kmem_alloc(sizeof (zbookmark_phys_t), KM_SLEEP);
./module/zfs/dmu_traverse.c:519:	td = kmem_alloc(sizeof (traverse_data_t), KM_SLEEP);
./module/zfs/dmu_traverse.c:521:	czb = kmem_alloc(sizeof (zbookmark_phys_t), KM_SLEEP);
./module/zfs/ddt_zap.c:65:	cbuf = kmem_alloc(sizeof (dde->dde_phys) + 1, KM_SLEEP);
./module/zfs/dsl_dataset.c:646:		(void) strcpy(name, "mos");
./module/zfs/dsl_dataset.c:719:	dsobj = dmu_object_alloc(mos, DMU_OT_DSL_DATASET, 0,
./module/zfs/dsl_dataset.c:737:		dsphys->ds_deadlist_obj = dsl_deadlist_alloc(mos, tx);
./module/zfs/dsl_dataset.c:1121:		cnt_track = fnvlist_alloc();
./module/zfs/dsl_dataset.c:1123:		nm = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/dsl_dataset.c:1260:	dsobj = dmu_object_alloc(mos, DMU_OT_DSL_DATASET, 0,
./module/zfs/dsl_dataset.c:1410:		suspended = fnvlist_alloc();
./module/zfs/dsl_dataset.c:1590:	nvlist_t *propval = fnvlist_alloc();
./module/zfs/dsl_dataset.c:1591:	nvlist_t *val = fnvlist_alloc();
./module/zfs/dsl_dataset.c:1868:	(void) strcpy(ds->ds_snapname, ddrsa->ddrsa_newsnapname);
./module/zfs/dsl_dataset.c:1921:	oldname = kmem_asprintf("%s@%s", fsname, oldsnapname);
./module/zfs/dsl_dataset.c:1922:	newname = kmem_asprintf("%s@%s", fsname, newsnapname);
./module/zfs/dsl_dataset.c:1996:	proprequest = fnvlist_alloc();
./module/zfs/dsl_dataset.c:1998:	bookmarks = fnvlist_alloc();
./module/zfs/dsl_dataset.c:2217:			(void) strcpy(ddpa->err_ds, snap->ds->ds_snapname);
./module/zfs/dsl_dataset.c:2509:		snap = kmem_alloc(sizeof (*snap), KM_SLEEP);
./module/zfs/dsl_userhold.c:169:			tags = fnvlist_alloc();
./module/zfs/dsl_userhold.c:228:	ca = kmem_alloc(sizeof (*ca), KM_SLEEP);
./module/zfs/dsl_userhold.c:245:		tmpholds = fnvlist_alloc();
./module/zfs/dsl_userhold.c:262:		tmpholds = fnvlist_alloc();
./module/zfs/dsl_userhold.c:317:	dduha.dduha_chkholds = fnvlist_alloc();
./module/zfs/dsl_userhold.c:367:	VERIFY0(nvlist_alloc(&holds_found, NV_UNIQUE_NAME, KM_SLEEP));
./module/zfs/dsl_userhold.c:386:				char *errtag = kmem_asprintf("%s#%s",
./module/zfs/dsl_userhold.c:607:	VERIFY0(nvlist_alloc(&ddura.ddura_todelete, NV_UNIQUE_NAME,
./module/zfs/dsl_userhold.c:609:	VERIFY0(nvlist_alloc(&ddura.ddura_chkholds, NV_UNIQUE_NAME,
./module/zfs/dsl_userhold.c:660:		za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/ddt.c:254:	(void) sprintf(name, DMU_POOL_DDT,
./module/zfs/ddt.c:685:ddt_alloc(const ddt_key_t *ddk)
./module/zfs/ddt.c:689:	dde = kmem_cache_alloc(ddt_entry_cache, KM_SLEEP);
./module/zfs/ddt.c:742:		dde = ddt_alloc(&dde_search.dde_key);
./module/zfs/ddt.c:834:ddt_table_alloc(spa_t *spa, enum zio_checksum c)
./module/zfs/ddt.c:838:	ddt = kmem_cache_alloc(ddt_cache, KM_SLEEP);
./module/zfs/ddt.c:872:		spa->spa_ddt[c] = ddt_table_alloc(spa, c);
./module/zfs/ddt.c:941:	dde = kmem_cache_alloc(ddt_entry_cache, KM_SLEEP);
./module/zfs/ddt.c:968:	dde = ddt_alloc(&ddk);
./module/zfs/zfs_rlock.c:205:	proxy = kmem_alloc(sizeof (rl_t), KM_SLEEP);
./module/zfs/zfs_rlock.c:234:	rear = kmem_alloc(sizeof (rl_t), KM_SLEEP);
./module/zfs/zfs_rlock.c:259:	rl = kmem_alloc(sizeof (rl_t), KM_SLEEP);
./module/zfs/zfs_rlock.c:432:	new = kmem_alloc(sizeof (rl_t), KM_SLEEP);
./module/zfs/zfs_ioctl.c:264:	buf = kmem_alloc(HIS_MAX_RECORD_LEN, KM_SLEEP);
./module/zfs/zfs_ioctl.c:1283:	packed = vmem_alloc(size, KM_SLEEP);
./module/zfs/zfs_ioctl.c:1472:		VERIFY(nvlist_alloc(&zplprops, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:1718:	hist_buf = vmem_alloc(size, KM_SLEEP);
./module/zfs/zfs_ioctl.c:2137:		VERIFY(nvlist_alloc(&nv, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:2414:			(void) strcpy(zc->zc_name, dsname);
./module/zfs/zfs_ioctl.c:2447:	nvlist_t *genericnvl = fnvlist_alloc();
./module/zfs/zfs_ioctl.c:2448:	nvlist_t *retrynvl = fnvlist_alloc();
./module/zfs/zfs_ioctl.c:2619:	VERIFY(nvlist_alloc(newprops, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:2686:	errors = fnvlist_alloc();
./module/zfs/zfs_ioctl.c:2739:		VERIFY(nvlist_alloc(&dummy, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:3169:		VERIFY(nvlist_alloc(&zct.zct_zplprops,
./module/zfs/zfs_ioctl.c:3607:	fullname = kmem_asprintf("%s@%s", fsname, snapname);
./module/zfs/zfs_ioctl.c:3861:	VERIFY(nvlist_alloc(&errors, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:3863:	zc = kmem_alloc(sizeof (zfs_cmd_t), KM_SLEEP);
./module/zfs/zfs_ioctl.c:3864:	(void) strcpy(zc->zc_name, dataset);
./module/zfs/zfs_ioctl.c:3869:		(void) strcpy(zc->zc_value, nvpair_name(pair));
./module/zfs/zfs_ioctl.c:4009:	(void) strcpy(tofs, zc->zc_value);
./module/zfs/zfs_ioctl.c:4025:	VERIFY(nvlist_alloc(&errors, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/zfs_ioctl.c:4574:	buf = vmem_alloc(bufsize, KM_SLEEP);
./module/zfs/zfs_ioctl.c:4689:	snap_name = kmem_asprintf("%s-%016llx", zc->zc_value,
./module/zfs/zfs_ioctl.c:4691:	hold_name = kmem_asprintf("%%%s", zc->zc_value);
./module/zfs/zfs_ioctl.c:4696:		(void) strcpy(zc->zc_value, snap_name);
./module/zfs/zfs_ioctl.c:5669:zfsdev_minor_alloc(void)
./module/zfs/zfs_ioctl.c:5697:	minor = zfsdev_minor_alloc();
./module/zfs/zfs_ioctl.c:5873:			lognv = fnvlist_alloc();
./module/zfs/zfs_ioctl.c:5882:		outnvl = fnvlist_alloc();
./module/zfs/bptree.c:61:bptree_alloc(objset_t *os, dmu_tx_t *tx)
./module/zfs/bptree.c:67:	obj = dmu_object_alloc(os, DMU_OTN_UINT64_METADATA,
./module/zfs/zpl_super.c:34:zpl_inode_alloc(struct super_block *sb)
./module/zfs/zpl_super.c:38:	VERIFY3S(zfs_inode_alloc(sb, &ip), ==, 0);
./module/zfs/zpl_super.c:334:	tmp_zmo = zfs_mntopts_alloc();
./module/zfs/zpl_super.c:372:	memcpy(zmo, tmp_zmo, sizeof (zfs_mntopts_t));
./module/zfs/zpl_super.c:451:	zfs_mntopts_t *zmo = zfs_mntopts_alloc();
./module/zfs/zpl_super.c:467:	zfs_mntopts_t *zmo = zfs_mntopts_alloc();
./module/zfs/dmu_objset.c:336:			arc_buf_t *buf = arc_buf_alloc(spa,
./module/zfs/dmu_objset.c:352:		os->os_phys_buf = arc_buf_alloc(spa, size,
./module/zfs/dmu_objset.c:437:	os->os_zil = zil_alloc(os, &os->os_zil_header);
./module/zfs/dmu_objset.c:633:	dn_marker = kmem_alloc(sizeof (dnode_t), KM_SLEEP);
./module/zfs/dmu_objset.c:1019:	char *longsnap = kmem_asprintf("%s@%s", fsname, snapname);
./module/zfs/dmu_objset.c:1020:	nvlist_t *snaps = fnvlist_alloc();
./module/zfs/dmu_objset.c:1579:	(void) strcpy(name, attr.za_name);
./module/zfs/dmu_objset.c:1624:	(void) strcpy(name, attr.za_name);
./module/zfs/dmu_objset.c:1672:	attr = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dmu_objset.c:1686:			child_dcp = kmem_alloc(sizeof (*child_dcp), KM_SLEEP);
./module/zfs/dmu_objset.c:1795:	dcp = kmem_alloc(sizeof (*dcp), KM_SLEEP);
./module/zfs/dmu_objset.c:1890:	attr = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dmu_objset.c:1904:			child = kmem_asprintf("%s/%s", name, attr->za_name);
./module/zfs/dmu_objset.c:1942:				child = kmem_asprintf("%s@%s",
./module/zfs/vdev_raidz.c:335:				    zio_buf_alloc(rm->rm_col[x].rc_size);
./module/zfs/vdev_raidz.c:415:	buf = rm->rm_datacopy = zio_buf_alloc(size);
./module/zfs/vdev_raidz.c:441:vdev_raidz_map_alloc(zio_t *zio, uint64_t unit_shift, uint64_t dcols,
./module/zfs/vdev_raidz.c:489:	rm = kmem_alloc(offsetof(raidz_map_t, rm_col[scols]), KM_SLEEP);
./module/zfs/vdev_raidz.c:537:		rm->rm_col[c].rc_data = zio_buf_alloc(rm->rm_col[c].rc_size);
./module/zfs/vdev_raidz.c:873:	    zio_buf_alloc(rm->rm_col[VDEV_RAIDZ_P].rc_size);
./module/zfs/vdev_raidz.c:875:	    zio_buf_alloc(rm->rm_col[VDEV_RAIDZ_Q].rc_size);
./module/zfs/vdev_raidz.c:1230:	p = kmem_alloc(psize, KM_SLEEP);
./module/zfs/vdev_raidz.c:1347:	p = kmem_alloc(psize, KM_SLEEP);
./module/zfs/vdev_raidz.c:1580:	rm = vdev_raidz_map_alloc(zio, tvd->vdev_ashift, vd->vdev_children,
./module/zfs/vdev_raidz.c:1721:		orig[c] = zio_buf_alloc(rc->rc_size);
./module/zfs/vdev_raidz.c:1820:		orig[n - 1] = zio_buf_alloc(rm->rm_col[0].rc_size);
./module/zfs/metaslab.c:256:metaslab_class_get_alloc(metaslab_class_t *mc)
./module/zfs/metaslab.c:915:metaslab_block_alloc(metaslab_t *msp, uint64_t size)
./module/zfs/metaslab.c:922:	start = msp->ms_ops->msop_alloc(msp, size);
./module/zfs/metaslab.c:991:metaslab_ff_alloc(metaslab_t *msp, uint64_t size)
./module/zfs/metaslab.c:1024:metaslab_df_alloc(metaslab_t *msp, uint64_t size)
./module/zfs/metaslab.c:1077:metaslab_cf_alloc(metaslab_t *msp, uint64_t size)
./module/zfs/metaslab.c:1131:metaslab_ndf_alloc(metaslab_t *msp, uint64_t size)
./module/zfs/metaslab.c:1869:		new_object = space_map_alloc(mos, tx);
./module/zfs/metaslab.c:2075:metaslab_group_alloc(metaslab_group_t *mg, uint64_t psize, uint64_t asize,
./module/zfs/metaslab.c:2173:		if ((offset = metaslab_block_alloc(msp, asize)) != -1ULL)
./module/zfs/metaslab.c:2339:		offset = metaslab_group_alloc(mg, psize, asize, txg, distance,
./module/zfs/metaslab.c:2544:metaslab_alloc(spa_t *spa, metaslab_class_t *mc, uint64_t psize, blkptr_t *bp,
./module/zfs/bpobj.c:46:			    bpobj_alloc(os, SPA_OLD_MAXBLOCKSIZE, tx);
./module/zfs/bpobj.c:56:		return (bpobj_alloc(os, blocksize, tx));
./module/zfs/bpobj.c:77:bpobj_alloc(objset_t *os, int blocksize, dmu_tx_t *tx)
./module/zfs/bpobj.c:88:	return (dmu_object_alloc(os, DMU_OT_BPOBJ, blocksize,
./module/zfs/bpobj.c:400:		bpo->bpo_phys->bpo_subobjs = dmu_object_alloc(bpo->bpo_os,
./module/zfs/unique.c:82:	unique_t *un = kmem_alloc(sizeof (unique_t), KM_SLEEP);
./module/zfs/zap_leaf.c:190:zap_leaf_chunk_alloc(zap_leaf_t *l)
./module/zfs/zap_leaf.c:242:		uint16_t chunk = zap_leaf_chunk_alloc(l);
./module/zfs/zap_leaf.c:355:		thiskey = kmem_alloc(array_numints * sizeof (*thiskey),
./module/zfs/zap_leaf.c:368:		char *thisname = kmem_alloc(array_numints, KM_SLEEP);
./module/zfs/zap_leaf.c:644:	chunk = zap_leaf_chunk_alloc(l);
./module/zfs/zap_leaf.c:681: * needed (using zap_name_alloc(zap_entry_read_name(zeh))).
./module/zfs/zap_leaf.c:703:			zn = zap_name_alloc(zap, name, MT_FIRST);
./module/zfs/zap_leaf.c:753:		uint16_t nchunk = zap_leaf_chunk_alloc(nl);
./module/zfs/zap_leaf.c:783:	chunk = zap_leaf_chunk_alloc(nl);
./module/zfs/txg.c:452:		cb_list = kmem_alloc(sizeof (list_t), KM_SLEEP);
./module/zfs/txg.c:489:	vs1 = kmem_alloc(sizeof (vdev_stat_t), KM_SLEEP);
./module/zfs/txg.c:490:	vs2 = kmem_alloc(sizeof (vdev_stat_t), KM_SLEEP);
./module/zfs/zfs_vnops.c:1535:		pn_alloc(&realnm);
./module/zfs/zfs_vnops.c:2065:			(void) strcpy(zap.za_name, ".");
./module/zfs/zfs_vnops.c:2070:			(void) strcpy(zap.za_name, "..");
./module/zfs/zfs_vnops.c:2075:			(void) strcpy(zap.za_name, ZFS_CTLDIR_NAME);
./module/zfs/zfs_vnops.c:2517:	tmpxvattr = kmem_alloc(sizeof (xvattr_t), KM_SLEEP);
./module/zfs/zfs_vnops.c:2520:	bulk = kmem_alloc(sizeof (sa_bulk_attr_t) * 7, KM_SLEEP);
./module/zfs/zfs_vnops.c:2521:	xattr_bulk = kmem_alloc(sizeof (sa_bulk_attr_t) * 7, KM_SLEEP);
./module/zfs/zfs_vnops.c:3134:		zl = kmem_alloc(sizeof (*zl), KM_SLEEP);
./module/zfs/vdev_label.c:219:	nv = fnvlist_alloc();
./module/zfs/vdev_label.c:316:		child = kmem_alloc(vd->vdev_children * sizeof (nvlist_t *),
./module/zfs/vdev_label.c:399:	array = kmem_alloc(rvd->vdev_children * sizeof (uint64_t), KM_SLEEP);
./module/zfs/vdev_label.c:445:	vp = zio_buf_alloc(sizeof (vdev_phys_t));
./module/zfs/vdev_label.c:713:	vp = zio_buf_alloc(sizeof (vdev_phys_t));
./module/zfs/vdev_label.c:731:		VERIFY(nvlist_alloc(&label, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/vdev_label.c:744:		VERIFY(nvlist_alloc(&label, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/vdev_label.c:782:	ub = zio_buf_alloc(VDEV_UBERBLOCK_RING);
./module/zfs/vdev_label.c:788:	pad2 = zio_buf_alloc(VDEV_PAD_SIZE);
./module/zfs/vdev_label.c:928:				    zio_buf_alloc(VDEV_UBERBLOCK_SIZE(vd)),
./module/zfs/vdev_label.c:1010:	ubbuf = zio_buf_alloc(VDEV_UBERBLOCK_SIZE(vd));
./module/zfs/vdev_label.c:1115:	vp = zio_buf_alloc(sizeof (vdev_phys_t));
./module/zfs/zfs_ctldir.c:137:zfsctl_snapshot_alloc(char *full_name, char *full_path, spa_t *spa,
./module/zfs/zfs_ctldir.c:455:zfsctl_inode_alloc(zfs_sb_t *zsb, uint64_t id,
./module/zfs/zfs_ctldir.c:536:		/* May fail due to concurrent zfsctl_inode_alloc() */
./module/zfs/zfs_ctldir.c:537:		ip = zfsctl_inode_alloc(zsb, id, fops, ops);
./module/zfs/zfs_ctldir.c:559:	zsb->z_ctldir = zfsctl_inode_alloc(zsb, ZFSCTL_INO_ROOT,
./module/zfs/zfs_ctldir.c:714:	path_buffer = kmem_alloc(len, KM_SLEEP);
./module/zfs/zfs_ctldir.c:728:	memcpy(full_path, path_ptr, path_len);
./module/zfs/zfs_ctldir.c:754:	snapname = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:859:	to = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:860:	from = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:861:	real = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:862:	fsname = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:934:	snapname = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:935:	real = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:980:	dsname = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/zfs_ctldir.c:1034:	argv[2] = kmem_asprintf(SET_UNMOUNT_CMD,
./module/zfs/zfs_ctldir.c:1114:	argv[2] = kmem_asprintf(SET_MOUNT_CMD, full_name, full_path);
./module/zfs/zfs_ctldir.c:1149:		se = zfsctl_snapshot_alloc(full_name, full_path,
./module/zfs/zfs_ctldir.c:1214:		mnt = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/dsl_deadlist.c:86:		dle = kmem_alloc(sizeof (*dle), KM_SLEEP);
./module/zfs/dsl_deadlist.c:148:dsl_deadlist_alloc(objset_t *os, dmu_tx_t *tx)
./module/zfs/dsl_deadlist.c:151:		return (bpobj_alloc(os, SPA_OLD_MAXBLOCKSIZE, tx));
./module/zfs/dsl_deadlist.c:188:		uint64_t obj = bpobj_alloc(dl->dl_os, SPA_OLD_MAXBLOCKSIZE, tx);
./module/zfs/dsl_deadlist.c:260:	dle = kmem_alloc(sizeof (*dle), KM_SLEEP);
./module/zfs/dsl_deadlist.c:331:	newobj = dsl_deadlist_alloc(dl->dl_os, tx);
./module/zfs/vdev_cache.c:186:	ve->ve_data = zio_buf_alloc(VCBS);
./module/zfs/vdev_cache.c:280:	ve_search = kmem_alloc(sizeof (vdev_cache_entry_t), KM_SLEEP);
./module/zfs/zio_inject.c:422:		handler = kmem_alloc(sizeof (inject_handler_t), KM_SLEEP);
./module/zfs/zfs_dir.c:264:			dl = kmem_alloc(sizeof (zfs_dirlock_t), KM_SLEEP);
./module/zfs/zfs_dir.c:296:		name = kmem_alloc(dl->dl_namesize, KM_SLEEP);
./module/zfs/zfs_znode.c:152:	 * backed by kmalloc() when on the Linux slab in order that any
./module/zfs/zfs_znode.c:188:	sharezp = kmem_cache_alloc(znode_cache, KM_SLEEP);
./module/zfs/zfs_znode.c:258:zfs_inode_alloc(struct super_block *sb, struct inode **ip)
./module/zfs/zfs_znode.c:262:	zp = kmem_cache_alloc(znode_cache, KM_SLEEP);
./module/zfs/zfs_znode.c:359:zfs_znode_alloc(zfs_sb_t *zsb, dmu_buf_t *db, int blksz,
./module/zfs/zfs_znode.c:613:			obj = dmu_object_alloc(zsb->z_os,
./module/zfs/zfs_znode.c:691:	sa_attrs = kmem_alloc(sizeof (sa_bulk_attr_t) * ZPL_END, KM_SLEEP);
./module/zfs/zfs_znode.c:771:		*zpp = zfs_znode_alloc(zsb, db, 0, obj_type, obj, sa_hdl,
./module/zfs/zfs_znode.c:975:	 * progress.  This is checked for in zfs_znode_alloc()
./module/zfs/zfs_znode.c:977:	 * if zfs_znode_alloc() fails it will drop the hold on the
./module/zfs/zfs_znode.c:980:	zp = zfs_znode_alloc(zsb, db, doi.doi_data_block_size,
./module/zfs/zfs_znode.c:1700:	rootzp = kmem_cache_alloc(znode_cache, KM_SLEEP);
./module/zfs/zfs_znode.c:1904:			(void) sprintf(component + 1, "<xattrdir>");
./module/zfs/spa_history.c:91:	spa->spa_history = dmu_object_alloc(mos, DMU_OT_SPA_HISTORY,
./module/zfs/spa_history.c:292:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/spa_history.c:450:	msg = kmem_vasprintf(fmt, adx);
./module/zfs/spa_history.c:483:	log_internal(fnvlist_alloc(), operation, spa, htx, fmt, adx);
./module/zfs/spa_history.c:497:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/spa_history.c:516:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/zpl_xattr.c:110:		memcpy(xf->buf + xf->offset, name, name_len);
./module/zfs/zpl_xattr.c:311:	memcpy(value, nv_value, nv_size);
./module/zfs/zpl_xattr.c:560:	xattr_name = kmem_asprintf("%s%s", XATTR_USER_PREFIX, name);
./module/zfs/zpl_xattr.c:581:	xattr_name = kmem_asprintf("%s%s", XATTR_USER_PREFIX, name);
./module/zfs/zpl_xattr.c:608:	xattr_name = kmem_asprintf("%s%s", XATTR_TRUSTED_PREFIX, name);
./module/zfs/zpl_xattr.c:629:	xattr_name = kmem_asprintf("%s%s", XATTR_TRUSTED_PREFIX, name);
./module/zfs/zpl_xattr.c:653:	xattr_name = kmem_asprintf("%s%s", XATTR_SECURITY_PREFIX, name);
./module/zfs/zpl_xattr.c:671:	xattr_name = kmem_asprintf("%s%s", XATTR_SECURITY_PREFIX, name);
./module/zfs/zpl_xattr.c:793:		value = kmem_alloc(size, KM_SLEEP);
./module/zfs/zpl_xattr.c:843:		value = kmem_alloc(size, KM_SLEEP);
./module/zfs/zpl_xattr.c:1008:		memcpy(list, xattr_name, xattr_size);
./module/zfs/space_reftree.c:97:	sr = kmem_alloc(sizeof (*sr), KM_SLEEP);
./module/zfs/zfs_debug.c:155:	strcpy(zdm->zdm_msg, buf);
./module/zfs/zfs_debug.c:178:	buf = kmem_alloc(size, KM_SLEEP);
./module/zfs/refcount.c:124:		ref = kmem_cache_alloc(reference_cache, KM_SLEEP);
./module/zfs/refcount.c:167:				    kmem_cache_alloc(reference_history_cache,
./module/zfs/dsl_pool.c:382:		obj = bpobj_alloc(dp->dp_meta_objset, SPA_OLD_MAXBLOCKSIZE, tx);
./module/zfs/dsl_pool.c:809:	 * We can't use bpobj_alloc(), because spa_version() still
./module/zfs/dsl_pool.c:811:	 * subobj support.  So call dmu_object_alloc() directly.
./module/zfs/dsl_pool.c:813:	obj = dmu_object_alloc(dp->dp_meta_objset, DMU_OT_BPOBJ,
./module/zfs/dsl_pool.c:866:	holds = fnvlist_alloc();
./module/zfs/dsl_pool.c:878:			tags = fnvlist_alloc();
./module/zfs/dsl_pool.c:931:	name = kmem_asprintf("%llx-%s", (u_longlong_t)dsobj, tag);
./module/zfs/fm.c:425:zfs_zevent_alloc(void)
./module/zfs/fm.c:552:	ev = zfs_zevent_alloc();
./module/zfs/fm.c:778:i_fm_alloc(nv_alloc_t *nva, size_t size)
./module/zfs/fm.c:879:	nv_alloc_t *nva = nvlist_lookup_nv_alloc(nvl);
./module/zfs/fm.c:1134:	nv_alloc_t *nva = nvlist_lookup_nv_alloc(fmri);
./module/zfs/fm.c:1179:	nv_alloc_t *nva = nvlist_lookup_nv_alloc(fmri);
./module/zfs/dnode.c:409:	dn = kmem_cache_alloc(dnode_cache, KM_SLEEP);
./module/zfs/dnode.c:1985: *	Used in dmu_object_alloc().
./module/zfs/zfs_acl.c:453:zfs_acl_alloc(int vers)
./module/zfs/zfs_acl.c:469:zfs_acl_node_alloc(size_t bytes)
./module/zfs/zfs_acl.c:475:		aclnode->z_acldata = kmem_alloc(bytes, KM_SLEEP);
./module/zfs/zfs_acl.c:816:	oldaclp = kmem_alloc(sizeof (zfs_oldace_t) * aclp->z_acl_count,
./module/zfs/zfs_acl.c:827:	newaclnode = zfs_acl_node_alloc(aclp->z_acl_count *
./module/zfs/zfs_acl.c:1094:	aclp = zfs_acl_alloc(version);
./module/zfs/zfs_acl.c:1099:	aclnode = zfs_acl_node_alloc(aclsize);
./module/zfs/zfs_acl.c:1392:				aoid = dmu_object_alloc(zsb->z_os,
./module/zfs/zfs_acl.c:1485:	newnode = zfs_acl_node_alloc((abstract_size * 6) + aclp->z_acl_bytes);
./module/zfs/zfs_acl.c:1578:	*aclp = zfs_acl_alloc(zfs_acl_version_zp(zp));
./module/zfs/zfs_acl.c:1647:	aclp = zfs_acl_alloc(paclp->z_version);
./module/zfs/zfs_acl.c:1684:		aclnode = zfs_acl_node_alloc(ace_size);
./module/zfs/zfs_acl.c:1846:			    zfs_acl_alloc(zfs_acl_version_zp(dzp));
./module/zfs/zfs_acl.c:1955:		vsecp->vsa_aclentp = kmem_alloc(aclsz, KM_SLEEP);
./module/zfs/zfs_acl.c:2002:	aclp = zfs_acl_alloc(zfs_acl_version(zsb->z_version));
./module/zfs/zfs_acl.c:2005:	aclnode = zfs_acl_node_alloc(aclcnt * sizeof (zfs_object_ace_t));
./module/zfs/spa_config.c:92:	pathname = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/spa_config.c:107:	buf = kmem_alloc(fsize, KM_SLEEP);
./module/zfs/spa_config.c:171:	buf = vmem_alloc(buflen, KM_SLEEP);
./module/zfs/spa_config.c:278:				VERIFY(nvlist_alloc(&nvl, NV_UNIQUE_NAME,
./module/zfs/spa_config.c:328:	VERIFY(nvlist_alloc(&pools, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa_config.c:403:	VERIFY(nvlist_alloc(&config, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/vdev.c:224:	newchild = kmem_alloc(newsize, KM_SLEEP);
./module/zfs/vdev.c:375:vdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *nv, vdev_t *parent, uint_t id,
./module/zfs/vdev.c:1091:		    VDEV_PAD_SIZE, zio_buf_alloc(VDEV_PAD_SIZE),
./module/zfs/vdev.c:2008:		new_object = space_map_alloc(mos, tx);
./module/zfs/vdev.c:2279:		vd->vdev_ms_array = dmu_object_alloc(spa->spa_meta_objset,
./module/zfs/dnode_sync.c:410:	db_marker = kmem_alloc(sizeof (dmu_buf_impl_t), KM_SLEEP);
./module/zfs/dmu_object.c:35:dmu_object_alloc(objset_t *os, dmu_object_type_t ot, int blocksize,
./module/zfs/zfs_vfsops.c:537:	(void) sprintf(buf, "%llx", (longlong_t)fuid);
./module/zfs/zfs_vfsops.c:644:	(void) sprintf(buf, "%llx", (longlong_t)fuid);
./module/zfs/zfs_vfsops.c:674:zfs_mntopts_alloc(void)
./module/zfs/zfs_vfsops.c:715:	zsb->z_mntopts = (zmo ? zmo : zfs_mntopts_alloc());
./module/zfs/dbuf.c:391:	 * should be using vmem_alloc() in the linux kernel
./module/zfs/dbuf.c:673:		db->db.db_data = zio_buf_alloc(DN_MAX_BONUSLEN);
./module/zfs/dbuf.c:696:		dbuf_set_data(db, arc_buf_alloc(db->db_objset->os_spa,
./module/zfs/dbuf.c:838:		dbuf_set_data(db, arc_buf_alloc(spa, db->db.db_size, db, type));
./module/zfs/dbuf.c:886:		dr->dt.dl.dr_data = zio_buf_alloc(DN_MAX_BONUSLEN);
./module/zfs/dbuf.c:894:		dr->dt.dl.dr_data = arc_buf_alloc(spa, size, db, type);
./module/zfs/dbuf.c:959:	db_search = kmem_alloc(sizeof (dmu_buf_impl_t), KM_SLEEP);
./module/zfs/dbuf.c:1128:	buf = arc_buf_alloc(dn->dn_objset->os_spa, size, db, type);
./module/zfs/dbuf.c:1219:		dn->dn_dirtyctx_firstset = kmem_alloc(1, KM_SLEEP);
./module/zfs/dbuf.c:1870:	db = kmem_cache_alloc(dbuf_cache, KM_SLEEP);
./module/zfs/dbuf.c:2127:			    arc_buf_alloc(dh->dh_dn->dn_objset->os_spa,
./module/zfs/dbuf.c:2710:		*datap = arc_buf_alloc(os->os_spa, blksz, db, type);
./module/zfs/vdev_disk.c:164:		argv[2] = kmem_asprintf(SET_SCHEDULER_CMD, device, elevator);
./module/zfs/vdev_disk.c:339:vdev_disk_dio_alloc(int bio_count)
./module/zfs/vdev_disk.c:507:	dr = vdev_disk_dio_alloc(bio_count);
./module/zfs/vdev_disk.c:545:		/* bio_alloc() with __GFP_WAIT never returns NULL */
./module/zfs/vdev_disk.c:546:		dr->dr_bio[i] = bio_alloc(GFP_NOIO,
./module/zfs/vdev_disk.c:636:	bio = bio_alloc(GFP_NOIO, 0);
./module/zfs/vdev_disk.c:637:	/* bio_alloc() with __GFP_WAIT never returns NULL */
./module/zfs/vdev_disk.c:809:	label = vmem_alloc(sizeof (vdev_label_t), KM_SLEEP);
./module/zfs/sa.c:416:	tb->lot_attrs = kmem_alloc(sizeof (sa_attr_type_t) * attr_count,
./module/zfs/sa.c:726:	attrs_start = attrs = kmem_alloc(sizeof (sa_attr_type_t) * attr_count,
./module/zfs/sa.c:1401:		handle = kmem_cache_alloc(sa_cache, KM_SLEEP);
./module/zfs/sa.c:1562:		idx_tab->sa_variable_lengths = kmem_alloc(sizeof (uint16_t) *
./module/zfs/sa.c:1683:		old_data[0] = kmem_alloc(bonus_data_size, KM_SLEEP);
./module/zfs/sa.c:1696:		old_data[1] = zio_buf_alloc(spill_data_size);
./module/zfs/dsl_destroy.c:220:	zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/dsl_destroy.c:221:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_destroy.c:520:	VERIFY0(nvlist_alloc(&dsda.dsda_successful_snaps,
./module/zfs/dsl_destroy.c:537:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/dsl_destroy.c:538:	nvlist_t *errlist = fnvlist_alloc();
./module/zfs/dsl_destroy.c:797:			dp->dp_bptree_obj = bptree_alloc(mos, tx);
./module/zfs/zap_micro.c:177:zap_name_alloc(zap_t *zap, const char *key, matchtype_t mt)
./module/zfs/zap_micro.c:179:	zap_name_t *zn = kmem_alloc(sizeof (zap_name_t), KM_SLEEP);
./module/zfs/zap_micro.c:209:	zap_name_t *zn = kmem_alloc(sizeof (zap_name_t), KM_SLEEP);
./module/zfs/zap_micro.c:278:	mze = kmem_alloc(sizeof (mzap_ent_t), KM_SLEEP);
./module/zfs/zap_micro.c:417:				zn = zap_name_alloc(zap, mze->mze_name,
./module/zfs/zap_micro.c:538:	mzp = zio_buf_alloc(sz);
./module/zfs/zap_micro.c:565:		zn = zap_name_alloc(zap, mze->mze_name, MT_EXACT);
./module/zfs/zap_micro.c:644:	uint64_t obj = dmu_object_alloc(os, ot, 0, bonustype, bonuslen, tx);
./module/zfs/zap_micro.c:655:	uint64_t obj = dmu_object_alloc(os, ot, 0, bonustype, bonuslen, tx);
./module/zfs/zap_micro.c:734:			zn = zap_name_alloc(zap, MZE_PHYS(zap, mze)->mze_name,
./module/zfs/zap_micro.c:781:	zn = zap_name_alloc(zap, name, mt);
./module/zfs/zap_micro.c:826:	zn = zap_name_alloc(zap, name, MT_EXACT);
./module/zfs/zap_micro.c:907:	zn = zap_name_alloc(zap, name, MT_EXACT);
./module/zfs/zap_micro.c:980:			(void) strcpy(mze->mze_name, zn->zn_key_orig);
./module/zfs/zap_micro.c:1011:	zn = zap_name_alloc(zap, key, MT_EXACT);
./module/zfs/zap_micro.c:1089:	zn = zap_name_alloc(zap, name, MT_EXACT);
./module/zfs/zap_micro.c:1165:	zn = zap_name_alloc(zap, name, mt);
./module/zfs/zap_micro.c:1322:			(void) strcpy(za->za_name, mzep->mze_name);
./module/zfs/zap_micro.c:1400:		zap_name_t *zn = zap_name_alloc(zap, name, MT_EXACT);
./module/zfs/zvol.c:128: * Find a zvol_state_t given the name provided at zvol_alloc() time.
./module/zfs/zvol.c:221:	doi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);
./module/zfs/zvol.c:358:	doi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);
./module/zfs/zvol.c:1204:zvol_alloc(dev_t dev, const char *name)
./module/zfs/zvol.c:1258: * Cleanup then free a zvol_state_t which was created by zvol_alloc().
./module/zfs/zvol.c:1281:	parent = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/zvol.c:1321:	doi = kmem_alloc(sizeof (dmu_object_info_t), KM_SLEEP);
./module/zfs/zvol.c:1339:	zv = zvol_alloc(MKDEV(zvol_major, minor), name);
./module/zfs/zvol.c:1546:	name = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/dmu_send.c:537:				abuf = arc_buf_alloc(spa, blksz, &abuf,
./module/zfs/dmu_send.c:1865:	ra.buf = vmem_alloc(ra.bufsize, KM_SLEEP);
./module/zfs/dmu_send.c:1897:			    kmem_alloc(sizeof (avl_tree_t), KM_SLEEP);
./module/zfs/dmu_send.c:2187:	gmep = kmem_alloc(sizeof (*gmep), KM_SLEEP);
./module/zfs/dmu_send.c:2216:	name = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/range_tree.c:224:		rs = kmem_cache_alloc(range_seg_cache, KM_SLEEP);
./module/zfs/range_tree.c:273:		newseg = kmem_cache_alloc(range_seg_cache, KM_SLEEP);
./module/zfs/dmu_tx.c:1481:	dcb = kmem_alloc(sizeof (dmu_tx_callback_t), KM_SLEEP);
./module/zfs/zfs_onexit.c:61: * On the first zfs_ioc_recv() call, dmu_recv_stream() will kmem_alloc()
./module/zfs/zfs_onexit.c:166:	ap = kmem_alloc(sizeof (zfs_onexit_action_node_t), KM_SLEEP);
./module/zfs/bplist.c:48:	bplist_entry_t *bpe = kmem_alloc(sizeof (*bpe), KM_SLEEP);
./module/zfs/spa_misc.c:180: *	Held as reader by metaslab_alloc() and metaslab_claim().
./module/zfs/spa_misc.c:604:	VERIFY(nvlist_alloc(&spa->spa_load_info, NV_UNIQUE_NAME,
./module/zfs/spa_misc.c:620:		VERIFY(nvlist_alloc(&spa->spa_label_features, NV_UNIQUE_NAME,
./module/zfs/spa_misc.c:1330:	new = kmem_alloc(len + 1, KM_SLEEP);
./module/zfs/spa.c:174:	VERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa.c:202:		alloc = metaslab_class_get_alloc(spa_normal_class(spa));
./module/zfs/spa.c:299:	err = nvlist_alloc(nvp, NV_UNIQUE_NAME, KM_SLEEP);
./module/zfs/spa.c:349:				strval = kmem_alloc(
./module/zfs/spa.c:370:			strval = kmem_alloc(za.za_num_integers, KM_SLEEP);
./module/zfs/spa.c:632:	dp = kmem_alloc(sizeof (spa_config_dirent_t),
./module/zfs/spa.c:859:	tqs->stqs_taskq = kmem_alloc(count * sizeof (taskq_t *), KM_SLEEP);
./module/zfs/spa.c:1213: * All vdev validation is done by the vdev_alloc() routine.
./module/zfs/spa.c:1224:	if ((error = vdev_alloc(spa, vdp, nv, parent, id, atype)) != 0)
./module/zfs/spa.c:1459:	spares = kmem_alloc(spa->spa_spares.sav_count * sizeof (void *),
./module/zfs/spa.c:1494:		newvdevs = kmem_alloc(nl2cache * sizeof (void *), KM_SLEEP);
./module/zfs/spa.c:1589:	l2cache = kmem_alloc(sav->sav_count * sizeof (void *), KM_SLEEP);
./module/zfs/spa.c:1618:	packed = vmem_alloc(nvsize, KM_SLEEP);
./module/zfs/spa.c:1674:		child = kmem_alloc(rvd->vdev_children * sizeof (nvlist_t **),
./module/zfs/spa.c:1676:		VERIFY(nvlist_alloc(&nv, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa.c:1938:	data = zio_data_buf_alloc(size);
./module/zfs/spa.c:2160:		spa->spa_load_info = fnvlist_alloc();
./module/zfs/spa.c:2229:	spa->spa_async_zio_root = kmem_alloc(max_ncpus * sizeof (void *),
./module/zfs/spa.c:2345:		VERIFY(nvlist_alloc(&unsup_feat, NV_UNIQUE_NAME, KM_SLEEP) ==
./module/zfs/spa.c:2428:		enabled_feat = fnvlist_alloc();
./module/zfs/spa.c:2429:		unsup_feat = fnvlist_alloc();
./module/zfs/spa.c:2925:		spa->spa_load_info = fnvlist_alloc();
./module/zfs/spa.c:3314:		VERIFY0(nvlist_alloc(&features, NV_UNIQUE_NAME, KM_SLEEP));
./module/zfs/spa.c:3516:		newdevs = kmem_alloc(sizeof (void *) *
./module/zfs/spa.c:3537:		VERIFY(nvlist_alloc(&sav->sav_config, NV_UNIQUE_NAME,
./module/zfs/spa.c:3604:	nvl = fnvlist_alloc();
./module/zfs/spa.c:3646:	spa->spa_async_zio_root = kmem_alloc(max_ncpus * sizeof (void *),
./module/zfs/spa.c:3692:		VERIFY(nvlist_alloc(&spa->spa_spares.sav_config, NV_UNIQUE_NAME,
./module/zfs/spa.c:3707:		VERIFY(nvlist_alloc(&spa->spa_l2cache.sav_config,
./module/zfs/spa.c:3734:	spa->spa_config_object = dmu_object_alloc(spa->spa_meta_objset,
./module/zfs/spa.c:3768:	obj = bpobj_alloc(spa->spa_meta_objset, 1 << 14, tx);
./module/zfs/spa.c:3854:	VERIFY(nvlist_alloc(&nvroot, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa.c:4161:			VERIFY(nvlist_alloc(&spa->spa_spares.sav_config,
./module/zfs/spa.c:4176:			VERIFY(nvlist_alloc(&spa->spa_l2cache.sav_config,
./module/zfs/spa.c:4268:			char *tmpname = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/spa.c:4279:				dsname = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/spa.c:4686:		oldvd->vdev_path = kmem_alloc(strlen(newvd->vdev_path) + 5,
./module/zfs/spa.c:4688:		(void) sprintf(oldvd->vdev_path, "%s/%s",
./module/zfs/spa.c:5164:	VERIFY(nvlist_alloc(&nvl, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa.c:5210:		VERIFY(nvlist_alloc(&newspa->spa_config_splitting,
./module/zfs/spa.c:5322:		newdev = kmem_alloc((count - 1) * sizeof (void *), KM_SLEEP);
./module/zfs/spa.c:6001:	packed = vmem_alloc(bufsize, KM_SLEEP);
./module/zfs/spa.c:6034:		sav->sav_object = dmu_object_alloc(spa->spa_meta_objset,
./module/zfs/spa.c:6042:	VERIFY(nvlist_alloc(&nvroot, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/spa.c:6046:		list = kmem_alloc(sav->sav_count*sizeof (void *), KM_SLEEP);
./module/zfs/zfs_sa.c:147:			(void) memcpy(xoap->xoa_av_scanstamp,
./module/zfs/zfs_sa.c:177:		(void) memcpy((caddr_t)db->db_data + ZFS_OLD_ZNODE_PHYS_SIZE,
./module/zfs/zfs_sa.c:201:			return nvlist_alloc(&zp->z_xattr_cached,
./module/zfs/zfs_sa.c:207:	obj = zio_buf_alloc(size);
./module/zfs/zfs_sa.c:235:	obj = zio_buf_alloc(size);
./module/zfs/zfs_sa.c:312:	bulk = kmem_alloc(sizeof (sa_bulk_attr_t) * 20, KM_SLEEP);
./module/zfs/vdev_mirror.c:100:vdev_mirror_map_alloc(zio_t *zio)
./module/zfs/vdev_mirror.c:337:	mm = vdev_mirror_map_alloc(zio);
./module/zfs/vdev_mirror.c:351:				    zio_buf_alloc(zio->io_size), zio->io_size,
./module/zfs/lz4.c:638:		(void) memcpy(op, anchor, iend - anchor);
./module/zfs/lz4.c:826:		(void) memcpy(op, anchor, iend - anchor);
./module/zfs/lz4.c:841:	ctx = kmem_cache_alloc(lz4_cache, KM_SLEEP);
./module/zfs/lz4.c:924:			(void) memcpy(op, ip, length);
./module/zfs/dsl_bookmark.c:280:		out_props = fnvlist_alloc();
./module/zfs/dsl_bookmark.c:455:	dbda.dbda_success = fnvlist_alloc();
./module/zfs/space_map.c:75:	entry_map = zio_buf_alloc(bufsize);
./module/zfs/space_map.c:275:	entry_map = zio_buf_alloc(sm->sm_blksz);
./module/zfs/space_map.c:367:	sm = kmem_alloc(sizeof (space_map_t), KM_SLEEP);
./module/zfs/space_map.c:436:		sm->sm_object = space_map_alloc(sm->sm_os, tx);
./module/zfs/space_map.c:471:space_map_alloc(objset_t *os, dmu_tx_t *tx)
./module/zfs/space_map.c:485:	object = dmu_object_alloc(os,
./module/zfs/arc.c:1091:	 * should be using vmem_alloc() in the linux kernel
./module/zfs/arc.c:1141:	nhdr = kmem_cache_alloc(new, KM_PUSHPAGE);
./module/zfs/arc.c:1272:	buf->b_hdr->b_freeze_cksum = kmem_alloc(sizeof (zio_cksum_t), KM_SLEEP);
./module/zfs/arc.c:1723:arc_buf_alloc(spa_t *spa, uint64_t size, void *tag, arc_buf_contents_t type)
./module/zfs/arc.c:1729:	hdr = kmem_cache_alloc(hdr_full_cache, KM_PUSHPAGE);
./module/zfs/arc.c:1740:	buf = kmem_cache_alloc(buf_cache, KM_PUSHPAGE);
./module/zfs/arc.c:1776:	buf = arc_buf_alloc(spa, size, arc_onloan_tag, ARC_BUFC_DATA);
./module/zfs/arc.c:1824:	buf = kmem_cache_alloc(buf_cache, KM_PUSHPAGE);
./module/zfs/arc.c:1890:	df = kmem_alloc(sizeof (*df), KM_SLEEP);
./module/zfs/arc.c:2569:		markers[i] = kmem_cache_alloc(hdr_full_cache, KM_SLEEP);
./module/zfs/arc.c:3845:		buf->b_data = zio_buf_alloc(size);
./module/zfs/arc.c:3849:		buf->b_data = zio_data_buf_alloc(size);
./module/zfs/arc.c:4342:			buf = arc_buf_alloc(spa, size, private, type);
./module/zfs/arc.c:4394:			buf = kmem_cache_alloc(buf_cache, KM_PUSHPAGE);
./module/zfs/arc.c:4555:	p = kmem_alloc(sizeof (*p), KM_SLEEP);
./module/zfs/arc.c:4823:		nhdr = kmem_cache_alloc(hdr_full_cache, KM_PUSHPAGE);
./module/zfs/arc.c:6266:	head = kmem_cache_alloc(hdr_l2only_cache, KM_PUSHPAGE);
./module/zfs/arc.c:6354:				cb = kmem_alloc(
./module/zfs/arc.c:6585:	cdata = zio_data_buf_alloc(len);
./module/zfs/arc.c:6675:		cdata = zio_data_buf_alloc(csize);
./module/zfs/zfs_replay.c:199:	fuid_infop = zfs_fuid_info_alloc();
./module/zfs/zfs_replay.c:227:	fuid_infop = zfs_fuid_info_alloc();
./module/zfs/zfs_replay.c:236:		zfuid = kmem_alloc(sizeof (zfs_fuid_t), KM_SLEEP);
./module/zfs/zfeature.c:185:	zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/zfeature.c:186:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/zfeature.c:187:	buf = kmem_alloc(MAXPATHLEN, KM_SLEEP);
./module/zfs/zap.c:983:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/zap.c:988:			(void) strcpy(name, za->za_name);
./module/zfs/dsl_scan.c:265:		    vmem_alloc(sizeof (zfs_all_blkstats_t), KM_SLEEP);
./module/zfs/dsl_scan.c:579:	zilog = zil_alloc(dp->dp_meta_objset, zh);
./module/zfs/dsl_scan.c:784:	bp_toread = kmem_alloc(sizeof (blkptr_t), KM_SLEEP);
./module/zfs/dsl_scan.c:1084:	dsname = kmem_alloc(ZFS_MAXNAMELEN, KM_SLEEP);
./module/zfs/dsl_scan.c:1351:	zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/dsl_scan.c:1352:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_scan.c:1831:		void *data = zio_data_buf_alloc(size);
./module/zfs/zil.c:175:	zn = kmem_alloc(sizeof (zil_bp_node_t), KM_SLEEP);
./module/zfs/zil.c:348:	lrbuf = zio_buf_alloc(SPA_OLD_MAXBLOCKSIZE);
./module/zfs/zil.c:470:	lwb = kmem_cache_alloc(zil_lwb_cache, KM_SLEEP);
./module/zfs/zil.c:474:	lwb->lwb_buf = zio_buf_alloc(BP_GET_LSIZE(bp));
./module/zfs/zil.c:820:			zv = kmem_alloc(sizeof (*zv), KM_SLEEP);
./module/zfs/zil.c:1197:	itx = zio_data_buf_alloc(offsetof(itx_t, itx_lr) + lrsize);
./module/zfs/zil.c:1381:			ian = kmem_alloc(sizeof (itx_async_node_t),
./module/zfs/zil.c:1794:zil_alloc(objset_t *os, zil_header_t *zh_phys)
./module/zfs/zil.c:2205:	zr.zr_lr = vmem_alloc(2 * SPA_MAXBLOCKSIZE, KM_SLEEP);
./module/zfs/zio.c:150:			(void) sprintf(name, "zio_buf_%lu", (ulong_t)size);
./module/zfs/zio.c:154:			(void) sprintf(name, "zio_data_buf_%lu", (ulong_t)size);
./module/zfs/zio.c:226:zio_buf_alloc(size_t size)
./module/zfs/zio.c:232:	return (kmem_cache_alloc(zio_buf_cache[c], KM_PUSHPAGE));
./module/zfs/zio.c:242:zio_data_buf_alloc(size_t size)
./module/zfs/zio.c:248:	return (kmem_cache_alloc(zio_data_buf_cache[c], KM_PUSHPAGE));
./module/zfs/zio.c:262:	return (kmem_cache_alloc(zio_buf_cache[c], flags));
./module/zfs/zio.c:294:	zio_transform_t *zt = kmem_alloc(sizeof (zio_transform_t), KM_SLEEP);
./module/zfs/zio.c:409:	zio_link_t *zl = kmem_cache_alloc(zio_link_cache, KM_SLEEP);
./module/zfs/zio.c:533:	zio = kmem_cache_alloc(zio_cache, KM_SLEEP);
./module/zfs/zio.c:967:		void *wbuf = zio_buf_alloc(size);
./module/zfs/zio.c:1082:		void *cbuf = zio_buf_alloc(psize);
./module/zfs/zio.c:1191:		void *cbuf = zio_buf_alloc(lsize);
./module/zfs/zio.c:1802:zio_gang_node_alloc(zio_gang_node_t **gnpp)
./module/zfs/zio.c:1809:	gn->gn_gbh = zio_buf_alloc(SPA_GANGBLOCKSIZE);
./module/zfs/zio.c:1847:	zio_gang_node_t *gn = zio_gang_node_alloc(gnpp);
./module/zfs/zio.c:2006:	error = metaslab_alloc(spa, spa_normal_class(spa), SPA_GANGBLOCKSIZE,
./module/zfs/zio.c:2021:	gn = zio_gang_node_alloc(gnpp);
./module/zfs/zio.c:2179:			    zio_buf_alloc(zio->io_size), zio->io_size,
./module/zfs/zio.c:2534:	error = metaslab_alloc(spa, mc, zio->io_size, bp,
./module/zfs/zio.c:2610:		error = metaslab_alloc(spa, spa_log_class(spa), size,
./module/zfs/zio.c:2616:		error = metaslab_alloc(spa, spa_normal_class(spa), size,
./module/zfs/zio.c:2713:		char *abuf = zio_buf_alloc(asize);
./module/zfs/zio.c:2841:	void *buf = zio_buf_alloc(zio->io_size);
./module/zfs/zio.c:3172:				abuf = zio_buf_alloc(asize);
./module/zfs/spa_stats.c:556:	ssh->private = kmem_alloc(ssh->size, KM_SLEEP);
./module/zfs/rrwlock.c:106:	rn = kmem_alloc(sizeof (*rn), KM_SLEEP);
./module/zfs/dsl_dir.c:211:				(void) strcpy(dd->dd_myname, tail);
./module/zfs/dsl_dir.c:221:			(void) strcpy(dd->dd_myname, spa_name(dp->dp_spa));
./module/zfs/dsl_dir.c:375:		(void) strcpy(component, path);
./module/zfs/dsl_dir.c:418:	buf = kmem_alloc(MAXNAMELEN, KM_SLEEP);
./module/zfs/dsl_dir.c:528:	zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/dsl_dir.c:529:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_dir.c:892:	ddobj = dmu_object_alloc(mos, DMU_OT_DSL_DIR, 0,
./module/zfs/dsl_dir.c:1251:	tr_list = kmem_alloc(sizeof (list_t), KM_SLEEP);
./module/zfs/dsl_dir.c:1906:	(void) strcpy(dd->dd_myname, mynewname);
./module/zfs/dsl_prop.c:93:	inheritstr = kmem_asprintf("%s%s", propname, ZPROP_INHERIT_SUFFIX);
./module/zfs/dsl_prop.c:94:	recvdstr = kmem_asprintf("%s%s", propname, ZPROP_RECVD_SUFFIX);
./module/zfs/dsl_prop.c:134:						(void) strcpy(setpoint,
./module/zfs/dsl_prop.c:191:			char *inheritstr = kmem_asprintf("%s%s", propname,
./module/zfs/dsl_prop.c:201:			char *recvdstr = kmem_asprintf("%s%s", propname,
./module/zfs/dsl_prop.c:208:					(void) strcpy(setpoint,
./module/zfs/dsl_prop.c:242:	cbr = kmem_alloc(sizeof (dsl_prop_cb_record_t), KM_SLEEP);
./module/zfs/dsl_prop.c:244:	cbr->cbr_propname = kmem_alloc(strlen(propname)+1, KM_SLEEP);
./module/zfs/dsl_prop.c:245:	(void) strcpy((char *)cbr->cbr_propname, propname);
./module/zfs/dsl_prop.c:329:	recvdstr = kmem_asprintf("%s%s", propname, ZPROP_RECVD_SUFFIX);
./module/zfs/dsl_prop.c:546:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_prop.c:597:	inheritstr = kmem_asprintf("%s%s", propname, ZPROP_INHERIT_SUFFIX);
./module/zfs/dsl_prop.c:598:	recvdstr = kmem_asprintf("%s%s", propname, ZPROP_RECVD_SUFFIX);
./module/zfs/dsl_prop.c:701:			tbuf = kmem_alloc(ZAP_MAXVALUELEN, KM_SLEEP);
./module/zfs/dsl_prop.c:720:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/dsl_prop.c:733:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/dsl_prop.c:746:	nvlist_t *nvl = fnvlist_alloc();
./module/zfs/dsl_prop.c:929:				valstr = kmem_asprintf("%s%s", propname,
./module/zfs/dsl_prop.c:965:		VERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/dsl_prop.c:970:			char *tmp = kmem_alloc(za.za_num_integers,
./module/zfs/dsl_prop.c:1013:	VERIFY(nvlist_alloc(nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/dsl_prop.c:1130:	VERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/dsl_prop.c:1152:	VERIFY(nvlist_alloc(&propval, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/dsl_deleg.c:329:	zc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/dsl_deleg.c:330:	za = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_deleg.c:331:	basezc = kmem_alloc(sizeof (zap_cursor_t), KM_SLEEP);
./module/zfs/dsl_deleg.c:332:	baseza = kmem_alloc(sizeof (zap_attribute_t), KM_SLEEP);
./module/zfs/dsl_deleg.c:333:	source = kmem_alloc(MAXNAMELEN + strlen(MOS_DIR_NAME) + 1, KM_SLEEP);
./module/zfs/dsl_deleg.c:334:	VERIFY(nvlist_alloc(nvp, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./module/zfs/dsl_deleg.c:345:		sp_nvp = fnvlist_alloc();
./module/zfs/dsl_deleg.c:355:			perms_nvp = fnvlist_alloc();
./module/zfs/dsl_deleg.c:502:		permnode = kmem_alloc(sizeof (perm_set_t), KM_SLEEP);
./cmd/mount_zfs/mount_zfs.c:196:				strcpy(badopt, opt);
./cmd/zpios/zpios_main.c:163:	args = malloc(sizeof (*args));
./cmd/zpios/zpios_main.c:422:	zpios_buffer = (char *)malloc(zpios_buffer_size);
./cmd/zpios/zpios_main.c:493:	cmd = (zpios_cmd_t *)malloc(cmd_size);
./cmd/zinject/zinject.c:480:	(void) strcpy(zc.zc_name, pool);
./cmd/zinject/zinject.c:831:		(void) strcpy(pool, argv[0]);
./cmd/zinject/zinject.c:865:		(void) strcpy(pool, argv[0]);
./cmd/zinject/zinject.c:895:		(void) strcpy(pool, argv[0]);
./cmd/zinject/zinject.c:918:		(void) strcpy(pool, argv[0]);
./cmd/zinject/zinject.c:930:			(void) strcpy(pool, argv[0]);
./cmd/zinject/translate.c:153:	(void) strcpy(dataset, mp.mnt_special);
./cmd/zinject/translate.c:158:	(void) strcpy(relpath, rel);
./cmd/zinject/translate.c:383:		(void) strcpy(poolname, object);
./cmd/zinject/translate.c:423:	(void) strcpy(poolname, dataset);
./cmd/zed/zed_strings.c:74:	zsp = calloc(1, sizeof (*zsp));
./cmd/zed/zed_strings.c:118:	np = calloc(1, sizeof (*np));
./cmd/zed/zed_exec.c:52:	buf = calloc(1, buflen);
./cmd/zed/zed_exec.c:62:		memcpy(p, q, len);
./cmd/zed/zed_conf.c:42:	zcp = calloc(1, sizeof (*zcp));
./cmd/zstreamdump/zstreamdump.c:72:safe_malloc(size_t size)
./cmd/zstreamdump/zstreamdump.c:74:	void *rv = malloc(size);
./cmd/zstreamdump/zstreamdump.c:174:	char *buf = safe_malloc(SPA_MAXBLOCKSIZE);
./cmd/zstreamdump/zstreamdump.c:324:					buf = safe_malloc(sz);
./cmd/zfs/zfs_util.h:34:void * safe_malloc(size_t size);
./cmd/zfs/zfs_main.c:334: * Utility function to guarantee malloc() success.
./cmd/zfs/zfs_main.c:338:safe_malloc(size_t size)
./cmd/zfs/zfs_main.c:342:	if ((data = calloc(1, size)) == NULL)
./cmd/zfs/zfs_main.c:643:	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:754:	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:1036:		cb->cb_batchedsnaps = fnvlist_alloc();
./cmd/zfs/zfs_main.c:1255:		cb.cb_nvl = fnvlist_alloc();
./cmd/zfs/zfs_main.c:1294:				cb.cb_batchedsnaps = fnvlist_alloc();
./cmd/zfs/zfs_main.c:1341:		nvl = fnvlist_alloc();
./cmd/zfs/zfs_main.c:1393:		cb.cb_batchedsnaps = fnvlist_alloc();
./cmd/zfs/zfs_main.c:2039:		(void) strcpy(cb->cb_lastfs, zfs_get_name(zhp));
./cmd/zfs/zfs_main.c:2380:	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:2382:	node = safe_malloc(sizeof (us_node_t));
./cmd/zfs/zfs_main.c:2568:				(void) sprintf(valstr, "%llu",
./cmd/zfs/zfs_main.c:2577:					(void) sprintf(valstr, "%llu",
./cmd/zfs/zfs_main.c:3573:	error = asprintf(&name, "%s@%s", zfs_get_name(zhp), sd->sd_snapname);
./cmd/zfs/zfs_main.c:3600:	if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:3602:	if (nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:4332:		    safe_malloc(sizeof (deleg_perm_node_t));
./cmd/zfs/zfs_main.c:4388:			who_perm_node_t *node = safe_malloc(
./cmd/zfs/zfs_main.c:4453:		fs_perm_node_t *node = safe_malloc(sizeof (fs_perm_node_t));
./cmd/zfs/zfs_main.c:4749:	if (nvlist_alloc(&base_nvl, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:4751:	if (nvlist_alloc(&set_nvl, NV_UNIQUE_NAME, 0) !=  0)
./cmd/zfs/zfs_main.c:4881:	if (nvlist_alloc(nvlp, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:4970:			(void) sprintf(id, "%u", rid);
./cmd/zfs/zfs_main.c:5521:	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)
./cmd/zfs/zfs_main.c:5852:	(void) sprintf(info, "(%d/%d)", current, total);
./cmd/zfs/zfs_main.c:5876:	(void) strcpy(&mntopts[len], newopts);
./cmd/zfs/zfs_main.c:5906:				options = safe_malloc(MNT_LINE_MAX + 1);
./cmd/zfs/zfs_main.c:6301:			node = safe_malloc(sizeof (unshare_unmount_node_t));
./cmd/zfs/zfs_main.c:6613:	nvl = fnvlist_alloc();
./cmd/zfs/zfs_iter.c:102:		zfs_node_t *node = safe_malloc(sizeof (zfs_node_t));
./cmd/zfs/zfs_iter.c:166:	col = safe_malloc(sizeof (zfs_sort_column_t));
./cmd/zfs/zfs_iter.c:171:		col->sc_user_prop = safe_malloc(strlen(name) + 1);
./cmd/zfs/zfs_iter.c:172:		(void) strcpy(col->sc_user_prop, name);
./cmd/zpool/zpool_iter.c:78:	zpool_node_t *node = safe_malloc(sizeof (zpool_node_t));
./cmd/zpool/zpool_iter.c:111:	zlp = safe_malloc(sizeof (zpool_list_t));
./cmd/zpool/zpool_main.c:428:	    nvlist_alloc(props, NV_UNIQUE_NAME, 0) != 0) {
./cmd/zpool/zpool_main.c:2102:				searchdirs = safe_malloc(sizeof (char *));
./cmd/zpool/zpool_main.c:2104:				char **tmp = safe_malloc((nsearch + 1) *
./cmd/zpool/zpool_main.c:2206:	if (nvlist_alloc(&policy, NV_UNIQUE_NAME, 0) != 0 ||
./cmd/zpool/zpool_main.c:2280:				searchdirs = safe_malloc(sizeof (char *));
./cmd/zpool/zpool_main.c:2282:				char **tmp = safe_malloc((nsearch + 1) *
./cmd/zpool/zpool_main.c:3854:	if (nvlist_alloc(&policy, NV_UNIQUE_NAME, 0) != 0 ||
./cmd/zpool/zpool_main.c:4170:	pathname = safe_malloc(len);
./cmd/zpool/zpool_main.c:4791:			verify(-1 != asprintf(&propname, "feature@%s", fname));
./cmd/zpool/zpool_main.c:5396:	(void) sprintf(str+20, ".%09lld", (longlong_t)tv[1]); /* '.123456789' */
./cmd/zpool/zpool_main.c:5966:		(void) strcpy((void *)buf, argv[2]);
./cmd/zpool/zpool_util.c:36: * Utility function to guarantee malloc() success.
./cmd/zpool/zpool_util.c:39:safe_malloc(size_t size)
./cmd/zpool/zpool_util.c:43:	if ((data = calloc(1, size)) == NULL) {
./cmd/zpool/zpool_util.h:38:void *safe_malloc(size_t);
./cmd/zpool/zpool_vdev.c:725:	verify(nvlist_alloc(&vdev, NV_UNIQUE_NAME, 0) == 0);
./cmd/zpool/zpool_vdev.c:799:	ret = safe_malloc(sizeof (replication_level_t));
./cmd/zpool/zpool_vdev.c:1548:				verify(nvlist_alloc(&nv, NV_UNIQUE_NAME,
./cmd/zpool/zpool_vdev.c:1604:	verify(nvlist_alloc(&nvroot, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:524:	buf = umem_alloc(FATAL_MSG_SZ, UMEM_NOFAIL);
./cmd/ztest/ztest.c:527:	(void) sprintf(buf, "ztest: ");
./cmd/ztest/ztest.c:529:	(void) vsprintf(buf + strlen(buf), message, args);
./cmd/ztest/ztest.c:776:		cmd = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:777:		realaltdir = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:819:	zs->zs_alloc = metaslab_class_get_alloc(spa_normal_class(ztest_spa));
./cmd/ztest/ztest.c:871:	pathbuf = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:902:	VERIFY(nvlist_alloc(&file, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:920:	child = umem_alloc(r * sizeof (nvlist_t *), UMEM_NOFAIL);
./cmd/ztest/ztest.c:925:	VERIFY(nvlist_alloc(&raidz, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:951:	child = umem_alloc(m * sizeof (nvlist_t *), UMEM_NOFAIL);
./cmd/ztest/ztest.c:956:	VERIFY(nvlist_alloc(&mirror, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:979:	child = umem_alloc(t * sizeof (nvlist_t *), UMEM_NOFAIL);
./cmd/ztest/ztest.c:988:	VERIFY(nvlist_alloc(&root, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:1093:	setpoint = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:1120:	VERIFY(nvlist_alloc(&props, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:1216:	rl = umem_alloc(sizeof (*rl), UMEM_NOFAIL);
./cmd/ztest/ztest.c:1525:			lr->lr_foid = dmu_object_alloc(os,
./cmd/ztest/ztest.c:1983:ztest_lr_alloc(size_t lrsize, char *name)
./cmd/ztest/ztest.c:2064:		lr_create_t *lr = ztest_lr_alloc(sizeof (*lr), od->od_name);
./cmd/ztest/ztest.c:2117:		lr_remove_t *lr = ztest_lr_alloc(sizeof (*lr), od->od_name);
./cmd/ztest/ztest.c:2140:	lr = ztest_lr_alloc(sizeof (*lr) + size, NULL);
./cmd/ztest/ztest.c:2163:	lr = ztest_lr_alloc(sizeof (*lr), NULL);
./cmd/ztest/ztest.c:2182:	lr = ztest_lr_alloc(sizeof (*lr), NULL);
./cmd/ztest/ztest.c:2238:	data = umem_alloc(blocksize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:2463:	name = kmem_asprintf("%s_upgrade", ztest_opts.zo_pool);
./cmd/ztest/ztest.c:2498:	props = fnvlist_alloc();
./cmd/ztest/ztest.c:2646:	path = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:2753:	schild = malloc(rvd->vdev_children * sizeof (nvlist_t *));
./cmd/ztest/ztest.c:2760:			VERIFY(nvlist_alloc(&schild[schildren], NV_UNIQUE_NAME,
./cmd/ztest/ztest.c:2778:	VERIFY(nvlist_alloc(&split, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:2784:	VERIFY(nvlist_alloc(&config, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:2838:	oldpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:2839:	newpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:2889:	(void) strcpy(oldpath, oldvd->vdev_path);
./cmd/ztest/ztest.c:2912:		(void) strcpy(newpath, newvd->vdev_path);
./cmd/ztest/ztest.c:3355:	zdtmp = umem_alloc(sizeof (ztest_ds_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:3356:	name = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3475:	snap1name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3476:	clone1name = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3477:	snap2name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3478:	clone2name = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3479:	snap3name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3530:	snap1name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3531:	clone1name = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3532:	snap2name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3533:	clone2name = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3534:	snap3name  = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3637:	od = umem_alloc(size, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3671:	od = umem_alloc(size, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3745:	packbuf = umem_alloc(packsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3746:	bigbuf = umem_alloc(bigsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3875:		void *packcheck = umem_alloc(packsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3876:		void *bigcheck = umem_alloc(bigsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:3969:	od = umem_alloc(size, UMEM_NOFAIL);
./cmd/ztest/ztest.c:4156:			void *packcheck = umem_alloc(packsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:4157:			void *bigcheck = umem_alloc(bigsize, UMEM_NOFAIL);
./cmd/ztest/ztest.c:4190:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4220:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4274:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4316:	(void) sprintf(propname, "prop_%llu", (u_longlong_t)prop);
./cmd/ztest/ztest.c:4317:	(void) sprintf(txgname, "txg_%llu", (u_longlong_t)prop);
./cmd/ztest/ztest.c:4378:	(void) sprintf(propname, "prop_%llu", (u_longlong_t)prop);
./cmd/ztest/ztest.c:4379:	(void) sprintf(txgname, "txg_%llu", (u_longlong_t)prop);
./cmd/ztest/ztest.c:4411:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4460:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4649:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:4822:	snaps = fnvlist_alloc();
./cmd/ztest/ztest.c:4823:	holds = fnvlist_alloc();
./cmd/ztest/ztest.c:4922:	holds = fnvlist_alloc();
./cmd/ztest/ztest.c:4982:	path0 = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:4983:	pathrand = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:5073:		(void) strcpy(path0, vd0->vdev_path);
./cmd/ztest/ztest.c:5074:		(void) strcpy(pathrand, vd0->vdev_path);
./cmd/ztest/ztest.c:5191:	od = umem_alloc(sizeof (ztest_od_t), UMEM_NOFAIL);
./cmd/ztest/ztest.c:5264:	buf = zio_buf_alloc(psize);
./cmd/ztest/ztest.c:5334:	newname = umem_alloc(strlen(oldname) + 5, UMEM_NOFAIL);
./cmd/ztest/ztest.c:5335:	(void) strcpy(newname, oldname);
./cmd/ztest/ztest.c:5386:	bin = umem_alloc(MAXPATHLEN + MAXNAMELEN + 20, UMEM_NOFAIL);
./cmd/ztest/ztest.c:5387:	zdb = umem_alloc(MAXPATHLEN + MAXNAMELEN + 20, UMEM_NOFAIL);
./cmd/ztest/ztest.c:5388:	zbuf = umem_alloc(1024, UMEM_NOFAIL);
./cmd/ztest/ztest.c:5392:		strcpy(bin, "/usr/sbin/zdb"); /* Installed */
./cmd/ztest/ztest.c:5394:		strcpy(bin, "/sbin/zdb"); /* Installed */
./cmd/ztest/ztest.c:5400:	(void) sprintf(zdb,
./cmd/ztest/ztest.c:5891:	zs->zs_alloc = metaslab_class_get_alloc(spa_normal_class(spa));
./cmd/ztest/ztest.c:5996:	    metaslab_class_get_alloc(spa_normal_class(spa)) < capacity) {
./cmd/ztest/ztest.c:6051:		(void) sprintf(timebuf,
./cmd/ztest/ztest.c:6054:		(void) sprintf(timebuf, "%lluh%02llum%02llus", h, m, s);
./cmd/ztest/ztest.c:6056:		(void) sprintf(timebuf, "%llum%02llus", m, s);
./cmd/ztest/ztest.c:6058:		(void) sprintf(timebuf, "%llus", s);
./cmd/ztest/ztest.c:6066:	VERIFY(nvlist_alloc(&props, NV_UNIQUE_NAME, 0) == 0);
./cmd/ztest/ztest.c:6102:		VERIFY3S(-1, !=, asprintf(&buf, "feature@%s",
./cmd/ztest/ztest.c:6217:		cmdbuf = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./cmd/ztest/ztest.c:6360:	VERIFY(asprintf((char **)&spa_config_path, "%s/zpool.cache",
./cmd/ztest/ztest.c:6363:	ztest_ds = umem_alloc(ztest_opts.zo_datasets * sizeof (ztest_ds_t),
./cmd/ztest/ztest.c:6390:	cmd = umem_alloc(MAXNAMELEN, UMEM_NOFAIL);
./cmd/zdb/zdb.c:210:	char *packed = umem_alloc(nvsize, UMEM_NOFAIL);
./cmd/zdb/zdb.c:248:		(void) sprintf(buf, "%llu", (longlong_t)num);
./cmd/zdb/zdb.c:475:	uint64_t *subobjs = kmem_alloc(doi.doi_max_offset, KM_SLEEP);
./cmd/zdb/zdb.c:1083:	if ((buf = malloc(SPA_OLD_MAXBLOCKSIZE)) == NULL) {
./cmd/zdb/zdb.c:1186:		(void) sprintf(blkbuf,
./cmd/zdb/zdb.c:1657:	sa_xattr_packed = malloc(sa_xattr_size);
./cmd/zdb/zdb.c:1910:	(void) sprintf(fill, "%6.2f", 100.0 * doi.doi_fill_count *
./cmd/zdb/zdb.c:2154:	if ((buf = malloc(statbuf.st_size)) == NULL) {
./cmd/zdb/zdb.c:2219:		path = malloc(len);
./cmd/zdb/zdb.c:2508:		void *data = zio_data_buf_alloc(size);
./cmd/zdb/zdb.c:2765:	zcb.zcb_totalasize = metaslab_class_get_alloc(spa_normal_class(spa));
./cmd/zdb/zdb.c:2801:	norm_alloc = metaslab_class_get_alloc(spa_normal_class(spa));
./cmd/zdb/zdb.c:2804:	total_alloc = norm_alloc + metaslab_class_get_alloc(spa_log_class(spa));
./cmd/zdb/zdb.c:3388:	lbuf = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);
./cmd/zdb/zdb.c:3443:		void *pbuf2 = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);
./cmd/zdb/zdb.c:3444:		void *lbuf2 = umem_alloc(SPA_MAXBLOCKSIZE, UMEM_NOFAIL);
./cmd/zdb/zdb.c:3576:		*target = umem_alloc(sz, UMEM_NOFAIL);
./cmd/zdb/zdb.c:3661:				searchdirs = umem_alloc(sizeof (char *),
./cmd/zdb/zdb.c:3664:				char **tmp = umem_alloc((nsearch + 1) *
./cmd/zdb/zdb.c:3755:	if (nvlist_alloc(&policy, NV_UNIQUE_NAME_TYPE, 0) != 0 ||
./cmd/zdb/zdb.c:3829:			zopt_object = calloc(zopt_objects, sizeof (uint64_t));
./cmd/zdb/zdb_il.c:138:	if ((buf = malloc(SPA_MAXBLOCKSIZE)) == NULL)
./cmd/zdb/zdb_il.c:324:		(void) strcpy(blkbuf, ", ");
./cmd/zhack/zhack.c:182:		VERIFY(nvlist_alloc(&props, NV_UNIQUE_NAME, 0) == 0);
./include/libuutil.h:148:extern char *uu_msprintf(const char *format, ...);
./include/libuutil.h:245: *	a = malloc(sizeof(*a));
./include/libuutil.h:348: *	a = malloc(sizeof(*a));
./include/sys/zfs_znode.h:334:extern int	zfs_inode_alloc(struct super_block *, struct inode **ip);
./include/sys/spa.h:899:	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\
./include/sys/zfs_fuid.h:113:extern zfs_fuid_info_t *zfs_fuid_info_alloc(void);
./include/sys/zio.h:524:extern void *zio_buf_alloc(size_t size);
./include/sys/zio.h:526:extern void *zio_data_buf_alloc(size_t size);
./include/sys/bpobj.h:70:uint64_t bpobj_alloc(objset_t *mos, int blocksize, dmu_tx_t *tx);
./include/sys/dsl_dataset.h:311:	char *__ds_name = kmem_alloc(MAXNAMELEN, KM_SLEEP); \
./include/sys/metaslab.h:65:int metaslab_alloc(spa_t *, metaslab_class_t *, uint64_t,
./include/sys/metaslab.h:82:uint64_t metaslab_class_get_alloc(metaslab_class_t *);
./include/sys/zfs_context.h:400:#define	kmem_alloc(_s, _f)	umem_alloc(_s, _f)
./include/sys/zfs_context.h:403:#define	vmem_alloc(_s, _f)	kmem_alloc(_s, _f)
./include/sys/zfs_context.h:409:#define	kmem_cache_alloc(_c, _f) umem_cache_alloc(_c, _f)
./include/sys/zfs_context.h:670:extern char *kmem_vasprintf(const char *fmt, va_list adx);
./include/sys/zfs_context.h:671:extern char *kmem_asprintf(const char *fmt, ...);
./include/sys/zfs_ioctl.h:411:extern minor_t zfsdev_minor_alloc(void);
./include/sys/zfs_vfsops.h:195:extern zfs_mntopts_t *zfs_mntopts_alloc(void);
./include/sys/space_map.h:151:uint64_t space_map_alloc(objset_t *os, dmu_tx_t *tx);
./include/sys/dmu.h:326: * dmu_object_alloc() chooses an object and returns it in *objectp.
./include/sys/dmu.h:333:uint64_t dmu_object_alloc(objset_t *os, dmu_object_type_t ot,
./include/sys/vdev_impl.h:296:extern int vdev_alloc(spa_t *spa, vdev_t **vdp, nvlist_t *config,
./include/sys/nvpair.h:155:int nvlist_alloc(nvlist_t **, uint_t, int);
./include/sys/nvpair.h:169:nv_alloc_t *nvlist_lookup_nv_alloc(nvlist_t *);
./include/sys/nvpair.h:280:nvlist_t *fnvlist_alloc(void);
./include/sys/dbuf.h:357:		(void) strcpy(__db_buf, "mdn"); \
./include/sys/dbuf.h:370:	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\
./include/sys/zap_impl.h:201:zap_name_t *zap_name_alloc(zap_t *zap, const char *key, matchtype_t mt);
./include/sys/zfs_acl.h:234:zfs_acl_t *zfs_acl_alloc(int);
./include/sys/zfs_acl.h:235:zfs_acl_node_t *zfs_acl_node_alloc(size_t);
./include/sys/bptree.h:51:uint64_t bptree_alloc(objset_t *os, dmu_tx_t *tx);
./include/sys/dsl_dir.h:179:	char *__ds_name = kmem_alloc(MAXNAMELEN + strlen(MOS_DIR_NAME) + 1, \
./include/sys/arc.h:168:arc_buf_t *arc_buf_alloc(spa_t *spa, uint64_t size, void *tag,
./include/sys/dnode.h:342:		(void) strcpy(__db_buf, "mdn"); \
./include/sys/zil.h:453:extern zilog_t	*zil_alloc(objset_t *os, zil_header_t *zh_phys);
./include/sys/dsl_deadlist.h:67:uint64_t dsl_deadlist_alloc(objset_t *os, dmu_tx_t *tx);
./include/libnvpair.h:89:extern nvlist_prtctl_t nvlist_prtctl_alloc(void);
./include/linux/vfs_compat.h:102:	sprintf(tmp, "%.28s%s", name, "-%d");
./include/libzfs_impl.h:142:void *zfs_alloc(libzfs_handle_t *, size_t);
./include/libzfs_impl.h:144:char *zfs_asprintf(libzfs_handle_t *, const char *, ...);
./lib/libzpool/kernel.c:597:	realpath = umem_alloc(MAXPATHLEN, UMEM_NOFAIL);
./lib/libzpool/kernel.c:628:		(void) sprintf(realpath, "%s", path);
./lib/libzpool/kernel.c:631:			(void) sprintf(realpath + (dsk - path) + 1, "r%s",
./lib/libzpool/kernel.c:634:		(void) sprintf(realpath, "%s", path);
./lib/libzpool/kernel.c:688:	char *realpath = umem_alloc(strlen(path) + 2, UMEM_NOFAIL);
./lib/libzpool/kernel.c:692:	(void) sprintf(realpath, "/%s", path);
./lib/libzpool/kernel.c:1248:kmem_vasprintf(const char *fmt, va_list adx)
./lib/libzpool/kernel.c:1254:	VERIFY(vasprintf(&buf, fmt, adx_copy) != -1);
./lib/libzpool/kernel.c:1261:kmem_asprintf(const char *fmt, ...)
./lib/libzpool/kernel.c:1267:	VERIFY(vasprintf(&buf, fmt, adx) != -1);
./lib/libzpool/util.c:54:		(void) sprintf(buf, "%llu", (u_longlong_t)n);
./lib/libzpool/util.c:56:		(void) sprintf(buf, "%.2f%c",
./lib/libzpool/util.c:59:		(void) sprintf(buf, "%.1f%c",
./lib/libzpool/util.c:62:		(void) sprintf(buf, "%llu%c", (u_longlong_t)n, u);
./lib/libzpool/util.c:128:		tname = calloc(1, strlen(cname) + 2);
./lib/libzpool/util.c:129:		(void) strcpy(tname, cname);
./lib/libzpool/taskq.c:59:task_alloc(taskq_t *tq, int tqflags)
./lib/libzpool/taskq.c:91:		t = kmem_alloc(sizeof (taskq_ent_t), tqflags);
./lib/libzpool/taskq.c:132:	if ((t = task_alloc(tq, tqflags)) == NULL) {
./lib/libzpool/taskq.c:299:	tq->tq_threadlist = kmem_alloc(nthreads * sizeof (kthread_t *),
./lib/libzpool/taskq.c:305:			task_free(tq, task_alloc(tq, KM_SLEEP));
./lib/libzpool/taskq.c:334:		task_free(tq, task_alloc(tq, KM_SLEEP));
./lib/libnvpair/nvpair_alloc_system.c:35:	return (kmem_alloc(size, (int)(uintptr_t)nva->nva_arg));
./lib/libnvpair/nvpair_alloc_system.c:48:	nv_alloc_sys,		/* nv_ao_alloc() */
./lib/libnvpair/libnvpair.c:526:nvlist_prtctl_alloc(void)
./lib/libnvpair/libnvpair.c:531:	if ((pctl = malloc(sizeof (*pctl))) == NULL)
./lib/libnvpair/libnvpair.c:534:	if ((ops = calloc(1, sizeof (*ops))) == NULL) {
./lib/libspl/strlcat.c:53:	(void) memcpy(dst + l1, src, copied);
./lib/libspl/strlcpy.c:49:	(void) memcpy(dst, src, copied);
./lib/libspl/mkdirp.c:169:	if ((wcPath = calloc(sizeof (wchar_t), mbPathlen+1)) == NULL) {
./lib/libspl/include/sys/kmem.h:38:#define	kmem_alloc(size, flags)		malloc(size)
./lib/libspl/include/umem.h:83:umem_alloc(size_t size, int flags)
./lib/libspl/include/umem.h:88:		ptr = malloc(size);
./lib/libspl/include/umem.h:120:	ptr = umem_alloc(size, flags);
./lib/libspl/include/umem.h:146:	cp = umem_alloc(sizeof (umem_cache_t), UMEM_DEFAULT);
./lib/libspl/include/umem.h:169:umem_cache_alloc(umem_cache_t *cp, int flags)
./lib/libspl/include/umem.h:177:		ptr = umem_alloc(cp->cache_bufsize, flags);
./lib/libuutil/uu_alloc.c:35:	void *p = malloc(n);
./lib/libuutil/uu_alloc.c:64:			(void) memcpy(buf, str, sz);
./lib/libuutil/uu_alloc.c:85:		(void) memcpy(p, s, len);
./lib/libuutil/uu_alloc.c:103:	(void) memcpy(p, buf, sz);
./lib/libuutil/uu_alloc.c:108:uu_msprintf(const char *format, ...)
./lib/libzfs_core/libzfs_core.c:139:		    malloc(zc.zc_nvlist_dst_size);
./lib/libzfs_core/libzfs_core.c:151:			    malloc(zc.zc_nvlist_dst_size);
./lib/libzfs_core/libzfs_core.c:176:	nvlist_t *args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:190:	nvlist_t *args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:231:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:281:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:309:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:376:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:435:	nvlist_t *innvl = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:474:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:509:	args = fnvlist_alloc();
./lib/libzfs_core/libzfs_core.c:639:	args = fnvlist_alloc();
./lib/libzfs/libzfs_util.c:523: * A safe form of malloc() which will die if the allocation fails.
./lib/libzfs/libzfs_util.c:526:zfs_alloc(libzfs_handle_t *hdl, size_t size)
./lib/libzfs/libzfs_util.c:530:	if ((data = calloc(1, size)) == NULL)
./lib/libzfs/libzfs_util.c:537: * A safe form of asprintf() which will die if the allocation fails.
./lib/libzfs/libzfs_util.c:541:zfs_asprintf(libzfs_handle_t *hdl, const char *fmt, ...)
./lib/libzfs/libzfs_util.c:549:	err = vasprintf(&ret, fmt, ap);
./lib/libzfs/libzfs_util.c:646:	memcpy(path, path_prefix, sizeof (path_prefix) - 1);
./lib/libzfs/libzfs_util.c:647:	strcpy(path + sizeof (path_prefix) - 1, module);
./lib/libzfs/libzfs_util.c:771:	if ((hdl = calloc(1, sizeof (libzfs_handle_t))) == NULL) {
./lib/libzfs/libzfs_util.c:1068:	    zfs_alloc(hdl, zc->zc_nvlist_dst_size)) == 0)
./lib/libzfs/libzfs_util.c:1084:	    zfs_alloc(hdl, zc->zc_nvlist_dst_size)) == 0)
./lib/libzfs/libzfs_util.c:1110:	if ((packed = zfs_alloc(hdl, len)) == NULL)
./lib/libzfs/libzfs_util.c:1639:	if ((entry = zfs_alloc(hdl, sizeof (zprop_list_t))) == NULL)
./lib/libzfs/libzfs_util.c:1772:	if ((entry = zfs_alloc(edp->hdl, sizeof (zprop_list_t))) == NULL)
./lib/libzfs/libzfs_util.c:1812:		if ((entry = zfs_alloc(hdl, sizeof (zprop_list_t))) == NULL)
./lib/libzfs/libzfs_sendrecv.c:146:	if ((dde = umem_cache_alloc(ddt->ddecache, UMEM_DEFAULT))
./lib/libzfs/libzfs_sendrecv.c:217:	char *buf = zfs_alloc(dda->dedup_hdl, SPA_MAXBLOCKSIZE);
./lib/libzfs/libzfs_sendrecv.c:248:	ddt.dedup_hash_array = calloc(numbuckets, sizeof (dedup_entry_t *));
./lib/libzfs/libzfs_sendrecv.c:529:	if ((fsavl = malloc(sizeof (avl_tree_t))) == NULL)
./lib/libzfs/libzfs_sendrecv.c:548:			if ((fn = malloc(sizeof (fsavl_node_t))) == NULL) {
./lib/libzfs/libzfs_sendrecv.c:650:	VERIFY(0 == nvlist_alloc(&nv, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:746:	VERIFY(0 == nvlist_alloc(&nvfs, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:761:	VERIFY(0 == nvlist_alloc(&nv, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:768:	VERIFY(0 == nvlist_alloc(&sd->parent_snaps, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:769:	VERIFY(0 == nvlist_alloc(&sd->snapprops, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:804:	VERIFY(0 == nvlist_alloc(&sd.fss, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:935:	VERIFY(0 == nvlist_alloc(&thisdbg, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:1076:		(void) strcpy(sdd->prevsnap, thissnap);
./lib/libzfs/libzfs_sendrecv.c:1200:	(void) strcpy(sdd->prevsnap, thissnap);
./lib/libzfs/libzfs_sendrecv.c:1456:			VERIFY(0 == nvlist_alloc(&hdrnv, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:1566:		sdd.snapholds = fnvlist_alloc();
./lib/libzfs/libzfs_sendrecv.c:1768:	buf = zfs_alloc(hdl, len);
./lib/libzfs/libzfs_sendrecv.c:1814:		(void) strcpy(newname, tryname);
./lib/libzfs/libzfs_sendrecv.c:1934:		(void) strcpy(gtnd->name, zhp->zfs_name);
./lib/libzfs/libzfs_sendrecv.c:2075:	VERIFY(0 == nvlist_alloc(&deleted, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:2191:				sprintf(guidname, "%llu",
./lib/libzfs/libzfs_sendrecv.c:2249:			sprintf(guidname, "%llu",
./lib/libzfs/libzfs_sendrecv.c:2283:			sprintf(guidname, "%llu",
./lib/libzfs/libzfs_sendrecv.c:2479:				VERIFY(0 == nvlist_alloc(&renamed,
./lib/libzfs/libzfs_sendrecv.c:2576:	void *buf = zfs_alloc(hdl, SPA_MAXBLOCKSIZE);
./lib/libzfs/libzfs_sendrecv.c:2702:			VERIFY(0 == nvlist_alloc(&props, NV_UNIQUE_NAME, 0));
./lib/libzfs/libzfs_sendrecv.c:2744:			cp = malloc(len + 2);
./lib/libzfs/libzfs_sendrecv.c:2746:			(void) strcpy(&cp[1], drrb->drr_toname);
./lib/libzfs/libzfs_sendrecv.c:2792:	(void) strcpy(zc.zc_value, tosnap);
./lib/libzfs/libzfs_sendrecv.c:2827:		(void) strcpy(zc.zc_name, zc.zc_value);
./lib/libzfs/libzfs_sendrecv.c:2834:			(void) strcpy(suffix, strrchr(zc.zc_value, '/'));
./lib/libzfs/libzfs_sendrecv.c:2849:		(void) strcpy(zc.zc_name, zc.zc_value);
./lib/libzfs/libzfs_sendrecv.c:2861:			(void) strcpy(snap, strchr(zc.zc_value, '@'));
./lib/libzfs/libzfs_sendrecv.c:2870:	(void) strcpy(zc.zc_name, zc.zc_value);
./lib/libzfs/libzfs_sendrecv.c:3030:		(void) strcpy(zc2.zc_name, zc.zc_value);
./lib/libzfs/libzfs_dataset.c:204:	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_dataset.c:264:	pool_name = zfs_alloc(zhp->zfs_hdl, len);
./lib/libzfs/libzfs_dataset.c:445:	zfs_handle_t *zhp = calloc(sizeof (zfs_handle_t), 1);
./lib/libzfs/libzfs_dataset.c:472:	zfs_handle_t *zhp = calloc(sizeof (zfs_handle_t), 1);
./lib/libzfs/libzfs_dataset.c:489:	zfs_handle_t *zhp = calloc(sizeof (zfs_handle_t), 1);
./lib/libzfs/libzfs_dataset.c:506:	zfs_handle_t *zhp = calloc(sizeof (zfs_handle_t), 1);
./lib/libzfs/libzfs_dataset.c:569:	props = fnvlist_alloc();
./lib/libzfs/libzfs_dataset.c:586:	zfs_handle_t *zhp = calloc(sizeof (zfs_handle_t), 1);
./lib/libzfs/libzfs_dataset.c:713:		mtn = zfs_alloc(hdl, sizeof (mnttab_node_t));
./lib/libzfs/libzfs_dataset.c:804:	mtn = zfs_alloc(hdl, sizeof (mnttab_node_t));
./lib/libzfs/libzfs_dataset.c:878:	if (nvlist_alloc(&ret, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_dataset.c:1099:			if (((new_sl = m_label_alloc(MAC_LABEL)) == NULL) ||
./lib/libzfs/libzfs_dataset.c:1540:	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0 ||
./lib/libzfs/libzfs_dataset.c:1605:			if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_dataset.c:2161:		if (nvlist_alloc(&nv, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_dataset.c:2163:		if (nvlist_alloc(&value, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_dataset.c:3273:		nvlist_t *nv = fnvlist_alloc();
./lib/libzfs/libzfs_dataset.c:3339:	verify(nvlist_alloc(&dd.nvl, NV_UNIQUE_NAME, 0) == 0);
./lib/libzfs/libzfs_dataset.c:3645:	verify(nvlist_alloc(&sd.sd_nvl, NV_UNIQUE_NAME, 0) == 0);
./lib/libzfs/libzfs_dataset.c:4040:				if ((entry = zfs_alloc(hdl,
./lib/libzfs/libzfs_dataset.c:4137:		if (nvlist_alloc(&nvlist, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_dataset.c:4281:	ha.nvl = fnvlist_alloc();
./lib/libzfs/libzfs_dataset.c:4390:		nvlist_t *torelease = fnvlist_alloc();
./lib/libzfs/libzfs_dataset.c:4413:	ha.nvl = fnvlist_alloc();
./lib/libzfs/libzfs_dataset.c:4498:	nvbuf = malloc(nvsz);
./lib/libzfs/libzfs_dataset.c:4566:	nvbuf = malloc(nvsz);
./lib/libzfs/libzfs_config.c:184:		if ((cn = zfs_alloc(hdl, sizeof (config_node_t))) == NULL) {
./lib/libzfs/libzfs_config.c:270:	(void) strcpy(zc.zc_name, zhp->zpool_name);
./lib/libzfs/libzfs_import.c:236:		if ((ne = zfs_alloc(hdl, sizeof (name_entry_t))) == NULL)
./lib/libzfs/libzfs_import.c:281:		if ((pe = zfs_alloc(hdl, sizeof (pool_entry_t))) == NULL) {
./lib/libzfs/libzfs_import.c:300:		if ((ve = zfs_alloc(hdl, sizeof (vdev_entry_t))) == NULL) {
./lib/libzfs/libzfs_import.c:320:		if ((ce = zfs_alloc(hdl, sizeof (config_entry_t))) == NULL) {
./lib/libzfs/libzfs_import.c:338:	if ((ne = zfs_alloc(hdl, sizeof (name_entry_t))) == NULL)
./lib/libzfs/libzfs_import.c:467:	if (nvlist_alloc(&ret, 0, 0) != 0)
./lib/libzfs/libzfs_import.c:473:		if (nvlist_alloc(&config, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_import.c:599:				newchild = zfs_alloc(hdl, (id + 1) *
./lib/libzfs/libzfs_import.c:631:				newchild = zfs_alloc(hdl, (max_id) *
./lib/libzfs/libzfs_import.c:663:				if (nvlist_alloc(&holey, NV_UNIQUE_NAME,
./lib/libzfs/libzfs_import.c:694:				if (nvlist_alloc(&missing, NV_UNIQUE_NAME,
./lib/libzfs/libzfs_import.c:714:		if (nvlist_alloc(&nvroot, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_import.c:882:	if ((label = malloc(sizeof (vdev_label_t))) == NULL)
./lib/libzfs/libzfs_import.c:953:	if ((label = calloc(sizeof (vdev_label_t), 1)) == NULL)
./lib/libzfs/libzfs_import.c:1312:	if ((buf = zfs_alloc(hdl, statbuf.st_size)) == NULL) {
./lib/libzfs/libzfs_import.c:1342:	if (nvlist_alloc(&pools, 0, 0) != 0) {
./lib/libzfs/libzfs_status.c:410:		(void) strcpy(refcnt, "Total");
./lib/libzfs/libzfs_iter.c:190:	props = fnvlist_alloc();
./lib/libzfs/libzfs_iter.c:254:	node = zfs_alloc(zhp->zfs_hdl, sizeof (zfs_node_t));
./lib/libzfs/libzfs_diff.c:105:	(void) memcpy(sb, &zc.zc_stat, sizeof (zfs_stat_t));
./lib/libzfs/libzfs_diff.c:535:	di->tosnap = zfs_asprintf(hdl, "%s@%s", di->ds, di->tmpsnap);
./lib/libzfs/libzfs_diff.c:618:		di->ds = zfs_alloc(di->zhp->zfs_hdl, tdslen + 1);
./lib/libzfs/libzfs_diff.c:656:		di->ds = zfs_alloc(hdl, dslen + 1);
./lib/libzfs/libzfs_diff.c:660:		di->fromsnap = zfs_asprintf(hdl, "%s%s", di->ds, atptrf);
./lib/libzfs/libzfs_diff.c:662:			di->tosnap = zfs_asprintf(hdl, "%s%s", di->ds, atptrt);
./lib/libzfs/libzfs_diff.c:703:	di->tomnt = zfs_asprintf(di->zhp->zfs_hdl, "%s%s%s", di->dsmnt,
./lib/libzfs/libzfs_diff.c:722:	di->frommnt = zfs_asprintf(di->zhp->zfs_hdl, "%s%s%s", frommntpt,
./lib/libzfs/libzfs_mount.c:1115:	if ((good = zfs_alloc(zhp->zpool_hdl,
./lib/libzfs/libzfs_mount.c:1209:				if ((mountpoints = zfs_alloc(hdl,
./lib/libzfs/libzfs_mount.c:1213:				if ((datasets = zfs_alloc(hdl,
./lib/libzfs/libzfs_pool.c:470:	if (nvlist_alloc(&retprops, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_pool.c:749:	if (nvlist_alloc(&nvl, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_pool.c:814:			zprop_list_t *entry = zfs_alloc(hdl,
./lib/libzfs/libzfs_pool.c:817:			entry->pl_user_prop = zfs_asprintf(hdl, "feature@%s",
./lib/libzfs/libzfs_pool.c:837:		propname = zfs_asprintf(hdl, "unsupported@%s",
./lib/libzfs/libzfs_pool.c:859:		entry = zfs_alloc(hdl, sizeof (zprop_list_t));
./lib/libzfs/libzfs_pool.c:933:				(void) strcpy(buf, ZFS_UNSUPPORTED_INACTIVE);
./lib/libzfs/libzfs_pool.c:935:				(void) strcpy(buf, ZFS_UNSUPPORTED_READONLY);
./lib/libzfs/libzfs_pool.c:1068:	if ((zhp = zfs_alloc(hdl, sizeof (zpool_handle_t))) == NULL)
./lib/libzfs/libzfs_pool.c:1100:	if ((zhp = zfs_alloc(hdl, sizeof (zpool_handle_t))) == NULL)
./lib/libzfs/libzfs_pool.c:1223:		    (nvlist_alloc(&zc_props, NV_UNIQUE_NAME, 0) != 0)) {
./lib/libzfs/libzfs_pool.c:1658:		if (nvlist_alloc(&props, NV_UNIQUE_NAME, 0) != 0) {
./lib/libzfs/libzfs_pool.c:2160:	verify(nvlist_alloc(&search, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./lib/libzfs/libzfs_pool.c:2196:	verify(nvlist_alloc(&search, NV_UNIQUE_NAME, KM_SLEEP) == 0);
./lib/libzfs/libzfs_pool.c:2952:	varray = zfs_alloc(hdl, children * sizeof (nvlist_t *));
./lib/libzfs/libzfs_pool.c:2979:			if (nvlist_alloc(&vdev, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_pool.c:3031:		if (nvlist_alloc(newroot, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_pool.c:3056:	if (nvlist_alloc(&newconfig, NV_UNIQUE_NAME, 0) != 0)
./lib/libzfs/libzfs_pool.c:3558:	if ((zc.zc_nvlist_dst = (uintptr_t)zfs_alloc(zhp->zpool_hdl,
./lib/libzfs/libzfs_pool.c:3562:	(void) strcpy(zc.zc_name, zhp->zpool_name);
./lib/libzfs/libzfs_pool.c:3571:				dst = zfs_alloc(zhp->zpool_hdl, count *
./lib/libzfs/libzfs_pool.c:3597:	verify(nvlist_alloc(nverrlistp, 0, KM_SLEEP) == 0);
./lib/libzfs/libzfs_pool.c:3610:		if (nvlist_alloc(&nv, NV_UNIQUE_NAME, KM_SLEEP) != 0)
./lib/libzfs/libzfs_pool.c:3646:	(void) strcpy(zc.zc_name, zhp->zpool_name);
./lib/libzfs/libzfs_pool.c:3675:	args = fnvlist_alloc();
./lib/libzfs/libzfs_pool.c:3788:	buf = malloc(buflen);
./lib/libzfs/libzfs_pool.c:3813:			buf = malloc(buflen);
./lib/libzfs/libzfs_pool.c:3824:		verify(nvlist_alloc(nvhisp, NV_UNIQUE_NAME, 0) == 0);
./lib/libzfs/libzfs_pool.c:4213:	(void) strcpy(vtoc->efi_parts[0].p_name, "zfs");
./lib/libzfs/libzfs_graph.c:137:	zfs_edge_t *zep = zfs_alloc(hdl, sizeof (zfs_edge_t));
./lib/libzfs/libzfs_graph.c:162:	zfs_vertex_t *zvp = zfs_alloc(hdl, sizeof (zfs_vertex_t));
./lib/libzfs/libzfs_graph.c:171:	if ((zvp->zv_edges = zfs_alloc(hdl,
./lib/libzfs/libzfs_graph.c:260:	zfs_graph_t *zgp = zfs_alloc(hdl, sizeof (zfs_graph_t));
./lib/libzfs/libzfs_graph.c:266:	if ((zgp->zg_hash = zfs_alloc(hdl,
./lib/libzfs/libzfs_graph.c:523:		char *pool = zfs_alloc(hdl, len);
./lib/libzfs/libzfs_graph.c:593:	if ((result[*idx] = zfs_alloc(hdl,
./lib/libzfs/libzfs_graph.c:597:	(void) strcpy(result[*idx], zgv->zv_dataset);
./lib/libzfs/libzfs_graph.c:623:	if ((*result = zfs_alloc(hdl,
./lib/libzfs/libzfs_fru.c:163:	if ((frup = calloc(sizeof (libzfs_fru_t), 1)) == NULL) {
./lib/libzfs/libzfs_fru.c:287:	    calloc(ZFS_FRU_HASH_SIZE * sizeof (void *), 1)) == NULL)
./lib/libzfs/libzfs_changelist.c:438:		if ((cn = zfs_alloc(zfs_get_handle(zhp),
./lib/libzfs/libzfs_changelist.c:540:	if ((clp = zfs_alloc(zhp->zfs_hdl, sizeof (prop_changelist_t))) == NULL)
./lib/libzfs/libzfs_changelist.c:650:	if ((cn = zfs_alloc(zhp->zfs_hdl,
./lib/libefi/rdwr_efi.c:158:	path = calloc(PATH_MAX, 1);
./lib/libefi/rdwr_efi.c:175:	(void) sprintf(path, "/proc/self/fd/%d", fd);
./lib/libefi/rdwr_efi.c:183:		strcpy(dki_info->dki_cname, "sd");
./lib/libefi/rdwr_efi.c:189:		strcpy(dki_info->dki_cname, "hd");
./lib/libefi/rdwr_efi.c:195:		strcpy(dki_info->dki_cname, "pseudo");
./lib/libefi/rdwr_efi.c:197:		strcpy(dki_info->dki_dname, "md");
./lib/libefi/rdwr_efi.c:202:		strcpy(dki_info->dki_cname, "vd");
./lib/libefi/rdwr_efi.c:208:		strcpy(dki_info->dki_cname, "xvd");
./lib/libefi/rdwr_efi.c:214:		strcpy(dki_info->dki_cname, "zd");
./lib/libefi/rdwr_efi.c:220:		strcpy(dki_info->dki_cname, "pseudo");
./lib/libefi/rdwr_efi.c:222:		strcpy(dki_info->dki_dname, "dm-");
./lib/libefi/rdwr_efi.c:227:		strcpy(dki_info->dki_cname, "pseudo");
./lib/libefi/rdwr_efi.c:229:		strcpy(dki_info->dki_dname, "ram");
./lib/libefi/rdwr_efi.c:234:		strcpy(dki_info->dki_cname, "pseudo");
./lib/libefi/rdwr_efi.c:236:		strcpy(dki_info->dki_dname, "loop");
./lib/libefi/rdwr_efi.c:241:		strcpy(dki_info->dki_dname, "unknown");
./lib/libefi/rdwr_efi.c:242:		strcpy(dki_info->dki_cname, "unknown");
./lib/libefi/rdwr_efi.c:329:	if ((*vtoc = calloc(length, 1)) == NULL)
./lib/libefi/rdwr_efi.c:366:	if ((*vtoc = calloc(length, 1)) == NULL)
./lib/libefi/rdwr_efi.c:876:		(void) memcpy(&mb, buf, sizeof (mb));
./lib/libefi/rdwr_efi.c:880:		(void) memcpy(&mb, buf, sizeof (mb));
./lib/libefi/rdwr_efi.c:920:	(void) memcpy(buf, &mb, sizeof (mb));
./lib/libshare/smb.c:150:						malloc(sizeof (smb_share_t));
./lib/libshare/libshare.c:64:	fstype = calloc(sizeof (sa_fstype_t), 1);
./lib/libshare/libshare.c:86:	impl_handle = calloc(sizeof (struct sa_handle_impl), 1);
./lib/libshare/libshare.c:738:	impl_share = calloc(sizeof (struct sa_share_impl), 1);
./lib/libshare/libshare.c:750:	impl_share->fsinfo = calloc(sizeof (sa_share_fsinfo_t), fstypes_count);
./lib/libshare/nfs.c:245:	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
./lib/libshare/nfs.c:253:	sprintf(hostpath, "%s:%s", linuxhost, sharepath);
./lib/libshare/nfs.c:260:	opts = malloc(4 + strlen(security) + 4 + strlen(linux_opts) + 1);
./lib/libshare/nfs.c:265:	sprintf(opts, "sec=%s,%s,%s", security, access, linux_opts);
./lib/libshare/nfs.c:450:	hostpath = malloc(strlen(linuxhost) + 1 + strlen(sharepath) + 1);
./lib/libshare/nfs.c:457:	sprintf(hostpath, "%s:%s", linuxhost, sharepath);

== files() ==
./module/zpios/pios.c:927:zpios_open(struct inode *inode, struct file *file)
./module/unicode/u8_textprep.c:32: * Man pages: u8_textprep_open(9F), u8_textprep_buf(9F), u8_textprep_close(9F),
./module/zfs/dsl_dataset.c:428:		dsl_deadlist_open(&ds->ds_deadlist,
./module/zfs/dsl_dataset.c:1329:	dsl_deadlist_open(&ds->ds_deadlist, mos,
./module/zfs/dsl_dataset.c:1403:	error = spa_open(firstname, &spa, FTAG);
./module/zfs/dsl_dataset.c:1540:	error = spa_open(fsname, &spa, FTAG);
./module/zfs/dsl_dataset.c:2824:	dsl_deadlist_open(&clone->ds_deadlist, dp->dp_meta_objset,
./module/zfs/dsl_dataset.c:2826:	dsl_deadlist_open(&origin_head->ds_deadlist, dp->dp_meta_objset,
./module/zfs/dsl_userhold.c:196:	error = spa_open(ca->zhca_spaname, &spa, FTAG);
./module/zfs/vdev_root.c:57:vdev_root_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,
./module/zfs/zfs_ioctl.c:301:	if (spa_open(name, &spa, FTAG) == 0) {
./module/zfs/zfs_ioctl.c:344:	if (spa_open(zc->zc_name, &spa, FTAG) == 0) {
./module/zfs/zfs_ioctl.c:1651:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1670:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:1684:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1710:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1737:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:1815:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:1841:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:1856:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1899:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1918:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1935:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:1970:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:1987:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:2806:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0) {
./module/zfs/zfs_ioctl.c:2826:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0) {
./module/zfs/zfs_ioctl.c:3051:	if ((error = spa_open(dataset, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:3337:	error = spa_open(poolname, &spa, FTAG);
./module/zfs/zfs_ioctl.c:3743:				if ((err = spa_open(dsname, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:3803:			if ((err = spa_open(dsname, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:4372:	if ((error = spa_open(zc->zc_name, &spa, FTAG)) != 0)
./module/zfs/zfs_ioctl.c:4411:		error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:4466:zfs_ioc_pool_reopen(zfs_cmd_t *zc)
./module/zfs/zfs_ioctl.c:4471:	error = spa_open(zc->zc_name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:4481:	 * vdev_open() decided if a resilver is required.
./module/zfs/zfs_ioctl.c:4484:	vdev_reopen(spa->spa_root_vdev);
./module/zfs/zfs_ioctl.c:5590:	error = spa_open(name, &spa, FTAG);
./module/zfs/zfs_ioctl.c:5756:zfsdev_open(struct inode *ino, struct file *filp)
./module/zfs/zfs_ioctl.c:5888:		    spa_open(zc->zc_name, &spa, FTAG) == 0) {
./module/zfs/dmu_objset.c:456:	dnode_special_open(os, &os->os_phys->os_meta_dnode,
./module/zfs/dmu_objset.c:459:		dnode_special_open(os, &os->os_phys->os_userused_dnode,
./module/zfs/dmu_objset.c:461:		dnode_special_open(os, &os->os_phys->os_groupused_dnode,
./module/zfs/dmu_objset.c:1976:	error = spa_open(name, &spa, FTAG);
./module/zfs/zpl_ctldir.c:41:zpl_common_open(struct inode *ip, struct file *filp)
./module/zfs/zpl_ctldir.c:46:	return (generic_file_open(ip, filp));
./module/zfs/vdev_raidz.c:1475:vdev_raidz_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,
./module/zfs/metaslab.c:1262:		error = space_map_open(&ms->ms_sm, mos, object, ms->ms_start,
./module/zfs/metaslab.c:1872:		VERIFY0(space_map_open(&msp->ms_sm, mos, new_object,
./module/zfs/bpobj.c:102:	VERIFY3U(0, ==, bpobj_open(&bpo, os, obj));
./module/zfs/bpobj.c:146:bpobj_open(bpobj_t *bpo, objset_t *os, uint64_t object)
./module/zfs/bpobj.c:297:		err = bpobj_open(&sublist, bpo->bpo_os, objarray[blkoff]);
./module/zfs/bpobj.c:388:	VERIFY3U(0, ==, bpobj_open(&subbpo, bpo->bpo_os, subobj));
./module/zfs/vdev_file.c:52:vdev_file_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
./module/zfs/txg.c:294:txg_hold_open(dsl_pool_t *dp, txg_handle_t *th)
./module/zfs/txg.c:690:txg_wait_open(dsl_pool_t *dp, uint64_t txg)
./module/zfs/zfs_vnops.c:125: *	Thread A calls dmu_tx_assign(TXG_WAIT) and blocks in txg_wait_open()
./module/zfs/zfs_vnops.c:196:zfs_open(struct inode *ip, int mode, int flag, cred_t *cr)
./module/zfs/dsl_deadlist.c:88:		VERIFY3U(0, ==, bpobj_open(&dle->dle_bpobj, dl->dl_os,
./module/zfs/dsl_deadlist.c:97:dsl_deadlist_open(dsl_deadlist_t *dl, objset_t *os, uint64_t object)
./module/zfs/dsl_deadlist.c:110:		VERIFY3U(0, ==, bpobj_open(&dl->dl_bpobj, os, object));
./module/zfs/dsl_deadlist.c:191:		VERIFY3U(0, ==, bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));
./module/zfs/dsl_deadlist.c:208:		VERIFY3U(0, ==, bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));
./module/zfs/dsl_deadlist.c:263:	VERIFY3U(0, ==, bpobj_open(&dle->dle_bpobj, dl->dl_os, obj));
./module/zfs/dsl_deadlist.c:307:	dsl_deadlist_open(&dl, os, dlobj);
./module/zfs/dsl_deadlist.c:428:	VERIFY3U(0, ==, bpobj_open(&bpo, dl->dl_os, obj));
./module/zfs/dsl_deadlist.c:472:		VERIFY3U(0, ==, bpobj_open(&bpo, dl->dl_os, obj));
./module/zfs/zio_inject.c:226:	 * device open (i.e. zio == NULL).
./module/zfs/zpl_xattr.c:26: * can be accessed using the attropen() system call which opens
./module/zfs/zpl_xattr.c:928:			ip->i_mode &= ~current_umask();
./module/zfs/vdev_missing.c:47:vdev_missing_open(vdev_t *vd, uint64_t *psize, uint64_t *max_psize,
./module/zfs/dsl_pool.c:196:dsl_pool_open(dsl_pool_t *dp)
./module/zfs/dsl_pool.c:246:		VERIFY0(bpobj_open(&dp->dp_free_bpobj,
./module/zfs/dsl_pool.c:292:	 * Drop our references from dsl_pool_open().
./module/zfs/dsl_pool.c:311:	/* undo the dmu_objset_open_impl(mos) from dsl_pool_open() */
./module/zfs/dsl_pool.c:385:		VERIFY0(bpobj_open(&dp->dp_free_bpobj,
./module/zfs/dsl_pool.c:817:	VERIFY0(bpobj_open(&dp->dp_free_bpobj, dp->dp_meta_objset, obj));
./module/zfs/dsl_pool.c:1019:	error = spa_open(name, &spa, tag);
./module/zfs/dnode.c:1008:dnode_special_open(objset_t *os, dnode_phys_t *dnp, uint64_t object,
./module/zfs/spa_config.c:184:	error = vn_open(dp->scd_path, UIO_SYSSPACE, oflags, 0644, &vp, 0, 0);
./module/zfs/spa_config.c:204:	if (vn_open(temp, UIO_SYSSPACE, oflags, 0644, &vp, CRCREAT, 0) == 0) {
./module/zfs/vdev.c:1109:	vd->vdev_open_error = vdev_open(vd);
./module/zfs/vdev.c:1148:			    vdev_open(vd->vdev_child[c]);
./module/zfs/vdev.c:1170:vdev_open(vdev_t *vd)
./module/zfs/vdev.c:1208:	error = vd->vdev_ops->vdev_op_open(vd, &osize, &max_osize, &ashift);
./module/zfs/vdev.c:1520:	 * doing a reopen(), we don't generate FMA ereports if we notice that
./module/zfs/vdev.c:1569:vdev_reopen(vdev_t *vd)
./module/zfs/vdev.c:1578:	(void) vdev_open(vd);
./module/zfs/vdev.c:1583:	 * opened in response to vdev_reopen().
./module/zfs/vdev.c:1611:	error = vdev_open(vd);
./module/zfs/vdev.c:1949:		error = space_map_open(&vd->vdev_dtl_sm, mos,
./module/zfs/vdev.c:2011:		VERIFY0(space_map_open(&vd->vdev_dtl_sm, mos, new_object,
./module/zfs/vdev.c:2330:	 * vdev_reopen(), we need this value to be present to remember why we
./module/zfs/vdev.c:2355:		vdev_reopen(tvd);
./module/zfs/vdev.c:2429:	vdev_reopen(tvd);
./module/zfs/vdev.c:2527:		vdev_reopen(tvd);
./module/zfs/vdev.c:2532:			vdev_reopen(tvd);
./module/zfs/vdev.c:2604:		vdev_reopen(vd == rvd ? rvd : vd->vdev_top);
./module/zfs/vdev.c:3219:		 * that this is part of a vdev_reopen().  In this case, we don't
./module/zfs/zfs_vfsops.c:863:	zsb->z_log = zil_open(zsb->z_os, zfs_get_data);
./module/zfs/zpl_file.c:35:zpl_open(struct inode *ip, struct file *filp)
./module/zfs/zpl_file.c:41:	error = generic_file_open(ip, filp);
./module/zfs/zpl_file.c:47:	error = -zfs_open(ip, filp->f_mode, filp->f_flags, cr);
./module/zfs/vdev_disk.c:190: *  - Because vdev_disk_open() initially needs to find the device
./module/zfs/vdev_disk.c:191: *    using its path, multiple vdev_disk_open() invocations in
./module/zfs/vdev_disk.c:209:	bdev = vdev_bdev_open(path, vdev_bdev_mode(mode), zfs_vdev_holder);
./module/zfs/vdev_disk.c:242:vdev_disk_open(vdev_t *v, uint64_t *psize, uint64_t *max_psize,
./module/zfs/vdev_disk.c:287:		bdev = vdev_bdev_open(v->vdev_path,
./module/zfs/vdev_disk.c:301:	/* Clear the nowritecache bit, causes vdev_reopen() to try again. */
./module/zfs/vdev_disk.c:798:	bdev = vdev_bdev_open(devpath, vdev_bdev_mode(FREAD), zfs_vdev_holder);
./module/zfs/dsl_destroy.c:199:	dsl_deadlist_open(&ds->ds_deadlist, mos,
./module/zfs/dsl_destroy.c:201:	dsl_deadlist_open(&ds_next->ds_deadlist, mos,
./module/zfs/dsl_destroy.c:916:	error = spa_open(name, &spa, FTAG);
./module/zfs/dsl_synctask.c:76:	err = spa_open(pool, &spa, FTAG);
./module/zfs/zap_micro.c:364:mzap_open(objset_t *os, uint64_t obj, dmu_buf_t *db)
./module/zfs/zap_micro.c:472:		zap = mzap_open(os, obj, db);
./module/zfs/zvol.c:390:		if ((error = spa_open(name, &spa, FTAG)) != 0)
./module/zfs/zvol.c:873:zvol_first_open(zvol_state_t *zv)
./module/zfs/zvol.c:884:	 * function calls fops->open() with the bdev->bd_mutex lock held.
./module/zfs/zvol.c:894:	 * bdev->bd_mutex being dropped, reacquired, and fops->open() being
./module/zfs/zvol.c:928:	zv->zv_zilog = zil_open(os, zvol_get_data);
./module/zfs/zvol.c:968:zvol_open(struct block_device *bdev, fmode_t flag)
./module/zfs/zvol.c:987:		error = zvol_first_open(zv);
./module/zfs/zvol.c:1153:	return (zvol_open(inode->i_bdev, file->f_mode));
./module/zfs/dmu_tx.c:1131:	tx->tx_txg = txg_hold_open(tx->tx_pool, &tx->tx_txgh);
./module/zfs/dmu_tx.c:1354:		txg_wait_open(tx->tx_pool, tx->tx_lasttried_txg + 1);
./module/zfs/spa_misc.c:1236:	 * It's OK to call spa_open() with the namespace lock held because we
./module/zfs/spa_misc.c:1240:	if ((err = spa_open(name, &spa, FTAG)) != 0) {
./module/zfs/spa.c:1445:		if (vdev_open(vd) != 0)
./module/zfs/spa.c:1545:			if (vdev_open(vd) != 0)
./module/zfs/spa.c:1751:			vdev_reopen(rvd);
./module/zfs/spa.c:1759:			vdev_reopen(tvd);
./module/zfs/spa.c:2045: * we do a reopen() call.  If the vdev label for every disk that was
./module/zfs/spa.c:2092:		vdev_reopen(spa->spa_root_vdev);
./module/zfs/spa.c:2112:		vdev_reopen(spa->spa_root_vdev);
./module/zfs/spa.c:2261:	error = vdev_open(rvd);
./module/zfs/spa.c:2511:	error = dsl_pool_open(spa->spa_dsl_pool);
./module/zfs/spa.c:2567:	error = bpobj_open(&spa->spa_deferred_bpobj, spa->spa_meta_objset, obj);
./module/zfs/spa.c:2992:	 * function because dsl_dir_open() is called during spa_load(), and ends
./module/zfs/spa.c:2993:	 * up calling spa_open() again.  The real fix is to figure out how to
./module/zfs/spa.c:2994:	 * avoid dsl_dir_open() calling this in the first place.
./module/zfs/spa.c:3046:			 * attempted vdev_open().  Return this to the user.
./module/zfs/spa.c:3104:spa_open(const char *name, spa_t **spapp, void *tag)
./module/zfs/spa.c:3459:		if ((error = vdev_open(vd)) == 0 &&
./module/zfs/spa.c:3776:	VERIFY3U(0, ==, bpobj_open(&spa->spa_deferred_bpobj,
./module/zfs/spa.c:4952:		vdev_reopen(tvd);
./module/zfs/spa.c:5158:	vdev_reopen(spa->spa_root_vdev);
./module/zfs/spa.c:5286:	vdev_reopen(spa->spa_root_vdev);
./module/zfs/spa.c:5423:	vdev_reopen(rvd);
./module/zfs/spa.c:5785:		vdev_reopen(vd);	/* vdev_open() does the actual probe */
./module/zfs/vdev_mirror.c:198:vdev_mirror_open(vdev_t *vd, uint64_t *asize, uint64_t *max_asize,
./module/zfs/space_map.c:357:space_map_open(space_map_t **smp, objset_t *os, uint64_t object,
./module/zfs/dsl_scan.c:1864:	 * spa_scrub_reopen flag indicates that vdev_open() should not
./module/zfs/dsl_scan.c:1869:	vdev_reopen(spa->spa_root_vdev);
./module/zfs/zil.c:1882:zil_open(objset_t *os, zil_get_data_t *get_data)
./module/zfs/dsl_prop.c:1062:	VERIFY0(spa_open(dsname, &spa, FTAG));
./cmd/mount_zfs/mount_zfs.c:244:		fd = open(dataset, O_RDONLY);
./cmd/mount_zfs/mount_zfs.c:298:	fd = open(MNTTAB, O_RDWR | O_CREAT, 0644);
./cmd/mount_zfs/mount_zfs.c:492:	if ((zhp = zfs_open(g_zfs, dataset,
./cmd/zpios/zpios_main.c:407:	zpiosctl_fd = open(ZPIOS_DEV, O_RDONLY);
./cmd/zinject/zinject.c:582:	if ((zfs_fd = open(ZFS_DEV, O_RDWR)) < 0) {
./cmd/zinject/zinject.c:967:		if ((zhp = zfs_open(g_zfs, dataset, ZFS_TYPE_DATASET)) == NULL)
./cmd/zinject/translate.c:121:	if ((fp = fopen(MNTTAB, "r")) == NULL) {
./cmd/zinject/translate.c:467:	if ((zhp = zpool_open(g_zfs, pool)) == NULL)
./cmd/zed/zed.c:127:	zed_log_pipe_open();
./cmd/zed/zed.c:186:	devnull = open("/dev/null", O_RDWR);
./cmd/zed/zed.c:220:	zed_log_stderr_open(LOG_NOTICE);
./cmd/zed/zed.c:224:		zed_log_stderr_open(LOG_INFO);
./cmd/zed/zed.c:233:	(void) umask(0);
./cmd/zed/zed.c:243:		zed_log_syslog_open(LOG_DAEMON);
./cmd/zed/zed_event.c:49:	zcp->zevent_fd = open(ZFS_DEV, O_RDWR);
./cmd/zed/zed_exec.c:108:		(void) umask(022);
./cmd/zed/zed_exec.c:109:		fd = open("/dev/null", O_RDWR);
./cmd/zed/zed_log.c:65:zed_log_pipe_open(void)
./cmd/zed/zed_log.c:160:zed_log_stderr_open(int priority)
./cmd/zed/zed_log.c:181:zed_log_syslog_open(int facility)
./cmd/zed/zed_conf.c:482:	mask = umask(0);
./cmd/zed/zed_conf.c:483:	umask(mask | 022);
./cmd/zed/zed_conf.c:484:	zcp->pid_fd = open(zcp->pid_file, (O_RDWR | O_CREAT), filemode);
./cmd/zed/zed_conf.c:485:	umask(mask);
./cmd/zed/zed_conf.c:588:	zcp->state_fd = open(zcp->state_file,
./cmd/zed/zed_log.h:24:void zed_log_pipe_open(void);
./cmd/zed/zed_log.h:32:void zed_log_stderr_open(int priority);
./cmd/zed/zed_log.h:36:void zed_log_syslog_open(int facility);
./cmd/zvol_id/zvol_id_main.c:78:	fd = open(dev_name, O_RDONLY);
./cmd/zfs/zfs_main.c:585:	zhp = zfs_open(hdl, dataset, type);
./cmd/zfs/zfs_main.c:683:	if ((zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_SNAPSHOT)) == NULL)
./cmd/zfs/zfs_main.c:839:		zpool_handle = zpool_open(g_zfs, argv[0]);
./cmd/zfs/zfs_main.c:1169:		zfs_handle_t *zhp = zfs_open(g_zfs, nvpair_name(pair),
./cmd/zfs/zfs_main.c:1258:		zhp = zfs_open(g_zfs, argv[0],
./cmd/zfs/zfs_main.c:1355:		if ((zhp = zfs_open(g_zfs, argv[0], type)) == NULL)
./cmd/zfs/zfs_main.c:2780:	if ((zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_DATASET)) == NULL)
./cmd/zfs/zfs_main.c:3241:	if ((zhp = zfs_open(g_zfs, argv[0], parents ? ZFS_TYPE_FILESYSTEM |
./cmd/zfs/zfs_main.c:3288:	zhp = zfs_open(g_zfs, argv[1], ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);
./cmd/zfs/zfs_main.c:3431:	if ((snap = zfs_open(g_zfs, argv[0], ZFS_TYPE_SNAPSHOT)) == NULL)
./cmd/zfs/zfs_main.c:3438:	if ((zhp = zfs_open(g_zfs, parentname, ZFS_TYPE_DATASET)) == NULL) {
./cmd/zfs/zfs_main.c:3643:		zhp = zfs_open(g_zfs, argv[0],
./cmd/zfs/zfs_main.c:3771:		zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_DATASET);
./cmd/zfs/zfs_main.c:3801:	zhp = zfs_open(g_zfs, argv[0], ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);
./cmd/zfs/zfs_main.c:5214:	if ((zhp = zfs_open(g_zfs, opts.dataset, ZFS_TYPE_FILESYSTEM |
./cmd/zfs/zfs_main.c:5327:		zhp = zfs_open(g_zfs, parent,
./cmd/zfs/zfs_main.c:5987:		if (freopen(MNTTAB, "r", mnttab_file) == NULL)
./cmd/zfs/zfs_main.c:6008:		if ((zhp = zfs_open(g_zfs, argv[0],
./cmd/zfs/zfs_main.c:6094:	if (freopen(MNTTAB, "r", mnttab_file) == NULL)
./cmd/zfs/zfs_main.c:6122:	if ((zhp = zfs_open(g_zfs, entry.mnt_special,
./cmd/zfs/zfs_main.c:6251:		if (freopen(MNTTAB, "r", mnttab_file) == NULL)
./cmd/zfs/zfs_main.c:6264:			if ((zhp = zfs_open(g_zfs, entry.mnt_special,
./cmd/zfs/zfs_main.c:6371:		if ((zhp = zfs_open(g_zfs, argv[0],
./cmd/zfs/zfs_main.c:6534:	if ((zhp = zfs_open(g_zfs, copy, ZFS_TYPE_FILESYSTEM)) == NULL)
./cmd/zfs/zfs_main.c:6607:	zhp = zfs_open(g_zfs, snapname, ZFS_TYPE_SNAPSHOT);
./cmd/zfs/zfs_iter.c:462:				zhp = zfs_open(g_zfs, argv[i], argtype);
./cmd/zpool/zpool_main.c:77:static int zpool_do_reopen(int, char **);
./cmd/zpool/zpool_main.c:577:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:684:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:733:	if ((fd = open(vdev, O_RDWR)) < 0) {
./cmd/zpool/zpool_main.c:1120:			zfs_handle_t *pool = zfs_open(g_zfs,
./cmd/zpool/zpool_main.c:3405:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:3509:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:3618:	if ((zhp = zpool_open(g_zfs, srcpool)) == NULL)
./cmd/zpool/zpool_main.c:3701:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:3778:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:3912:	if ((zhp = zpool_open(g_zfs, poolname)) == NULL)
./cmd/zpool/zpool_main.c:3928:zpool_do_reopen(int argc, char **argv)
./cmd/zpool/zpool_main.c:3962:	ret = zpool_reopen(zhp);
./cmd/zpool/zpool_main.c:5633:	zevent_fd = open(ZFS_DEV, O_RDWR);
./cmd/zpool/zpool_main.c:5965:		int fd = open(ZFS_DEV, O_RDWR);
./cmd/zpool/zpool_vdev.c:255:	if ((fd = open(path, O_RDONLY|O_DIRECT)) < 0)
./cmd/zpool/zpool_vdev.c:314:	if ((fd = open(file, O_RDONLY)) < 0)
./cmd/zpool/zpool_vdev.c:435:	if ((fd = open(path, O_RDONLY|O_DIRECT)) < 0) {
./cmd/zpool/zpool_vdev.c:541:	if ((fd = open(path, O_RDONLY|O_DIRECT)) < 0)
./cmd/zpool/zpool_vdev.c:595:	if ((fd = open(path, O_RDONLY)) < 0)
./cmd/zpool/zpool_vdev.c:932:				if ((fd = open(path, O_RDONLY)) >= 0) {
./cmd/zpool/zpool_vdev.c:1126:	if ((fd = open(path, O_WRONLY|O_EXCL)) < 0) {
./cmd/zpool/zpool_vdev.c:1219:		fd = open(devpath, O_RDWR|O_EXCL);
./cmd/ztest/ztest.c:894:		int fd = open(path, O_RDWR | O_CREAT | O_TRUNC, 0666);
./cmd/ztest/ztest.c:2402:	VERIFY(zil_open(os, ztest_get_data) == zd->zd_zilog);
./cmd/ztest/ztest.c:2445:	VERIFY3U(0, ==, spa_open(zo->zo_pool, &spa, FTAG));
./cmd/ztest/ztest.c:2505:	VERIFY3S(spa_open(name, &spa, FTAG), ==, 0);
./cmd/ztest/ztest.c:3015:	if ((fd = open(vd->vdev_path, O_RDWR)) == -1)
./cmd/ztest/ztest.c:3409:	zilog = zil_open(os, ztest_get_data);
./cmd/ztest/ztest.c:4171:			txg_wait_open(dmu_objset_pool(os), 0);
./cmd/ztest/ztest.c:5130:	fd = open(pathrand, O_RDWR);
./cmd/ztest/ztest.c:5346:	VERIFY3U(ENOENT, ==, spa_open(oldname, &spa, FTAG));
./cmd/ztest/ztest.c:5351:	VERIFY3U(0, ==, spa_open(newname, &spa, FTAG));
./cmd/ztest/ztest.c:5364:	VERIFY3U(0, ==, spa_open(oldname, &spa, FTAG));
./cmd/ztest/ztest.c:5411:	fp = popen(zdb, "r");
./cmd/ztest/ztest.c:5469:	VERIFY3U(0, ==, spa_open(oldname, &spa, FTAG));
./cmd/ztest/ztest.c:5521:	VERIFY3U(ENOENT, ==, spa_open(oldname, &spa, FTAG));
./cmd/ztest/ztest.c:5526:	VERIFY3U(0, ==, spa_open(newname, &spa, FTAG));
./cmd/ztest/ztest.c:5676:	 * Note that we can only check this in ztest_dataset_open(),
./cmd/ztest/ztest.c:5687:ztest_dataset_open(int d)
./cmd/ztest/ztest.c:5733:	zilog = zil_open(os, ztest_get_data);
./cmd/ztest/ztest.c:5795:	VERIFY0(spa_open(ztest_opts.zo_pool, &spa, FTAG));
./cmd/ztest/ztest.c:5869:		    ztest_dataset_open(t) != 0)
./cmd/ztest/ztest.c:5954:	VERIFY3U(0, ==, spa_open(ztest_opts.zo_pool, &spa, FTAG));
./cmd/ztest/ztest.c:5955:	VERIFY3U(0, ==, ztest_dataset_open(0));
./cmd/ztest/ztest.c:6022:	VERIFY3U(0, ==, spa_open(ztest_opts.zo_pool, &spa, FTAG));
./cmd/ztest/ztest.c:6024:	VERIFY3U(0, ==, ztest_dataset_open(0));
./cmd/ztest/ztest.c:6111:	VERIFY3U(0, ==, spa_open(ztest_opts.zo_pool, &spa, FTAG));
./cmd/ztest/ztest.c:6341:	ztest_fd_rand = open("/dev/urandom", O_RDONLY);
./cmd/ztest/ztest.c:6503:		if (spa_open(ztest_opts.zo_pool, &spa, FTAG) == 0) {
./cmd/zdb/zdb.c:186: * Called for usage errors that are discovered after a call to spa_open(),
./cmd/zdb/zdb.c:1505:			error = bpobj_open(&subbpo, bpo->bpo_os, subobj);
./cmd/zhack/zhack.c:148:	if (readonly && spa_open(target, &spa, FTAG) == 0) {
./cmd/zhack/zhack.c:165:			    spa_open(target, &spa, FTAG) == 0) {
./cmd/zhack/zhack.c:199:zhack_spa_open(const char *target, boolean_t readonly, void *tag, spa_t **spa)
./cmd/zhack/zhack.c:206:	err = spa_open(target, spa, tag);
./cmd/zhack/zhack.c:274:	zhack_spa_open(target, B_TRUE, FTAG, &spa);
./cmd/zhack/zhack.c:355:	zhack_spa_open(target, B_FALSE, FTAG, &spa);
./cmd/zhack/zhack.c:448:	zhack_spa_open(target, B_FALSE, FTAG, &spa);
./include/sys/spa_impl.h:141:	uint64_t	spa_first_txg;		/* first txg after spa_open() */
./include/sys/spa.h:587:extern int spa_open(const char *pool, spa_t **, void *tag);
./include/sys/bpobj.h:75:int bpobj_open(bpobj_t *bpo, objset_t *mos, uint64_t object);
./include/sys/vdev.h:50:extern int vdev_open(vdev_t *);
./include/sys/vdev.h:55:extern void vdev_reopen(vdev_t *);
./include/sys/dsl_dataset.h:179:	/* for objset_open() */
./include/sys/dsl_pool.h:139:int dsl_pool_open(dsl_pool_t *dp);
./include/sys/zfs_context.h:569:extern int vn_open(char *path, int x1, int oflags, int mode, vnode_t **vpp,
./include/sys/zfs_vnops.h:40:extern int zfs_open(struct inode *ip, int mode, int flag, cred_t *cr);
./include/sys/space_map.h:154:int space_map_open(space_map_t **smp, objset_t *os, uint64_t object,
./include/sys/fs/zfs.h:645:	VDEV_AUX_OPEN_FAILED,	/* ldi_open_*() or vn_open() failed	*/
./include/sys/txg.h:72:extern uint64_t txg_hold_open(struct dsl_pool *dp, txg_handle_t *txghp);
./include/sys/txg.h:95:extern void txg_wait_open(struct dsl_pool *dp, uint64_t txg);
./include/sys/dnode.h:292:void dnode_special_open(struct objset *dd, dnode_phys_t *dnp,
./include/sys/zil.h:456:extern zilog_t	*zil_open(objset_t *os, zil_get_data_t *get_data);
./include/sys/dsl_deadlist.h:65:void dsl_deadlist_open(dsl_deadlist_t *dl, objset_t *os, uint64_t object);
./include/linux/vfs_compat.h:327:current_umask(void)
./include/linux/blkdev_compat.h:213:#define	vdev_bdev_open(path, md, hld)	blkdev_get_by_path(path, \
./include/linux/blkdev_compat.h:217:#define	vdev_bdev_open(path, md, hld)	open_bdev_exclusive(path, md, hld)
./include/linux/blkdev_compat.h:220:#define	vdev_bdev_open(path, md, hld)	open_bdev_excl(path, md, hld)
./include/linux/blkdev_compat.h:335: * A common holder for vdev_bdev_open() is used to relax the exclusive open
./include/libzfs.h:222:extern zpool_handle_t *zpool_open(libzfs_handle_t *, const char *);
./include/libzfs.h:259:extern int zpool_reopen(zpool_handle_t *);
./include/libzfs.h:430:extern zfs_handle_t *zfs_open(libzfs_handle_t *, const char *, int);
./lib/libzpool/kernel.c:588:vn_open(char *path, int x1, int flags, int mode, vnode_t **vpp, int x2, int x3)
./lib/libzpool/kernel.c:651:		old_umask = umask(0);
./lib/libzpool/kernel.c:661:		(void) umask(old_umask);
./lib/libzpool/kernel.c:695:	ret = vn_open(realpath, x1, flags, mode, vpp, x2, x3);
./lib/libzpool/kernel.c:758: * At a minimum we need to update the size since vdev_reopen()
./lib/libzpool/kernel.c:1122:	f = fopen("/sys/module/spl/parameters/spl_hostid", "r");
./lib/libzpool/kernel.c:1155:	VERIFY((random_fd = open("/dev/random", O_RDONLY)) != -1);
./lib/libzpool/kernel.c:1156:	VERIFY((urandom_fd = open("/dev/urandom", O_RDONLY)) != -1);
./lib/libspl/include/sys/kstat.h:281: *		are not lost across driver close/open (e.g., raw disk I/O
./lib/libuutil/uu_open.c:58:		f = open(fname, O_CREAT | O_EXCL | O_RDWR, 0600);
./lib/libzfs_core/libzfs_core.c:96:		g_fd = open("/dev/zfs", O_RDWR);
./lib/libzfs_core/libzfs_core.c:343: * If cleanup_fd is not -1, it must be the result of open("/dev/zfs", O_EXCL).
./lib/libzfs/libzfs_util.c:660:		devnull_fd = open("/dev/null", O_WRONLY);
./lib/libzfs/libzfs_util.c:743:		fd = open(ZFS_DEV, O_RDWR);
./lib/libzfs/libzfs_util.c:775:	if ((hdl->libzfs_fd = open(ZFS_DEV, O_RDWR)) < 0) {
./lib/libzfs/libzfs_util.c:783:	if ((hdl->libzfs_mnttab = fopen(MNTTAB, "r")) == NULL) {
./lib/libzfs/libzfs_util.c:790:	hdl->libzfs_sharetab = fopen("/etc/dfs/sharetab", "r");
./lib/libzfs/libzfs_util.c:864:		return (zfs_open(hdl, path, argtype));
./lib/libzfs/libzfs_util.c:873:	if (freopen(MNTTAB, "r", hdl->libzfs_mnttab) == NULL)
./lib/libzfs/libzfs_util.c:892:	return (zfs_open(hdl, entry.mnt_special, ZFS_TYPE_FILESYSTEM));
./lib/libzfs/libzfs_sendrecv.c:260:	ofp = fdopen(dda->inputfd, "r");
./lib/libzfs/libzfs_sendrecv.c:752:		zfs_handle_t *origin = zfs_open(zhp->zfs_hdl,
./lib/libzfs/libzfs_sendrecv.c:800:	zhp = zfs_open(hdl, fsname, ZFS_TYPE_FILESYSTEM | ZFS_TYPE_VOLUME);
./lib/libzfs/libzfs_sendrecv.c:1349:		zhp = zfs_open(rzhp->zfs_hdl, fsname, ZFS_TYPE_DATASET);
./lib/libzfs/libzfs_sendrecv.c:1561:		sdd.cleanup_fd = open(ZFS_DEV, O_RDWR);
./lib/libzfs/libzfs_sendrecv.c:1798:	zhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);
./lib/libzfs/libzfs_sendrecv.c:1872:	zhp = zfs_open(hdl, name, ZFS_TYPE_DATASET);
./lib/libzfs/libzfs_sendrecv.c:2020:	guid1hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);
./lib/libzfs/libzfs_sendrecv.c:2027:	guid2hdl = zfs_open(hdl, buf, ZFS_TYPE_SNAPSHOT);
./lib/libzfs/libzfs_sendrecv.c:2492:				zhp = zfs_open(hdl, nvpair_name(pair),
./lib/libzfs/libzfs_sendrecv.c:2903:		if ((zhp = zfs_open(hdl, zc.zc_name,
./lib/libzfs/libzfs_sendrecv.c:3136:		h = zfs_open(hdl, zc.zc_value,
./lib/libzfs/libzfs_sendrecv.c:3339:		FILE *procf = fopen("/proc/sys/fs/pipe-max-size", "r");
./lib/libzfs/libzfs_sendrecv.c:3356:	cleanup_fd = open(ZFS_DEV, O_RDWR);
./lib/libzfs/libzfs_sendrecv.c:3368:		zhp = zfs_open(hdl, top_zfs, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_dataset.c:403: * Makes a handle from the given dataset name.  Used by zfs_open() and
./lib/libzfs/libzfs_dataset.c:620:zfs_open(libzfs_handle_t *hdl, const char *path, int types)
./lib/libzfs/libzfs_dataset.c:703:	if (freopen(MNTTAB, "r", hdl->libzfs_mnttab) == NULL)
./lib/libzfs/libzfs_dataset.c:772:		if (freopen(MNTTAB, "r", hdl->libzfs_mnttab) == NULL)
./lib/libzfs/libzfs_dataset.c:2180:			root = zfs_open(zhp->zfs_hdl, pool,
./lib/libzfs/libzfs_dataset.c:3034:		h = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_dataset.c:3037:		h = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_dataset.c:3066:		h = zfs_open(hdl, target, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_dataset.c:3640:	if ((zhp = zfs_open(hdl, fsname, ZFS_TYPE_FILESYSTEM |
./lib/libzfs/libzfs_dataset.c:3900:		zhrp = zfs_open(zhp->zfs_hdl, parentname, ZFS_TYPE_DATASET);
./lib/libzfs/libzfs_import.c:107:	if ((fd = open(path, O_RDONLY)) < 0)
./lib/libzfs/libzfs_import.c:1297:	if ((fd = open(cachefile, O_RDONLY)) < 0) {
./lib/libzfs/libzfs_iter.c:49:		zfs_handle_t *clone = zfs_open(zhp->zfs_hdl, nvpair_name(pair),
./lib/libzfs/libzfs_diff.c:432:	if ((ofp = fdopen(di->outputfd, "w")) == NULL) {
./lib/libzfs/libzfs_diff.c:622:		zhp = zfs_open(hdl, di->ds, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_diff.c:634:			zhp = zfs_open(hdl, origin, ZFS_TYPE_FILESYSTEM);
./lib/libzfs/libzfs_diff.c:737:	di->cleanupfd = open(ZFS_DEV, O_RDWR);
./lib/libzfs/libzfs_mount.c:1099:	if ((zfsp = zfs_open(hdl, zhp->zpool_name, ZFS_TYPE_DATASET)) == NULL)
./lib/libzfs/libzfs_mount.c:1182:	if (freopen(MNTTAB, "r", hdl->libzfs_mnttab) == NULL)
./lib/libzfs/libzfs_pool.c:1126:zpool_open(libzfs_handle_t *hdl, const char *pool)
./lib/libzfs/libzfs_pool.c:1311:	    (zfp = zfs_open(hdl, zhp->zpool_name, ZFS_TYPE_FILESYSTEM)) == NULL)
./lib/libzfs/libzfs_pool.c:2380:	if ((fd = open(path, O_RDWR|O_DIRECT)) < 0) {
./lib/libzfs/libzfs_pool.c:2392:	 * The module will do it for us in vdev_disk_open().
./lib/libzfs/libzfs_pool.c:3284:zpool_reopen(zpool_handle_t *zhp)
./lib/libzfs/libzfs_pool.c:3341:	if ((fd = open(path, O_RDONLY)) < 0)
./lib/libzfs/libzfs_pool.c:4029:	if ((fd = open(diskname, O_RDWR|O_DIRECT)) >= 0) {
./lib/libzfs/libzfs_pool.c:4104:	if ((fd = open(path, O_RDWR|O_DIRECT)) < 0)
./lib/libzfs/libzfs_pool.c:4169:	if ((fd = open(path, O_RDWR|O_DIRECT)) < 0) {
./lib/libzfs/libzfs_graph.c:377: * avoid the overhead and additional semantics of zfs_open().
./lib/libzfs/libzfs_fru.c:63: * Because the FMA packages depend on ZFS, we have to dlopen() libtopo in case
./lib/libzfs/libzfs_fru.c:209:	if ((_topo_dlhandle = dlopen(path, RTLD_LAZY)) == NULL)
./lib/libzfs/libzfs_fru.c:274:	if ((hdl->libzfs_topo_hdl = _topo_open(TOPO_VERSION,
./lib/libzfs/libzfs_changelist.c:640:	if ((temp = zfs_open(zhp->zfs_hdl, zfs_get_name(zhp),
./lib/libshare/smb.c:104:		if ((share_file_fp = fopen(file_path, "r")) == NULL) {
./lib/libshare/libshare.c:116:	fp = fopen("/etc/dfs/sharetab", "r");
./lib/libshare/libshare.c:186:	temp_fp = fdopen(temp_fd, "w");
./lib/libshare/libshare.c:297:	zhp = zfs_open(impl_share->handle->zfs_libhandle, impl_share->dataset,
./lib/libshare/nfs.c:529:	nfs_exportfs_temp_fp = fdopen(dup(nfs_exportfs_temp_fd), "r");

== logging() ==
./module/zpios/pios.c:836:	/* Returns first encountered thread error (if any) */
./module/zfs/dsl_userhold.c:198:		zfs_dbgmsg("couldn't release holds on pool=%s "
./module/zfs/dsl_userhold.c:204:		zfs_dbgmsg("couldn't release holds on pool=%s "
./module/zfs/bptree.c:224:		zfs_dbgmsg("bptree index %lld: traversing from min_txg=%lld "
./module/zfs/vdev_raidz.c:1663:raidz_checksum_error(zio_t *zio, raidz_col_t *rc, void *bad_data)
./module/zfs/vdev_raidz.c:1697:	ret = zio_checksum_error(zio, &zbc);
./module/zfs/vdev_raidz.c:1732:			raidz_checksum_error(zio, rc, orig[c]);
./module/zfs/vdev_raidz.c:1748:vdev_raidz_worst_error(raidz_map_t *rm)
./module/zfs/vdev_raidz.c:1753:		error = zio_worst_error(error, rm->rm_col[c].rc_error);
./module/zfs/vdev_raidz.c:1855:						raidz_checksum_error(zio, rc,
./module/zfs/vdev_raidz.c:1989:			zio->io_error = vdev_raidz_worst_error(rm);
./module/zfs/vdev_raidz.c:2130:		zio->io_error = vdev_raidz_worst_error(rm);
./module/zfs/metaslab.c:1431:			spa_dbgmsg(spa, "txg %llu, requesting force condense: "
./module/zfs/metaslab.c:1745:	spa_dbgmsg(spa, "condensing: txg %llu, msp[%llu] %p, "
./module/zfs/metaslab.c:2100:				spa_dbgmsg(spa, "%s: failed to meet weight "
./module/zfs/zrlock.c:74:zrl_add_debug(zrlock_t *zrl, const char *zc)
./module/zfs/spa_errlog.c:93:spa_log_error(spa_t *spa, zio_t *zio)
./module/zfs/spa_history.c:241:		zfs_dbgmsg("command: %s",
./module/zfs/spa_history.c:245:			zfs_dbgmsg("txg %lld %s %s (id %llu) %s",
./module/zfs/spa_history.c:252:			zfs_dbgmsg("txg %lld %s %s",
./module/zfs/spa_history.c:258:		zfs_dbgmsg("ioctl %s",
./module/zfs/zfs_debug.c:146:__zfs_dbgmsg(char *buf)
./module/zfs/zfs_debug.c:227:		__zfs_dbgmsg(buf);
./module/zfs/vdev.c:2040:		zfs_dbgmsg("txg %llu, spa %s, DTL old object %llu, "
./module/zfs/vdev.c:3422:				zfs_dbgmsg("SLOW IO: zio timestamp %lluns, "
./module/zfs/vdev_disk.c:99:vdev_disk_error(zio_t *zio)
./module/zfs/vdev_disk.c:398:				vdev_disk_error(zio);
./module/zfs/vdev_disk.c:622:		vdev_disk_error(zio);
./module/zfs/range_tree.c:71:			zfs_dbgmsg("i=%d, hist=%p, hist=%llu, rt_hist=%llu",
./module/zfs/zio_checksum.c:190:zio_checksum_error(zio_t *zio, zio_bad_cksum_t *info)
./module/zfs/spa_misc.c:523:	zfs_dbgmsg("slow spa_sync: started %llu seconds ago, calls %llu",
./module/zfs/spa_misc.c:1815:			perror("could not enable watchpoints: "
./module/zfs/spa.c:5930:	zfs_dbgmsg("spa=%s async request task=%u", spa->spa_name, task);
./module/zfs/vdev_mirror.c:386:vdev_mirror_worst_error(mirror_map_t *mm)
./module/zfs/vdev_mirror.c:393:		error[s] = zio_worst_error(error[s], mc->mc_error);
./module/zfs/vdev_mirror.c:445:				zio->io_error = vdev_mirror_worst_error(mm);
./module/zfs/vdev_mirror.c:469:		zio->io_error = vdev_mirror_worst_error(mm);
./module/zfs/space_map.c:429:		zfs_dbgmsg("txg %llu, spa %s, reallocating: "
./module/zfs/arc.c:6628: * version. On decompression error (corrupt compressed stream), the
./module/zfs/zfs_replay.c:75:zfs_replay_error(zfs_sb_t *zsb, lr_t *lr, boolean_t byteswap)
./module/zfs/dsl_scan.c:114:		zfs_dbgmsg("old-style scrub was in progress; "
./module/zfs/dsl_scan.c:180:			zfs_dbgmsg("new-style scrub was modified "
./module/zfs/dsl_scan.c:872:			zfs_dbgmsg("destroying ds %llu; currently traversing; "
./module/zfs/dsl_scan.c:881:			zfs_dbgmsg("destroying ds %llu; currently traversing; "
./module/zfs/dsl_scan.c:900:			zfs_dbgmsg("destroying ds %llu; in queue; "
./module/zfs/dsl_scan.c:906:			zfs_dbgmsg("destroying ds %llu; in queue; removing",
./module/zfs/dsl_scan.c:910:		zfs_dbgmsg("destroying ds %llu; ignoring",
./module/zfs/dsl_scan.c:936:		zfs_dbgmsg("snapshotting ds %llu; currently traversing; "
./module/zfs/dsl_scan.c:947:		zfs_dbgmsg("snapshotting ds %llu; in queue; "
./module/zfs/dsl_scan.c:967:		zfs_dbgmsg("clone_swap ds %llu; currently traversing; "
./module/zfs/dsl_scan.c:973:		zfs_dbgmsg("clone_swap ds %llu; currently traversing; "
./module/zfs/dsl_scan.c:996:		zfs_dbgmsg("clone_swap ds %llu; in queue; "
./module/zfs/dsl_scan.c:1008:		zfs_dbgmsg("clone_swap ds %llu; in queue; "
./module/zfs/dsl_scan.c:1086:	zfs_dbgmsg("scanned dataset %llu (%s) with min=%llu max=%llu; "
./module/zfs/dsl_scan.c:1105:		zfs_dbgmsg("incomplete pass; visiting again");
./module/zfs/dsl_scan.c:1264:	zfs_dbgmsg("scanned %llu ddt entries with class_max = %u; pausing=%u",
./module/zfs/dsl_scan.c:1467:		zfs_dbgmsg("restarting scan func=%u txg=%llu",
./module/zfs/dsl_scan.c:1546:		zfs_dbgmsg("freed %llu blocks in %llums from "
./module/zfs/dsl_scan.c:1602:		zfs_dbgmsg("txg %llu scan complete", tx->tx_txg);
./module/zfs/dsl_scan.c:1611:		zfs_dbgmsg("doing scan sync txg %llu; "
./module/zfs/dsl_scan.c:1623:		zfs_dbgmsg("doing scan sync txg %llu; bm=%llu/%llu/%llu/%llu",
./module/zfs/dsl_scan.c:1639:	zfs_dbgmsg("visited %llu blocks in %llums",
./module/zfs/dsl_scan.c:1645:		zfs_dbgmsg("txg %llu traversal complete, waiting till txg %llu",
./module/zfs/dsl_scan.c:1678:	zfs_dbgmsg("restarting resilver txg=%llu", txg);
./module/zfs/zil.c:727: * Any other error (no device or read failure) returns an error.
./module/zfs/zil.c:2079:zil_replay_error(zilog_t *zilog, lr_t *lr, int error)
./module/zfs/zil.c:2117:		return (zil_replay_error(zilog, lr, EINVAL));
./module/zfs/zil.c:2142:			return (zil_replay_error(zilog, lr, error));
./module/zfs/zil.c:2173:			return (zil_replay_error(zilog, lr, error));
./module/zfs/zio.c:489:		*errorp = zio_worst_error(*errorp, zio->io_error);
./module/zfs/zio.c:2538:		spa_dbgmsg(spa, "%s: metaslab allocation failure: zio %p, "
./module/zfs/zio.c:3002:	if ((error = zio_checksum_error(zio, &info)) != 0) {
./module/zfs/zio.c:3034:zio_worst_error(int e1, int e2)
./module/zfs/zio.c:3221:			spa_log_error(zio->io_spa, zio);
./cmd/zinject/zinject.c:308:		    strerror(errno));
./cmd/zinject/zinject.c:429:		    id, strerror(errno));
./cmd/zinject/zinject.c:462:		    id, strerror(errno));
./cmd/zinject/zinject.c:486:		    strerror(errno));
./cmd/zinject/zinject.c:580:	libzfs_print_on_error(g_zfs, B_TRUE);
./cmd/zinject/translate.c:114:		    fullpath, strerror(errno));
./cmd/zinject/translate.c:185:		    dataset, strerror(err));
./cmd/zinject/translate.c:272:		    dataset, strerror(err));
./cmd/zed/zed.c:99:			zed_log_msg(LOG_INFO, "Locked all pages in memory");
./cmd/zed/zed.c:105:	zed_log_die("Failed to lock memory pages: %s", strerror(errno));
./cmd/zed/zed.c:133:		    strerror(errno));
./cmd/zed/zed.c:152:		    strerror(errno));
./cmd/zed/zed.c:168:		    strerror(errno));
./cmd/zed/zed.c:188:		zed_log_die("Failed to open /dev/null: %s", strerror(errno));
./cmd/zed/zed.c:192:		    strerror(errno));
./cmd/zed/zed.c:196:		    strerror(errno));
./cmd/zed/zed.c:200:		    strerror(errno));
./cmd/zed/zed.c:203:		zed_log_die("Failed to close /dev/null: %s", strerror(errno));
./cmd/zed/zed.c:256:	zed_log_msg(LOG_NOTICE,
./cmd/zed/zed.c:276:	zed_log_msg(LOG_NOTICE, "Exiting");
./cmd/zed/zed_event.c:43:		zed_log_die("Failed zed_event_init: %s", strerror(EINVAL));
./cmd/zed/zed_event.c:52:		    ZFS_DEV, strerror(errno));
./cmd/zed/zed_event.c:62:		zed_log_die("Failed zed_event_fini: %s", strerror(EINVAL));
./cmd/zed/zed_event.c:66:			zed_log_msg(LOG_WARNING, "Failed to close \"%s\": %s",
./cmd/zed/zed_event.c:67:			    ZFS_DEV, strerror(errno));
./cmd/zed/zed_event.c:100:		zed_log_msg(LOG_ERR, "Failed to seek zevent: %s",
./cmd/zed/zed_event.c:101:		    strerror(errno));
./cmd/zed/zed_event.c:114:			zed_log_msg(LOG_WARNING, "Missed %d events", n_dropped);
./cmd/zed/zed_event.c:121:			zed_log_msg(LOG_WARNING, "Failed to lookup zevent eid");
./cmd/zed/zed_event.c:124:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:127:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:142:			zed_log_msg(LOG_WARNING, "Failed to seek to eid=0");
./cmd/zed/zed_event.c:146:	zed_log_msg(LOG_NOTICE, "Processing events since eid=%llu", eid);
./cmd/zed/zed_event.c:186: * Returns 0 on success, and -1 on error (with errno set).
./cmd/zed/zed_event.c:208:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:213:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:232:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:245:		zed_log_msg(LOG_WARNING, "Failed to add %s for eid=%llu: %s",
./cmd/zed/zed_event.c:261:		zed_log_msg(LOG_WARNING, "Failed to add %s for eid=%llu: %s",
./cmd/zed/zed_event.c:265:		zed_log_msg(LOG_WARNING, "Failed to add %s for eid=%llu: %s",
./cmd/zed/zed_event.c:266:		    keybuf, eid, strerror(errno));
./cmd/zed/zed_event.c:276:	zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:687:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:796:		zed_log_msg(LOG_WARNING, "Failed to add %s%s for eid=%llu: %s",
./cmd/zed/zed_event.c:799:		zed_log_msg(LOG_WARNING, "Failed to add %s%s for eid=%llu: %s",
./cmd/zed/zed_event.c:826:		zed_log_msg(LOG_ERR, "Failed to service zevent: %s",
./cmd/zed/zed_event.c:827:		    strerror(errno));
./cmd/zed/zed_event.c:837:		zed_log_msg(LOG_WARNING, "Missed %d events", n_dropped);
./cmd/zed/zed_event.c:844:		zed_log_msg(LOG_WARNING, "Failed to lookup zevent eid");
./cmd/zed/zed_event.c:847:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:850:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_event.c:854:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_exec.c:96:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_exec.c:98:		    prog, eid, strerror(ENAMETOOLONG));
./cmd/zed/zed_exec.c:103:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_exec.c:105:		    prog, eid, strerror(errno));
./cmd/zed/zed_exec.c:118:		zed_log_msg(LOG_INFO, "Invoking \"%s\" eid=%llu pid=%d",
./cmd/zed/zed_exec.c:126:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_exec.c:130:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_exec.c:134:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_exec.c:139:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_log.c:73:		    (int) getpid(), strerror(errno));
./cmd/zed/zed_log.c:93:		    (int) getpid(), strerror(errno));
./cmd/zed/zed_log.c:118:		    (int) getpid(), strerror(errno));
./cmd/zed/zed_log.c:147:			    (int) getpid(), strerror(errno));
./cmd/zed/zed_log.c:157: * Refer to syslog(3) for valid priority values.
./cmd/zed/zed_log.c:178: * Refer to syslog(3) for valid option/facility values.
./cmd/zed/zed_log.c:218:		syslog(priority, "%s", buf);
./cmd/zed/zed_log.c:229:zed_log_msg(int priority, const char *fmt, ...)
./cmd/zed/zed_conf.c:70:	zed_log_die("Failed to create conf: %s", strerror(errno));
./cmd/zed/zed_conf.c:87:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:89:			    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:94:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:96:			    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:100:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:102:			    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:232:		    strerror(errno));
./cmd/zed/zed_conf.c:234:		zed_log_die("Failed to copy path: %s", strerror(ENAMETOOLONG));
./cmd/zed/zed_conf.c:236:		zed_log_die("Failed to copy path: %s", strerror(ENAMETOOLONG));
./cmd/zed/zed_conf.c:241:		zed_log_die("Failed to copy path: %s", strerror(ENOMEM));
./cmd/zed/zed_conf.c:318:		zed_log_die("Failed to parse config: %s", strerror(EINVAL));
./cmd/zed/zed_conf.c:343:		zed_log_msg(LOG_ERR, "Failed to scan zedlet dir: %s",
./cmd/zed/zed_conf.c:344:		    strerror(errno));
./cmd/zed/zed_conf.c:350:		zed_log_msg(LOG_WARNING, "Failed to scan dir \"%s\": %s",
./cmd/zed/zed_conf.c:351:		    zcp->zedlet_dir, strerror(errno));
./cmd/zed/zed_conf.c:357:		zed_log_msg(LOG_WARNING, "Failed to open dir \"%s\": %s",
./cmd/zed/zed_conf.c:358:		    zcp->zedlet_dir, strerror(errno));
./cmd/zed/zed_conf.c:370:			zed_log_msg(LOG_WARNING, "Failed to stat \"%s\": %s",
./cmd/zed/zed_conf.c:371:			    direntp->d_name, strerror(ENAMETOOLONG));
./cmd/zed/zed_conf.c:375:			zed_log_msg(LOG_WARNING, "Failed to stat \"%s\": %s",
./cmd/zed/zed_conf.c:376:			    pathname, strerror(errno));
./cmd/zed/zed_conf.c:380:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_conf.c:386:			zed_log_msg(LOG_NOTICE,
./cmd/zed/zed_conf.c:392:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_conf.c:398:			zed_log_msg(LOG_NOTICE,
./cmd/zed/zed_conf.c:404:			zed_log_msg(LOG_NOTICE,
./cmd/zed/zed_conf.c:410:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:412:			    direntp->d_name, strerror(errno));
./cmd/zed/zed_conf.c:416:			zed_log_msg(LOG_INFO,
./cmd/zed/zed_conf.c:421:		zed_log_msg(LOG_WARNING, "Failed to close dir \"%s\": %s",
./cmd/zed/zed_conf.c:422:		    zcp->zedlet_dir, strerror(errno));
./cmd/zed/zed_conf.c:455:		zed_log_msg(LOG_ERR, "Failed to create PID file: %s",
./cmd/zed/zed_conf.c:456:		    strerror(errno));
./cmd/zed/zed_conf.c:466:		zed_log_msg(LOG_ERR, "Failed to create PID file: %s",
./cmd/zed/zed_conf.c:467:		    strerror(errno));
./cmd/zed/zed_conf.c:475:		zed_log_msg(LOG_ERR, "Failed to create directory \"%s\": %s",
./cmd/zed/zed_conf.c:476:		    buf, strerror(errno));
./cmd/zed/zed_conf.c:487:		zed_log_msg(LOG_ERR, "Failed to open PID file \"%s\": %s",
./cmd/zed/zed_conf.c:488:		    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:493:		zed_log_msg(LOG_ERR, "Failed to lock PID file \"%s\": %s",
./cmd/zed/zed_conf.c:494:		    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:499:			zed_log_msg(LOG_ERR,
./cmd/zed/zed_conf.c:503:			zed_log_msg(LOG_ERR,
./cmd/zed/zed_conf.c:507:			zed_log_msg(LOG_ERR,
./cmd/zed/zed_conf.c:519:		zed_log_msg(LOG_ERR, "Failed to write PID file \"%s\": %s",
./cmd/zed/zed_conf.c:520:		    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:522:		zed_log_msg(LOG_ERR, "Failed to write PID file \"%s\": %s",
./cmd/zed/zed_conf.c:523:		    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:525:		zed_log_msg(LOG_ERR, "Failed to sync PID file \"%s\": %s",
./cmd/zed/zed_conf.c:526:		    zcp->pid_file, strerror(errno));
./cmd/zed/zed_conf.c:556:		zed_log_msg(LOG_ERR, "Failed to open state file: %s",
./cmd/zed/zed_conf.c:557:		    strerror(errno));
./cmd/zed/zed_conf.c:563:		zed_log_msg(LOG_WARNING, "Failed to open state file: %s",
./cmd/zed/zed_conf.c:564:		    strerror(errno));
./cmd/zed/zed_conf.c:572:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:574:		    dirbuf, strerror(errno));
./cmd/zed/zed_conf.c:579:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:581:			    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:591:		zed_log_msg(LOG_WARNING, "Failed to open state file \"%s\": %s",
./cmd/zed/zed_conf.c:592:		    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:597:		zed_log_msg(LOG_WARNING, "Failed to lock state file \"%s\": %s",
./cmd/zed/zed_conf.c:598:		    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:604:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:608:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:612:			zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:636:		zed_log_msg(LOG_ERR,
./cmd/zed/zed_conf.c:637:		    "Failed to read state file: %s", strerror(errno));
./cmd/zed/zed_conf.c:641:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:643:		    strerror(errno));
./cmd/zed/zed_conf.c:658:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:660:		    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:664:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:686:		zed_log_msg(LOG_ERR,
./cmd/zed/zed_conf.c:687:		    "Failed to write state file: %s", strerror(errno));
./cmd/zed/zed_conf.c:691:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:693:		    strerror(errno));
./cmd/zed/zed_conf.c:706:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:708:		    zcp->state_file, strerror(errno));
./cmd/zed/zed_conf.c:713:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:719:		zed_log_msg(LOG_WARNING,
./cmd/zed/zed_conf.c:721:		    zcp->state_file, strerror(errno));
./cmd/zed/zed_file.c:84: * or -1 on error (with errno set).
./cmd/zed/zed_file.c:111: * Return 0 on success, or -1 on error (with errno set).
./cmd/zed/zed_file.c:137: * holding a conflicting lock, or -1 on error (with errno set).
./cmd/zed/zed_log.h:40:void zed_log_msg(int priority, const char *fmt, ...);
./cmd/zstreamdump/zstreamdump.c:327:				if (ferror(send_stream))
./cmd/zstreamdump/zstreamdump.c:328:					perror("fread");
./cmd/zstreamdump/zstreamdump.c:331:					perror(strerror(err));
./cmd/zvol_id/zvol_id_main.c:39:ioctl_get_msg(char *var, int fd)
./cmd/zvol_id/zvol_id_main.c:84:	error = ioctl_get_msg(zvol_name, fd);
./cmd/zvol_id/zvol_id_main.c:86:		printf("ioctl_get_msg failed:%s\n", strerror(errno));
./cmd/zfs/zfs_main.c:1346:			(void) zfs_standard_error(g_zfs, err,
./cmd/zfs/zfs_main.c:6084:		    cmdname, path, strerror(errno));
./cmd/zfs/zfs_main.c:6112:			    strerror(errno));
./cmd/zfs/zfs_main.c:6129:		    cmdname, path, strerror(errno));
./cmd/zfs/zfs_main.c:6715:	libzfs_print_on_error(g_zfs, B_TRUE);
./cmd/zpool/zpool_main.c:1042:			    "%s\n"), buf, strerror(errno));
./cmd/zpool/zpool_main.c:5945:	libzfs_print_on_error(g_zfs, B_TRUE);
./cmd/zpool/zpool_vdev.c:92: * vdev_error() function keeps track of whether we have seen an error yet, and
./cmd/zpool/zpool_vdev.c:281:vdev_error(const char *fmt, ...)
./cmd/zpool/zpool_vdev.c:348:				vdev_error(gettext("%s is reserved as a hot "
./cmd/zpool/zpool_vdev.c:352:				vdev_error(gettext("%s is part of %s pool "
./cmd/zpool/zpool_vdev.c:367:check_error(int err)
./cmd/zpool/zpool_vdev.c:370:	    "failed: %s\n"), strerror(err));
./cmd/zpool/zpool_vdev.c:397:			vdev_error(gettext("%s contains a filesystem of "
./cmd/zpool/zpool_vdev.c:436:		check_error(errno);
./cmd/zpool/zpool_vdev.c:446:			vdev_error(gettext("%s does not contain an EFI "
./cmd/zpool/zpool_vdev.c:466:			vdev_error(gettext("%s contains a corrupt primary "
./cmd/zpool/zpool_vdev.c:512:			check_error(err);
./cmd/zpool/zpool_vdev.c:518:			check_error(err);
./cmd/zpool/zpool_vdev.c:674:			    path, strerror(errno));
./cmd/zpool/zpool_vdev.c:687:			 * regurgitate strerror() since it's the best we
./cmd/zpool/zpool_vdev.c:701:				    path, strerror(errno));
./cmd/zpool/zpool_vdev.c:907:						vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:960:						vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:985:					vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:997:					vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:1011:					vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:1091:			vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:1097:			vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:1103:			vdev_error(gettext(
./cmd/zpool/zpool_vdev.c:1128:		    path, strerror(errno));
./cmd/zpool/zpool_vdev.c:1139:		    "of '%s': %s\n"), size, path, strerror(errno));
./cmd/ztest/ztest.c:533:		    ": %s", strerror(save_errno));
./cmd/ztest/ztest.c:727:				    optarg, strerror(errno));
./cmd/ztest/ztest.c:6331:		    strerror(errno));
./cmd/ztest/ztest.c:6337:		    strerror(errno));
./cmd/zdb/zdb.c:2144:		    strerror(errno));
./cmd/zdb/zdb.c:2150:		    strerror(errno));
./cmd/zdb/zdb.c:2226:		(void) printf("cannot open '%s': %s\n", path, strerror(errno));
./cmd/zdb/zdb.c:2233:		    strerror(errno));
./cmd/zdb/zdb.c:3758:		fatal("internal error: %s", strerror(ENOMEM));
./cmd/zdb/zdb.c:3776:				    target, strerror(ENOMEM));
./cmd/zdb/zdb.c:3822:		fatal("can't open '%s': %s", target, strerror(error));
./cmd/zdb/zdb.c:3835:					    argv[i], strerror(errno));
./cmd/zhack/zhack.c:195:		    strerror(error));
./cmd/zhack/zhack.c:211:		    strerror(err));
./include/libuutil.h:75:uint32_t uu_error(void);
./include/libuutil.h:76:const char *uu_strerror(uint32_t);
./include/libuutil.h:85:extern void uu_warn(const char *, ...);
./include/libuutil.h:86:extern void uu_vwarn(const char *, va_list);
./include/sys/zrlock.h:48:#define	zrl_add(_z)	zrl_add_debug((_z), __func__)
./include/sys/zrlock.h:49:extern void zrl_add_debug(zrlock_t *, const char *);
./include/sys/spa.h:865:extern void spa_log_error(spa_t *spa, zio_t *zio);
./include/sys/spa.h:910:#define	spa_dbgmsg(spa, ...)			\
./include/sys/spa.h:913:		zfs_dbgmsg(__VA_ARGS__);	\
./include/sys/zfs_debug.h:58:#define	zfs_dbgmsg(...) \
./include/sys/zio.h:546:extern int zio_worst_error(int e1, int e2);
./include/sys/zap.h:54: * Any of the routines that return an int may return an I/O error (EIO
./include/sys/zfs_context.h:203: * "return (SET_ERROR(log_error(EINVAL, info)));" would log the error twice).
./include/sys/trace_dbgmsg.h:28: * This file defines tracepoint events for use by the dbgmsg(),
./include/sys/trace.h:35: * dprintf(), dbgmsg(), and SET_ERROR().
./include/sys/mntent.h:36:#define	MOUNT_SYSERR	0x02		/* System error (ENOMEM, etc) */
./include/sys/sdt.h:56: * "return (SET_ERROR(log_error(EINVAL, info)));" would log the error twice).
./include/sys/sdt.h:59:	(trace_zfs_set__error(__FILE__, __func__, __LINE__, err), err)
./include/sys/zio_checksum.h:68:extern int zio_checksum_error(zio_t *zio, zio_bad_cksum_t *out);
./include/libuutil_impl.h:42:void uu_set_error(uint_t);
./include/libzfs.h:200:extern void libzfs_print_on_error(libzfs_handle_t *, boolean_t);
./include/libzfs.h:209:extern int zfs_standard_error(libzfs_handle_t *, int, const char *);
./include/libzfs_impl.h:139:int zfs_error(libzfs_handle_t *, int, const char *);
./include/libzfs_impl.h:148:int zfs_standard_error(libzfs_handle_t *, int, const char *);
./include/libzfs_impl.h:150:int zpool_standard_error(libzfs_handle_t *, int, const char *);
./lib/libuutil/uu_alloc.c:38:		uu_set_error(UU_ERROR_SYSTEM);
./lib/libuutil/uu_list.c:71:		uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_list.c:76:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_list.c:82:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_list.c:185:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_list.c:194:		uu_set_error(UU_ERROR_NOT_SUPPORTED);
./lib/libuutil/uu_list.c:200:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_list.c:324:		uu_set_error(UU_ERROR_NOT_SUPPORTED);
./lib/libuutil/uu_list.c:461:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_list.c:467:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_list.c:505:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_list.c:535:	uu_set_error(UU_ERROR_CALLBACK_FAILED);
./lib/libuutil/uu_list.c:615:		uu_set_error(UU_ERROR_NOT_SUPPORTED);
./lib/libuutil/uu_list.c:641:		uu_set_error(UU_ERROR_NOT_SUPPORTED);
./lib/libuutil/uu_pname.c:97:		(void) fprintf(stderr, ERRNO_FMT, strerror(err));
./lib/libuutil/uu_pname.c:101:uu_vwarn(const char *format, va_list alist)
./lib/libuutil/uu_pname.c:108:uu_warn(const char *format, ...)
./lib/libuutil/uu_dprintf.c:72:		uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_ident.c:99:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_ident.c:120:	uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_avl.c:75:		uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_avl.c:80:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_avl.c:86:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_avl.c:215:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_avl.c:221:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_avl.c:368:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_avl.c:374:		uu_set_error(UU_ERROR_NO_MEMORY);
./lib/libuutil/uu_avl.c:404:		uu_set_error(UU_ERROR_UNKNOWN_FLAG);
./lib/libuutil/uu_avl.c:416:	uu_set_error(UU_ERROR_CALLBACK_FAILED);
./lib/libuutil/uu_misc.c:73:uu_set_error(uint_t code)
./lib/libuutil/uu_misc.c:102:uu_error(void)
./lib/libuutil/uu_misc.c:111:	 * Because UU_ERROR_NONE == 0, if uu_set_error() was
./lib/libuutil/uu_misc.c:118:uu_strerror(uint32_t code)
./lib/libuutil/uu_strtoint.c:58:		uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_strtoint.c:79:		uu_set_error(UU_ERROR_EMPTY);
./lib/libuutil/uu_strtoint.c:147:			uu_set_error(UU_ERROR_INVALID_CHAR);
./lib/libuutil/uu_strtoint.c:149:			uu_set_error(UU_ERROR_INVALID_DIGIT);
./lib/libuutil/uu_strtoint.c:152:				uu_set_error(UU_ERROR_UNDERFLOW);
./lib/libuutil/uu_strtoint.c:154:				uu_set_error(UU_ERROR_OVERFLOW);
./lib/libuutil/uu_strtoint.c:205:		uu_set_error(UU_ERROR_UNDERFLOW);
./lib/libuutil/uu_strtoint.c:208:		uu_set_error(UU_ERROR_OVERFLOW);
./lib/libuutil/uu_strtoint.c:230:	uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libuutil/uu_strtoint.c:273:		uu_set_error(UU_ERROR_UNDERFLOW);
./lib/libuutil/uu_strtoint.c:276:		uu_set_error(UU_ERROR_OVERFLOW);
./lib/libuutil/uu_strtoint.c:298:	uu_set_error(UU_ERROR_INVALID_ARGUMENT);
./lib/libzfs/libzfs_util.c:282:zfs_verror(libzfs_handle_t *hdl, int error, const char *fmt, va_list ap)
./lib/libzfs/libzfs_util.c:308:zfs_error(libzfs_handle_t *hdl, int error, const char *msg)
./lib/libzfs/libzfs_util.c:321:	zfs_verror(hdl, error, fmt, ap);
./lib/libzfs/libzfs_util.c:329:zfs_common_error(libzfs_handle_t *hdl, int error, const char *fmt,
./lib/libzfs/libzfs_util.c:335:		zfs_verror(hdl, EZFS_PERM, fmt, ap);
./lib/libzfs/libzfs_util.c:339:		zfs_verror(hdl, EZFS_NODELEGATION, fmt, ap);
./lib/libzfs/libzfs_util.c:343:		zfs_verror(hdl, EZFS_IO, fmt, ap);
./lib/libzfs/libzfs_util.c:347:		zfs_verror(hdl, EZFS_FAULT, fmt, ap);
./lib/libzfs/libzfs_util.c:351:		zfs_verror(hdl, EZFS_INTR, fmt, ap);
./lib/libzfs/libzfs_util.c:359:zfs_standard_error(libzfs_handle_t *hdl, int error, const char *msg)
./lib/libzfs/libzfs_util.c:372:	if (zfs_common_error(hdl, error, fmt, ap) != 0) {
./lib/libzfs/libzfs_util.c:381:		zfs_verror(hdl, EZFS_IO, fmt, ap);
./lib/libzfs/libzfs_util.c:387:		zfs_verror(hdl, EZFS_NOENT, fmt, ap);
./lib/libzfs/libzfs_util.c:392:		zfs_verror(hdl, EZFS_NOSPC, fmt, ap);
./lib/libzfs/libzfs_util.c:398:		zfs_verror(hdl, EZFS_EXISTS, fmt, ap);
./lib/libzfs/libzfs_util.c:404:		zfs_verror(hdl, EZFS_BUSY, fmt, ap);
./lib/libzfs/libzfs_util.c:407:		zfs_verror(hdl, EZFS_POOLREADONLY, fmt, ap);
./lib/libzfs/libzfs_util.c:410:		zfs_verror(hdl, EZFS_NAMETOOLONG, fmt, ap);
./lib/libzfs/libzfs_util.c:413:		zfs_verror(hdl, EZFS_BADVERSION, fmt, ap);
./lib/libzfs/libzfs_util.c:418:		zfs_verror(hdl, EZFS_POOLUNAVAIL, fmt, ap);
./lib/libzfs/libzfs_util.c:421:		zfs_error_aux(hdl, strerror(error));
./lib/libzfs/libzfs_util.c:422:		zfs_verror(hdl, EZFS_UNKNOWN, fmt, ap);
./lib/libzfs/libzfs_util.c:431:zpool_standard_error(libzfs_handle_t *hdl, int error, const char *msg)
./lib/libzfs/libzfs_util.c:444:	if (zfs_common_error(hdl, error, fmt, ap) != 0) {
./lib/libzfs/libzfs_util.c:451:		zfs_verror(hdl, EZFS_NODEVICE, fmt, ap);
./lib/libzfs/libzfs_util.c:457:		zfs_verror(hdl, EZFS_NOENT, fmt, ap);
./lib/libzfs/libzfs_util.c:463:		zfs_verror(hdl, EZFS_EXISTS, fmt, ap);
./lib/libzfs/libzfs_util.c:468:		zfs_verror(hdl, EZFS_BUSY, fmt, ap);
./lib/libzfs/libzfs_util.c:474:		zfs_verror(hdl, EZFS_BADDEV, fmt, ap);
./lib/libzfs/libzfs_util.c:478:		zfs_verror(hdl, EZFS_DEVOVERFLOW, fmt, ap);
./lib/libzfs/libzfs_util.c:482:		zfs_verror(hdl, EZFS_POOL_NOTSUP, fmt, ap);
./lib/libzfs/libzfs_util.c:486:		zfs_verror(hdl, EZFS_POOL_INVALARG, fmt, ap);
./lib/libzfs/libzfs_util.c:491:		zfs_verror(hdl, EZFS_NOSPC, fmt, ap);
./lib/libzfs/libzfs_util.c:497:		zfs_verror(hdl, EZFS_POOLUNAVAIL, fmt, ap);
./lib/libzfs/libzfs_util.c:501:		zfs_verror(hdl, EZFS_POOLREADONLY, fmt, ap);
./lib/libzfs/libzfs_util.c:505:		zfs_error_aux(hdl, strerror(error));
./lib/libzfs/libzfs_util.c:506:		zfs_verror(hdl, EZFS_UNKNOWN, fmt, ap);
./lib/libzfs/libzfs_util.c:519:	return (zfs_error(hdl, EZFS_NOMEM, "internal error"));
./lib/libzfs/libzfs_util.c:635:libzfs_print_on_error(libzfs_handle_t *hdl, boolean_t printerr)
./lib/libzfs/libzfs_util.c:868:		(void) fprintf(stderr, "%s: %s\n", path, strerror(errno));
./lib/libzfs/libzfs_util.c:1607:	(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_util.c:1635:		return (zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_util.c:1684:		return (zfs_error(hdl, EZFS_BADPROP, dgettext(TEXT_DOMAIN,
./lib/libzfs/libzfs_util.c:1710:			return (zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_sendrecv.c:64:extern void zfs_setprop_error(libzfs_handle_t *, zfs_prop_t, int, char *);
./lib/libzfs/libzfs_sendrecv.c:287:				if (ferror(stdin))
./lib/libzfs/libzfs_sendrecv.c:288:					perror("fread");
./lib/libzfs/libzfs_sendrecv.c:877:			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));
./lib/libzfs/libzfs_sendrecv.c:886:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:899:			zfs_error_aux(hdl, strerror(errno));
./lib/libzfs/libzfs_sendrecv.c:900:			return (zfs_error(hdl, EZFS_BADBACKUP, errbuf));
./lib/libzfs/libzfs_sendrecv.c:903:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_sendrecv.c:957:			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));
./lib/libzfs/libzfs_sendrecv.c:966:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:979:			zfs_error_aux(hdl, strerror(errno));
./lib/libzfs/libzfs_sendrecv.c:980:			return (zfs_error(hdl, EZFS_BADBACKUP, errbuf));
./lib/libzfs/libzfs_sendrecv.c:983:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1416:		return (zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1431:			zfs_error_aux(zhp->zfs_hdl, strerror(errno));
./lib/libzfs/libzfs_sendrecv.c:1432:			return (zfs_error(zhp->zfs_hdl, EZFS_PIPEFAILED,
./lib/libzfs/libzfs_sendrecv.c:1441:			zfs_error_aux(zhp->zfs_hdl, strerror(errno));
./lib/libzfs/libzfs_sendrecv.c:1442:			return (zfs_error(zhp->zfs_hdl,
./lib/libzfs/libzfs_sendrecv.c:1648:			return (zfs_standard_error(zhp->zfs_hdl,
./lib/libzfs/libzfs_sendrecv.c:1656:	err = zfs_standard_error(zhp->zfs_hdl, err, errbuf);
./lib/libzfs/libzfs_sendrecv.c:1689:			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1698:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1704:			return (zfs_error(hdl, EZFS_BUSY, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1717:			zfs_error_aux(hdl, strerror(errno));
./lib/libzfs/libzfs_sendrecv.c:1718:			return (zfs_error(hdl, EZFS_BADBACKUP, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1721:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_sendrecv.c:1748:		return (zfs_error(hdl, EZFS_BADSTREAM, dgettext(TEXT_DOMAIN,
./lib/libzfs/libzfs_sendrecv.c:2394:			error = zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:2405:		error = zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:2427:		error = zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:2433:		error = zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:2447:			error = zfs_error(hdl, EZFS_NOMEM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:2596:				return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2649:			return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2733:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2760:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2778:			return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2797:		return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2810:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2890:				return (zfs_error(hdl, EZFS_EXISTS, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2899:				return (zfs_error(hdl, EZFS_EXISTS, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2917:			return (zfs_error(hdl, EZFS_EXISTS, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2950:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:2962:			return (zfs_error(hdl, EZFS_BADRESTORE, errbuf));
./lib/libzfs/libzfs_sendrecv.c:3017:				zfs_setprop_error(hdl, prop, intval, tbuf);
./lib/libzfs/libzfs_sendrecv.c:3081:			(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3088:			(void) zfs_error(hdl, EZFS_BADRESTORE, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3104:			(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3109:			(void) zfs_error(hdl, EZFS_BADSTREAM, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3114:			(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3119:			(void) zfs_error(hdl, EZFS_NOSPC, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3122:			(void) zfs_standard_error(hdl, ioctl_errno, errbuf);
./lib/libzfs/libzfs_sendrecv.c:3214:		return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_sendrecv.c:3254:		return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:3265:		return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:3271:		return (zfs_error(hdl, EZFS_BADSTREAM, errbuf));
./lib/libzfs/libzfs_sendrecv.c:3320:		perror("fstat");
./lib/libzfs/libzfs_dataset.c:634:		(void) zfs_error(hdl, EZFS_INVALIDNAME, errbuf);
./lib/libzfs/libzfs_dataset.c:643:		(void) zfs_standard_error(hdl, errno, errbuf);
./lib/libzfs/libzfs_dataset.c:648:		(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:900:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:908:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:927:			(void) zfs_error(hdl, EZFS_PROPTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:944:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:953:				(void) zfs_error(hdl, EZFS_PROPREADONLY,
./lib/libzfs/libzfs_dataset.c:964:					(void) zfs_error(hdl,
./lib/libzfs/libzfs_dataset.c:980:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1005:			(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);
./lib/libzfs/libzfs_dataset.c:1012:			(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1020:			(void) zfs_error(hdl, EZFS_PROPTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:1029:			(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);
./lib/libzfs/libzfs_dataset.c:1052:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1078:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1132:			(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1138:			(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1168:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1199:					(void) zfs_error(hdl, EZFS_ZONED,
./lib/libzfs/libzfs_dataset.c:1207:					(void) zfs_error(hdl, EZFS_ZONED,
./lib/libzfs/libzfs_dataset.c:1219:				(void) zfs_error(hdl, EZFS_ZONED, errbuf);
./lib/libzfs/libzfs_dataset.c:1260:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:1276:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:1313:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:1327:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:1336:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:1364:		(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1410:zfs_setprop_error(libzfs_handle_t *hdl, zfs_prop_t prop, int err,
./lib/libzfs/libzfs_dataset.c:1427:			(void) zfs_error(hdl, EZFS_PROPSPACE, errbuf);
./lib/libzfs/libzfs_dataset.c:1434:			(void) zfs_error(hdl, EZFS_PROPSPACE, errbuf);
./lib/libzfs/libzfs_dataset.c:1438:			(void) zfs_standard_error(hdl, err, errbuf);
./lib/libzfs/libzfs_dataset.c:1444:		(void) zfs_standard_error(hdl, EBUSY, errbuf);
./lib/libzfs/libzfs_dataset.c:1448:		(void) zfs_error(hdl, EZFS_DSREADONLY, errbuf);
./lib/libzfs/libzfs_dataset.c:1454:		(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1461:		(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:1470:			(void) zfs_error(hdl, EZFS_NOTSUP, errbuf);
./lib/libzfs/libzfs_dataset.c:1472:			(void) zfs_standard_error(hdl, err, errbuf);
./lib/libzfs/libzfs_dataset.c:1478:			(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_dataset.c:1480:			(void) zfs_standard_error(hdl, err, errbuf);
./lib/libzfs/libzfs_dataset.c:1490:			(void) zfs_error(hdl, EZFS_VOLTOOBIG, errbuf);
./lib/libzfs/libzfs_dataset.c:1496:		(void) zfs_standard_error(hdl, err, errbuf);
./lib/libzfs/libzfs_dataset.c:1567:		ret = zfs_error(hdl, EZFS_ZONED, errbuf);
./lib/libzfs/libzfs_dataset.c:1598:		zfs_setprop_error(hdl, prop, errno, errbuf);
./lib/libzfs/libzfs_dataset.c:1671:			return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:1678:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_dataset.c:1687:		return (zfs_error(hdl, EZFS_PROPREADONLY, errbuf));
./lib/libzfs/libzfs_dataset.c:1690:		return (zfs_error(hdl, EZFS_PROPNONINHERIT, errbuf));
./lib/libzfs/libzfs_dataset.c:1696:		return (zfs_error(hdl, EZFS_PROPTYPE, errbuf));
./lib/libzfs/libzfs_dataset.c:1709:		return (zfs_error(hdl, EZFS_ZONED, errbuf));
./lib/libzfs/libzfs_dataset.c:1722:		ret = zfs_error(hdl, EZFS_ZONED, errbuf);
./lib/libzfs/libzfs_dataset.c:1730:		return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_dataset.c:2024:			return (zfs_error(zhp->zfs_hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_dataset.c:2934:		return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:2946:		return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_dataset.c:2958:				return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_dataset.c:2963:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_dataset.c:2965:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_dataset.c:2974:		(void) zfs_standard_error(hdl, EPERM, errbuf);
./lib/libzfs/libzfs_dataset.c:2983:		(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:3135:		return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3151:		return (zfs_error(hdl, EZFS_EXISTS, errbuf));
./lib/libzfs/libzfs_dataset.c:3176:			return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:3189:				return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:3197:			return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:3205:			return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:3224:			return (zfs_error(hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_dataset.c:3229:			return (zfs_error(hdl, EZFS_BADTYPE, errbuf));
./lib/libzfs/libzfs_dataset.c:3237:			return (zfs_error(hdl, EZFS_BADPROP, errbuf));
./lib/libzfs/libzfs_dataset.c:3243:			return (zfs_error(hdl, EZFS_BADVERSION, errbuf));
./lib/libzfs/libzfs_dataset.c:3250:				return (zfs_error(hdl, EZFS_VOLTOOBIG,
./lib/libzfs/libzfs_dataset.c:3255:			return (zfs_standard_error(hdl, errno, errbuf));
./lib/libzfs/libzfs_dataset.c:3373:		ret = zfs_standard_error(hdl, ret, errbuf);
./lib/libzfs/libzfs_dataset.c:3386:			ret = zfs_error(hdl, EZFS_EXISTS, errbuf);
./lib/libzfs/libzfs_dataset.c:3389:			ret = zfs_standard_error(hdl, errno, errbuf);
./lib/libzfs/libzfs_dataset.c:3416:		return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3456:			return (zfs_error(zhp->zfs_hdl, EZFS_NOENT, errbuf));
./lib/libzfs/libzfs_dataset.c:3461:			return (zfs_error(zhp->zfs_hdl, EZFS_CROSSTARGET,
./lib/libzfs/libzfs_dataset.c:3465:			return (zfs_standard_error(zhp->zfs_hdl, errno,
./lib/libzfs/libzfs_dataset.c:3491:		return (zfs_error(hdl, EZFS_BADTYPE, errbuf));
./lib/libzfs/libzfs_dataset.c:3498:		return (zfs_error(hdl, EZFS_BADTYPE, errbuf));
./lib/libzfs/libzfs_dataset.c:3515:			return (zfs_error(hdl, EZFS_EXISTS, errbuf));
./lib/libzfs/libzfs_dataset.c:3518:			return (zfs_standard_error(hdl, save_errno, errbuf));
./lib/libzfs/libzfs_dataset.c:3574:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3594:			(void) zfs_standard_error(hdl,
./lib/libzfs/libzfs_dataset.c:3604:				(void) zfs_error(hdl, EZFS_EXISTS, errbuf);
./lib/libzfs/libzfs_dataset.c:3608:				(void) zfs_standard_error(hdl, ret, errbuf);
./lib/libzfs/libzfs_dataset.c:3633:		return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3843:				return (zfs_error(hdl, EZFS_CROSSTARGET,
./lib/libzfs/libzfs_dataset.c:3848:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3853:			return (zfs_error(hdl, EZFS_BADTYPE, errbuf));
./lib/libzfs/libzfs_dataset.c:3857:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3869:			return (zfs_error(hdl, EZFS_CROSSTARGET, errbuf));
./lib/libzfs/libzfs_dataset.c:3877:			return (zfs_error(hdl, EZFS_INVALIDNAME, errbuf));
./lib/libzfs/libzfs_dataset.c:3888:		return (zfs_error(hdl, EZFS_ZONED, errbuf));
./lib/libzfs/libzfs_dataset.c:3915:			(void) zfs_error(hdl, EZFS_ZONED, errbuf);
./lib/libzfs/libzfs_dataset.c:3946:			(void) zfs_error(hdl, EZFS_EXISTS, errbuf);
./lib/libzfs/libzfs_dataset.c:3948:			(void) zfs_standard_error(zhp->zfs_hdl, errno, errbuf);
./lib/libzfs/libzfs_dataset.c:4296:		(void) zfs_standard_error(zhp->zfs_hdl, ret, errbuf);
./lib/libzfs/libzfs_dataset.c:4332:			(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:4335:			(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4338:			(void) zfs_standard_error(hdl, ret, errbuf);
./lib/libzfs/libzfs_dataset.c:4356:			(void) zfs_error(hdl, EZFS_TAGTOOLONG, errbuf);
./lib/libzfs/libzfs_dataset.c:4359:			(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4362:			(void) zfs_error(hdl, EZFS_REFTAG_HOLD, errbuf);
./lib/libzfs/libzfs_dataset.c:4365:			(void) zfs_standard_error(hdl,
./lib/libzfs/libzfs_dataset.c:4428:			(void) zfs_error(hdl, EZFS_REFTAG_RELE, errbuf);
./lib/libzfs/libzfs_dataset.c:4430:			(void) zfs_standard_error(hdl, ret, errbuf);
./lib/libzfs/libzfs_dataset.c:4452:			(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:4468:			(void) zfs_error(hdl, EZFS_REFTAG_RELE, errbuf);
./lib/libzfs/libzfs_dataset.c:4471:			(void) zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4500:		err = (zfs_error(hdl, EZFS_NOMEM, strerror(errno)));
./lib/libzfs/libzfs_dataset.c:4522:			err = zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:4525:			err = zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4528:			err = zfs_error(hdl, EZFS_NOENT, errbuf);
./lib/libzfs/libzfs_dataset.c:4585:			err = zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:4588:			err = zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4591:			err = zfs_error(hdl, EZFS_NOENT, errbuf);
./lib/libzfs/libzfs_dataset.c:4622:			err = zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_dataset.c:4625:			err = zfs_error(hdl, EZFS_BADTYPE, errbuf);
./lib/libzfs/libzfs_dataset.c:4628:			err = zfs_error(hdl, EZFS_NOENT, errbuf);
./lib/libzfs/libzfs_config.c:152:				return (zfs_standard_error(hdl, errno,
./lib/libzfs/libzfs_import.c:1109:			zfs_error_aux(hdl, strerror(errno));
./lib/libzfs/libzfs_import.c:1131:			zfs_error_aux(hdl, strerror(errno));
./lib/libzfs/libzfs_import.c:1298:		zfs_error_aux(hdl, "%s", strerror(errno));
./lib/libzfs/libzfs_import.c:1299:		(void) zfs_error(hdl, EZFS_BADCACHE,
./lib/libzfs/libzfs_import.c:1305:		zfs_error_aux(hdl, "%s", strerror(errno));
./lib/libzfs/libzfs_import.c:1307:		(void) zfs_error(hdl, EZFS_BADCACHE,
./lib/libzfs/libzfs_import.c:1320:		(void) zfs_error(hdl, EZFS_BADCACHE,
./lib/libzfs/libzfs_import.c:1330:		(void) zfs_error(hdl, EZFS_BADCACHE,
./lib/libzfs/libzfs_iter.c:91:			rc = zfs_standard_error(zhp->zfs_hdl, errno,
./lib/libzfs/libzfs_iter.c:484:					err = zfs_error(zhp->zfs_hdl,
./lib/libzfs/libzfs_diff.c:434:		strncpy(di->errbuf, strerror(errno), sizeof (di->errbuf));
./lib/libzfs/libzfs_diff.c:500:		return (zfs_error(di->zhp->zfs_hdl, EZFS_DIFF, di->errbuf));
./lib/libzfs/libzfs_diff.c:525:			return (zfs_error(hdl, EZFS_DIFF, di->errbuf));
./lib/libzfs/libzfs_diff.c:530:			return (zfs_standard_error(hdl, err, di->errbuf));
./lib/libzfs/libzfs_diff.c:578:			return (zfs_error(hdl, EZFS_INVALIDNAME,
./lib/libzfs/libzfs_diff.c:607:		return (zfs_error(hdl, EZFS_INVALIDNAME, di->errbuf));
./lib/libzfs/libzfs_diff.c:641:			return (zfs_error(hdl, EZFS_INVALIDNAME, di->errbuf));
./lib/libzfs/libzfs_diff.c:680:		return (zfs_error(di->zhp->zfs_hdl, EZFS_BADTYPE, di->errbuf));
./lib/libzfs/libzfs_diff.c:772:		zfs_error_aux(zhp->zfs_hdl, strerror(errno));
./lib/libzfs/libzfs_diff.c:774:		return (zfs_error(zhp->zfs_hdl, EZFS_PIPEFAILED, errbuf));
./lib/libzfs/libzfs_diff.c:785:		zfs_error_aux(zhp->zfs_hdl, strerror(errno));
./lib/libzfs/libzfs_diff.c:789:		return (zfs_error(zhp->zfs_hdl,
./lib/libzfs/libzfs_diff.c:811:			zfs_error_aux(zhp->zfs_hdl, strerror(errno));
./lib/libzfs/libzfs_diff.c:818:			zfs_error_aux(zhp->zfs_hdl, strerror(di.zerr));
./lib/libzfs/libzfs_diff.c:819:			return (zfs_error(zhp->zfs_hdl, EZFS_DIFF, di.errbuf));
./lib/libzfs/libzfs_diff.c:821:			return (zfs_error(zhp->zfs_hdl, EZFS_DIFFDATA, errbuf));
./lib/libzfs/libzfs_diff.c:829:		zfs_error_aux(zhp->zfs_hdl, strerror(di.zerr));
./lib/libzfs/libzfs_diff.c:830:		return (zfs_error(zhp->zfs_hdl, EZFS_DIFF, di.errbuf));
./lib/libzfs/libzfs_mount.c:496:			zfs_error_aux(hdl, strerror(rc));
./lib/libzfs/libzfs_pool.c:489:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:496:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:505:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:522:			(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:529:			(void) zfs_error(hdl, EZFS_PROPREADONLY, errbuf);
./lib/libzfs/libzfs_pool.c:549:				(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_pool.c:559:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:567:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:577:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:585:				(void) zfs_error(hdl, EZFS_BADVERSION, errbuf);
./lib/libzfs/libzfs_pool.c:597:				(void) zfs_error(hdl, EZFS_INVALIDNAME, errbuf);
./lib/libzfs/libzfs_pool.c:604:				(void) zfs_error(hdl, EZFS_OPENFAILED, errbuf);
./lib/libzfs/libzfs_pool.c:619:				(void) zfs_error(hdl, EZFS_POOL_NOTSUP, errbuf);
./lib/libzfs/libzfs_pool.c:632:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:639:				(void) zfs_error(hdl, EZFS_BADPATH, errbuf);
./lib/libzfs/libzfs_pool.c:655:				(void) zfs_error(hdl, EZFS_BADPATH, errbuf);
./lib/libzfs/libzfs_pool.c:665:				(void) zfs_error(hdl, EZFS_BADPATH, errbuf);
./lib/libzfs/libzfs_pool.c:677:				(void) zfs_error(hdl, EZFS_BADPATH, errbuf);
./lib/libzfs/libzfs_pool.c:691:					(void) zfs_error(hdl, EZFS_BADPROP,
./lib/libzfs/libzfs_pool.c:700:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:709:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:718:				(void) zfs_error(hdl, EZFS_BADPROP, errbuf);
./lib/libzfs/libzfs_pool.c:783:		(void) zpool_standard_error(zhp->zpool_hdl, errno, errbuf);
./lib/libzfs/libzfs_pool.c:1196:		return (zfs_error(hdl, EZFS_INVALIDNAME, msg));
./lib/libzfs/libzfs_pool.c:1256:			return (zfs_error(hdl, EZFS_BADDEV, msg));
./lib/libzfs/libzfs_pool.c:1274:			return (zfs_error(hdl, EZFS_BADDEV, msg));
./lib/libzfs/libzfs_pool.c:1279:			return (zfs_error(hdl, EZFS_BADDEV, msg));
./lib/libzfs/libzfs_pool.c:1284:			return (zfs_error(hdl, EZFS_BADDEV, msg));
./lib/libzfs/libzfs_pool.c:1287:			return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:1324:			(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:1326:			(void) zpool_standard_error(hdl, errno, msg);
./lib/libzfs/libzfs_pool.c:1365:		return (zfs_error(hdl, EZFS_BADVERSION, msg));
./lib/libzfs/libzfs_pool.c:1383:				return (zfs_error(hdl, EZFS_POOL_NOTSUP, msg));
./lib/libzfs/libzfs_pool.c:1395:		return (zfs_error(hdl, EZFS_BADVERSION, msg));
./lib/libzfs/libzfs_pool.c:1413:			(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:1432:			(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:1438:			(void) zfs_error(hdl, EZFS_BADVERSION, msg);
./lib/libzfs/libzfs_pool.c:1444:			(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:1448:			(void) zpool_standard_error(hdl, errno, msg);
./lib/libzfs/libzfs_pool.c:1488:			return (zfs_error(zhp->zpool_hdl, EZFS_ACTIVE_SPARE,
./lib/libzfs/libzfs_pool.c:1859:			(void) zfs_error(hdl, EZFS_BADVERSION, desc);
./lib/libzfs/libzfs_pool.c:1863:			(void) zfs_error(hdl, EZFS_INVALCONFIG, desc);
./lib/libzfs/libzfs_pool.c:1869:			(void) zfs_error(hdl, EZFS_BADDEV, desc);
./lib/libzfs/libzfs_pool.c:1883:			(void) zpool_standard_error(hdl, error, desc);
./lib/libzfs/libzfs_pool.c:1887:			(void) zpool_standard_error(hdl, error, desc);
./lib/libzfs/libzfs_pool.c:1893:			(void) zfs_error(hdl, EZFS_BADDEV, desc);
./lib/libzfs/libzfs_pool.c:1897:			(void) zpool_standard_error(hdl, error, desc);
./lib/libzfs/libzfs_pool.c:1968:			return (zfs_error(hdl, EZFS_SCRUBBING, msg));
./lib/libzfs/libzfs_pool.c:1970:			return (zfs_error(hdl, EZFS_RESILVERING, msg));
./lib/libzfs/libzfs_pool.c:1972:		return (zfs_error(hdl, EZFS_NO_SCRUB, msg));
./lib/libzfs/libzfs_pool.c:1974:		return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:2383:		return (zfs_error(hdl, EZFS_OPENFAILED, msg));
./lib/libzfs/libzfs_pool.c:2399:		return (zfs_error(hdl, EZFS_NOCAP, msg));
./lib/libzfs/libzfs_pool.c:2430:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:2435:		return (zfs_error(hdl, EZFS_ISSPARE, msg));
./lib/libzfs/libzfs_pool.c:2450:			return (zfs_error(hdl, EZFS_VDEVNOTSUP, msg));
./lib/libzfs/libzfs_pool.c:2461:					return (zfs_error(hdl, EZFS_NODEVICE,
./lib/libzfs/libzfs_pool.c:2481:			return (zfs_error(hdl, EZFS_POSTSPLIT_ONLINE, msg));
./lib/libzfs/libzfs_pool.c:2483:		return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:2508:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:2513:		return (zfs_error(hdl, EZFS_ISSPARE, msg));
./lib/libzfs/libzfs_pool.c:2527:		return (zfs_error(hdl, EZFS_NOREPLICAS, msg));
./lib/libzfs/libzfs_pool.c:2533:		return (zfs_error(hdl, EZFS_UNPLAYED_LOGS, msg));
./lib/libzfs/libzfs_pool.c:2536:		return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:2567:		return (zfs_error(hdl, EZFS_NOREPLICAS, msg));
./lib/libzfs/libzfs_pool.c:2570:		return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:2596:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:2663:		return (zfs_error(hdl, EZFS_POOL_NOTSUP, msg));
./lib/libzfs/libzfs_pool.c:2670:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:2673:		return (zfs_error(hdl, EZFS_ISSPARE, msg));
./lib/libzfs/libzfs_pool.c:2676:		return (zfs_error(hdl, EZFS_ISL2CACHE, msg));
./lib/libzfs/libzfs_pool.c:2685:		return (zfs_error(hdl, EZFS_INVALCONFIG, msg));
./lib/libzfs/libzfs_pool.c:2706:		return (zfs_error(hdl, EZFS_BADTARGET, msg));
./lib/libzfs/libzfs_pool.c:2755:		(void) zfs_error(hdl, EZFS_BADTARGET, msg);
./lib/libzfs/libzfs_pool.c:2764:		(void) zfs_error(hdl, EZFS_INVALCONFIG, msg);
./lib/libzfs/libzfs_pool.c:2770:		(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:2779:		(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:2789:		(void) zfs_error(hdl, EZFS_BADDEV, msg);
./lib/libzfs/libzfs_pool.c:2796:		(void) zfs_error(hdl, EZFS_DEVOVERFLOW, msg);
./lib/libzfs/libzfs_pool.c:2800:		(void) zpool_standard_error(hdl, errno, msg);
./lib/libzfs/libzfs_pool.c:2824:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:2827:		return (zfs_error(hdl, EZFS_ISSPARE, msg));
./lib/libzfs/libzfs_pool.c:2830:		return (zfs_error(hdl, EZFS_ISL2CACHE, msg));
./lib/libzfs/libzfs_pool.c:2845:		(void) zfs_error(hdl, EZFS_BADTARGET, msg);
./lib/libzfs/libzfs_pool.c:2852:		(void) zfs_error(hdl, EZFS_NOREPLICAS, msg);
./lib/libzfs/libzfs_pool.c:2856:		(void) zpool_standard_error(hdl, errno, msg);
./lib/libzfs/libzfs_pool.c:2924:		return (zfs_error(hdl, EZFS_INVALIDNAME, msg));
./lib/libzfs/libzfs_pool.c:2998:			retval = zfs_error(hdl, EZFS_INVALCONFIG, msg);
./lib/libzfs/libzfs_pool.c:3025:		retval = zfs_error(hdl, EZFS_INVALCONFIG, msg);
./lib/libzfs/libzfs_pool.c:3080:		retval = zpool_standard_error(hdl, errno, msg);
./lib/libzfs/libzfs_pool.c:3134:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:3142:		return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:3149:		return (zfs_error(hdl, EZFS_BADVERSION, msg));
./lib/libzfs/libzfs_pool.c:3157:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:3188:			return (zfs_error(hdl, EZFS_NODEVICE, msg));
./lib/libzfs/libzfs_pool.c:3195:			return (zfs_error(hdl, EZFS_ISSPARE, msg));
./lib/libzfs/libzfs_pool.c:3233:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:3257:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:3277:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:3297:	return (zpool_standard_error(hdl, errno, msg));
./lib/libzfs/libzfs_pool.c:4150:			return (zfs_error(hdl, EZFS_POOL_NOTSUP, errbuf));
./lib/libzfs/libzfs_pool.c:4176:		return (zfs_error(hdl, EZFS_OPENFAILED, errbuf));
./lib/libzfs/libzfs_pool.c:4191:		return (zfs_error(hdl, EZFS_NOCAP, errbuf));
./lib/libzfs/libzfs_pool.c:4231:		return (zfs_error(hdl, EZFS_LABELFAILED, errbuf));
./lib/libzfs/libzfs_pool.c:4246:		return (zfs_error(hdl, EZFS_LABELFAILED, errbuf));
./lib/libzfs/libzfs_pool.c:4257:		return (zfs_error(hdl, EZFS_LABELFAILED, errbuf));
./lib/libzfs/libzfs_graph.c:568:		return (zfs_error(hdl, EZFS_RECURSIVE,
./lib/libzfs/libzfs_changelist.c:571:		assert(uu_error() == UU_ERROR_NO_MEMORY);
./lib/libzfs/libzfs_changelist.c:572:		(void) zfs_error(zhp->zfs_hdl, EZFS_NOMEM, "internal error");
./lib/libzfs/libzfs_changelist.c:583:		assert(uu_error() == UU_ERROR_NO_MEMORY);
./lib/libzfs/libzfs_changelist.c:584:		(void) zfs_error(zhp->zfs_hdl, EZFS_NOMEM, "internal error");
./lib/libshare/libshare.c:94:		libzfs_print_on_error(impl_handle->zfs_libhandle, B_TRUE);

== environment() ==
./cmd/zinject/translate.c:348:	debug = (getenv("ZINJECT_DEBUG") != NULL);
./cmd/zed/zed_event.c:744:		if ((val = getenv(*keyp)))
./cmd/zfs/zfs_main.c:473:	if (getenv("ZFS_ABORT") != NULL) {
./cmd/zfs/zfs_main.c:6744:	if (getenv("ZFS_ABORT") != NULL) {
./cmd/zpool/zpool_main.c:364:	if (getenv("ZFS_ABORT") != NULL) {
./cmd/zpool/zpool_main.c:2272:	if ((searchdirs == NULL) && (env = getenv("ZPOOL_IMPORT_PATH"))) {
./cmd/zpool/zpool_main.c:5984:	if (getenv("ZFS_ABORT") != NULL) {
./cmd/ztest/ztest.c:6234:		VERIFY(0 == setenv("ZTEST_FD_DATA", fd_data_str, 1));
./cmd/ztest/ztest.c:6238:			VERIFY(0 == setenv("LD_LIBRARY_PATH", libpath, 1));
./cmd/ztest/ztest.c:6318:	char *fd_data_str = getenv("ZTEST_FD_DATA");
./cmd/zdb/zdb.c:3616:	spa_config_path_env = getenv("SPA_CONFIG_PATH");
./lib/libzpool/kernel.c:169:		stkstr = getenv("ZFS_STACK_SIZE");
./lib/libzpool/kernel.c:835:		dprintf_string = getenv("ZFS_DEBUG");
./lib/libspl/include/sys/tzfile.h:43:#define	TZDEFAULT	(getenv("TZ"))
./lib/libuutil/uu_pname.c:125:			cp = getenv("UU_DIE_ABORTS");
./lib/libzfs/libzfs_util.c:710:		load_str = getenv("ZFS_MODULE_LOADING");
./lib/libzfs/libzfs_util.c:735:	timeout_str = getenv("ZFS_MODULE_TIMEOUT");
./lib/libzfs/libzfs_util.c:940:	env = getenv("ZPOOL_IMPORT_PATH");
./lib/libzfs/libzfs_util.c:978:	env = getenv("ZPOOL_IMPORT_PATH");
./lib/libzfs/libzfs_config.c:359:		restricted = getenv("__ZFS_POOL_RESTRICT");

== privileged() ==
./module/zcommon/zfs_prop.c:285:	zprop_register_index(ZFS_PROP_SETUID, "setuid", 1, PROP_INHERIT,
./module/zfs/zpl_super.c:246:		zmo->z_setuid = B_TRUE;
./module/zfs/zpl_super.c:247:		zmo->z_do_setuid = B_TRUE;
./module/zfs/zpl_super.c:250:		zmo->z_setuid = B_FALSE;
./module/zfs/zpl_super.c:251:		zmo->z_do_setuid = B_TRUE;
./module/zfs/zfs_vnops.c:2634:				 * Remove setuid/setgid for non-privileged users
./module/zfs/zfs_acl.c:1829:		    secpolicy_vnode_setids_setgids(cr, gid) != 0)
./module/zfs/zfs_vfsops.c:218:setuid_changed_cb(void *arg, uint64_t newval)
./module/zfs/zfs_vfsops.c:304:	    zfs_prop_to_name(ZFS_PROP_SETUID), setuid_changed_cb, zsb);
./module/zfs/zfs_vfsops.c:326:	if (zmo->z_do_setuid)
./module/zfs/zfs_vfsops.c:327:		setuid_changed_cb(zsb, zmo->z_setuid);
./module/zfs/zfs_vfsops.c:362:	    setuid_changed_cb, zsb);
./module/zfs/zfs_vfsops.c:987:		VERIFY(dsl_prop_unregister(ds, "setuid", setuid_changed_cb,
./include/sys/zfs_vfsops.h:50:	boolean_t	z_setuid;
./include/sys/zfs_vfsops.h:51:	boolean_t	z_do_setuid;
./include/sys/mntent.h:73:#define	MNTOPT_SETUID	"suid"		/* Both setuid and devices allowed */
./include/sys/mntent.h:74:#define	MNTOPT_NOSETUID	"nosuid"	/* Neither setuid nor devices allowed */
./module/zpios/pios.c:1134:zpios_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
./module/zpios/pios.c:1161:zpios_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
./module/zpios/pios.c:1163:	return (zpios_unlocked_ioctl(file, cmd, arg));
./module/zcommon/zfs_namecheck.c:31: * userland code as well as the ioctl() layer to ensure that we don't
./module/zcommon/zfs_namecheck.c:32: * inadvertently expose a hole through direct ioctl()s that never gets tested.
./module/zfs/zfs_ioctl.c:43: * of the marshalling is handled in the common entry point, zfsdev_ioctl().
./module/zfs/zfs_ioctl.c:47: * from userland by lzc_ioctl().
./module/zfs/zfs_ioctl.c:58: *   The ioctl request number, which userland will pass to ioctl(2).
./module/zfs/zfs_ioctl.c:5780:zfsdev_ioctl(struct file *filp, unsigned cmd, unsigned long arg)
./module/zfs/zfs_ioctl.c:5939:zfsdev_compat_ioctl(struct file *filp, unsigned cmd, unsigned long arg)
./module/zfs/zfs_ioctl.c:5941:	return (zfsdev_ioctl(filp, cmd, arg));
./module/zfs/zpl_xattr.c:975:	error = __posix_acl_chmod(&acl, GFP_KERNEL, ip->i_mode);
./module/zfs/zfs_acl.c:1465:zfs_acl_chmod(zfs_sb_t *zsb, uint64_t mode, zfs_acl_t *aclp)
./module/zfs/zfs_acl.c:1580:	zfs_acl_chmod(ZTOZSB(zp), mode, *aclp);
./module/zfs/zfs_acl.c:1669:		 * then zfs_acl_chmod() isn't needed.
./module/zfs/zfs_acl.c:1854:			zfs_acl_chmod(zsb, acl_ids->z_mode, acl_ids->z_aclp);
./module/zfs/zfs_acl.c:2604:			error = secpolicy_vnode_chown(cr, owner);
./module/zfs/zfs_acl.c:2613:			error = secpolicy_vnode_chown(cr, owner);
./module/zfs/zpl_file.c:785:zpl_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
./module/zfs/zpl_file.c:799:zpl_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
./module/zfs/zpl_file.c:801:	return (zpl_ioctl(filp, cmd, arg));
./module/zfs/zvol.c:1042:zvol_ioctl(struct block_device *bdev, fmode_t mode,
./module/zfs/zvol.c:1070:zvol_compat_ioctl(struct block_device *bdev, fmode_t mode,
./module/zfs/zvol.c:1073:	return (zvol_ioctl(bdev, mode, cmd, arg));
./module/zfs/zvol.c:1169:	return (zvol_ioctl(inode->i_bdev, file->f_mode, cmd, arg));
./module/zfs/zvol.c:1180:	return (zvol_compat_ioctl(file->f_dentry->d_inode->i_bdev,
./module/zfs/spa_misc.c:206: *	an explicit vdev_t argument -- such as zio_ioctl(), zio_read_phys(),
./module/zfs/zio.c:898:zio_ioctl(zio_t *pio, spa_t *spa, vdev_t *vd, int cmd,
./module/zfs/zio.c:914:			zio_nowait(zio_ioctl(zio, spa, vd->vdev_child[c], cmd,
./module/zfs/zio.c:1044:	zio_nowait(zio_ioctl(zio, zio->io_spa, vd, DKIOCFLUSHWRITECACHE,
./module/zfs/zpl_inode.c:132:zpl_mknod(struct inode *dir, struct dentry *dentry, zpl_umode_t mode,
./cmd/zpios/zpios_main.c:356:	rc = ioctl(zpiosctl_fd, ZPIOS_CFG, &cfg);
./cmd/zpios/zpios_main.c:378:	rc = ioctl(zpiosctl_fd, ZPIOS_CFG, &cfg);
./cmd/zpios/zpios_main.c:515:	rc = ioctl(zpiosctl_fd, ZPIOS_CMD, cmd);
./cmd/zinject/zinject.c:94: * kernel via a special ioctl() to initiate fault injection for the given
./cmd/zinject/zinject.c:131: * internal tuple using libzpool, and then issues an ioctl() to register the
./cmd/zinject/zinject.c:301:	while (ioctl(zfs_fd, ZFS_IOC_INJECT_LIST_NEXT, &zc) == 0)
./cmd/zinject/zinject.c:427:	if (ioctl(zfs_fd, ZFS_IOC_CLEAR_FAULT, &zc) != 0) {
./cmd/zinject/zinject.c:460:	if (ioctl(zfs_fd, ZFS_IOC_CLEAR_FAULT, &zc) != 0) {
./cmd/zinject/zinject.c:484:	if (ioctl(zfs_fd, ZFS_IOC_INJECT_FAULT, &zc) != 0) {
./cmd/zinject/zinject.c:542:	if (ioctl(zfs_fd, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)
./cmd/zinject/zinject.c:962:	 * If this is pool-wide metadata, unmount everything.  The ioctl() will
./cmd/zvol_id/zvol_id_main.c:44:	error = ioctl(fd, BLKZNAME, msg);
./cmd/zpool/zpool_main.c:2679:		error = ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws);
./cmd/zpool/zpool_main.c:5967:		return (!!ioctl(fd, ZFS_IOC_POOL_FREEZE, buf));
./cmd/zpool/zpool_vdev.c:258:	error = ioctl(fd, SG_IO, (unsigned long) &io_hdr);
./include/sys/zio.h:492:extern zio_t *zio_ioctl(zio_t *pio, spa_t *spa, vdev_t *vd, int cmd,
./include/linux/vfs_compat.h:269:#define	__posix_acl_chmod(acl, gfp, mode)	posix_acl_chmod(acl, gfp, mode)
./include/linux/vfs_compat.h:273:__posix_acl_chmod(struct posix_acl **acl, int flags, umode_t umode) {
./include/libzfs.h:421:extern int zfs_ioctl(libzfs_handle_t *, int, struct zfs_cmd *);
./lib/libspl/include/sys/kstat.h:57: *	kcid = ioctl(kd, KSTAT_IOC_CHAIN_ID, NULL);
./lib/libspl/include/sys/kstat.h:58: *	kcid = ioctl(kd, KSTAT_IOC_READ, kstat_t *);
./lib/libspl/include/sys/kstat.h:59: *	kcid = ioctl(kd, KSTAT_IOC_WRITE, kstat_t *);
./lib/libspl/include/sys/kstat.h:183: * coming online) between ioctl()s.
./lib/libspl/include/sys/stat.h:44:		if (ioctl(fd, BLKGETSIZE64, &st->st_size) != 0)
./lib/libzfs_core/libzfs_core.c:119:lzc_ioctl(zfs_ioc_t ioc, const char *name,
./lib/libzfs_core/libzfs_core.c:146:	while (ioctl(g_fd, ioc, &zc) != 0) {
./lib/libzfs_core/libzfs_core.c:180:	error = lzc_ioctl(ZFS_IOC_CREATE, fsname, args, NULL);
./lib/libzfs_core/libzfs_core.c:194:	error = lzc_ioctl(ZFS_IOC_CLONE, fsname, args, NULL);
./lib/libzfs_core/libzfs_core.c:236:	error = lzc_ioctl(ZFS_IOC_SNAPSHOT, pool, args, errlist);
./lib/libzfs_core/libzfs_core.c:286:	error = lzc_ioctl(ZFS_IOC_DESTROY_SNAPS, pool, args, errlist);
./lib/libzfs_core/libzfs_core.c:312:	err = lzc_ioctl(ZFS_IOC_SPACE_SNAPS, lastsnap, args, &result);
./lib/libzfs_core/libzfs_core.c:326:	 * own zfs_cmd_t rather than using zfsc_ioctl().
./lib/libzfs_core/libzfs_core.c:331:	return (ioctl(g_fd, ZFS_IOC_OBJSET_STATS, &zc) == 0);
./lib/libzfs_core/libzfs_core.c:381:	error = lzc_ioctl(ZFS_IOC_HOLD, pool, args, errlist);
./lib/libzfs_core/libzfs_core.c:421:	return (lzc_ioctl(ZFS_IOC_RELEASE, pool, holds, errlist));
./lib/libzfs_core/libzfs_core.c:436:	error = lzc_ioctl(ZFS_IOC_GET_HOLDS, snapname, innvl, holdsp);
./lib/libzfs_core/libzfs_core.c:482:	err = lzc_ioctl(ZFS_IOC_SEND_NEW, snapname, args, NULL);
./lib/libzfs_core/libzfs_core.c:512:	err = lzc_ioctl(ZFS_IOC_SEND_SPACE, snapname, args, &result);
./lib/libzfs_core/libzfs_core.c:558:	 * zfs_cmd_t rather than using zfsc_ioctl().
./lib/libzfs_core/libzfs_core.c:614:	error = ioctl(g_fd, ZFS_IOC_RECV, &zc);
./lib/libzfs_core/libzfs_core.c:640:	err = lzc_ioctl(ZFS_IOC_ROLLBACK, fsname, args, &result);
./lib/libzfs_core/libzfs_core.c:676:	error = lzc_ioctl(ZFS_IOC_BOOKMARK, pool, bookmarks, errlist);
./lib/libzfs_core/libzfs_core.c:705:	return (lzc_ioctl(ZFS_IOC_GET_BOOKMARKS, fsname, props, bmarks));
./lib/libzfs_core/libzfs_core.c:738:	error = lzc_ioctl(ZFS_IOC_DESTROY_BOOKMARKS, pool, bmarks, errlist);
./lib/libzfs/libzfs_util.c:1059: * an ioctl().
./lib/libzfs/libzfs_util.c:1075: * Called when an ioctl() which returns an nvlist fails with ENOMEM.  This will
./lib/libzfs/libzfs_util.c:1149:zfs_ioctl(libzfs_handle_t *hdl, int request, zfs_cmd_t *zc)
./lib/libzfs/libzfs_util.c:1151:	return (ioctl(hdl->libzfs_fd, request, zc));
./lib/libzfs/libzfs_sendrecv.c:853:estimate_ioctl(zfs_handle_t *zhp, uint64_t fromsnap_obj,
./lib/libzfs/libzfs_sendrecv.c:868:	if (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SEND, &zc) != 0) {
./lib/libzfs/libzfs_sendrecv.c:917:dump_ioctl(zfs_handle_t *zhp, const char *fromsnap, uint64_t fromsnap_obj,
./lib/libzfs/libzfs_sendrecv.c:941:	if (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_SEND, &zc) != 0) {
./lib/libzfs/libzfs_sendrecv.c:1036:		if (zfs_ioctl(hdl, ZFS_IOC_SEND_PROGRESS, &zc) != 0)
./lib/libzfs/libzfs_sendrecv.c:1136:		err = estimate_ioctl(zhp, sdd->prevsnap_obj,
./lib/libzfs/libzfs_sendrecv.c:1191:		err = dump_ioctl(zhp, sdd->prevsnap, sdd->prevsnap_obj,
./lib/libzfs/libzfs_sendrecv.c:1216:	if (ioctl(zhp->zfs_hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, &zc) != 0) {
./lib/libzfs/libzfs_sendrecv.c:1234:		if (ioctl(zhp->zfs_hdl->libzfs_fd,
./lib/libzfs/libzfs_sendrecv.c:1822:		err = ioctl(hdl->libzfs_fd, ZFS_IOC_RENAME, &zc);
./lib/libzfs/libzfs_sendrecv.c:1840:		err = ioctl(hdl->libzfs_fd, ZFS_IOC_RENAME, &zc);
./lib/libzfs/libzfs_sendrecv.c:1894:	err = ioctl(hdl->libzfs_fd, ZFS_IOC_DESTROY, &zc);
./lib/libzfs/libzfs_sendrecv.c:2142:				error = zfs_ioctl(hdl, ZFS_IOC_PROMOTE, &zc);
./lib/libzfs/libzfs_sendrecv.c:2209:					(void) zfs_ioctl(hdl,
./lib/libzfs/libzfs_sendrecv.c:2892:			if (ioctl(hdl->libzfs_fd, ZFS_IOC_SNAPSHOT_LIST_NEXT,
./lib/libzfs/libzfs_sendrecv.c:2989:	err = ioctl_err = zfs_ioctl(hdl, ZFS_IOC_RECV, &zc);
./lib/libzfs/libzfs_sendrecv.c:3033:			(void) zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc2);
./lib/libzfs/libzfs_dataset.c:292:get_stats_ioctl(zfs_handle_t *zhp, zfs_cmd_t *zc)
./lib/libzfs/libzfs_dataset.c:298:	while (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, zc) != 0) {
./lib/libzfs/libzfs_dataset.c:314:get_recvd_props_ioctl(zfs_handle_t *zhp)
./lib/libzfs/libzfs_dataset.c:326:	while (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_RECVD_PROPS, &zc) != 0) {
./lib/libzfs/libzfs_dataset.c:385:	if (get_stats_ioctl(zhp, &zc) != 0)
./lib/libzfs/libzfs_dataset.c:456:	if (get_stats_ioctl(zhp, &zc) == -1) {
./lib/libzfs/libzfs_dataset.c:1588:	 * Execute the corresponding ioctl() to set this property.
./lib/libzfs/libzfs_dataset.c:1595:	ret = zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);
./lib/libzfs/libzfs_dataset.c:1613:			(void) zfs_ioctl(hdl, ZFS_IOC_SET_PROP, &zc);
./lib/libzfs/libzfs_dataset.c:1677:		if (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_INHERIT_PROP, &zc) != 0)
./lib/libzfs/libzfs_dataset.c:1729:	if ((ret = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_INHERIT_PROP, &zc)) != 0) {
./lib/libzfs/libzfs_dataset.c:1982:		if (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_OBJSET_ZPLPROPS, &zc)) {
./lib/libzfs/libzfs_dataset.c:2067:		if (get_recvd_props_ioctl(zhp) != 0)
./lib/libzfs/libzfs_dataset.c:2750:	err = ioctl(zhp->zfs_hdl->libzfs_fd, ZFS_IOC_USERSPACE_ONE, &zc);
./lib/libzfs/libzfs_dataset.c:2820:	err = ioctl(zhp->zfs_hdl->libzfs_fd, ZFS_IOC_SPACE_WRITTEN, &zc);
./lib/libzfs/libzfs_dataset.c:2942:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, &zc) != 0 &&
./lib/libzfs/libzfs_dataset.c:3144:	 * try to create a dataset on top of an existing dataset, the ioctl()
./lib/libzfs/libzfs_dataset.c:3294:	if (zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_DESTROY, &zc) != 0 &&
./lib/libzfs/libzfs_dataset.c:3504:	ret = zfs_ioctl(hdl, ZFS_IOC_PROMOTE, &zc);
./lib/libzfs/libzfs_dataset.c:3759:	 * simply pass the name on to the ioctl() call.  There is still
./lib/libzfs/libzfs_dataset.c:3934:	if ((ret = zfs_ioctl(zhp->zfs_hdl, ZFS_IOC_RENAME, &zc)) != 0) {
./lib/libzfs/libzfs_dataset.c:4169:	error = ioctl(hdl->libzfs_fd, ZFS_IOC_SMB_ACL, &zc);
./lib/libzfs/libzfs_dataset.c:4224:		if (zfs_ioctl(hdl, ZFS_IOC_USERSPACE_MANY, &zc) != 0) {
./lib/libzfs/libzfs_dataset.c:4509:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_GET_FSACL, &zc) != 0) {
./lib/libzfs/libzfs_dataset.c:4577:	if (zfs_ioctl(hdl, ZFS_IOC_SET_FSACL, &zc) != 0) {
./lib/libzfs/libzfs_config.c:134:		if (ioctl(hdl->libzfs_fd, ZFS_IOC_POOL_CONFIGS, &zc) != 0) {
./lib/libzfs/libzfs_config.c:279:		if (ioctl(zhp->zpool_hdl->libzfs_fd, ZFS_IOC_POOL_STATS,
./lib/libzfs/libzfs_import.c:398:	while ((err = ioctl(hdl->libzfs_fd, ZFS_IOC_POOL_TRYIMPORT,
./lib/libzfs/libzfs_iter.c:61:zfs_do_list_ioctl(zfs_handle_t *zhp, int arg, zfs_cmd_t *zc)
./lib/libzfs/libzfs_iter.c:69:	rc = ioctl(zhp->zfs_hdl->libzfs_fd, arg, zc);
./lib/libzfs/libzfs_iter.c:116:	while ((ret = zfs_do_list_ioctl(zhp, ZFS_IOC_DATASET_LIST_NEXT,
./lib/libzfs/libzfs_iter.c:155:	while ((ret = zfs_do_list_ioctl(zhp, ZFS_IOC_SNAPSHOT_LIST_NEXT,
./lib/libzfs/libzfs_diff.c:101:	error = ioctl(di->zhp->zfs_hdl->libzfs_fd, ZFS_IOC_OBJ_TO_STATS, &zc);
./lib/libzfs/libzfs_diff.c:395:		err = ioctl(lhdl->libzfs_fd, ZFS_IOC_NEXT_OBJ, &zc);
./lib/libzfs/libzfs_diff.c:518:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_TMP_SNAPSHOT, &zc) != 0) {
./lib/libzfs/libzfs_diff.c:793:	/* do the ioctl() */
./lib/libzfs/libzfs_diff.c:798:	iocerr = ioctl(zhp->zfs_hdl->libzfs_fd, ZFS_IOC_DIFF, &zc);
./lib/libzfs/libzfs_pool.c:75:	while (ioctl(hdl->libzfs_fd, ZFS_IOC_POOL_GET_PROPS, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:768:	 * Execute the corresponding ioctl() to set this property.
./lib/libzfs/libzfs_pool.c:777:	ret = zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_POOL_SET_PROPS, &zc);
./lib/libzfs/libzfs_pool.c:1237:	if ((ret = zfs_ioctl(hdl, ZFS_IOC_POOL_CREATE, &zc)) != 0) {
./lib/libzfs/libzfs_pool.c:1317:	if (zfs_ioctl(hdl, ZFS_IOC_POOL_DESTROY, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:1402:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_ADD, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:1480:	if (zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_POOL_EXPORT, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:1802:	while ((ret = zfs_ioctl(hdl, ZFS_IOC_POOL_IMPORT, &zc)) != 0 &&
./lib/libzfs/libzfs_pool.c:1943:	if (zfs_ioctl(hdl, ZFS_IOC_POOL_SCAN, &zc) == 0 ||
./lib/libzfs/libzfs_pool.c:2476:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:2518:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)
./lib/libzfs/libzfs_pool.c:2558:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)
./lib/libzfs/libzfs_pool.c:2593:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_VDEV_SET_STATE, &zc) == 0)
./lib/libzfs/libzfs_pool.c:2714:	ret = zfs_ioctl(hdl, ZFS_IOC_VDEV_ATTACH, &zc);
./lib/libzfs/libzfs_pool.c:2834:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_DETACH, &zc) == 0)
./lib/libzfs/libzfs_pool.c:3079:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_SPLIT, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:3154:	if (zfs_ioctl(hdl, ZFS_IOC_VDEV_REMOVE, &zc) == 0)
./lib/libzfs/libzfs_pool.c:3210:	while ((error = zfs_ioctl(hdl, ZFS_IOC_CLEAR, &zc)) != 0 &&
./lib/libzfs/libzfs_pool.c:3254:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_CLEAR, &zc) == 0)
./lib/libzfs/libzfs_pool.c:3274:	if (zfs_ioctl(hdl, ZFS_IOC_POOL_REGUID, &zc) == 0)
./lib/libzfs/libzfs_pool.c:3295:	if (zfs_ioctl(hdl, ZFS_IOC_POOL_REOPEN, &zc) == 0)
./lib/libzfs/libzfs_pool.c:3359: * Issue the necessary ioctl() to update the stored path value for the vdev.  We
./lib/libzfs/libzfs_pool.c:3373:	(void) ioctl(zhp->zpool_hdl->libzfs_fd, ZFS_IOC_VDEV_SETPATH, &zc);
./lib/libzfs/libzfs_pool.c:3421: * translation and issue the appropriate ioctl() to update the path of the vdev.
./lib/libzfs/libzfs_pool.c:3564:		if (ioctl(zhp->zpool_hdl->libzfs_fd, ZFS_IOC_ERROR_LOG,
./lib/libzfs/libzfs_pool.c:3649:	if (zfs_ioctl(hdl, ZFS_IOC_POOL_UPGRADE, &zc) != 0)
./lib/libzfs/libzfs_pool.c:3679:		err = ioctl(hdl->libzfs_fd, ZFS_IOC_LOG_HISTORY, &zc);
./lib/libzfs/libzfs_pool.c:3706:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_POOL_GET_HISTORY, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:3864:	if (zfs_ioctl(hdl, ZFS_IOC_EVENTS_NEXT, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:3915:	if (zfs_ioctl(hdl, ZFS_IOC_EVENTS_CLEAR, &zc) != 0)
./lib/libzfs/libzfs_pool.c:3938:	if (zfs_ioctl(hdl, ZFS_IOC_EVENTS_SEEK, &zc) != 0) {
./lib/libzfs/libzfs_pool.c:3979:	if (ioctl(zhp->zpool_hdl->libzfs_fd,
./lib/libzfs/libzfs_pool.c:3994:	if (ioctl(zhp->zpool_hdl->libzfs_fd, ZFS_IOC_OBJ_TO_PATH,
./lib/libzfs/libzfs_graph.c:376: * is very flat.  We manually invoke the necessary ioctl() calls to
./lib/libzfs/libzfs_graph.c:398:	    ioctl(hdl->libzfs_fd, ZFS_IOC_DATASET_LIST_NEXT, &zc) == 0;
./lib/libzfs/libzfs_graph.c:406:		if (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, &zc) != 0)
./lib/libzfs/libzfs_graph.c:442:	    ioctl(hdl->libzfs_fd, ZFS_IOC_SNAPSHOT_LIST_NEXT, &zc) == 0;
./lib/libzfs/libzfs_graph.c:450:		if (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, &zc) != 0)
./lib/libzfs/libzfs_graph.c:483:	if (ioctl(hdl->libzfs_fd, ZFS_IOC_OBJSET_STATS, &zc) != 0)
./lib/libzfs/libzfs_fru.c:370:	if (zfs_ioctl(zhp->zpool_hdl, ZFS_IOC_VDEV_SETFRU, &zc) != 0)
./lib/libefi/rdwr_efi.c:136:	if (ioctl(fd, BLKSSZGET, &sector_size) < 0)
./lib/libefi/rdwr_efi.c:139:	if (ioctl(fd, BLKGETSIZE64, &capacity_size) < 0)
./lib/libefi/rdwr_efi.c:256:	if (ioctl(fd, DKIOCINFO, (caddr_t)dki_info) == -1)
./lib/libefi/rdwr_efi.c:401:efi_ioctl(int fd, int cmd, dk_efi_t *dk_ioc)
./lib/libefi/rdwr_efi.c:496:		if (ioctl(fd, BLKFLSBUF, 0) == -1)
./lib/libefi/rdwr_efi.c:504:			(void) fprintf(stderr, "unsupported ioctl()\n");
./lib/libefi/rdwr_efi.c:511:	error = ioctl(fd, cmd, (void *)dk_ioc);
./lib/libefi/rdwr_efi.c:525:	while ((error = ioctl(fd, BLKRRPART)) != 0) {
./lib/libefi/rdwr_efi.c:544:	if (efi_ioctl(fd, DKIOCGETEFI, dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:673:		if (efi_ioctl(fd, DKIOCGETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:753:				rval = efi_ioctl(fd, DKIOCGETEFI, &dk_ioc);
./lib/libefi/rdwr_efi.c:764:		rval = efi_ioctl(fd, DKIOCGETEFI, &dk_ioc);
./lib/libefi/rdwr_efi.c:875:	if (efi_ioctl(fd, DKIOCGETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:925:	if (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:1259:	if (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:1283:	if (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:1312:	if (efi_ioctl(fd, DKIOCSETEFI, &dk_ioc) == -1) {
./lib/libefi/rdwr_efi.c:1346:	if (ioctl(fd, DKIOCGEXTVTOC, &extvtoc) == -1) {
./lib/libefi/rdwr_efi.c:1350:			if (ioctl(fd, DKIOCGVTOC, &vtoc) == -1)

== networking() ==
./module/zfs/zap_leaf.c:49:#define	LEAF_HASH(l, h) \
./module/zfs/zap_leaf.c:50:	((ZAP_LEAF_HASH_NUMENTRIES(l)-1) & \
./module/zfs/zap_leaf.c:52:	(64 - ZAP_LEAF_HASH_SHIFT(l) - zap_leaf_phys(l)->l_hdr.lh_prefix_len)))
./module/zfs/zap_leaf.c:54:#define	LEAF_HASH_ENTPTR(l, h) (&zap_leaf_phys(l)->l_hash[LEAF_HASH(l, h)])
./module/zfs/zap_leaf.c:126:	for (i = 0; i < ZAP_LEAF_HASH_NUMENTRIES(&l); i++)
./module/zfs/zap_leaf.c:129:	for (i = 0; i < ZAP_LEAF_NUMCHUNKS(&l); i++) {
./module/zfs/zap_leaf.c:130:		zap_leaf_chunk_t *lc = &ZAP_LEAF_CHUNK(&l, i);
./module/zfs/zap_leaf.c:172:	    2*ZAP_LEAF_HASH_NUMENTRIES(l));
./module/zfs/zap_leaf.c:173:	for (i = 0; i < ZAP_LEAF_NUMCHUNKS(l); i++) {
./module/zfs/zap_leaf.c:174:		ZAP_LEAF_CHUNK(l, i).l_free.lf_type = ZAP_CHUNK_FREE;
./module/zfs/zap_leaf.c:175:		ZAP_LEAF_CHUNK(l, i).l_free.lf_next = i+1;
./module/zfs/zap_leaf.c:177:	ZAP_LEAF_CHUNK(l, ZAP_LEAF_NUMCHUNKS(l)-1).l_free.lf_next = CHAIN_END;
./module/zfs/zap_leaf.c:179:	zap_leaf_phys(l)->l_hdr.lh_magic = ZAP_LEAF_MAGIC;
./module/zfs/zap_leaf.c:180:	zap_leaf_phys(l)->l_hdr.lh_nfree = ZAP_LEAF_NUMCHUNKS(l);
./module/zfs/zap_leaf.c:197:	ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:198:	ASSERT3U(ZAP_LEAF_CHUNK(l, chunk).l_free.lf_type, ==, ZAP_CHUNK_FREE);
./module/zfs/zap_leaf.c:201:	    ZAP_LEAF_CHUNK(l, chunk).l_free.lf_next;
./module/zfs/zap_leaf.c:211:	struct zap_leaf_free *zlf = &ZAP_LEAF_CHUNK(l, chunk).l_free;
./module/zfs/zap_leaf.c:212:	ASSERT3U(zap_leaf_phys(l)->l_hdr.lh_nfree, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:213:	ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:243:		struct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:247:		for (i = 0; i < ZAP_LEAF_ARRAY_BYTES; i++) {
./module/zfs/zap_leaf.c:276:		int nextchunk = ZAP_LEAF_CHUNK(l, chunk).l_array.la_next;
./module/zfs/zap_leaf.c:277:		ASSERT3U(ZAP_LEAF_CHUNK(l, chunk).l_array.la_type, ==,
./module/zfs/zap_leaf.c:299:		struct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:312:	    buf_len > array_len + ZAP_LEAF_ARRAY_BYTES) {
./module/zfs/zap_leaf.c:315:			    &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:316:			bcopy(la->la_array, p, ZAP_LEAF_ARRAY_BYTES);
./module/zfs/zap_leaf.c:317:			p += ZAP_LEAF_ARRAY_BYTES;
./module/zfs/zap_leaf.c:324:		struct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:327:		ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:328:		for (i = 0; i < ZAP_LEAF_ARRAY_BYTES && len > 0; i++) {
./module/zfs/zap_leaf.c:386:		struct zap_leaf_array *la = &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:387:		int toread = MIN(array_numints - bseen, ZAP_LEAF_ARRAY_BYTES);
./module/zfs/zap_leaf.c:388:		ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:407:	ASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);
./module/zfs/zap_leaf.c:410:	for (chunkp = LEAF_HASH_ENTPTR(l, zn->zn_hash);
./module/zfs/zap_leaf.c:413:		le = ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:415:		ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:463:	uint16_t bestlh = ZAP_LEAF_HASH_NUMENTRIES(l)-1;
./module/zfs/zap_leaf.c:467:	ASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);
./module/zfs/zap_leaf.c:469:	for (lh = LEAF_HASH(l, h); lh <= bestlh; lh++) {
./module/zfs/zap_leaf.c:472:			le = ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:474:			ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:503:	    ZAP_LEAF_ENTRY(zeh->zeh_leaf, *zeh->zeh_chunkp);
./module/zfs/zap_leaf.c:524:	    ZAP_LEAF_ENTRY(zeh->zeh_leaf, *zeh->zeh_chunkp);
./module/zfs/zap_leaf.c:545:	struct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, *zeh->zeh_chunkp);
./module/zfs/zap_leaf.c:547:	delta_chunks = ZAP_LEAF_ARRAY_NCHUNKS(num_integers * integer_size) -
./module/zfs/zap_leaf.c:548:	    ZAP_LEAF_ARRAY_NCHUNKS(le->le_value_numints * le->le_value_intlen);
./module/zfs/zap_leaf.c:571:	le = ZAP_LEAF_ENTRY(l, entry_chunk);
./module/zfs/zap_leaf.c:597:	numchunks = 1 + ZAP_LEAF_ARRAY_NCHUNKS(zn->zn_key_orig_numints *
./module/zfs/zap_leaf.c:598:	    zn->zn_key_intlen) + ZAP_LEAF_ARRAY_NCHUNKS(valuelen);
./module/zfs/zap_leaf.c:599:	if (numchunks > ZAP_LEAF_NUMCHUNKS(l))
./module/zfs/zap_leaf.c:607:			for (chunk = *LEAF_HASH_ENTPTR(l, h);
./module/zfs/zap_leaf.c:609:				le = ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:620:				for (chunk = *LEAF_HASH_ENTPTR(l, h);
./module/zfs/zap_leaf.c:622:					le = ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:645:	le = ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:694:	for (chunk = *LEAF_HASH_ENTPTR(zeh->zeh_leaf, zeh->zeh_hash);
./module/zfs/zap_leaf.c:696:		le = ZAP_LEAF_ENTRY(zeh->zeh_leaf, chunk);
./module/zfs/zap_leaf.c:725:	struct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, entry);
./module/zfs/zap_leaf.c:734:	for (chunkp = LEAF_HASH_ENTPTR(l, le->le_hash);
./module/zfs/zap_leaf.c:736:		le2 = ZAP_LEAF_ENTRY(l, *chunkp);
./module/zfs/zap_leaf.c:755:		    &ZAP_LEAF_CHUNK(nl, nchunk).l_array;
./module/zfs/zap_leaf.c:757:		    &ZAP_LEAF_CHUNK(l, chunk).l_array;
./module/zfs/zap_leaf.c:760:		ASSERT3U(chunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:761:		ASSERT3U(nchunk, <, ZAP_LEAF_NUMCHUNKS(l));
./module/zfs/zap_leaf.c:780:	le = ZAP_LEAF_ENTRY(l, entry);
./module/zfs/zap_leaf.c:784:	nle = ZAP_LEAF_ENTRY(nl, chunk);
./module/zfs/zap_leaf.c:818:	    2*ZAP_LEAF_HASH_NUMENTRIES(l));
./module/zfs/zap_leaf.c:832:	for (i = 0; i < ZAP_LEAF_NUMCHUNKS(l); i++) {
./module/zfs/zap_leaf.c:833:		struct zap_leaf_entry *le = ZAP_LEAF_ENTRY(l, i);
./module/zfs/zap_leaf.c:860:	    zap_leaf_phys(l)->l_hdr.lh_nfree * (ZAP_LEAF_ARRAY_BYTES+1))*10 /
./module/zfs/zap_leaf.c:865:	for (i = 0; i < ZAP_LEAF_HASH_NUMENTRIES(l); i++) {
./module/zfs/zap_leaf.c:871:			    ZAP_LEAF_ENTRY(l, chunk);
./module/zfs/zap_leaf.c:873:			n = 1 + ZAP_LEAF_ARRAY_NCHUNKS(le->le_name_numints) +
./module/zfs/zap_leaf.c:874:			    ZAP_LEAF_ARRAY_NCHUNKS(le->le_value_numints *
./module/zfs/vdev_file.c:197:			 * We cannot safely call vfs_fsync() when PF_FSTRANS
./module/zfs/zap_micro.c:246:		/* ASSERT(magic == ZAP_LEAF_MAGIC); */
./module/zfs/zap_micro.c:428:		    2*ZAP_LEAF_CHUNKSIZE);
./module/zfs/zap.c:483:	ASSERT3U(ZAP_LEAF_HASH_NUMENTRIES(l), >, ZAP_LEAF_NUMCHUNKS(l) / 3);
./module/zfs/zap.c:486:	ASSERT3P(&ZAP_LEAF_CHUNK(l, 0), ==, (zap_leaf_chunk_t *)
./module/zfs/zap.c:487:	    &zap_leaf_phys(l)->l_hash[ZAP_LEAF_HASH_NUMENTRIES(l)]);
./module/zfs/zap.c:490:	ASSERT3U((uintptr_t)&ZAP_LEAF_CHUNK(l, ZAP_LEAF_NUMCHUNKS(l)) -
./module/zfs/zap.c:542:	ASSERT3U(zap_leaf_phys(l)->l_hdr.lh_magic, ==, ZAP_LEAF_MAGIC);
./module/zfs/zap.c:693:	    zap_leaf_phys(l)->l_hdr.lh_nfree < ZAP_LEAF_LOW_WATER);
./include/sys/zap_leaf.h:26:#ifndef	_SYS_ZAP_LEAF_H
./include/sys/zap_leaf.h:27:#define	_SYS_ZAP_LEAF_H
./include/sys/zap_leaf.h:39:#define	ZAP_LEAF_MAGIC 0x2AB1EAF
./include/sys/zap_leaf.h:42:#define	ZAP_LEAF_CHUNKSIZE 24
./include/sys/zap_leaf.h:49:#define	ZAP_LEAF_NUMCHUNKS(l) \
./include/sys/zap_leaf.h:50:	(((1<<(l)->l_bs) - 2*ZAP_LEAF_HASH_NUMENTRIES(l)) / \
./include/sys/zap_leaf.h:51:	ZAP_LEAF_CHUNKSIZE - 2)
./include/sys/zap_leaf.h:57:#define	ZAP_LEAF_ARRAY_BYTES (ZAP_LEAF_CHUNKSIZE - 3)
./include/sys/zap_leaf.h:59:#define	ZAP_LEAF_ARRAY_NCHUNKS(bytes) \
./include/sys/zap_leaf.h:60:	(((bytes)+ZAP_LEAF_ARRAY_BYTES-1)/ZAP_LEAF_ARRAY_BYTES)
./include/sys/zap_leaf.h:69:#define	ZAP_LEAF_LOW_WATER (20)
./include/sys/zap_leaf.h:77:#define	ZAP_LEAF_HASH_SHIFT(l) ((l)->l_bs - 5)
./include/sys/zap_leaf.h:78:#define	ZAP_LEAF_HASH_NUMENTRIES(l) (1 << ZAP_LEAF_HASH_SHIFT(l))
./include/sys/zap_leaf.h:85:#define	ZAP_LEAF_CHUNK(l, idx) \
./include/sys/zap_leaf.h:87:	(zap_leaf_phys(l)->l_hash + ZAP_LEAF_HASH_NUMENTRIES(l)))[idx]
./include/sys/zap_leaf.h:88:#define	ZAP_LEAF_ENTRY(l, idx) (&ZAP_LEAF_CHUNK(l, idx).l_entry)
./include/sys/zap_leaf.h:109:		uint32_t lh_magic;		/* ZAP_LEAF_MAGIC */
./include/sys/zap_leaf.h:122:	 * ZAP_LEAF_HASH_NUMENTRIES(zap) entries.  The hash table is
./include/sys/zap_leaf.h:123:	 * followed by an array of ZAP_LEAF_NUMCHUNKS(zap)
./include/sys/zap_leaf.h:125:	 * with the ZAP_LEAF_CHUNK() macro.
./include/sys/zap_leaf.h:145:		uint8_t la_array[ZAP_LEAF_ARRAY_BYTES];
./include/sys/zap_leaf.h:150:		uint8_t lf_pad[ZAP_LEAF_ARRAY_BYTES];
./include/sys/zap_leaf.h:248:#endif /* _SYS_ZAP_LEAF_H */
./lib/libzfs/libzfs_sendrecv.c:1430:		if ((err = socketpair(AF_UNIX, SOCK_STREAM, 0, pipefd))) {
./module/zpios/pios.c:135:	dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, OBJ_SIZE);
./module/zpios/pios.c:469:zpios_dmu_write(run_args_t *run_args, objset_t *os, uint64_t object,
./module/zpios/pios.c:481:		dmu_tx_hold_write(tx, object, offset, size);
./module/zpios/pios.c:501:	dmu_write(os, object, offset, size, buf, tx);
./module/zpios/pios.c:508:zpios_dmu_read(run_args_t *run_args, objset_t *os, uint64_t object,
./module/zpios/pios.c:519:	return (dmu_read(os, object, offset, size, buf, flags));
./module/zpios/pios.c:575:		rc = zpios_dmu_write(run_args, obj.os, obj.obj,
./module/zpios/pios.c:582:				    "dmu_write(): %d\n", rc);
./module/zpios/pios.c:644:		rc = zpios_dmu_read(run_args, obj.os, obj.obj,
./module/zpios/pios.c:651:				    "dmu_read(): %d\n", rc);
./module/zpios/pios.c:1173:zpios_write(struct file *file, const char __user *buf,
./module/zpios/pios.c:1207:zpios_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
./module/zfs/zfs_fuid.c:134:		VERIFY(dmu_read(os, fuid_obj, 0,
./module/zfs/zfs_fuid.c:279:	dmu_write(zsb->z_os, zsb->z_fuid_obj, 0, zsb->z_fuid_size, packed, tx);
./module/zfs/zfs_fuid.c:769:		dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,
./module/zfs/zfs_fuid.c:774:		dmu_tx_hold_write(tx, zsb->z_fuid_obj, 0,
./module/zfs/dmu.c:130:dmu_buf_hold_noread(objset_t *os, uint64_t object, uint64_t offset,
./module/zfs/dmu.c:166:	err = dmu_buf_hold_noread(os, object, offset, tag, dbp);
./module/zfs/dmu.c:169:		err = dbuf_read(db, NULL, db_flags);
./module/zfs/dmu.c:299:	VERIFY(0 == dbuf_read(db, NULL, DB_RF_MUST_SUCCEED | DB_RF_NOPREFETCH));
./module/zfs/dmu.c:329:	err = dbuf_read(db, NULL, flags);
./module/zfs/dmu.c:435:			(void) dbuf_read(db, zio, dbuf_flags);
./module/zfs/dmu.c:755:dmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
./module/zfs/dmu.c:814:dmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
./module/zfs/dmu.c:885:	VERIFY0(dmu_buf_hold_noread(os, object, offset,
./module/zfs/dmu.c:1445: * dmu_write().
./module/zfs/dmu.c:1486:		dmu_write(os, object, offset, blksz, buf->b_data, tx);
./module/zfs/dmu.c:1627:	zio_nowait(zio_write(pio, os->os_spa, dmu_tx_get_txg(tx), zgd->zgd_bp,
./module/zfs/dmu.c:1780:	zio_nowait(arc_write(pio, os->os_spa, txg,
./module/zfs/dmu_traverse.c:196:	(void) arc_read(NULL, td->td_spa, bp, NULL, NULL,
./module/zfs/dmu_traverse.c:281:		err = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dmu_traverse.c:315:		err = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dmu_traverse.c:338:		err = arc_read(NULL, td->td_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dmu_traverse.c:467:	(void) arc_read(NULL, spa, bp, NULL, NULL, ZIO_PRIORITY_ASYNC_READ,
./module/zfs/dmu_traverse.c:474:traverse_prefetch_thread(void *arg)
./module/zfs/dmu_traverse.c:554:		err = arc_read(NULL, td->td_spa, rootbp,
./module/zfs/ddt.c:1032:		zio_nowait(zio_rewrite(zio, zio->io_spa, 0, &blk,
./module/zfs/zfs_ioctl.c:369:zfs_secpolicy_read(zfs_cmd_t *zc, nvlist_t *innvl, cred_t *cr)
./module/zfs/zfs_ioctl.c:1145:	int err = zfs_secpolicy_read(zc, innvl, cr);
./module/zfs/zfs_ioctl.c:1174:	int err = zfs_secpolicy_read(zc, innvl, cr);
./module/zfs/zfs_ioctl.c:5357:zfs_ioctl_register_dataset_read(zfs_ioc_t ioc, zfs_ioc_legacy_func_t *func)
./module/zfs/zfs_ioctl.c:5509:	zfs_ioctl_register_dataset_read(ZFS_IOC_SPACE_WRITTEN,
./module/zfs/zfs_ioctl.c:5511:	zfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_RECVD_PROPS,
./module/zfs/zfs_ioctl.c:5513:	zfs_ioctl_register_dataset_read(ZFS_IOC_NEXT_OBJ,
./module/zfs/zfs_ioctl.c:5515:	zfs_ioctl_register_dataset_read(ZFS_IOC_GET_FSACL,
./module/zfs/zfs_ioctl.c:5517:	zfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_STATS,
./module/zfs/zfs_ioctl.c:5519:	zfs_ioctl_register_dataset_read(ZFS_IOC_OBJSET_ZPLPROPS,
./module/zfs/zfs_ioctl.c:5521:	zfs_ioctl_register_dataset_read(ZFS_IOC_DATASET_LIST_NEXT,
./module/zfs/zfs_ioctl.c:5523:	zfs_ioctl_register_dataset_read(ZFS_IOC_SNAPSHOT_LIST_NEXT,
./module/zfs/zfs_ioctl.c:5525:	zfs_ioctl_register_dataset_read(ZFS_IOC_SEND_PROGRESS,
./module/zfs/bptree.c:140:	dmu_write(os, obj, bt->bt_end * sizeof (*bte), sizeof (*bte), bte, tx);
./module/zfs/bptree.c:217:		err = dmu_read(os, obj, i * sizeof (bte), sizeof (bte),
./module/zfs/bptree.c:246:				dmu_write(os, obj, i * sizeof (bte),
./module/zfs/bptree.c:268:				dmu_write(os, obj, i * sizeof (bte),
./module/zfs/zpl_super.c:47:	ASSERT(atomic_read(&ip->i_count) == 0);
./module/zfs/dmu_objset.c:322:		err = arc_read(NULL, spa, os->os_rootbp,
./module/zfs/dmu_objset.c:1138:	zio = arc_write(pio, os->os_spa, tx->tx_txg,
./module/zfs/metaslab.c:1805:	space_map_write(sm, condense_tree, SM_ALLOC, tx);
./module/zfs/metaslab.c:1809:	space_map_write(sm, msp->ms_tree, SM_FREE, tx);
./module/zfs/metaslab.c:1893:		space_map_write(msp->ms_sm, alloctree, SM_ALLOC, tx);
./module/zfs/metaslab.c:1894:		space_map_write(msp->ms_sm, *freetree, SM_FREE, tx);
./module/zfs/metaslab.c:1940:		dmu_write(mos, vd->vdev_ms_array, sizeof (uint64_t) *
./module/zfs/bpobj.c:409:	dmu_write(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,
./module/zfs/bpobj.c:431:			 * Make sure that we are not asking dmu_write()
./module/zfs/bpobj.c:436:			dmu_write(bpo->bpo_os, bpo->bpo_phys->bpo_subobjs,
./module/zfs/zap_leaf.c:286:zap_leaf_array_read(zap_leaf_t *l, uint16_t chunk,
./module/zfs/zap_leaf.c:358:		zap_leaf_array_read(l, chunk, sizeof (*thiskey), array_numints,
./module/zfs/zap_leaf.c:371:		zap_leaf_array_read(l, chunk, sizeof (char), array_numints,
./module/zfs/zap_leaf.c:499:zap_entry_read(const zap_entry_handle_t *zeh,
./module/zfs/zap_leaf.c:509:	zap_leaf_array_read(zeh->zeh_leaf, le->le_value_chunk,
./module/zfs/zap_leaf.c:528:		zap_leaf_array_read(zeh->zeh_leaf, le->le_name_chunk, 8,
./module/zfs/zap_leaf.c:531:		zap_leaf_array_read(zeh->zeh_leaf, le->le_name_chunk, 1,
./module/zfs/txg.c:110:static void txg_sync_thread(dsl_pool_t *dp);
./module/zfs/txg.c:111:static void txg_quiesce_thread(dsl_pool_t *dp);
./module/zfs/txg.c:478:txg_sync_thread(dsl_pool_t *dp)
./module/zfs/txg.c:587:txg_quiesce_thread(dsl_pool_t *dp)
./module/zfs/zfs_vnops.c:345:			(void) dmu_read(os, oid, start+off, nbytes, pb+off,
./module/zfs/zfs_vnops.c:375:mappedread(struct inode *ip, int nbytes, uio_t *uio)
./module/zfs/zfs_vnops.c:440:zfs_read(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr)
./module/zfs/zfs_vnops.c:534:			error = mappedread(ip, nbytes, uio);
./module/zfs/zfs_vnops.c:579:zfs_write(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr)
./module/zfs/zfs_vnops.c:756:		dmu_tx_hold_write(tx, zp->z_id, woff, MIN(n, max_blksz));
./module/zfs/zfs_vnops.c:809:			 * write via dmu_write().
./module/zfs/zfs_vnops.c:814:				dmu_write(zsb->z_os, zp->z_id, woff,
./module/zfs/zfs_vnops.c:889:		zfs_log_write(zilog, tx, TX_WRITE, zp, woff, tx_bytes, ioflag,
./module/zfs/zfs_vnops.c:928:	ASSERT(atomic_read(&ip->i_count) > 0);
./module/zfs/zfs_vnops.c:931:	if (atomic_read(&ip->i_count) == 1)
./module/zfs/zfs_vnops.c:1015:			error = dmu_read(os, object, offset, size, buf,
./module/zfs/zfs_vnops.c:1389:			dmu_tx_hold_write(tx, DMU_NEW_OBJECT,
./module/zfs/zfs_vnops.c:1799:		dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,
./module/zfs/zfs_vnops.c:2245:	vap->va_size = i_size_read(ip);
./module/zfs/zfs_vnops.c:2828:				dmu_tx_hold_write(tx, DMU_NEW_OBJECT,
./module/zfs/zfs_vnops.c:2831:				dmu_tx_hold_write(tx, acl_obj, 0,
./module/zfs/zfs_vnops.c:2835:			dmu_tx_hold_write(tx, DMU_NEW_OBJECT,
./module/zfs/zfs_vnops.c:3584:	dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, MAX(1, len));
./module/zfs/zfs_vnops.c:3590:		dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,
./module/zfs/zfs_vnops.c:3896:	offset = i_size_read(ip);	/* File length in bytes */
./module/zfs/zfs_vnops.c:3914:	 * is to register a page_mkwrite() handler to count the page
./module/zfs/zfs_vnops.c:3925:	 * rules in order to avoid deadlocking in either zfs_read() or
./module/zfs/zfs_vnops.c:3929:	 *    This is critical because zfs_read() calls find_lock_page()
./module/zfs/zfs_vnops.c:3990:	dmu_tx_hold_write(tx, zp->z_id, pgoff, pglen);
./module/zfs/zfs_vnops.c:4010:	dmu_write(zsb->z_os, zp->z_id, pgoff, pglen, va, tx);
./module/zfs/zfs_vnops.c:4025:	zfs_log_write(zsb->z_log, tx, TX_WRITE, zp, pgoff, pglen, 0,
./module/zfs/zfs_vnops.c:4185:	i_size = i_size_read(ip);
./module/zfs/zfs_vnops.c:4200:		err = dmu_read(os, zp->z_id, io_off, PAGESIZE, va,
./module/zfs/zfs_vnops.c:4658:		 * that has been returned in zfs_write().
./module/zfs/vdev_label.c:181:vdev_label_read(zio_t *zio, vdev_t *vd, int l, void *buf, uint64_t offset,
./module/zfs/vdev_label.c:195:vdev_label_write(zio_t *zio, vdev_t *vd, int l, void *buf, uint64_t offset,
./module/zfs/vdev_label.c:453:		vdev_label_read(zio, vd, l, vp,
./module/zfs/vdev_label.c:799:		vdev_label_write(zio, vd, l, vp,
./module/zfs/vdev_label.c:808:		vdev_label_write(zio, vd, l, pad2,
./module/zfs/vdev_label.c:812:		vdev_label_write(zio, vd, l, ub,
./module/zfs/vdev_label.c:927:				vdev_label_read(zio, vd, l,
./module/zfs/vdev_label.c:1015:		vdev_label_write(zio, vd, l, ubbuf,
./module/zfs/vdev_label.c:1123:			vdev_label_write(zio, vd, l, vp,
./module/zfs/vdev_cache.c:254:vdev_cache_read(zio_t *zio)
./module/zfs/vdev_cache.c:333:vdev_cache_write(zio_t *zio)
./module/zfs/zfs_dir.c:617:	ASSERT(atomic_read(&ZTOI(zp)->i_count) == 0);
./module/zfs/zfs_znode.c:516:	i_size_write(ip, zp->z_size);
./module/zfs/zfs_znode.c:1321:		dmu_tx_hold_write(tx, zp->z_id, 0, newblksz);
./module/zfs/spa_history.c:131:	if ((err = dmu_read(mos, spa->spa_history, phys_bof, firstread,
./module/zfs/spa_history.c:135:		if ((err = dmu_read(mos, spa->spa_history,
./module/zfs/spa_history.c:148:spa_history_write(spa_t *spa, void *buf, uint64_t len, spa_history_phys_t *shpp,
./module/zfs/spa_history.c:168:	dmu_write(mos, spa->spa_history, phys_eof, firstwrite, buf, tx);
./module/zfs/spa_history.c:173:		dmu_write(mos, spa->spa_history, shpp->sh_pool_create_len,
./module/zfs/spa_history.c:269:	ret = spa_history_write(spa, &le_len, sizeof (le_len), shpp, tx);
./module/zfs/spa_history.c:271:		ret = spa_history_write(spa, record_packed, reclen, shpp, tx);
./module/zfs/spa_history.c:419:	err = dmu_read(mos, spa->spa_history, phys_read_off, read_len, buf,
./module/zfs/spa_history.c:422:		err = dmu_read(mos, spa->spa_history, shpp->sh_pool_create_len,
./module/zfs/zpl_xattr.c:217:	rrm_enter_read(&(zsb)->z_teardown_lock, FTAG);
./module/zfs/zpl_xattr.c:261:		error = i_size_read(xip);
./module/zfs/zpl_xattr.c:265:	if (size < i_size_read(xip)) {
./module/zfs/zpl_xattr.c:351:	rrm_enter_read(&(zsb)->z_teardown_lock, FTAG);
./module/zfs/zpl_xattr.c:501:	rrm_enter_read(&(zsb)->z_teardown_lock, FTAG);
./module/zfs/dmu_diff.c:136:		if (arc_read(NULL, spa, bp, arc_getbuf_func, &abuf,
./module/zfs/dnode.c:1122:	err = dbuf_read(db, NULL, DB_RF_CANFAIL);
./module/zfs/dnode.c:1894:		error = dbuf_read(db, NULL, DB_RF_CANFAIL | DB_RF_HAVESTRUCT);
./module/zfs/zfs_acl.c:1057:zfs_acl_node_read(znode_t *zp, boolean_t have_lock, zfs_acl_t **aclpp,
./module/zfs/zfs_acl.c:1105:			error = dmu_read(ZTOZSB(zp)->z_os,
./module/zfs/zfs_acl.c:1166:	error = zfs_acl_node_read(zp, B_TRUE, &aclp, B_FALSE);
./module/zfs/zfs_acl.c:1174:	 * zfs_acl_node_read() when the SA can't be located.
./module/zfs/zfs_acl.c:1407:				dmu_write(zsb->z_os, aoid, off,
./module/zfs/zfs_acl.c:1839:			VERIFY(0 == zfs_acl_node_read(dzp, B_TRUE,
./module/zfs/zfs_acl.c:1913:	error = zfs_acl_node_read(zp, B_FALSE, &aclp, B_FALSE);
./module/zfs/zfs_acl.c:2105:			dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0,
./module/zfs/zfs_acl.c:2108:			dmu_tx_hold_write(tx, acl_obj, 0, aclp->z_acl_bytes);
./module/zfs/zfs_acl.c:2111:		dmu_tx_hold_write(tx, DMU_NEW_OBJECT, 0, aclp->z_acl_bytes);
./module/zfs/zfs_acl.c:2235:	error = zfs_acl_node_read(zp, B_FALSE, &aclp, B_FALSE);
./module/zfs/spa_config.c:149:spa_config_write(spa_config_dirent_t *dp, nvlist_t *nvl)
./module/zfs/spa_config.c:292:		spa_config_write(dp, nvl);
./module/zfs/vdev.c:894:			error = dmu_read(mos, vd->vdev_ms_array,
./module/zfs/vdev.c:2027:	space_map_write(vd->vdev_dtl_sm, rtsync, SM_ALLOC, tx);
./module/zfs/vdev.c:2858:		 * This is either a normal write (not a repair), or it's
./module/zfs/dnode_sync.c:69:		(void) dbuf_read(db, NULL, DB_RF_MUST_SUCCEED|DB_RF_HAVESTRUCT);
./module/zfs/dnode_sync.c:259:		(void) dbuf_read(db, NULL, DB_RF_MUST_SUCCEED);
./module/zfs/zfs_vfsops.c:1170:		if (atomic_read(&ZTOI(zp)->i_count) == 1)
./module/zfs/zpl_file.c:225:	error = -zfs_read(ip, &uio, flags, cr);
./module/zfs/zpl_file.c:232:	task_io_account_read(read);
./module/zfs/zpl_file.c:251:zpl_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
./module/zfs/zpl_file.c:282:zpl_iter_read(struct kiocb *kiocb, struct iov_iter *to)
./module/zfs/zpl_file.c:298:zpl_aio_read(struct kiocb *kiocb, const struct iovec *iovp,
./module/zfs/zpl_file.c:317:		*ppos = i_size_read(ip);
./module/zfs/zpl_file.c:328:	error = -zfs_write(ip, &uio, flags, cr);
./module/zfs/zpl_file.c:335:	task_io_account_write(wrote);
./module/zfs/zpl_file.c:353:zpl_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
./module/zfs/zpl_file.c:384:zpl_iter_write(struct kiocb *kiocb, struct iov_iter *from)
./module/zfs/zpl_file.c:400:zpl_aio_write(struct kiocb *kiocb, const struct iovec *iovp,
./module/zfs/zpl_file.c:441: * well for the common read(2)/write(2) case.  However, mmap(2)
./module/zfs/zpl_file.c:447: * When a file with an mmap'ed region is written to using write(2)
./module/zfs/zpl_file.c:449: * are updated.  For a read(2) data will be read first from the page
./module/zfs/zpl_file.c:450: * cache then the ARC if needed.  Neither a write(2) or read(2) will
./module/zfs/zpl_file.c:458: * page aging behavior.  Note because a read(2) of a mmap'ed file
./module/zfs/zpl_file.c:506: * data in the ARC which is kept up to date via .write() and .writepage().
./module/zfs/zpl_file.c:617: * which never call .write().  These dirty pages are kept in sync with
./module/zfs/zpl_file.c:655:	olen = i_size_read(ip);
./module/zfs/dbuf.c:80:static void dbuf_write(dbuf_dirty_record_t *dr, arc_buf_t *data, dmu_tx_t *tx);
./module/zfs/dbuf.c:721:	err = arc_read(zio, db->db_objset->os_spa, db->db_blkptr,
./module/zfs/dbuf.c:732:dbuf_read(dmu_buf_impl_t *db, zio_t *zio, uint32_t flags)
./module/zfs/dbuf.c:825:dbuf_noread(dmu_buf_impl_t *db)
./module/zfs/dbuf.c:1337:	 * and dbuf_dirty.  We win, as though the dbuf_noread() had
./module/zfs/dbuf.c:1555:	(void) dbuf_read(db, NULL, rf);
./module/zfs/dbuf.c:1582:	dbuf_noread(db);
./module/zfs/dbuf.c:1836:		err = dbuf_read(*parentp, NULL,
./module/zfs/dbuf.c:2042:			(void) arc_read(NULL, dn->dn_objset->os_spa,
./module/zfs/dbuf.c:2565:		(void) dbuf_read(db, NULL, DB_RF_MUST_SUCCEED);
./module/zfs/dbuf.c:2582:	dbuf_write(dr, db->db_buf, tx);
./module/zfs/dbuf.c:2717:	dbuf_write(dr, *datap, tx);
./module/zfs/dbuf.c:3008:dbuf_write(dbuf_dirty_record_t *dr, arc_buf_t *data, dmu_tx_t *tx)
./module/zfs/dbuf.c:3086:		dr->dr_zio = zio_write(zio, os->os_spa, txg,
./module/zfs/dbuf.c:3097:		dr->dr_zio = zio_write(zio, os->os_spa, txg,
./module/zfs/dbuf.c:3104:		dr->dr_zio = arc_write(zio, os->os_spa, txg,
./module/zfs/vdev_disk.c:591:		ASSERT3S(atomic_read(&dr->dr_ref), ==, 1);
./module/zfs/zap_micro.c:1367:zap_count_write(objset_t *os, uint64_t zapobj, const char *name, int add,
./module/zfs/zap_micro.c:1402:			err = fzap_count_write(zn, add, towrite,
./module/zfs/zvol.c:464:zvol_replay_write(zvol_state_t *zv, lr_write_t *lr, boolean_t byteswap)
./module/zfs/zvol.c:477:	dmu_tx_hold_write(tx, ZVOL_OBJ, off, len);
./module/zfs/zvol.c:482:		dmu_write(os, ZVOL_OBJ, off, len, data, tx);
./module/zfs/zvol.c:516: * zvol_log_write() handles synchronous writes using TX_WRITE ZIL transactions.
./module/zfs/zvol.c:524:zvol_log_write(zvol_state_t *zv, dmu_tx_t *tx, uint64_t offset,
./module/zfs/zvol.c:547:		 * Unlike zfs_log_write() we can be called with
./module/zfs/zvol.c:565:		if (write_state == WR_COPIED && dmu_read(zv->zv_objset,
./module/zfs/zvol.c:593:zvol_write(struct bio *bio)
./module/zfs/zvol.c:614:	dmu_tx_hold_write(tx, ZVOL_OBJ, offset, size);
./module/zfs/zvol.c:626:		zvol_log_write(zv, tx, offset, size,
./module/zfs/zvol.c:686:zvol_read(struct bio *bio)
./module/zfs/zvol.c:748:		error = zvol_write(bio);
./module/zfs/zvol.c:750:		error = zvol_read(bio);
./module/zfs/zvol.c:809:		error = dmu_read(os, object, offset, size, buf,
./module/zfs/dmu_send.c:202:dump_write(dmu_sendarg_t *dsp, dmu_object_type_t type,
./module/zfs/dmu_send.c:492:		if (arc_read(NULL, spa, bp, arc_getbuf_func, &abuf,
./module/zfs/dmu_send.c:511:		if (arc_read(NULL, spa, bp, arc_getbuf_func, &abuf,
./module/zfs/dmu_send.c:531:		if (arc_read(NULL, spa, bp, arc_getbuf_func, &abuf,
./module/zfs/dmu_send.c:556:				err = dump_write(dsp, type, zb->zb_object,
./module/zfs/dmu_send.c:563:			err = dump_write(dsp, type, zb->zb_object,
./module/zfs/dmu_send.c:1352:restore_read(struct restorearg *ra, int len, char *buf)
./module/zfs/dmu_send.c:1515:		data = restore_read(ra, P2ROUNDUP(drro->drr_bonuslen, 8), NULL);
./module/zfs/dmu_send.c:1617:restore_write(struct restorearg *ra, objset_t *os,
./module/zfs/dmu_send.c:1638:	data = restore_read(ra, drrw->drr_length, abuf->b_data);
./module/zfs/dmu_send.c:1647:	dmu_tx_hold_write(tx, drrw->drr_object,
./module/zfs/dmu_send.c:1712:	dmu_tx_hold_write(tx, drrwbr->drr_object,
./module/zfs/dmu_send.c:1719:	dmu_write(os, drrwbr->drr_object,
./module/zfs/dmu_send.c:1745:	data = restore_read(ra, P2ROUNDUP(drrwnp->drr_psize, 8), NULL);
./module/zfs/dmu_send.c:1751:	dmu_tx_hold_write(tx, drrwnp->drr_object,
./module/zfs/dmu_send.c:1780:	data = restore_read(ra, drrs->drr_length, NULL);
./module/zfs/dmu_send.c:1921:	    NULL != (drr = restore_read(&ra, sizeof (*drr), NULL))) {
./module/zfs/dmu_send.c:1936:			 * restore_read(), which will invalidate drr.
./module/zfs/dmu_send.c:1952:			ra.err = restore_write(&ra, os, &drrw);
./module/zfs/dmu_tx.c:181:	err = dbuf_read(db, zio, DB_RF_CANFAIL | DB_RF_NOPREFETCH);
./module/zfs/dmu_tx.c:232:dmu_tx_count_write(dmu_tx_hold_t *txh, uint64_t off, uint64_t len)
./module/zfs/dmu_tx.c:426:dmu_tx_hold_write(dmu_tx_t *tx, uint64_t object, uint64_t off, int len)
./module/zfs/dmu_tx.c:439:	dmu_tx_count_write(txh, off, len);
./module/zfs/dmu_tx.c:552:		err = dbuf_read(dbuf, NULL, DB_RF_HAVESTRUCT | DB_RF_CANFAIL);
./module/zfs/dmu_tx.c:646:			dmu_tx_count_write(txh, 0, dn->dn_datablksz);
./module/zfs/dmu_tx.c:650:			dmu_tx_count_write(txh, off, 1);
./module/zfs/dmu_tx.c:653:			dmu_tx_count_write(txh, off+len, 1);
./module/zfs/dmu_tx.c:730:		dmu_tx_count_write(txh, 0, 2 << fzap_default_block_shift);
./module/zfs/dmu_tx.c:777:	err = zap_count_write(dn->dn_objset, dn->dn_object, name, add,
./module/zfs/dmu_tx.c:1328:		 * this tx and try again.  The common case, zfs_write(),
./module/zfs/zfs_onexit.c:120: * they might be running in another thread (e.g. txg_sync_thread). Callers
./module/zfs/spa_misc.c:158: * from disk (dmu_read() -> zio_read() -> SCL_ZIO).
./module/zfs/spa.c:1001:spa_thread(void *arg)
./module/zfs/spa.c:1023:		if (cpupart_bind_thread(curthread, zio_taskq_psrset_bind,
./module/zfs/spa.c:1199:	 * We want to make sure spa_thread() has actually exited the ZFS
./module/zfs/spa.c:1619:	error = dmu_read(spa->spa_meta_objset, obj, 0, nvsize, packed,
./module/zfs/spa.c:1946:	zio_nowait(zio_read(rio, spa, bp, data, size,
./module/zfs/spa.c:5812:spa_async_thread(spa_t *spa)
./module/zfs/spa.c:6007:	dmu_write(spa->spa_meta_objset, obj, 0, bufsize, packed, tx);
./module/zfs/space_map.c:52: * Note: space_map_load() will drop sm_lock across dmu_read() calls.
./module/zfs/space_map.c:94:		error = dmu_read(sm->sm_os, space_map_object(sm), offset, size,
./module/zfs/space_map.c:237: * Note: space_map_write() will drop sm_lock across dmu_write() calls.
./module/zfs/space_map.c:240:space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
./module/zfs/space_map.c:302:				dmu_write(os, space_map_object(sm),
./module/zfs/space_map.c:323:		dmu_write(os, space_map_object(sm), sm->sm_phys->smp_objsize,
./module/zfs/arc.c:79: * or 2) via one of the ARC lists.  The arc_read() interface
./module/zfs/arc.c:1502:	 * in arc_read() when bringing a buffer out of the L2ARC.  However, the
./module/zfs/arc.c:1885:arc_buf_free_on_write(void *data, size_t size,
./module/zfs/arc.c:1909:		arc_buf_free_on_write(buf->b_data, hdr->b_size, free_func);
./module/zfs/arc.c:1964:	arc_buf_free_on_write(hdr->b_l1hdr.b_tmp_cdata,
./module/zfs/arc.c:2515:			 * just before arc_reclaim_thread() sleeps.
./module/zfs/arc.c:2715: * in the context of the arc_reclaim_thread().  A reference is taken here
./module/zfs/arc.c:3414: *  - arc_reclaim_thread() tries to acquire hash lock "L" using mutex_enter,
./module/zfs/arc.c:3418: * using mutex_tryenter() from arc_reclaim_thread().
./module/zfs/arc.c:3421:arc_reclaim_thread(void)
./module/zfs/arc.c:3514:arc_user_evicts_thread(void)
./module/zfs/arc.c:3984:		 * the arc_read() will have kicked this off the list.
./module/zfs/arc.c:4217:arc_read(zio_t *pio, spa_t *spa, const blkptr_t *bp, arc_done_func_t *done,
./module/zfs/arc.c:4514:				/* l2arc read error; goto zio_read() */
./module/zfs/arc.c:4533:		rzio = zio_read(pio, spa, bp, buf->b_data, size,
./module/zfs/arc.c:5018:arc_write(zio_t *pio, spa_t *spa, uint64_t txg,
./module/zfs/arc.c:5045:	zio = zio_write(pio, spa, txg, bp, buf->b_data, hdr->b_size, zp,
./module/zfs/arc.c:5594: *      l2arc_feed_thread()    arc_read()
./module/zfs/arc.c:5602: *          l2arc_write() |           |
./module/zfs/arc.c:5640: * l2arc_feed_thread(), illustrated below; example sizes are included to
./module/zfs/arc.c:5651: *	                                      l2arc_feed_thread()
./module/zfs/arc.c:5678: * lists as pictured, the l2arc_feed_thread() will search from the list heads
./module/zfs/arc.c:5853:l2arc_do_free_on_write(void)
./module/zfs/arc.c:5990:	l2arc_do_free_on_write();
./module/zfs/arc.c:6066:			zio_nowait(zio_read(pio, cb->l2rcb_spa, &cb->l2rcb_bp,
./module/zfs/arc.c:6735:l2arc_feed_thread(void)
./module/zfs/arc.c:6960:	l2arc_do_free_on_write();
./module/zfs/zfs_replay.c:627:zfs_replay_write(zfs_sb_t *zsb, lr_write_t *lr, boolean_t byteswap)
./module/zfs/zap.c:785:		err = zap_entry_read(&zeh, integer_size, num_integers, buf);
./module/zfs/zap.c:1223:			err = zap_entry_read(&zeh, 8, 1, &za->za_first_integer);
./module/zfs/zap.c:1320:fzap_count_write(zap_name_t *zn, int add, uint64_t *towrite,
./module/zfs/dsl_scan.c:604:	(void) arc_read(scn->scn_zio_root, scn->scn_dp->dp_spa, bp,
./module/zfs/dsl_scan.c:664:		err = arc_read(NULL, dp->dp_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dsl_scan.c:691:		err = arc_read(NULL, dp->dp_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dsl_scan.c:715:		err = arc_read(NULL, dp->dp_spa, bp, arc_getbuf_func, &buf,
./module/zfs/dsl_scan.c:1846:		zio_nowait(zio_read(NULL, spa, bp, data, size,
./module/zfs/zfs_log.c:448: * zfs_log_write() handles TX_WRITE transactions. The specified callback is
./module/zfs/zfs_log.c:455:zfs_log_write(zilog_t *zilog, dmu_tx_t *tx, int txtype,
./module/zfs/zfs_log.c:502:		if (write_state == WR_COPIED && dmu_read(ZTOZSB(zp)->z_os,
./module/zfs/zil.c:221:	error = arc_read(NULL, zilog->zl_spa, bp, arc_getbuf_func, &abuf,
./module/zfs/zil.c:300:	error = arc_read(NULL, zilog->zl_spa, bp, arc_getbuf_func, &abuf,
./module/zfs/zil.c:932:		lwb->lwb_zio = zio_rewrite(zilog->zl_root_zio, zilog->zl_spa,
./module/zfs/zio.c:713:zio_read(zio_t *pio, spa_t *spa, const blkptr_t *bp,
./module/zfs/zio.c:731:zio_write(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,
./module/zfs/zio.c:771:zio_rewrite(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp, void *data,
./module/zfs/zio.c:818:	 * deferred, and which will not need to do a read (i.e. not GANG or
./module/zfs/zio.c:849:	 * GANG and DEDUP blocks can induce a read (for the gang block header,
./module/zfs/zio.c:1698: * zio_read_gang() is a wrapper around zio_read() that omits reading gang
./module/zfs/zio.c:1700: * performs a zio_rewrite() of the data or, for gang headers, a zio_rewrite()
./module/zfs/zio.c:1732:	return (zio_read(pio, pio->io_spa, bp, data, BP_GET_PSIZE(bp),
./module/zfs/zio.c:1743:		zio = zio_rewrite(pio, pio->io_spa, pio->io_txg, bp,
./module/zfs/zio.c:1766:		zio = zio_rewrite(pio, pio->io_spa, pio->io_txg, bp,
./module/zfs/zio.c:1852:	zio_nowait(zio_read(gio, gio->io_spa, bp, gn->gn_gbh,
./module/zfs/zio.c:2028:	zio = zio_rewrite(pio, spa, txg, bp, gbh, SPA_GANGBLOCKSIZE, NULL, NULL,
./module/zfs/zio.c:2048:		zio_nowait(zio_write(zio, spa, txg, &gbh->zg_blkptr[g],
./module/zfs/zio.c:2079:zio_nop_write(zio_t *zio)
./module/zfs/zio.c:2178:			zio_nowait(zio_read(zio, zio->io_spa, &blk,
./module/zfs/zio.c:2187:	zio_nowait(zio_read(zio, zio->io_spa, bp,
./module/zfs/zio.c:2266:			error = arc_read(NULL, spa, &blk,
./module/zfs/zio.c:2365:zio_ddt_write(zio_t *zio)
./module/zfs/zio.c:2433:		dio = zio_write(zio, spa, txg, bp, zio->io_orig_data,
./module/zfs/zio.c:2455:		cio = zio_write(zio, spa, txg, bp, zio->io_orig_data,
./module/zfs/zio.c:2765:		if (zio->io_type == ZIO_TYPE_READ && vdev_cache_read(zio))
./module/zfs/zio.c:2799:			vdev_cache_write(zio);
./module/zfs/rrwlock.c:195:rrw_enter_read(rrwlock_t *rrl, void *tag)
./module/zfs/rrwlock.c:214:rrw_enter_write(rrwlock_t *rrl)
./module/zfs/rrwlock.c:234:		rrw_enter_read(rrl, tag);
./module/zfs/rrwlock.c:236:		rrw_enter_write(rrl);
./module/zfs/rrwlock.c:344:		rrm_enter_read(rrl, tag);
./module/zfs/rrwlock.c:346:		rrm_enter_write(rrl);
./module/zfs/rrwlock.c:360:rrm_enter_read(rrmlock_t *rrl, void *tag)
./module/zfs/rrwlock.c:362:	rrw_enter_read(&rrl->locks[RRM_TD_LOCK()], tag);
./module/zfs/rrwlock.c:366:rrm_enter_write(rrmlock_t *rrl)
./module/zfs/rrwlock.c:371:		rrw_enter_write(&rrl->locks[i]);
./module/zfs/dsl_dir.c:128:static uint64_t dsl_dir_space_towrite(dsl_dir_t *dd);
./module/zfs/dsl_dir.c:1029:dsl_dir_space_towrite(dsl_dir_t *dd)
./module/zfs/dsl_dir.c:1071:		used += dsl_dir_space_towrite(dd);
./module/zfs/dsl_dir.c:1139:	est_inflight = dsl_dir_space_towrite(dd);
./module/zfs/dsl_dir.c:1348:		est_used = dsl_dir_space_towrite(dd) +
./module/zfs/dsl_dir.c:1482:	towrite = dsl_dir_space_towrite(ds->ds_dir);
./cmd/zpios/zpios_main.c:522:		rc2 = read(zpiosctl_fd, zpios_buffer, zpios_buffer_size - 1);
./cmd/zed/zed_log.c:141:		n = read(_ctx.pipe_fd[0], &c, sizeof (c));
./cmd/zed/zed_file.c:39:		if ((n_read = read(fd, p, n_left)) < 0) {
./cmd/zed/zed_file.c:68:		if ((n_written = write(fd, p, n_left)) < 0) {
./cmd/zstreamdump/zstreamdump.c:90:ssread(void *buf, size_t len, zio_cksum_t *cksum)
./cmd/zstreamdump/zstreamdump.c:94:	if ((outlen = fread(buf, len, 1, send_stream)) == 0)
./cmd/zstreamdump/zstreamdump.c:234:	while (ssread(drr, sizeof (dmu_replay_record_t), &zc)) {
./cmd/zstreamdump/zstreamdump.c:326:				(void) ssread(buf, sz, &zc);
./cmd/zstreamdump/zstreamdump.c:398:				(void) ssread(buf, P2ROUNDUP(drro->drr_bonuslen,
./cmd/zstreamdump/zstreamdump.c:452:			(void) ssread(buf, drrw->drr_length, &zc);
./cmd/zstreamdump/zstreamdump.c:524:			(void) ssread(buf, drrs->drr_length, &zc);
./cmd/zstreamdump/zstreamdump.c:558:			(void) ssread(buf,
./cmd/zpool/zpool_vdev.c:440:	if ((err = efi_alloc_and_read(fd, &vtoc)) != 0) {
./cmd/zpool/zpool_vdev.c:1133:	err = write(fd, buf, size);
./cmd/ztest/ztest.c:843:	if (read(ztest_fd_rand, &r, sizeof (r)) != sizeof (r))
./cmd/ztest/ztest.c:1413:ztest_log_write(ztest_ds_t *zd, dmu_tx_t *tx, lr_write_t *lr)
./cmd/ztest/ztest.c:1428:	    dmu_read(zd->zd_os, lr->lr_foid, lr->lr_offset, lr->lr_length,
./cmd/ztest/ztest.c:1616:ztest_replay_write(ztest_ds_t *zd, lr_write_t *lr, boolean_t byteswap)
./cmd/ztest/ztest.c:1666:	dmu_tx_hold_write(tx, lr->lr_foid, offset, length);
./cmd/ztest/ztest.c:1694:			VERIFY(dmu_read(os, lr->lr_foid, offset,
./cmd/ztest/ztest.c:1704:		 * the ztest_get_data() callback does a dmu_read() of the
./cmd/ztest/ztest.c:1722:		dmu_write(os, lr->lr_foid, offset, length, data, tx);
./cmd/ztest/ztest.c:1728:	(void) ztest_log_write(zd, tx, lr);
./cmd/ztest/ztest.c:1938:		error = dmu_read(os, object, offset, size, buf,
./cmd/ztest/ztest.c:2134:ztest_write(ztest_ds_t *zd, uint64_t object, uint64_t offset, uint64_t size,
./cmd/ztest/ztest.c:2150:	error = ztest_replay_write(zd, lr, B_FALSE);
./cmd/ztest/ztest.c:2210:	dmu_tx_hold_write(tx, object, offset, size);
./cmd/ztest/ztest.c:2253:		(void) ztest_write(zd, object, offset, sizeof (wbt), &wbt);
./cmd/ztest/ztest.c:2267:		(void) ztest_write(zd, object, offset, blocksize, data);
./cmd/ztest/ztest.c:2272:		(void) ztest_write(zd, object, offset, blocksize, data);
./cmd/ztest/ztest.c:2298:		VERIFY0(dmu_read(zd->zd_os, object, offset, blocksize, data,
./cmd/ztest/ztest.c:2301:		(void) ztest_write(zd, object, offset, blocksize, data);
./cmd/ztest/ztest.c:3664:ztest_dmu_read_write(ztest_ds_t *zd, uint64_t id)
./cmd/ztest/ztest.c:3757:	error = dmu_read(os, packobj, packoff, packsize, packbuf,
./cmd/ztest/ztest.c:3760:	error = dmu_read(os, bigobj, bigoff, bigsize, bigbuf,
./cmd/ztest/ztest.c:3769:	dmu_tx_hold_write(tx, packobj, packoff, packsize);
./cmd/ztest/ztest.c:3774:		dmu_tx_hold_write(tx, bigobj, bigoff, bigsize);
./cmd/ztest/ztest.c:3847:	dmu_write(os, packobj, packoff, packsize, packbuf, tx);
./cmd/ztest/ztest.c:3866:		dmu_write(os, bigobj, bigoff, bigsize, bigbuf, tx);
./cmd/ztest/ztest.c:3878:		VERIFY(0 == dmu_read(os, packobj, packoff,
./cmd/ztest/ztest.c:3880:		VERIFY(0 == dmu_read(os, bigobj, bigoff,
./cmd/ztest/ztest.c:4065:		dmu_tx_hold_write(tx, packobj, packoff, packsize);
./cmd/ztest/ztest.c:4066:		dmu_tx_hold_write(tx, bigobj, bigoff, bigsize);
./cmd/ztest/ztest.c:4095:			error = dmu_read(os, packobj, packoff,
./cmd/ztest/ztest.c:4098:			error = dmu_read(os, bigobj, bigoff, bigsize,
./cmd/ztest/ztest.c:4109:		dmu_write(os, packobj, packoff, packsize, packbuf, tx);
./cmd/ztest/ztest.c:4159:			VERIFY(0 == dmu_read(os, packobj, packoff,
./cmd/ztest/ztest.c:4161:			VERIFY(0 == dmu_read(os, bigobj, bigoff,
./cmd/ztest/ztest.c:4241:		if (ztest_write(zd, od->od_object, randoff, blocksize,
./cmd/ztest/ztest.c:4662:	dmu_tx_hold_write(tx, od->od_object, 0, sizeof (uint64_t));
./cmd/ztest/ztest.c:4706:	VERIFY(0 == dmu_read(os, od->od_object, 0, sizeof (uint64_t),
./cmd/ztest/ztest.c:4713:	dmu_write(os, od->od_object, 0, sizeof (uint64_t), &txg, tx);
./cmd/ztest/ztest.c:5152:		if (pwrite(fd, &bad, sizeof (bad), offset) != sizeof (bad))
./cmd/ztest/ztest.c:5221:	dmu_tx_hold_write(tx, object, 0, copies * blocksize);
./cmd/ztest/ztest.c:5267:	(void) zio_wait(zio_rewrite(NULL, spa, 0, &blk,
./cmd/ztest/ztest.c:5545:ztest_resume_thread(void *arg)
./cmd/ztest/ztest.c:5592:ztest_thread(void *arg)
./cmd/zdb/zdb.c:212:	VERIFY(0 == dmu_read(os, object, 0, nvsize, packed, DMU_READ_PREFETCH));
./cmd/zdb/zdb.c:456:		int err = dmu_read(os, object,
./cmd/zdb/zdb.c:477:	int err = dmu_read(os, object, 0, doi.doi_max_offset, subobjs, 0);
./cmd/zdb/zdb.c:688:		VERIFY0(dmu_read(os, space_map_object(sm), offset,
./cmd/zdb/zdb.c:1269:		err = arc_read(NULL, spa, bp, arc_getbuf_func, &buf,
./cmd/zdb/zdb.c:1502:			VERIFY0(dmu_read(bpo->bpo_os,
./cmd/zdb/zdb.c:2160:	if (read(fd, buf, statbuf.st_size) != statbuf.st_size) {
./cmd/zdb/zdb.c:2521:		zio_nowait(zio_read(NULL, spa, bp, data, size,
./cmd/zdb/zdb.c:3195:	VERIFY(write(fileno(stdout), buf, size) == size);
./cmd/zdb/zdb.c:3415:		zio_nowait(zio_read(zio, spa, bp, pbuf, psize, NULL, NULL,
./cmd/zdb/zdb_il.c:122:zil_prt_rec_write(zilog_t *zilog, int txtype, lr_write_t *lr)
./cmd/zdb/zdb_il.c:164:		error = zio_wait(zio_read(NULL, zilog->zl_spa,
./include/sys/spa_impl.h:100: *	PROC_CREATED	-> PROC_ACTIVE		spa_thread()
./include/sys/spa_impl.h:102: *	PROC_DEACTIVATE	-> PROC_GONE		spa_thread()
./include/sys/spa_impl.h:110:	SPA_PROC_GONE		/* spa_thread() is exiting, spa_proc = &p0 */
./include/sys/zap_leaf.h:202:extern int zap_entry_read(const zap_entry_handle_t *zeh,
./include/sys/zfs_znode.h:253:		rrm_enter_read(&(zsb)->z_teardown_lock, FTAG); \
./include/sys/zfs_znode.h:353:extern void zfs_log_write(zilog_t *zilog, dmu_tx_t *tx, int txtype,
./include/sys/zio.h:469:extern zio_t *zio_read(zio_t *pio, spa_t *spa, const blkptr_t *bp, void *data,
./include/sys/zio.h:473:extern zio_t *zio_write(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,
./include/sys/zio.h:479:extern zio_t *zio_rewrite(zio_t *pio, spa_t *spa, uint64_t txg, blkptr_t *bp,
./include/sys/rrwlock.h:74:void rrw_enter_read(rrwlock_t *rrl, void *tag);
./include/sys/rrwlock.h:76:void rrw_enter_write(rrwlock_t *rrl);
./include/sys/rrwlock.h:101:void rrm_enter_read(rrmlock_t *rrl, void *tag);
./include/sys/rrwlock.h:102:void rrm_enter_write(rrmlock_t *rrl);
./include/sys/vdev.h:113:extern boolean_t vdev_cache_read(zio_t *zio);
./include/sys/vdev.h:114:extern void vdev_cache_write(zio_t *zio);
./include/sys/zap.h:220:int zap_count_write(objset_t *os, uint64_t zapobj, const char *name,
./include/sys/zfs_vnops.h:43:extern int zfs_read(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr);
./include/sys/zfs_vnops.h:44:extern int zfs_write(struct inode *ip, uio_t *uio, int ioflag, cred_t *cr);
./include/sys/space_map.h:148:void space_map_write(space_map_t *sm, range_tree_t *rt, maptype_t maptype,
./include/sys/dmu.h:418: * data.  As with any normal buffer, you must call dmu_buf_read() to
./include/sys/dmu.h:654:void dmu_tx_hold_write(dmu_tx_t *tx, uint64_t object, uint64_t off, int len);
./include/sys/dmu.h:705:int dmu_read(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
./include/sys/dmu.h:707:void dmu_write(objset_t *os, uint64_t object, uint64_t offset, uint64_t size,
./include/sys/dbuf.h:291:int dbuf_read(dmu_buf_impl_t *db, zio_t *zio, uint32_t flags);
./include/sys/efi_partition.h:230:extern	int	efi_alloc_and_read(int, struct dk_gpt **);
./include/sys/efi_partition.h:231:extern	int	efi_write(int, struct dk_gpt *);
./include/sys/zap_impl.h:215:int fzap_count_write(zap_name_t *zn, int add, uint64_t *towrite,
./include/sys/dmu_impl.h:279:int dmu_buf_hold_noread(objset_t *, uint64_t, uint64_t,
./include/sys/arc.h:187:int arc_read(zio_t *pio, spa_t *spa, const blkptr_t *bp,
./include/sys/arc.h:190:zio_t *arc_write(zio_t *pio, spa_t *spa, uint64_t txg,
./include/sys/zil.h:359:	WR_INDIRECT,	/* indirect - a large write (dmu_sync() data */
./include/linux/vfs_compat.h:61:	i_size_write(ip, new);
./lib/libzpool/kernel.c:1052:		bytes = read(fd, ptr, resid);
./lib/libzpool/taskq.c:229:taskq_thread(void *arg)
./lib/libzfs_core/libzfs_core.c:521:recv_read(int fd, void *buf, int ilen)
./lib/libzfs_core/libzfs_core.c:528:		rv = read(fd, cp, len);
./lib/libzfs_core/libzfs_core.c:600:	error = recv_read(fd, &drr, sizeof (drr));
./lib/libzfs/libzfs_sendrecv.c:120:ssread(void *buf, size_t len, FILE *stream)
./lib/libzfs/libzfs_sendrecv.c:124:	if ((outlen = fread(buf, len, 1, stream)) == 0)
./lib/libzfs/libzfs_sendrecv.c:190:cksum_and_write(const void *buf, uint64_t len, zio_cksum_t *zc, int outfd)
./lib/libzfs/libzfs_sendrecv.c:193:	return (write(outfd, buf, len));
./lib/libzfs/libzfs_sendrecv.c:261:	while (ssread(drr, sizeof (dmu_replay_record_t), ofp) != 0) {
./lib/libzfs/libzfs_sendrecv.c:275:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:286:				(void) ssread(buf, sz, ofp);
./lib/libzfs/libzfs_sendrecv.c:289:				if (cksum_and_write(buf, sz, &stream_cksum,
./lib/libzfs/libzfs_sendrecv.c:302:			if ((write(outfd, drr,
./lib/libzfs/libzfs_sendrecv.c:310:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:314:				(void) ssread(buf,
./lib/libzfs/libzfs_sendrecv.c:317:				if (cksum_and_write(buf,
./lib/libzfs/libzfs_sendrecv.c:327:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:330:			(void) ssread(buf, drrs->drr_length, ofp);
./lib/libzfs/libzfs_sendrecv.c:331:			if (cksum_and_write(buf, drrs->drr_length,
./lib/libzfs/libzfs_sendrecv.c:339:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:349:			(void) ssread(buf, drrw->drr_length, ofp);
./lib/libzfs/libzfs_sendrecv.c:403:				if (cksum_and_write(&wbr_drr,
./lib/libzfs/libzfs_sendrecv.c:409:				if (cksum_and_write(drr,
./lib/libzfs/libzfs_sendrecv.c:413:				if (cksum_and_write(buf,
./lib/libzfs/libzfs_sendrecv.c:423:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:426:			(void) ssread(buf,
./lib/libzfs/libzfs_sendrecv.c:428:			if (cksum_and_write(buf,
./lib/libzfs/libzfs_sendrecv.c:437:			if (cksum_and_write(drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:1010:send_progress_thread(void *arg)
./lib/libzfs/libzfs_sendrecv.c:1494:			err = cksum_and_write(&drr, sizeof (drr), &zc, outfd);
./lib/libzfs/libzfs_sendrecv.c:1498:				err = cksum_and_write(packbuf, buflen, &zc,
./lib/libzfs/libzfs_sendrecv.c:1511:			err = write(outfd, &drr, sizeof (drr));
./lib/libzfs/libzfs_sendrecv.c:1647:		if (write(outfd, &drr, sizeof (drr)) == -1) {
./lib/libzfs/libzfs_sendrecv.c:1732:recv_read(libzfs_handle_t *hdl, int fd, void *buf, int ilen,
./lib/libzfs/libzfs_sendrecv.c:1740:		rv = read(fd, cp, len);
./lib/libzfs/libzfs_sendrecv.c:1772:	err = recv_read(hdl, fd, buf, len, byteswap, zc);
./lib/libzfs/libzfs_sendrecv.c:2412:	if (0 != (error = recv_read(hdl, fd, &drre, sizeof (drre),
./lib/libzfs/libzfs_sendrecv.c:2585:	while (recv_read(hdl, fd, drr, sizeof (dmu_replay_record_t),
./lib/libzfs/libzfs_sendrecv.c:2610:			(void) recv_read(hdl, fd, buf,
./lib/libzfs/libzfs_sendrecv.c:2620:			(void) recv_read(hdl, fd, buf,
./lib/libzfs/libzfs_sendrecv.c:2628:			(void) recv_read(hdl, fd, buf,
./lib/libzfs/libzfs_sendrecv.c:2637:			(void) recv_read(hdl, fd, buf,
./lib/libzfs/libzfs_sendrecv.c:3218:	if (0 != (err = recv_read(hdl, infd, &drr, sizeof (drr), B_FALSE,
./lib/libzfs/libzfs_sendrecv.c:3234:		 * recv_read() above; do it again correctly.
./lib/libzfs/libzfs_import.c:1317:	if (read(fd, buf, statbuf.st_size) != statbuf.st_size) {
./lib/libzfs/libzfs_diff.c:445:			rv = read(di->datafd, cp, len);
./lib/libzfs/libzfs_pool.c:4032:		if ((err = efi_alloc_and_read(fd, &vtoc)) >= 0) {
./lib/libzfs/libzfs_pool.c:4107:	if ((err = efi_alloc_and_read(fd, &vtoc)) != 0) {
./lib/libzfs/libzfs_pool.c:4208:	 * partitions, and efi_write() will fail if we use it.  V_ROOT, V_BOOT,
./lib/libzfs/libzfs_pool.c:4219:	if ((rval = efi_write(fd, vtoc)) != 0 || (rval = efi_rescan(fd)) != 0) {
./lib/libefi/rdwr_efi.c:114:static int efi_read(int, struct dk_gpt *);
./lib/libefi/rdwr_efi.c:356:efi_alloc_and_read(int fd, struct dk_gpt **vtoc)
./lib/libefi/rdwr_efi.c:370:	rval = efi_read(fd, *vtoc);
./lib/libefi/rdwr_efi.c:384:			rval = efi_read(fd, *vtoc);
./lib/libefi/rdwr_efi.c:439:		error = read(fd, data, dk_ioc->dki_length);
./lib/libefi/rdwr_efi.c:474:		error = write(fd, data, dk_ioc->dki_length);
./lib/libefi/rdwr_efi.c:591:efi_read(int fd, struct dk_gpt *vtoc)
./lib/libefi/rdwr_efi.c:1053:	rval = efi_alloc_and_read(fd, &efi_label);
./lib/libefi/rdwr_efi.c:1100:	 * efi_write()). So there is no need to copy data.
./lib/libefi/rdwr_efi.c:1106:	rval = efi_write(fd, efi_label);
./lib/libefi/rdwr_efi.c:1126:efi_write(int fd, struct dk_gpt *vtoc)

== http:// ==
./module/zpios/pios.c:18: *  For details, see <http://zfsonlinux.org/>.
./module/zpios/pios.c:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./module/unicode/uconv.c:9: * or http://www.opensolaris.org/os/licensing.
./module/unicode/u8_textprep.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_fletcher.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zpool_prop.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_prop.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_uio.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_comutil.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_namecheck.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zprop_common.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zcommon/zfs_deleg.c:9: * or http://www.opensolaris.org/os/licensing.
./module/nvpair/nvpair_alloc_spl.c:10: * or http://www.opensolaris.org/os/licensing.
./module/nvpair/fnvpair.c:9: * or http://www.opensolaris.org/os/licensing.
./module/nvpair/nvpair.c:9: * or http://www.opensolaris.org/os/licensing.
./module/nvpair/nvpair_alloc_fixed.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_fuid.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_traverse.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/ddt_zap.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/sha256.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/sha256.c:32: * http://csrc.nist.gov/publications/PubsFIPS.html
./module/zfs/dsl_dataset.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_userhold.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/ddt.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_root.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_rlock.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_ioctl.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/bptree.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_super.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_objset.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_ctldir.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_raidz.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/metaslab.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/bpobj.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/unique.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zap_leaf.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zrlock.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_file.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfeature_common.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/txg.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_vnops.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_fm.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_label.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_ctldir.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_deadlist.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_cache.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_errlog.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zio_inject.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_dir.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_znode.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/lzjb.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_history.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_xattr.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/space_reftree.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_debug.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_missing.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/refcount.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_diff.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_pool.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/fm.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/multilist.c:11: * http://www.illumos.org/license/CDDL.
./module/zfs/dnode.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_acl.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_config.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_zfetch.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dnode_sync.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_object.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_vfsops.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_file.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/trace.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dbuf.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_disk.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/uberblock.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/sa.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/gzip.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_destroy.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_synctask.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_boot.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zap_micro.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zvol.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_send.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/range_tree.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zio_checksum.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dmu_tx.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_onexit.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/bplist.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_misc.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa.c:2546:				    "http://zfsonlinux.org/msg/ZFS-8000-EY",
./module/zfs/zfs_sa.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zio_compress.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_mirror.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/lz4.c:5: * BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
./module/zfs/lz4.c:31: * - LZ4 homepage : http://fastcompression.blogspot.com/p/lz4.html
./module/zfs/lz4.c:32: * - LZ4 source repository : http://code.google.com/p/lz4/
./module/zfs/dbuf_stats.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/vdev_queue.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_bookmark.c:11: * http://www.illumos.org/license/CDDL.
./module/zfs/blkptr.c:11: * http://www.illumos.org/license/CDDL.
./module/zfs/space_map.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/arc.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_replay.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfeature.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zap.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_scan.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_log.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zil.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_export.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zio.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/spa_stats.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/rrwlock.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zpl_inode.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_dir.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zfs_byteswap.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_prop.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/dsl_deleg.c:9: * or http://www.opensolaris.org/os/licensing.
./module/zfs/zle.c:9: * or http://www.opensolaris.org/os/licensing.
./module/avl/avl.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/mount_zfs/mount_zfs.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpios/zpios.h:18: *  For details, see <http://zfsonlinux.org/>.
./cmd/zpios/zpios.h:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./cmd/zpios/zpios_util.c:18: *  For details, see <http://zfsonlinux.org/>.
./cmd/zpios/zpios_util.c:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./cmd/zpios/zpios_main.c:18: *  For details, see <http://zfsonlinux.org/>.
./cmd/zpios/zpios_main.c:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./cmd/zinject/zinject.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zinject/zinject.h:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zinject/translate.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zed/zed.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_exec.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_exec.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_strings.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_strings.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_event.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_event.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_exec.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_exec.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_log.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_log.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_conf.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_conf.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_conf.c:186:	    "  <http://opensource.org/licenses/CDDL-1.0>.",
./cmd/zed/zed_file.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_file.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_file.c:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_file.c:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_log.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_log.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_strings.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_strings.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_event.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_event.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zed/zed_conf.h:3: * for ZFS on Linux (ZoL) <http://zfsonlinux.org/>.
./cmd/zed/zed_conf.h:11: * "OPENSOLARIS.LICENSE" or at <http://opensource.org/licenses/CDDL-1.0>.
./cmd/zstreamdump/zstreamdump.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zvol_id/zvol_id_main.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zfs/zfs_iter.h:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zfs/zfs_util.h:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zfs/zfs_main.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zfs/zfs_iter.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpool/zpool_iter.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpool/zpool_main.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpool/zpool_main.c:1921:		(void) printf(gettext("   see: http://zfsonlinux.org/msg/%s\n"),
./cmd/zpool/zpool_main.c:4270: *         see: http://zfsonlinux.org/msg/ZFS-xxxx-01
./cmd/zpool/zpool_main.c:4551:		(void) printf(gettext("   see: http://zfsonlinux.org/msg/%s\n"),
./cmd/zpool/zpool_util.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpool/zpool_util.h:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zpool/zpool_vdev.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/ztest/ztest.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zdb/zdb.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zdb/zdb_il.c:9: * or http://www.opensolaris.org/os/licensing.
./cmd/zhack/zhack.c:9: * or http://www.opensolaris.org/os/licensing.
./include/zfs_deleg.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libuutil.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/spa_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfeature.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/u8_textprep.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zap_leaf.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_onexit.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_rlock.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/sa.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_znode.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zrlock.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zil_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/spa.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_fuid.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_delay.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/arc_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/avl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_synctask.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_debug.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/multilist.h:11: * http://www.illumos.org/license/CDDL.
./include/sys/zio.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_acl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/ddt.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/metaslab_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_ctldir.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/rrwlock.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/bpobj.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_scan.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/vdev.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_dataset.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zap.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/nvpair_impl.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_pool.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/range_tree.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/metaslab.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_context.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_ioctl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_vfsops.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_prop.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_dbgmsg.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_userhold.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/u8_textprep_data.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/u8_textprep_data.h:29: * the Terms of Use in http://www.unicode.org/copyright.html.
./include/sys/bplist.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_deleg.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/sa_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_multilist.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/refcount.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_vnops.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_dnode.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/uuid.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/xvattr.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/space_map.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_objset.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/fs/zfs.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/fs/zfs.h:732: * Errata described by http://zfsonlinux.org/msg/ZFS-8000-ER.  The ordering
./include/sys/trace_dmu.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/uberblock_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zio_compress.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/vdev_file.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/spa_boot.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/mntent.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/unique.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/sdt.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/vdev_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/nvpair.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/uio_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_zrlock.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/fm/util.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/fm/fs/zfs.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/fm/protocol.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_traverse.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_dir.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dbuf.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/efi_partition.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zap_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_acl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/space_reftree.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zpl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zvol.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/txg.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_zil.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_zfetch.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_tx.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_sa.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/uberblock.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/bptree.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_destroy.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/vdev_disk.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_dir.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/avl_impl.h:10: * or http://www.opensolaris.org/os/licensing.
./include/sys/zio_checksum.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/blkptr.h:11: * http://www.illumos.org/license/CDDL.
./include/sys/trace_txg.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_arc.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/trace_dbuf.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_bookmark.h:11: * http://www.illumos.org/license/CDDL.
./include/sys/arc.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zio_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dnode.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zil.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/zfs_stat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dsl_deadlist.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/txg_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/sys/dmu_send.h:9: * or http://www.opensolaris.org/os/licensing.
./include/zfs_prop.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libuutil_impl.h:10: * or http://www.opensolaris.org/os/licensing.
./include/libuutil_common.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libnvpair.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/kmap_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/vfs_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/xattr_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/dcache_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/utsname_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/linux/blkdev_compat.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libzfs.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libzfs_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./include/zpios-internal.h:18: *  For details, see <http://zfsonlinux.org/>.
./include/zpios-internal.h:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./include/zfs_namecheck.h:9: * or http://www.opensolaris.org/os/licensing.
./include/zfeature_common.h:9: * or http://www.opensolaris.org/os/licensing.
./include/zfs_comutil.h:9: * or http://www.opensolaris.org/os/licensing.
./include/zpios-ctl.h:18: *  For details, see <http://zfsonlinux.org/>.
./include/zpios-ctl.h:31: *  with ZPIOS.  If not, see <http://www.gnu.org/licenses/>.
./include/zfs_fletcher.h:9: * or http://www.opensolaris.org/os/licensing.
./include/libzfs_core.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzpool/kernel.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzpool/util.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzpool/taskq.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libnvpair/nvpair_alloc_system.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libnvpair/libnvpair.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/timestamp.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/asm-generic/atomic.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/gethrtime.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/strlcat.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/getexecname.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/strlcpy.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/zone.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/getmntany.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/gethrestime.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/mkdirp.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/list.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/attr.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/thread.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/ia32/sys/asm_linkage.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/devid.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/statcommon.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/string.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/stdio.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/kstat.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/byteorder.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/cmn_err.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/cred.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/sysevent/eventdefs.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/mount.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/types32.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/mkdev.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/va_list.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/callb.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/uio.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/kmem.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/vnode.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/note.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/sunddi.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/vtoc.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/time.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/priv.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/processor.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/zone.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/dklabel.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/isa_defs.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/compress.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/frame.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/inttypes.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/sysmacros.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/systm.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/sysevent.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/list.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/systeminfo.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/varargs.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/param.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/int_types.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/bitmap.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/stat.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/int_limits.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/stack.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/feature_tests.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/debug.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/mnttab.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/dkio.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/mhd.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/file.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/policy.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/tzfile.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/list_impl.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/dktp/fdisk.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/acl_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/acl.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/types.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/sys/stropts.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/umem.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/stdlib.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/ucred.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/note.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/limits.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/unistd.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/priv.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/libshare.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/zone.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/rpc/xdr.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/rpc/types.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/libdevinfo.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/assert.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/locale.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/strings.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/synch.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/tzfile.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/atomic.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/util/sscanf.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/libgen.h:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/include/stropts.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/xdr.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libspl/strnlen.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_alloc.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_list.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_open.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_string.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_pname.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_dprintf.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_ident.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_avl.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_misc.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libuutil/uu_strtoint.c:10: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs_core/libzfs_core.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_util.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_sendrecv.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_dataset.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_config.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_import.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_status.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_iter.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_diff.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_mount.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_mount.c:272: * http://www.kernel.org/pub/linux/utils/util-linux/libmount-docs/index.html
./lib/libzfs/libzfs_pool.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_graph.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_fru.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libzfs/libzfs_changelist.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libefi/rdwr_efi.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/nfs.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/libshare_impl.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/smb.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/smb.h:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/libshare.c:9: * or http://www.opensolaris.org/os/licensing.
./lib/libshare/nfs.c:9: * or http://www.opensolaris.org/os/licensing.

== encryption ==
./include/linux/blkdev_compat.h:308:	"an issue report at: https://github.com/zfsonlinux/zfs/issues/new"
./lib/libspl/include/umem.h:37: * https://labs.omniti.com/trac/portableumem

== sql() ==
./module/zfs/vdev_raidz.c:1614:		zio_execute(zio);
./module/zfs/vdev_raidz.c:1655:	zio_execute(zio);
./module/zfs/vdev_file.c:216:		zio_execute(zio);
./module/zfs/zfs_vnops.c:1147:			error = zfs_fastaccesschk_execute(zdp, cr);
./module/zfs/zfs_vnops.c:1159:				error = zfs_fastaccesschk_execute(zdp, cr);
./module/zfs/vdev_missing.c:73:	zio_execute(zio);
./module/zfs/zfs_acl.c:2399:zfs_fastaccesschk_execute(znode_t *zdp, cred_t *cr)
./module/zfs/zpl_file.c:424:			error = lseek_execute(filp, ip, offset, maxbytes);
./module/zfs/vdev_disk.c:693:		zio_execute(zio);
./module/zfs/vdev_mirror.c:355:			zio_execute(zio);
./module/zfs/vdev_mirror.c:382:	zio_execute(zio);
./module/zfs/vdev_queue.c:641:		zio_execute(dio);
./module/zfs/vdev_queue.c:696:		zio_execute(zio);
./module/zfs/vdev_queue.c:774:			zio_execute(nio);
./module/zfs/zio.c:96:static inline void __zio_execute(zio_t *zio);
./module/zfs/zio.c:498:		__zio_execute(pio);
./module/zfs/zio.c:1401: * zio_execute() is a wrapper around the static function
./module/zfs/zio.c:1402: * __zio_execute() so that we can force  __zio_execute() to be
./module/zfs/zio.c:1404: * because __zio_execute() is called recursively in several zio
./module/zfs/zio.c:1405: * code paths.  zio_execute() itself cannot be inlined because
./module/zfs/zio.c:1409:zio_execute(zio_t *zio)
./module/zfs/zio.c:1414:	__zio_execute(zio);
./module/zfs/zio.c:1420:__zio_execute(zio_t *zio)
./module/zfs/zio.c:1501:	__zio_execute(zio);
./module/zfs/zio.c:1536:	__zio_execute(zio);
./module/zfs/zio.c:1546:zio_reexecute(zio_t *pio)
./module/zfs/zio.c:1583:		zio_reexecute(cio);
./module/zfs/zio.c:1592:		__zio_execute(pio);
./module/zfs/zio.c:1647:	zio_reexecute(pio);
./module/zfs/zio.c:2663: * force the underlying vdev layers to call either zio_execute() or
./module/zfs/zio.c:3295:		 * This approach ensures that zio_reexecute() honors
./cmd/ztest/ztest.c:5571:ztest_execute(int test, ztest_info_t *zi, uint64_t id)
./cmd/ztest/ztest.c:5626:			ztest_execute(rand, zi, id);
./include/sys/zio.h:516:extern void zio_execute(zio_t *zio);
./include/sys/zfs_acl.h:219:int zfs_fastaccesschk_execute(struct znode *, cred_t *);
./include/linux/vfs_compat.h:171:lseek_execute(

== tmp() ==
./cmd/ztest/ztest.c:6131:	static char ztest_name_data[] = "/tmp/ztest.data.XXXXXX";
./cmd/zdb/zdb.c:3230: *	leaf_name	  - For example: c1t0d0 or /tmp/ztest.0a
./lib/libshare/nfs.c:658:	static char nfs_exportfs_tempfile[] = "/tmp/exportfs.XXXXXX";

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==
./cmd/ztest/ztest.c:6238:			VERIFY(0 == setenv("LD_LIBRARY_PATH", libpath, 1));

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./module/zpios/pios.c:234:			ASSERT(region->obj.obj > 0); /* XXX - Handle this */
./module/zpios/pios.c:333:	 * XXX: I don't much care for this chunk selection mechansim
./module/zfs/dmu.c:558:	 * XXX - Note, if the dnode for the requested object is not
./module/zfs/dmu.c:1345:		 * XXX uiomove could block forever (eg.nfs-backed
./module/zfs/dmu.c:1637: * N.B. and XXX: the caller is responsible for making sure that the
./module/zfs/dmu.c:1877:			 * XXX -- we should design a compression algorithm
./module/zfs/zfs_ioctl.c:327:		/* XXX reading from non-owned objset */
./module/zfs/zfs_ioctl.c:1409:			 * XXX we could probably try again, since the unmounting
./module/zfs/zfs_ioctl.c:1765:	/* XXX reading from objset not owned */
./module/zfs/zfs_ioctl.c:1794:	/* XXX reading from objset not owned */
./module/zfs/zfs_ioctl.c:2012:		 * XXX reading with out owning
./module/zfs/zfs_ioctl.c:2121:	/* XXX reading without owning */
./module/zfs/zfs_ioctl.c:2336: * XXX: It would be better for callers of the property interface if we handled
./module/zfs/zfs_ioctl.c:4622:		/* XXX kind of reading contents without owning */
./module/zfs/dmu_objset.c:1116:	/* XXX the write_done callback should really give us the tx... */
./module/zfs/vdev_raidz.c:1951:	ASSERT(zio->io_bp != NULL);  /* XXX need to add code to enforce this */
./module/zfs/vdev_raidz.c:1978:		 * XXX -- for now, treat partial writes as a success.
./module/zfs/zap_leaf.c:658:	/* XXX if we did the search above, we could just use that */
./module/zfs/zfs_vnops.c:792:		 * XXX - should we really limit each write to z_max_blksz?
./module/zfs/zfs_vnops.c:2095:			 * XXX: This should be a feature flag for compatibility
./module/zfs/zfs_vnops.c:2574:		 * XXX - Note, we are not providing any open
./module/zfs/zfs_vnops.c:2579:		/* XXX - would it be OK to generate a log record here? */
./module/zfs/zfs_vnops.c:2952:	/* XXX - shouldn't this be done *before* the ATIME/MTIME checks? */
./module/zfs/zfs_vnops.c:3092: * XXX - z_parent_lock can overlap with map or grow locks
./module/zfs/zfs_vnops.c:3913:	 * FIXME: Allow mmap writes past its quota.  The correct fix
./module/zfs/zfs_vnops.c:4463:		/* XXX - this should be the generation number for the objset */
./module/zfs/vdev_cache.c:78: * TODO: Note that with the current ZFS code, it turns out that the
./module/zfs/zfs_dir.c:99:	 * XXX: This should be a feature flag for compatibility
./module/zfs/dsl_pool.c:669:		/* XXX writing something we didn't dirty? */
./module/zfs/dmu_zfetch.c:201:	 * XXX: use a faster division method?
./module/zfs/dmu_zfetch.c:347:	 * XXX: This locking strategy is a bit coarse; however, it's impact has
./module/zfs/dmu_zfetch.c:359:		 * XXX - should this be an assert?
./module/zfs/vdev.c:2423:	/* XXX - L2ARC 1.0 does not support expansion */
./module/zfs/vdev.c:2447:		/* XXX - L2ARC 1.0 does not support expansion */
./module/zfs/vdev.c:2804:				/* XXX cleanup? */
./module/zfs/dnode_sync.c:476:		/* XXX - use dbuf_undirty()? */
./module/zfs/dnode_sync.c:512:	 * XXX - It would be nice to assert this, but we may still
./module/zfs/dmu_object.c:66:		 * XXX We should check for an i/o error here and return
./module/zfs/dbuf.c:398:		/* XXX - we should really return an error instead of assert */
./module/zfs/dbuf.c:526:			 * have the struct_rwlock.  XXX indblksz no longer
./module/zfs/dbuf.c:1112:	/* XXX does *this* func really need the lock? */
./module/zfs/dbuf.c:1122:	 * XXX we should be doing a dbuf_read, checking the return
./module/zfs/dbuf.c:1201:	 * XXX make this true for indirects too?  The problem is that
./module/zfs/dbuf.c:1598:			/* XXX dbuf_undirty? */
./module/zfs/vdev_disk.c:310:	/* TODO: report possible expansion size */
./module/zfs/vdev_disk.c:760:	/* XXX: Implement me as a vnode lookup for the device */
./module/zfs/vdev_disk.c:770:	/* XXX: Implement me as a vnode rele for the device */
./module/zfs/zap_micro.c:553:	/* XXX destroy the avl later, so we can use the stored hash value */
./module/zfs/zvol.c:677:	 * TODO: maybe we should add the operation to the log.
./module/zfs/dmu_tx.c:865:	/* XXX No checking on the meta dnode for now */
./module/zfs/dmu_tx.c:887:			/* XXX txh_arg2 better not be zero... */
./module/zfs/dmu_tx.c:1189:	 * XXX - the "fudge" factor is to account for skipped blocks that
./module/zfs/spa.c:1729:				 * XXX - once we have 'readonly' pool
./module/zfs/vdev_mirror.c:421:		 * XXX -- for now, treat partial writes as success.
./module/zfs/vdev_mirror.c:436:			 * XXX -- for replacing vdevs, there's no great answer.
./module/zfs/arc.c:6039:		zio->io_bp_copy = cb->l2rcb_bp;	/* XXX fix in L2ARC 2.0	*/
./module/zfs/arc.c:6040:		zio->io_bp = &zio->io_bp_copy;	/* XXX fix in L2ARC 2.0	*/
./module/zfs/dsl_scan.c:1816:				 * XXX -- it would be better to change our
./cmd/zinject/translate.c:223:		/* XXX add support for suffixes */
./cmd/zed/zed_strings.c:196: * XXX: Not thread-safe.
./cmd/zed/zed_strings.c:217: * XXX: Not thread-safe.
./cmd/zed/zed_event.c:18:#include <libzfs.h>			/* FIXME: Replace with libzfs_core. */
./cmd/zed/zed_event.c:116:			 * FIXME: Increase max size of event nvlist in
./cmd/zed/zed_event.c:559: * FIXME: Refactor with cmd/zpool/zpool_main.c:zpool_do_events_nvprint()?
./cmd/zed/zed_event.c:639:		    "%s", "_NOT_IMPLEMENTED_");			/* FIXME */
./cmd/zed/zed_event.c:648:		    "%s", "_NOT_IMPLEMENTED_");			/* FIXME */
./cmd/zed/zed_event.c:652:		    "%s", "_NOT_IMPLEMENTED_");			/* FIXME */
./cmd/zed/zed_event.c:683:		    "%s", "_NOT_IMPLEMENTED_");			/* FIXME */
./cmd/zed/zed_event.c:839:		 * FIXME: Increase max size of event nvlist in
./cmd/zed/zed_exec.c:120:		/* FIXME: Timeout rogue child processes with sigalarm? */
./cmd/zed/zed_conf.c:312: * FIXME: Not yet implemented.
./cmd/zed/zed_conf.c:329: * FIXME: Check if zedlet_dir and all parent dirs are secure.
./cmd/zed/zed_conf.c:543: * FIXME: Move state information into kernel.
./cmd/zed/zed_file.c:195: * FIXME: No longer needed?
./cmd/ztest/ztest.c:235: * XXX -- fix zfs range locks to be generic so we can use them here.
./cmd/ztest/ztest.c:2987:	/* XXX workaround 6690467 */
./cmd/ztest/ztest.c:6131:	static char ztest_name_data[] = "/tmp/ztest.data.XXXXXX";
./include/sys/dmu.h:365: * XXX Can only be called on a objset with no dirty data.
./include/sys/dmu_objset.h:104:	struct dmu_tx *os_synctx; /* XXX sketchy */
./include/sys/dmu_impl.h:54: * XXX try to improve evicting path?
./include/sys/zio_impl.h:41: * XXX -- Describe ZFS I/O pipeline here. Fill in as needed.
./include/sys/zio_impl.h:47: * I/O operations: (XXX - provide detail for each of the operations)
./lib/libspl/asm-generic/atomic.c:436:	/* XXX - Implement me */
./lib/libspl/asm-generic/atomic.c:442:	/* XXX - Implement me */
./lib/libspl/asm-generic/atomic.c:448:	/* XXX - Implement me */
./lib/libspl/asm-generic/atomic.c:454:	/* XXX - Implement me */
./lib/libspl/include/sys/dkio.h:73:#define	DKC_XXX_0	3	/* unassigned */
./lib/libspl/include/sys/dkio.h:74:#define	DKC_XXX_1	4	/* unassigned */
./lib/libspl/include/sys/dkio.h:78:#define	DKC_XXX_2	9	/* unassigned */
./lib/libspl/include/umem.h:31: * XXX: We should use the real portable umem library if it is detected
./lib/libspl/xdr.c:38: * FIXME: Not well tested it may not work as expected.
./lib/libuutil/uu_list.c:444:	/* GLXXX debugging? */
./lib/libuutil/uu_list.c:585:	 * XXX: disable list modification until list is empty
./lib/libuutil/uu_dprintf.c:102:	/* XXX Assert that severity is not UU_DPRINTF_SILENT. */
./lib/libzfs/libzfs_sendrecv.c:2582:	/* XXX would be great to use lseek if possible... */
./lib/libzfs/libzfs_sendrecv.c:3049:		 * XXX Do this faster by just iterating over snaps in
./lib/libzfs/libzfs_dataset.c:360:	 * XXX Why do we store the user props separately, in addition to
./lib/libzfs/libzfs_pool.c:2445:		 * XXX - L2ARC 1.0 devices can't support expansion.
./lib/libzfs/libzfs_pool.c:2721:			 * XXX need a better way to prevent user from
./lib/libzfs/libzfs_pool.c:3136:	 * XXX - this should just go away.
./lib/libshare/smb.c:331:	/* TODO: Accept 'name' and sec/acl (?) */
./lib/libshare/libshare.c:173:	char tempfile[] = "/etc/dfs/sharetab.XXXXXX";
./lib/libshare/nfs.c:647: * TODO : Use /var/lib/nfs/etab instead of our private copy.
./lib/libshare/nfs.c:650: * TODO : The temporary file descriptor is never closed since
./lib/libshare/nfs.c:658:	static char nfs_exportfs_tempfile[] = "/tmp/exportfs.XXXXXX";

== unsafe input mechanisms ==

