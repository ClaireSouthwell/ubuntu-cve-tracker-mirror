#! /usr/bin/env python3
# Standard library
import os
import sys
import cve_lib
import re
import argparse
from http.cookiejar import MozillaCookieJar

# Local
## from lib.file_helpers import JsonStore, download_gzip_file
from cvss import CVSS3
from macaroonbakery import httpbakery


def authentication(method, url, payload):
    """
    Authenticate with Macaroons in order to use Webteam API
    """

    client = httpbakery.Client(cookies=MozillaCookieJar(os.path.join(os.path.expanduser('~'), ".ubuntu.com.login")))

    if os.path.exists(client.cookies.filename):
        client.cookies.load(ignore_discard=True)

    response = client.request(method, url=url, json=payload)
    client.cookies.save(ignore_discard=True)
    return response

parser = argparse.ArgumentParser(
    description="This file loads CVEs to webteam's db, using the endpoint ubuntu.com/security/cve"
)
parser.add_argument(
    "--stop", action="store_true",
    help="Exit after non-200 status.",
    )
parser.add_argument(
    "file_path",
    action="store",
    type=str,
    nargs="+",
    help="[Required] The path of the CVE file(s) or folder(s)",
)
args = parser.parse_args()

url = f"https://ubuntu.com/security/"


def post_single_cve(cve_filename):
    # Upload active and ignored (in Ubuntu)
    cve_data = cve_lib.load_cve(cve_filename)

    references = cve_data["References"].split("\n")
    if references[0] == "":
        references.pop(0)

    cvss3 = None
    if len(cve_data["CVSS"]) > 0:
        if "3." in cve_data["CVSS"][0][1]:
            # Use CVSS3
            c = CVSS3(cve_data["CVSS"][0][1])
            cvss3 = c.scores()[0]

    packages = []
    for pkg in cve_data["pkgs"]:
        statuses = []
        for [key, value] in cve_data["pkgs"][pkg].items():
            codename_parts = key.split("/")
            codename = codename_parts[0]

            # TODO this is not going to work
            # devel in a CVE file isn't always going to be the current devel release
            # probably the best thing is to just delete these from the object
            # and not post devel release info to the API at all
            if codename == "devel":
                codename = cve_lib.devel_release

            if codename in cve_lib.releases + ["upstream"]:
                statuses.append(
                    {
                        "release_codename": codename,
                        "status": value[0],
                        "description": value[1],
                    }
                )
        package = {
            "name": pkg,
            "source": f"https://people.canonical.com/~ubuntu-security/cve/pkg/{key}.html",
            "ubuntu": f"https://packages.ubuntu.com/search?suite=all&section=all&arch=any&searchon=sourcenames&keywords={key}",
            "debian": f"https://tracker.debian.org/pkg/{key}",
            "statuses": statuses,
        }
        packages.append(package)

    status = "active"

    if "** REJECT **" in cve_data["Description"]:
        status = "rejected"

    notes = []

    for [author, note] in cve_data["Notes"]:
        notes.append({"author": author, "note": note})

    priority = cve_data["Priority"]

    if priority == "untriaged":
        priority = "unknown"

    cve = {
        "id": cve_data["Candidate"],
        "published": cve_data["PublicDate"],
        "description": cve_data["Description"],
        "ubuntu_description": cve_data["Ubuntu-Description"],
        "notes": notes,
        "priority": priority,
        "cvss3": cvss3,  # CVSS vector to convert into Base score
        "references": references,
        "bugs": cve_data["Bugs"].strip().split(),
        "packages": packages,
        "status": status,
    }

    return cve


## if args:
## headers = {"Content-type": "application/json"}
cves = []
CVE_filename_regex = re.compile(".*/?CVE-\\d{4}-\\d{4,7}$")
NFU_filename_regex = re.compile(".*/not-for-us.txt$")
ignore_paths = ['experimental', 'subprojects', 'scripts']

OK_regex = re.compile(r'^<Response \[2..\]>$')

for cve_filename in args.file_path:

    if os.path.isdir(cve_filename):
        list_cve_files = []
        # Note os.listdir gives unsorted list depending on filestystem
        for file in os.listdir(cve_filename):
            print(file)
            if re.match(CVE_filename_regex, file):
                list_cve_files.append(file)

        list_cves = sorted(list_cve_files)
        print(f"Processing {len(list_cves)} in '{cve_filename}' directory")
        for index in range(len(list_cves)):
            relative_path = f"{cve_filename}/{list_cves[index]}"
            cve = post_single_cve(relative_path)
            cves.append(cve)

    elif re.match(NFU_filename_regex, cve_filename):
        not_for_us_cve_ids = cve_lib.parse_CVEs_from_uri(cve_filename)
        print(f"Processing {len(not_for_us_cve_ids)} from '{cve_filename}' as not for us")
        for cve_id in not_for_us_cve_ids:
            cves.append(
                {
                    "id": cve_id,
                    "notes": [
                        {
                            "author": "ubuntu-security",
                            "note": "Does not apply to software found in Ubuntu.",
                        }
                    ],
                    "references": [
                        f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
                        ],
                    "status": "not-in-ubuntu",
                }
            )

    elif any(x in cve_filename for x in ignore_paths):
        print(f"skipping {cve_filename}")
        continue

    elif re.match(CVE_filename_regex, cve_filename) and os.path.isfile(cve_filename):
    #elif os.path.isfile(cve_filename):
        ## print(f"Processing '{cve_filename}' as single CVE file")
        cve = post_single_cve(cve_filename)
        cves.append(cve)

    else:
        print(f"Warning: '{cve_filename}' not found or not known to be a CVE file", file=sys.stderr)

print(f"{len(cves)} total CVEs")

# Split into chunks of 50
for chunk in [
    cves[i : i + 50] for i in range(0, len(cves), 50)  # noqa: E203
]:
    resp = authentication("PUT", f"{url}cve", chunk)
    print(resp, str(resp.text).rstrip())
    if args.stop and not re.match(OK_regex, str(resp)):
        sys.exit(1)

