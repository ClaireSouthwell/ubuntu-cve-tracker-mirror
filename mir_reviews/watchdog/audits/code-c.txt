Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./src/watchdog.c:58:static int sync_system(int sync_it)
./src/watchdog.c:98:				execl(rbinary, rbinary, parm, NULL);
./src/watchdog.c:100:				execl(rbinary, rbinary, parm, name, NULL);
./src/watchdog.c:104:				execl(rbinary, rbinary, "repair", parm, NULL);
./src/watchdog.c:106:				execl(rbinary, rbinary, "repair", parm, name, NULL);
./src/watchdog.c:407:		do_check(sync_system(sync_it), rbinary, NULL);
./src/mount.c:721:					execv(mountprog, mountargs);
./src/shutdown.c:310:			ph = popen(exe, "w");
./src/test_binary.c:103:			execl(tbinary, tbinary, NULL);
./src/test_binary.c:105:			execl(tbinary, tbinary, "test", NULL);

== memory_management() ==
./src/watchdog.c:79:	sprintf(parm, "%d", result);
./src/watchdog.c:86:		strcpy(filename_buf, logdir);
./src/watchdog.c:90:		strcpy(filename_buf, logdir);
./src/watchdog.c:286:	filename_buf = (char *)xcalloc(strlen(logdir) + sizeof("/repair-bin.stdout") + 1, sizeof(char));
./src/mount.c:278:		*extra_opts = xmalloc(strlen(opts) + 1);
./src/mount.c:700:			sprintf(mountprog, "/sbin/mount.%s", type);
./src/mount.c:942:	environ = (char **)xmalloc(sizeof(char *) * (i + 1));
./src/mount.c:952:		strcpy(argv0[0], PROC_NAME);
./src/mount.c:1051:				mtmp = (struct mntentchn *)xmalloc(sizeof(*mtmp));
./src/mount.c:1057:						sprintf(major, "#%x", DISKMAJOR(statbuf.st_rdev));
./src/mount.c:1077:				cp = (struct child *)xmalloc(sizeof *cp);
./src/xmalloc.c:21:void *xmalloc(size_t size)
./src/xmalloc.c:28:	t = malloc(size);
./src/xmalloc.c:35:void *xcalloc(size_t nmemb, size_t size)
./src/xmalloc.c:42:	t = calloc(nmemb, size);
./src/xmalloc.c:70:	t = xmalloc(n + 1);
./src/shutdown.c:185:			if ((rootfs.mnt_opts = malloc(strlen(mnt->mnt_opts) + strlen("remount,ro") + 2)) == NULL) {
./src/shutdown.c:188:				sprintf(rootfs.mnt_opts, "%s,remount,ro", mnt->mnt_opts);
./src/shutdown.c:229:		if ((p = (PROC *) calloc(1, sizeof(PROC))) == NULL) {
./src/shutdown.c:309:			sprintf(exe, "%s -i %s", PATH_SENDMAIL, admin);
./src/shutdown.c:400:		strcpy(wtmp.ut_user, "shutdown");
./src/shutdown.c:401:		strcpy(wtmp.ut_line, "~");
./src/shutdown.c:402:		strcpy(wtmp.ut_id, "~~");
./src/sundries.c:21:	p = xmalloc(sizeof *p);
./src/sundries.c:35:	res = xmalloc(strlen(s) + strlen(t) + 1);
./src/sundries.c:36:	strcpy(res, s);
./src/sundries.c:51:	res = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);
./src/sundries.c:52:	strcpy(res, s);
./src/sundries.c:70:	res = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);
./src/sundries.c:71:	strcpy(res, s);
./src/sundries.c:154:	sprintf(notype, "no%s", type);
./src/sundries.c:185:	canonical = xmalloc(PATH_MAX + 1);
./src/heartbeat.c:54:			timestamps = (char *)xcalloc(hbstamps, TS_SIZE);
./src/heartbeat.c:58:				memcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE);
./src/heartbeat.c:66:			sprintf(rbuf, "%*s\n", TS_SIZE - 1, "--restart--");
./src/heartbeat.c:67:			memcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE);
./src/heartbeat.c:97:		sprintf(tbufw, "%*s\n", TS_SIZE - 1, tbuf);
./src/heartbeat.c:99:		memcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE);
./src/fstab.c:15:#include "sundries.h"		/* for xmalloc() etc */
./src/fstab.c:101:		mc->nxt = (struct mntentchn *)xmalloc(sizeof(*mc));
./src/lomount.c:101:		sprintf(dev, "/dev/loop%d", i);
./src/logmessage.c:6: * NOTE: We can't use malloc() here as one reason for a call could be the
./src/logmessage.c:115:	vsprintf(buf, fmt, args);
./src/logmessage.c:139:	vsprintf(buf, fmt, args);
./src/umount.c:114:		memcpy(&saddr.sin_addr, hostp->h_addr, hostp->h_length);
./src/configfile.c:110:	new = (struct list *)xcalloc(1, sizeof(struct list));
./src/mntent.c:29:	ss = sp = xmalloc(4 * n + 1);
./src/mntent.c:76:	ret = sp = xmalloc(ss - s + 1);
./src/mntent.c:98:	mntFILE *mfp = xmalloc(sizeof(*mfp));
./src/nfsmount.c:163:		memcpy(&p, &pmap->pml_map, sizeof(p));
./src/nfsmount.c:234:	strcpy(hostdir, spec);
./src/nfsmount.c:263:			memcpy(&server_addr.sin_addr, hp->h_addr, hp->h_length);
./src/nfsmount.c:267:	memcpy(&mount_server_addr, &server_addr, sizeof(mount_server_addr));
./src/nfsmount.c:279:	sprintf(new_opts, "%s%saddr=%s", old_opts, *old_opts ? "," : "", s);
./src/nfsmount.c:504:				memcpy(&mount_server_addr.sin_addr, hp->h_addr, hp->h_length);
./src/nfsmount.c:638:		memcpy(data.root.data, (char *)status.nfsv2.fhstatus_u.fhs_fhandle, NFS_FHSIZE);
./src/nfsmount.c:641:		memcpy(data.old_root.data, (char *)status.nfsv2.fhstatus_u.fhs_fhandle, NFS_FHSIZE);
./src/nfsmount.c:656:		memcpy(data.root.data, (char *)fhandle->fhandle3_val, fhandle->fhandle3_len);
./src/nfsmount.c:707:	memcpy((char *)&data.addr, (char *)&server_addr, sizeof(data.addr));
./src/nfsmount.c:791:	sprintf(buf, "unknown nfs status return value: %d", stat);
./src/test_binary.c:27:	struct process *node = (struct process *)xmalloc(sizeof(struct process));
./src/test_binary.c:92:		strcpy(filename_buf, logdir);
./src/test_binary.c:96:		strcpy(filename_buf, logdir);
./src/net.c:196:			net->packet = (unsigned char *)xcalloc((unsigned int)(DATALEN + MAXIPLEN + MAXICMPLEN), sizeof(char));
./include/sundries.h:60:#include "xmalloc.h"	/* Has xmalloc(), xstrdup() & xstrndup() */
./include/xmalloc.h:4:void *xmalloc (size_t size);
./include/xmalloc.h:5:void *xcalloc (size_t nmemb, size_t size);

== files() ==
./src/wd_identify.c:71:	watchdog = open(devname, O_WRONLY);
./src/watchdog.c:88:		if (!freopen(filename_buf, "a+", stdout))
./src/watchdog.c:92:		if (!freopen(filename_buf, "a+", stderr))
./src/memory.c:44:		mem_fd = open(mem_name, O_RDONLY);
./src/iface.c:16:	FILE *file = fopen("/proc/net/dev", "r");
./src/mount.c:388:	fd = open(device, O_RDONLY);
./src/mount.c:450:static int procopen(void)
./src/mount.c:452:	return ((procfs = fopen(PROC_FILESYSTEMS, "r")) != NULL);
./src/mount.c:474:	if (procopen()) {
./src/mount.c:566:	if (!procopen())
./src/mount.c:838:					    && (fd = open(spec, O_RDONLY)) >= 0) {
./src/mount.c:1176:	while ((fd = open("/dev/null", O_RDWR)) == 0 || fd == 1 || fd == 2) ;
./src/lock_mem.c:74:				fp = fopen(buf, "w");
./src/lock_mem.c:88:				fp = fopen(buf, "w");
./src/shutdown.c:310:			ph = popen(exe, "w");
./src/shutdown.c:394:	if ((fd = open(_PATH_WTMP, O_WRONLY | O_APPEND)) >= 0) {
./src/shutdown.c:416:		if ((fd_seed = open("/dev/urandom", O_RDONLY)) >= 0) {
./src/file_table.c:17:	fd = open("/proc/uptime", O_RDONLY);
./src/heartbeat.c:44:		hb = ((hb = fopen(heartbeat, "r+")) == NULL) ? fopen(heartbeat, "w+") : hb;
./src/fstab.c:63:		int fd = open(MOUNTED, O_RDWR | O_CREAT, 0644);
./src/fstab.c:275:		lock = open(MOUNTED_LOCK, O_WRONLY | O_CREAT, 0);
./src/lomount.c:73:	if ((fd = open(device, O_RDONLY)) < 0) {
./src/lomount.c:104:			fd = open(dev, O_RDONLY);
./src/lomount.c:121:	if ((procdev = fopen(PROC_DEVICES, "r")) != NULL) {
./src/lomount.c:159:	if ((ffd = open(file, mode)) < 0) {
./src/lomount.c:161:			ffd = open(file, mode = O_RDONLY);
./src/lomount.c:167:	if ((fd = open(device, mode)) < 0) {
./src/lomount.c:231:	if ((fd = open(device, O_RDONLY)) < 0) {
./src/keep_alive.c:44:		watchdog_fd = open(name, O_WRONLY);
./src/temp.c:92:	fp = fopen(name, "r");
./src/daemon-pid.c:38:	FILE *fp = fopen(fname, "r");
./src/daemon-pid.c:80:	fp = fopen(fname, "w");
./src/configfile.c:149:	if ((wc = fopen(configfile, "r")) == NULL) {
./src/mntent.c:100:	mfp->mntent_fp = fopen(file, mode);
./src/load.c:36:		load_fd = open(load_name, O_RDONLY);
./src/pidfile.c:17:	int fd = open(file->name, O_RDONLY), pid;
./src/test_binary.c:94:		if (!freopen(filename_buf, "a+", stdout))
./src/test_binary.c:98:		if (!freopen(filename_buf, "a+", stderr))

== logging() ==
./src/wd_identify.c:73:		log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", devname, errno, strerror(errno));
./src/wd_identify.c:79:		log_message(LOG_ERR, "cannot get watchdog identity (errno = %d = '%s')", errno, strerror(errno));
./src/wd_identify.c:86:		log_message(LOG_ERR, "write watchdog device gave error %d = '%s'!", errno, strerror(errno));
./src/wd_identify.c:89:		log_message(LOG_ALERT, "cannot close watchdog (errno = %d = '%s')", errno, strerror(errno));
./src/watchdog.c:116:			log_message(LOG_ERR, "process table is full!");
./src/watchdog.c:137:		log_message(LOG_ERR, "repair child %d timed out", child_pid);
./src/watchdog.c:141:		log_message(LOG_ERR, "child %d does not exist (errno = %d = '%s')", child_pid, err, strerror(err));
./src/watchdog.c:149:		log_message(LOG_ERR, "repair binary %s returned %d", rbinary, ret);
./src/watchdog.c:263:		fatal_error(EX_USAGE, "Error:\n"
./src/watchdog.c:269:		fatal_error(EX_USAGE, "Error:\n"
./src/watchdog.c:276:		fatal_error(EX_SYSERR, "Cannot create directory %s (%s)", logdir, strerror(errno));
./src/watchdog.c:293:			perror(progname);
./src/watchdog.c:299:			perror(progname);
./src/watchdog.c:305:				perror(progname);
./src/watchdog.c:313:			perror(progname);
./src/watchdog.c:335:		fatal_error(EX_USAGE, "unable to gain lock via PID file");
./src/watchdog.c:339:	log_message(LOG_INFO, "starting daemon (%d.%d):", MAJOR_VERSION, MINOR_VERSION);
./src/watchdog.c:340:	log_message(LOG_INFO, "int=%ds realtime=%s sync=%s soft=%s mla=%d mem=%d",
./src/watchdog.c:344:		log_message(LOG_INFO, "ping: no machine to check");
./src/watchdog.c:347:			log_message(LOG_INFO, "ping: %s", act->name);
./src/watchdog.c:350:		log_message(LOG_INFO, "file: no file to check");
./src/watchdog.c:353:			log_message(LOG_INFO, "file: %s:%d", act->name, act->parameter.file.mtime);
./src/watchdog.c:356:		log_message(LOG_INFO, "pidfile: no server process to check");
./src/watchdog.c:359:			log_message(LOG_INFO, "pidfile: %s", act->name);
./src/watchdog.c:362:		log_message(LOG_INFO, "interface: no interface to check");
./src/watchdog.c:365:			log_message(LOG_INFO, "interface: %s", act->name);
./src/watchdog.c:368:		log_message(LOG_INFO, "temperature: no sensors to check");
./src/watchdog.c:370:		log_message(LOG_INFO, "temperature: maximum = %d", maxtemp);
./src/watchdog.c:372:			log_message(LOG_INFO, "temperature: %s", act->name);
./src/watchdog.c:375:	log_message(LOG_INFO, "test=%s(%ld) repair=%s(%ld) alive=%s heartbeat=%s to=%s no_act=%s force=%s",
./src/watchdog.c:461:			log_message(LOG_INFO, "still alive after %ld interval(s)", count);
./src/memory.c:47:			log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", mem_name, err, strerror(err));
./src/memory.c:72:		log_message(LOG_ERR, "lseek %s gave errno = %d = '%s'", mem_name, err, strerror(err));
./src/memory.c:83:		log_message(LOG_ERR, "read %s gave errno = %d = '%s'", mem_name, err, strerror(err));
./src/memory.c:95:		log_message(LOG_ERR, "%s contains invalid data (read = %s)", mem_name, buf);
./src/memory.c:107:		log_message(LOG_INFO, "currently there are %d kB of free memory available", free);
./src/memory.c:110:		log_message(LOG_ERR, "memory %d kB is less than %d pages", free, minpages);
./src/memory.c:126:		log_message(LOG_ALERT, "cannot close %s (errno = %d)", mem_name, errno);
./src/memory.c:149:		log_message(LOG_ALERT, "cannot allocate %lu bytes (errno = %d = '%s')",
./src/memory.c:150:			    (unsigned long)len, i, strerror(i));
./src/iface.c:20:		log_message(LOG_ERR, "cannot open /proc/net/dev (errno = %d = '%s')", err, strerror(err));
./src/iface.c:33:			if (!ferror(file))
./src/iface.c:37:				log_message(LOG_ERR, "cannot read /proc/net/dev (errno = %d = '%s')", err, strerror(err));
./src/iface.c:54:					log_message(LOG_INFO, "device %s received %lu bytes", dev->name, bytes);
./src/iface.c:58:					log_message(LOG_ERR, "device %s did not receive anything since last check", dev->name);
./src/iface.c:69:		log_message(LOG_ERR, "cannot close /proc/net/dev (errno = %d = '%s')", err, strerror(err));
./src/mount.c:436:	perror(device);
./src/mount.c:488:		error("mount: according to mtab, %s is already mounted on %s", mc->mnt_fsname, node);
./src/mount.c:490:		error("mount: according to mtab, %s is mounted on %s", spec, mc->mnt_dir);
./src/mount.c:509:		die(EX_FILEIO, "mount: can't open %s for writing: %s", MOUNTED, strerror(errno));
./src/mount.c:521:			die(EX_FILEIO, "mount: error writing %s: %s", MOUNTED, strerror(errno));
./src/mount.c:525:			die(EX_FILEIO, "mount: error changing mode of %s: %s", MOUNTED, strerror(errno));
./src/mount.c:641:			error("mount: loop device specified twice");
./src/mount.c:646:			error("mount: type specified twice");
./src/mount.c:728:					error("cannot fork: %s", strerror(errno));
./src/mount.c:762:					error("mount: can't open %s: %s", MOUNTED, strerror(errno));
./src/mount.c:765:						error("mount: error writing %s: %s", MOUNTED, strerror(errno));
./src/mount.c:786:		error("mount: you must specify the filesystem type");
./src/mount.c:792:					error("mount: mount point %s is not a directory", node);
./src/mount.c:794:					error("mount: permission denied");
./src/mount.c:796:				error("mount: must be superuser to use mount");
./src/mount.c:800:				error("mount: %s is busy", node);
./src/mount.c:804:					error("mount: %s is busy", node);	/* no */
./src/mount.c:806:					error("mount: proc already mounted");
./src/mount.c:808:				error("mount: %s already mounted or %s busy", spec, node);
./src/mount.c:814:				error("mount: mount point %s does not exist", node);
./src/mount.c:816:				error("mount: mount point %s is a symbolic link to nowhere", node);
./src/mount.c:818:				error("mount: special device %s does not exist", spec);
./src/mount.c:821:				perror("mount");
./src/mount.c:825:			error("mount: mount point %s is not a directory", node);
./src/mount.c:832:					error("mount: %s not mounted already, or bad option", node);
./src/mount.c:834:					error("mount: wrong fs type, bad option, bad superblock on %s,\n"
./src/mount.c:849:			error("mount table full");
./src/mount.c:852:			error("mount: %s: can't read superblock", spec);
./src/mount.c:856:				error("mount: %s has wrong major or minor number", spec);
./src/mount.c:861:				error("mount: fs type %s not supported by kernel", type);
./src/mount.c:873:					error("mount: probably you meant %s", lowtype);
./src/mount.c:875:					error("mount: maybe you meant iso9660 ?");
./src/mount.c:878:				error("mount: %s has wrong device number or fs type %s not supported", spec, type);
./src/mount.c:882:				error("mount: %s is not a block device, and stat fails?", spec);
./src/mount.c:884:				error("mount: the kernel does not recognize %s as a block device\n"
./src/mount.c:887:				error("mount: %s is not a block device (maybe try `-o loop'?)", spec);
./src/mount.c:889:				error("mount: %s is not a block device", spec);
./src/mount.c:892:			error("mount: %s is not a valid block device", spec);
./src/mount.c:897:				error("mount: block device %s is not permitted on its filesystem", spec);
./src/mount.c:912:				error("mount: %s%s is write-protected, mounting read-only",
./src/mount.c:918:			error("mount: %s", strerror(mnt_err));
./src/mount.c:1095:				error("mount: cannot fork: %s", strerror(errno));
./src/mount.c:1121:				perror("waitpid");
./src/mount.c:1263:			error("not mounted anything");
./src/lock_mem.c:54:			log_message(LOG_ERR, "cannot lock realtime memory (errno = %d = '%s')", errno, strerror(errno));
./src/lock_mem.c:61:				log_message(LOG_ERR, "cannot set scheduler (errno = %d = '%s')", errno, strerror(errno));
./src/lock_mem.c:99:			log_message(LOG_WARNING, "unable to disable oom handling!");
./src/lock_mem.c:115:			log_message(LOG_ERR, "cannot unlock realtime memory (errno = %d = '%s')", errno, strerror(errno));
./src/file_stat.c:19:		log_message(LOG_ERR, "cannot stat %s (errno = %d = '%s')", file->name, err, strerror(err));
./src/file_stat.c:31:			log_message(LOG_INFO, "file %s was last changed at %s", file->name, text);
./src/file_stat.c:36:			log_message(LOG_ERR, "file %s was not changed in %d seconds.", file->name, file->parameter.file.mtime);
./src/xmalloc.c:30:		fatal_error(EX_SYSERR, "xmalloc failed for %lu bytes", (unsigned long)size);
./src/xmalloc.c:44:		fatal_error(EX_SYSERR, "xcalloc failed for %lu x %lu bytes", (unsigned long)nmemb, (unsigned long)size);
./src/xmalloc.c:58:		fatal_error(EX_SYSERR, "xstrdup failed for %lu byte string", (unsigned long)strlen(s));
./src/xmalloc.c:68:		fatal_error(EX_SOFTWARE, "bad xstrndup call (%sn = %d)", s == NULL ? "" : "s = NULL, ", n);
./src/shutdown.c:88:	log_message(LOG_INFO, "stopping daemon (%d.%d)", MAJOR_VERSION, MINOR_VERSION);
./src/shutdown.c:131:	log_message(LOG_ALERT, "WATCHDOG PANIC: failed to reboot, trying hard-reset");
./src/shutdown.c:135:	log_message(LOG_ALERT, "WATCHDOG PANIC: still alive after sleeping %d seconds", 4 * dev_timeout);
./src/shutdown.c:152:				perror(mnt->mnt_fsname);
./src/shutdown.c:161:				perror(mnt->mnt_fsname);
./src/shutdown.c:166:				perror(mnt->mnt_fsname);
./src/shutdown.c:182:				log_message(LOG_ERR, "out of memory");
./src/shutdown.c:186:				log_message(LOG_ERR, "out of memory");
./src/shutdown.c:210:		log_message(LOG_ERR, "cannot opendir /proc");
./src/shutdown.c:230:			log_message(LOG_ERR, "out of memory");
./src/shutdown.c:307:			log_message(LOG_ERR, "%s does not exist or is not executable (errno = %d)", PATH_SENDMAIL, errno);
./src/shutdown.c:312:				log_message(LOG_ERR, "cannot start %s (errno = %d)", PATH_SENDMAIL, errno);
./src/shutdown.c:321:				if (ferror(ph) != 0) {
./src/shutdown.c:322:					log_message(LOG_ERR, "cannot send mail (errno = %d)", errno);
./src/shutdown.c:329:					if (ferror(ph) != 0) {
./src/shutdown.c:330:						log_message(LOG_ERR, "cannot send mail (errno = %d)", errno);
./src/shutdown.c:338:						if (ferror(ph) != 0) {
./src/shutdown.c:339:							log_message(LOG_ERR, "cannot send mail (errno = %d)", errno);
./src/shutdown.c:344:					log_message(LOG_ERR, "cannot finish mail (errno = %d)", errno);
./src/shutdown.c:352:	log_message(LOG_ALERT, "shutting down the system because of error %d", errorcode);
./src/shutdown.c:407:			log_message(LOG_ERR, "failed writing wtmp (%s)", strerror(errno));
./src/shutdown.c:424:						log_message(LOG_ERR, "failed writing urandom (%s)", strerror(errno));
./src/shutdown.c:434:		log_message(LOG_ERR, "failed stopping acct() (%s)", strerror(errno));
./src/file_table.c:23:			log_message(LOG_ERR, "file table overflow detected!");
./src/file_table.c:27:			log_message(LOG_ERR, "cannot open /proc/uptime (errno = %d = '%s')", err, strerror(err));
./src/file_table.c:35:			log_message(LOG_ERR, "close /proc/uptime gave errno = %d = '%s'", err, strerror(err));
./src/sundries.c:92:void error(const char *fmt, ...)
./src/heartbeat.c:46:			log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", heartbeat, errno, strerror(errno));
./src/heartbeat.c:110:				log_message(LOG_ERR, "write heartbeat file gave error %d = '%s'!", err, strerror(err));
./src/heartbeat.c:115:				log_message(LOG_ERR, "write heartbeat file gave error %d = '%s'!", err, strerror(err));
./src/heartbeat.c:121:				log_message(LOG_ERR, "write heartbeat file gave error %d = '%s'!", err, strerror(err));
./src/heartbeat.c:135:		log_message(LOG_ALERT, "cannot close %s (errno = %d)", heartbeat, errno);
./src/fstab.c:111:	if (ferror(mfp->mntent_fp)) {
./src/fstab.c:112:		error("warning: error reading %s: %s", fnam, strerror(errno));
./src/fstab.c:142:			error("warning: can't open %s: %s", MOUNTED, strerror(errsv));
./src/fstab.c:163:		error("warning: can't open %s: %s", _PATH_FSTAB, strerror(errno));
./src/fstab.c:278:			    "(use -n flag to override)", MOUNTED_LOCK, strerror(errno));
./src/fstab.c:293:			    MOUNTED_LOCK, errnosv == EINTR ? "timed out" : strerror(errno));
./src/fstab.c:335:		error("cannot open %s (%s) - mtab not updated", MOUNTED, strerror(errno));
./src/fstab.c:341:		error("can't open %s (%s) - mtab not updated", MOUNTED_TEMP, strerror(errno));
./src/fstab.c:363:			die(EX_FILEIO, "error writing %s: %s", MOUNTED_TEMP, strerror(errno));
./src/fstab.c:366:		die(EX_FILEIO, "error writing %s: %s", MOUNTED_TEMP, strerror(errno));
./src/fstab.c:370:		fprintf(stderr, "error changing mode of %s: %s\n", MOUNTED_TEMP, strerror(errno));
./src/fstab.c:374:		fprintf(stderr, "can't rename %s to %s: %s\n", MOUNTED_TEMP, MOUNTED, strerror(errno));
./src/lomount.c:31:void error(const char *fmt, ...);	/* idem */
./src/lomount.c:74:		fprintf(stderr, "loop: can't open device %s: %s\n", device, strerror(errno));
./src/lomount.c:78:		fprintf(stderr, "loop: can't get info on device %s: %s\n", device, strerror(errno));
./src/lomount.c:134:		error("mount: could not find any device /dev/loop#");
./src/lomount.c:137:			error("mount: Could not find any loop device.\n"
./src/lomount.c:140:			error("mount: Could not find any loop device, and, according to %s,\n"
./src/lomount.c:144:			error("mount: Could not find any loop device. Maybe this kernel does not know\n"
./src/lomount.c:148:		error("mount: could not find any free loop device");
./src/lomount.c:163:			perror(file);
./src/lomount.c:168:		perror(device);
./src/lomount.c:212:		perror("ioctl: LOOP_SET_FD");
./src/lomount.c:217:		perror("ioctl: LOOP_SET_STATUS");
./src/lomount.c:232:		fprintf(stderr, "loop: can't delete device %s: %s\n", device, strerror(errno));
./src/lomount.c:236:		perror("ioctl: LOOP_CLR_FD");
./src/keep_alive.c:46:			log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", name, errno, strerror(errno));
./src/keep_alive.c:55:				log_message(LOG_ERR, "cannot get watchdog identity (errno = %d = '%s')", errno, strerror(errno));
./src/keep_alive.c:58:				log_message(LOG_INFO, "hardware watchdog identity: %s", ident.identity);
./src/keep_alive.c:81:				log_message(LOG_ERR, "cannot set timeout %d (errno = %d = '%s')", timeout, errno, strerror(errno));
./src/keep_alive.c:83:				log_message(LOG_INFO, "watchdog now set to %d seconds", timeout);
./src/keep_alive.c:90:				log_message(LOG_ERR, "cannot get timeout (errno = %d = '%s')", errno, strerror(errno));
./src/keep_alive.c:92:				log_message(LOG_INFO, "watchdog was set to %d seconds", timeout);
./src/keep_alive.c:109:		log_message(LOG_ERR, "write watchdog device gave error %d = '%s'!", err, strerror(err));
./src/keep_alive.c:145:			log_message(LOG_ERR, "write watchdog device gave error %d = '%s'!", err, strerror(err));
./src/keep_alive.c:151:			log_message(LOG_ALERT, "cannot close watchdog (errno = %d = '%s')", err, strerror(err));
./src/temp.c:95:		log_message(LOG_ERR, "failed to open %s (%s)", name, strerror(err));
./src/temp.c:105:		log_message(LOG_ERR, "failed to read %s (%s)", name, strerror(err));
./src/temp.c:113:		log_message(LOG_INFO, "current temperature is %.3f for %s", temp, name);
./src/temp.c:144:			log_message(LOG_WARNING, "temperature increases above %d (%s)", templevel3, act->name);
./src/temp.c:149:			log_message(LOG_WARNING, "temperature increases above %d (%s)", templevel2, act->name);
./src/temp.c:155:			log_message(LOG_WARNING, "temperature increases above %d (%s)", templevel1, act->name);
./src/temp.c:162:			log_message(LOG_INFO, "temperature now OK again for %s", act->name);
./src/temp.c:168:		log_message(LOG_ERR, "it is too hot inside (temperature = %d >= %d for %s)", temperature, maxtemp, act->name);
./src/daemon-pid.c:51:				log_message(LOG_WARNING, "PID file %s already used by PID=%d", fname, pid);
./src/daemon-pid.c:65: * Return value is zero if OK, or -1 for error (null name, PID file in use, or can't write).
./src/daemon-pid.c:87:		log_message(LOG_ERR, "cannot open PID file %s (%s)", fname, strerror(errno));
./src/daemon-pid.c:105:			log_message(LOG_ERR, "cannot remove PID file %s (%s)", saved_fname, strerror(errno));
./src/logmessage.c:4: * Also has fatal_error() function to the same then exit.
./src/logmessage.c:23:static int output_message(int level, char *buf);
./src/logmessage.c:36: * or to syslog (assuming it is compiled as such, otherwise terminal as well).
./src/logmessage.c:64: * log_message() and fatal_error() calls. When using syslog we can output
./src/logmessage.c:68:static int output_message(int level, char *buf)
./src/logmessage.c:75:		syslog(level, "%s", buf);
./src/logmessage.c:88:		syslog(level, "failed writing message terminal (rv=%d, errno='%s')", rv, strerror(errno));
./src/logmessage.c:100: * the string '%s' and give it strerror(errno) as an argument.
./src/logmessage.c:103:int log_message(int level, const char *fmt, ...)
./src/logmessage.c:119:	rv = output_message(level, buf);
./src/logmessage.c:128:void fatal_error(int exitcode, const char *fmt, ...)
./src/logmessage.c:143:	output_message(LOG_ERR, buf);
./src/umount.c:122:		clnt_pcreateerror("Cannot MOUNTPROG RPC");
./src/umount.c:132:		clnt_perror(clp, "Bad UMNT RPC");
./src/umount.c:147:		error("umount: %s: invalid block device", dev);
./src/umount.c:150:		error("umount: %s: not mounted", dev);
./src/umount.c:153:		error("umount: %s: can't write superblock", dev);
./src/umount.c:158:		error("umount: %s: device is busy", dev);
./src/umount.c:161:		error("umount: %s: not found", dev);
./src/umount.c:164:		error("umount: %s: must be superuser to umount", dev);
./src/umount.c:167:		error("umount: %s: block devices not permitted on fs", dev);
./src/umount.c:170:		error("umount: %s: %s", dev, strerror(err));
./src/umount.c:232:			perror("remount");
./src/configfile.c:150:		fatal_error(EX_SYSERR, "Can't open config file \"%s\" (%s)", configfile, strerror(errno));
./src/configfile.c:156:			if (!ferror(wc))
./src/configfile.c:159:				fatal_error(EX_SYSERR, "Error reading config file (%s)", strerror(errno));
./src/configfile.c:308:		fatal_error(EX_SYSERR, "Error closing file (%s)", strerror(errno));
./src/configfile.c:314:		fatal_error(EX_SYSERR, "Parameters %s = %d in file \"%s\" must be > 0", INTERVAL, tint, configfile);
./src/configfile.c:357:			log_message(LOG_WARNING, "skipping hidden file %s", fname);
./src/configfile.c:366:		log_message(LOG_DEBUG, "adding %s to list of auto-repair binaries", fname);
./src/wd_keepalive.c:55:	log_message(LOG_INFO, "stopping watchdog keepalive daemon (%d.%d)", MAJOR_VERSION, MINOR_VERSION);
./src/wd_keepalive.c:141:		perror(progname);
./src/wd_keepalive.c:147:		perror(progname);
./src/wd_keepalive.c:153:			perror(progname);
./src/wd_keepalive.c:161:		perror(progname);
./src/wd_keepalive.c:182:		fatal_error(EX_USAGE, "unable to gain lock via PID file");
./src/wd_keepalive.c:187:	log_message(LOG_INFO, "starting watchdog keepalive daemon (%d.%d):", MAJOR_VERSION, MINOR_VERSION);
./src/wd_keepalive.c:189:		log_message(LOG_INFO, " no watchdog device configured, aborting");
./src/wd_keepalive.c:191:		log_message(LOG_INFO, " int=%d alive=%s realtime=%s", tint, devname, realtime ? "yes" : "no");
./src/load.c:38:			log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", load_name, errno, strerror(errno));
./src/load.c:61:		log_message(LOG_ERR, "lseek %s gave errno = %d = '%s'", load_name, err, strerror(err));
./src/load.c:72:		log_message(LOG_ERR, "read %s gave errno = %d = '%s'", load_name, err, strerror(err));
./src/load.c:92:		log_message(LOG_ERR, "%s does not contain any data (read = %s)", load_name, buf);
./src/load.c:101:		log_message(LOG_INFO, "current load is %d %d %d", avg1, avg5, avg15);
./src/load.c:105:		log_message(LOG_ERR, "loadavg %d %d %d is higher than the given threshold %d %d %d!",
./src/load.c:122:		log_message(LOG_ALERT, "cannot close %s (errno = %d)", load_name, errno);
./src/pidfile.c:22:		log_message(LOG_ERR, "cannot open %s (errno = %d = '%s')", file->name, err, strerror(err));
./src/pidfile.c:35:		log_message(LOG_ERR, "lseek %s gave errno = %d = '%s'", file->name, err, strerror(err));
./src/pidfile.c:50:		log_message(LOG_ERR, "read %s gave errno = %d = '%s'", file->name, err, strerror(err));
./src/pidfile.c:64:		log_message(LOG_ERR, "could not close %s, errno = %d = '%s'", file->name, err, strerror(err));
./src/pidfile.c:74:		log_message(LOG_ERR, "pinging process %d (%s) gave errno = %d = '%s'", pid, file->name, err, strerror(err));
./src/pidfile.c:84:		log_message(LOG_INFO, "was able to ping process %d (%s).", pid, file->name);
./src/nfsmount.c:73:static char *nfs_strerror(int stat);
./src/nfsmount.c:600:					clnt_perror(mclient, "mount");
./src/nfsmount.c:605:					clnt_perror(mclient, "mount");
./src/nfsmount.c:612:					clnt_pcreateerror("mount");
./src/nfsmount.c:635:				hostname, dirname, nfs_strerror(status.nfsv2.fhs_status));
./src/nfsmount.c:649:				hostname, dirname, nfs_strerror(status.nfsv3.fhs_status));
./src/nfsmount.c:673:		perror("nfs socket");
./src/nfsmount.c:677:		perror("nfs bindresvport");
./src/nfsmount.c:700:		perror("nfs connect");
./src/nfsmount.c:782:static char *nfs_strerror(int stat)
./src/nfsmount.c:789:			return strerror(nfs_errtbl[i].errnum);
./src/test_binary.c:83:		log_message(LOG_ERR, "test-binary %s exceeded time limit %ld", tbinary, timeout);
./src/test_binary.c:115:			log_message(LOG_ERR, "process table is full!");
./src/test_binary.c:146:				log_message(LOG_ERR, "test binary %s returned %d", tbinary, WEXITSTATUS(result));
./src/test_binary.c:150:				log_message(LOG_ERR, "test binary %s was killed by uncaught signal %d", tbinary, WTERMSIG(result));
./src/test_binary.c:158:				log_message(LOG_ERR, "child %d did not exit immediately (error = %d = '%s')", child_pid, err, strerror(err));
./src/ifdown.c:39:		perror("socket");
./src/ifdown.c:47:		perror("SIOCGIFCONF");
./src/ifdown.c:61:			perror(ifr[i].ifr_name);
./src/net.c:89:				log_message(LOG_ERR, "network is unreachable (target: %s)", target);
./src/net.c:94:				log_message(LOG_ERR, "sendto gave errno = %d = '%s'", err, strerror(err));
./src/net.c:128:					log_message(LOG_ERR, "ping select timeout = %2ld.%06ld seconds",
./src/net.c:143:							log_message(LOG_ERR, "recvfrom gave errno = %d = '%s'", err, strerror(err));
./src/net.c:159:								log_message(LOG_INFO, "got answer from target %s", target);
./src/net.c:169:	log_message(LOG_ERR, "no response from ping (target: %s)", target);
./src/net.c:194:			     fatal_error(EX_USAGE, "unknown host %s", act->name);
./src/net.c:198:				fatal_error(EX_SYSERR, "unknown protocol icmp.");
./src/net.c:202:			    fatal_error(EX_SYSERR, "error opening socket (%s)", strerror(errno));
./include/sundries.h:37:void error(const char *fmt, ...);
./include/logmessage.h:12: * We need the LOG_? values used for log_message() so either include <syslog.h>
./include/logmessage.h:30: * Define exit status for fatal_error() calls (from sundries.h originally).
./include/logmessage.h:65:int  log_message(int level,		const char *fmt, ...) PRINTF_STYLE(2, 3);
./include/logmessage.h:66:void fatal_error(int exitcode,	const char *fmt, ...) PRINTF_STYLE(2, 3);

== environment() ==

== privileged() ==
./src/mount.c:706:					setuid(getuid());
./src/mount.c:707:					setgid(getgid());
./src/wd_identify.c:78:	if (ioctl(watchdog, WDIOC_GETSUPPORT, &ident) < 0) {
./src/mount.c:523:	if (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)
./src/mount.c:839:						if (ioctl(fd, BLKGETSIZE, &size) == 0 && size <= 2)
./src/fstab.c:369:	if (fchmod(fileno(mftmp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)
./src/lomount.c:77:	if (ioctl(fd, LOOP_GET_STATUS, &loopinfo) < 0) {
./src/lomount.c:106:				if (ioctl(fd, LOOP_GET_STATUS, &loopinfo) == 0)
./src/lomount.c:211:	if (ioctl(fd, LOOP_SET_FD, ffd) < 0) {
./src/lomount.c:215:	if (ioctl(fd, LOOP_SET_STATUS, &loopinfo) < 0) {
./src/lomount.c:216:		(void)ioctl(fd, LOOP_CLR_FD, 0);
./src/lomount.c:235:	if (ioctl(fd, LOOP_CLR_FD, 0) < 0) {
./src/keep_alive.c:22:#include <stropts.h>			/* for ioctl() */
./src/keep_alive.c:54:			if (ioctl(watchdog_fd, WDIOC_GETSUPPORT, &ident) < 0) {
./src/keep_alive.c:80:			if (ioctl(watchdog_fd, WDIOC_SETTIMEOUT, &timeout) < 0) {
./src/keep_alive.c:89:			if (ioctl(watchdog_fd, WDIOC_GETTIMEOUT, &timeout) < 0) {
./src/ifdown.c:45:	if (ioctl(fd, SIOCGIFCONF, &ifc) < 0) {
./src/ifdown.c:59:		if (ioctl(fd, SIOCSIFFLAGS, &ifr[i]) < 0) {

== networking() ==
./src/umount.c:117:	saddr.sin_family = AF_INET;
./src/nfsmount.c:250:	server_addr.sin_family = AF_INET;
./src/nfsmount.c:492:			mount_server_addr.sin_family = AF_INET;
./src/nfsmount.c:503:				mount_server_addr.sin_family = AF_INET;
./src/nfsmount.c:669:		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/nfsmount.c:671:		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
./src/nfsmount.c:807:	sin.sin_family = AF_INET;
./src/ifdown.c:37:	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
./src/net.c:191:			((struct sockaddr_in *)&(net->to))->sin_family = AF_INET;
./src/net.c:200:			if ((net->sock_fp = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0
./src/wd_identify.c:85:	if (write(watchdog, "V", 1) < 0)
./src/memory.c:81:	if (read(mem_fd, buf, sizeof(buf)) < 0) {
./src/mount.c:96:/* True for explicit read/write (-w).  */
./src/mount.c:392:	if (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))
./src/mount.c:406:		if (lseek(fd, 0, SEEK_SET) != 0 || read(fd, (char *)&xsb, sizeof(xsb)) != sizeof(xsb))
./src/mount.c:416:		if (lseek(fd, 8192, SEEK_SET) != 8192 || read(fd, (char *)&ufssb, sizeof(ufssb)) != sizeof(ufssb))
./src/mount.c:424:		if (lseek(fd, 0x8000, SEEK_SET) != 0x8000 || read(fd, (char *)&isosb, sizeof(isosb)) != sizeof(isosb))
./src/shutdown.c:406:		if (write(fd, (char *)&wtmp, sizeof(wtmp)) < 0)
./src/shutdown.c:422:				if (read(fd_seed, buf, 512) == 512) {
./src/shutdown.c:423:					if (write(fd_bck, buf, 512) < 0)
./src/heartbeat.c:108:			if (fwrite(timestamps + (lastts * TS_SIZE), TS_SIZE, hbstamps - lastts, hb) == 0) {
./src/heartbeat.c:113:			if (fwrite(timestamps, TS_SIZE, lastts, hb) == 0) {
./src/heartbeat.c:119:			if (fwrite(timestamps, TS_SIZE, nrts, hb) == 0) {
./src/keep_alive.c:107:	if (write(watchdog_fd, "\0", 1) < 0) {
./src/keep_alive.c:143:		if (write(watchdog_fd, "V", 1) < 0) {
./src/load.c:70:	if (read(load_fd, buf, sizeof(buf)) < 0) {
./src/pidfile.c:48:	if (read(fd, buf, sizeof(buf)) < 0) {
./src/nfsmount.c:21: * Omit the call to connect() for Linux version 1.3.11 or later.
./src/nfsmount.c:669:		fsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/nfsmount.c:671:		fsock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
./src/nfsmount.c:695:	 * connect() the socket for kernels 1.3.10 and below only,
./src/nfsmount.c:699:	if (linux_version_code() <= 66314 && connect(fsock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
./src/ifdown.c:37:	if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
./src/net.c:82:		j = sendto(sock_fp, (char *)outpack, DATALEN + 8, 0, &to, sizeof(struct sockaddr));
./src/net.c:200:			if ((net->sock_fp = socket(AF_INET, SOCK_RAW, proto->p_proto)) < 0
./src/net.c:202:			    fatal_error(EX_SYSERR, "error opening socket (%s)", strerror(errno));

== http:// ==
./include/logmessage.h:52: * http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html

== encryption ==

== sql() ==

== tmp() ==
./src/lomount.c:91:	/* Just creating a device, say in /tmp, is probably a bad idea -

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==

== unsafe input mechanisms ==

