#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import glob, sys, os, re

# common to all scripts
releases      = ['dapper','edgy','feisty','gutsy','hardy','intrepid']
eol_releases  = ['edgy']
devel_release = 'intrepid'

priorities = [ 'negligible', 'low', 'medium', 'high', 'critical' ]

active_dir = "active"
embargoed_dir = "embargoed"
ignored_dir = "ignored"
retired_dir = "retired"

EXIT_FAIL = 1
EXIT_OKAY = 0

def drop_dup_release(cve,rel):
    output = file(cve+".new",'w')
    saw = set()
    for line in file(cve).readlines():
        if line.startswith('%s_' % (rel)):
            pkg = line.split('_')[1].split(':')[0]
            if not pkg in saw:
                output.write(line)
                saw.add(pkg)
        else:
            output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def clone_release(cve,pkg,oldrel,newrel):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if line.startswith('%s_%s:' % (oldrel,pkg)):
            newline = line.replace('%s_%s:'%(oldrel,pkg),'%s_%s:'%(newrel,pkg),1)
            output.write(newline)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def update_state(cve,pkg,rel,state,notes):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if line.startswith('%s_%s:' % (rel, pkg)):
            line = '%s_%s: %s (%s)\n' % (rel, pkg, state, notes)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def drop_field(cve,field):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if not line.startswith('%s:' % (field)):
            output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def add_reference(cve,url):
    output = file(cve+".new",'w')
    in_references = False
    for line in file(cve).readlines():
        if in_references and not line.startswith(' '):
            output.write(' ' + url + '\n')
            in_references = False
        elif not in_references and line.startswith('References:'):
            in_references = True
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def update_description(cve,desc):
    desc = desc.rstrip()
    # Description is a multi-line entry -- it must start with a newline
    if not desc.startswith('\n'):
        desc = '\n' + desc
    output = file(cve+".new",'w')
    skip = 0
    for line in file(cve).readlines():
        if skip and line.startswith(' '):
            continue
        skip = 0
        if line.startswith('Description:'):
            prefix = 'Description:'
            for descline in desc.split('\n'):
                output.write('%s%s\n' % (prefix,descline))
                prefix = ' '
            skip = 1
            continue
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def get_cve_list():
    cves = [elem for elem in os.listdir(active_dir) \
           if re.match('^CVE-\d+-\d+$',elem)]

    uems = []
    if os.path.islink(embargoed_dir):
        uems = [elem for elem in os.listdir(embargoed_dir) \
               if re.match('^[\w-]*$',elem)]
        for cve in uems:
            if cve in cves:
                print >>sys.stderr, "Duplicated CVE (in embargoed): %s" % (cve)
        cves = cves + uems

    return (cves, uems)

def load_cve(cve):
    '''Loads a given CVE into:
       dict( fields...
             'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
           )
    '''

    msg = ''
    code = EXIT_OKAY

    data = dict()
    affected = dict()
    lastfield = None
    fields_seen = []
    for line in file(cve).readlines():
        line = line.rstrip()

        # Ignore blank/commented lines
        if len(line) == 0 or line.startswith('#'):
            continue
        if line.startswith(' '):
            data[lastfield] += '\n%s' % (line[1:])
            continue

        try:
            field, value = line.split(':',1)
        except ValueError, e:
            msg += "%s: bad line '%s' (%s)\n" % (cve, line, e)
            code = EXIT_FAIL
            continue

        lastfield = field = field.strip()
        if field in fields_seen:
            msg += "%s: repeated field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            fields_seen.append(field)
        value = value.strip()
        if field == 'Candidate':
            data.setdefault(field,value)
            if value != "" and not value.startswith('CVE-') and not value.startswith('UEM-') and not value.startswith('EMB-'):
                msg += "%s: unknown Candidate '%s' (must be /(CVE|UEM|EMB)-/)\n" % (cve, value)
                code = EXIT_FAIL
        elif 'Priority' in field:
            if 'Priority_' in field:
                try:
                    foo, pkg = field.split('_',1)
                except ValueError:
                    msg += "%s: bad field with 'Priority_': '%s'\n" % (cve, field)
                    code = EXIT_FAIL
                    continue
            data.setdefault(field,value)
            if not value in ['untriaged'] + priorities:
                msg += "%s: unknown Priority '%s'\n" % (cve, value)
                code = EXIT_FAIL
        elif 'Patches_' in field:
            try:
                foo, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with 'Patches_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            data.setdefault(field,value)
        elif '_' in field:
            try:
                release, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with '_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            if not release in releases + ['upstream', 'devel'] and not release in eol_releases:
                msg += "%s: bad release '%s'\n" % (cve, release)
                code = EXIT_FAIL
                continue
            try:
                info = value.split(' ',1)
            except ValueError:
                msg += "%s: missing state for '%s': '%s'\n" % (cve, field, value)
                code = EXIT_FAIL
                continue
            state = info[0]
            if state == '':
                state = 'needs-triage'

            if len(info) < 2:
                notes = ""
            else:
                notes = info[1].strip()
            if notes.startswith('('):
                notes = notes[1:]
            if notes.endswith(')'):
                notes = notes[:-1]

            # Work-around for old-style of only recording released versions
            if notes == '' and state[0] in ('0123456789'):
                notes = state
                state = 'released'

            if state not in ['needs-triage','needed','active','pending','released','deferred','DNE','ignored','not-affected']:
                msg += "%s: %s_%s has unknown state: '%s'\n" % (cve, release, pkg, state)
                code = EXIT_FAIL

            # Verify "active" states have an Assignee
            if state == 'active' and data['Assigned-to'].strip() == "":
                msg += "%s: %s_%s has state '%s' but lacks 'Assigned-to'\n" % (cve, release, pkg)
                code = EXIT_FAIL

            affected.setdefault(pkg,dict())
            affected[pkg].setdefault(release,[state,notes])
        elif not field in ['References','Description','Ubuntu-Description','Notes','Bugs','Assigned-to','CoordinatedReleaseDate','Discovered-by']:
            msg += "%s: unknown field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            data.setdefault(field,value)

    pkgs = sorted(affected.keys())
    # this check isn't safe due to the "ignored" cves.
    if False and len(pkgs) == 0:
            msg += "%s: no packages affected?!\n" % (cve)
            code = EXIT_FAIL
    # check for missing upstreams
    append = ''
    for pkg in pkgs:
        if not 'upstream' in affected[pkg].keys():
            append += 'upstream_%s: \n' % (pkg)
    if append != '':
        print >>sys.stderr, "%s: adding missing 'upstream' for: %s" % (cve, ", ".join(pkgs))
        file(cve,'a').write(append)

    data['pkgs'] = affected

    if code != EXIT_OKAY:
        raise ValueError, msg.strip()
    return data

# supported options
#  linux = rename linux-source-* packages to "linux"
#  packages = list of packages to pay attention to
#  debug = bool, display debug information
def load_all(cves, uems, opt=None):
    table = dict()
    priority = dict()
    listcves = []
    for cve in cves:
        table.setdefault(cve, dict())
        priority.setdefault(cve, dict())
        cvedir = active_dir
        if cve in uems:
            cvedir = embargoed_dir
        cvefile = os.path.join(cvedir, cve)
        info = load_cve(cvefile)

        # Allow for Priority overrides
        priority[cve]['default'] = 'untriaged'
        try:
            priority[cve]['default'] = info['Priority']
        except:
            priority[cve]['default'] = 'untriaged'

        for package in info['pkgs']:
            pkg = package
            # special-case the kernel, since it is per-release
            if opt and opt.linux:
                if pkg in ['linux-source-2.6.15','linux-source-2.6.20','linux-source-2.6.22']:
                 pkg = 'linux'
            if opt and opt.packages and pkg not in opt.packages:
                continue
            table[cve].setdefault(pkg,dict())
            for release in info['pkgs'][package]:
                rel = release
                if rel == 'devel':
                    rel = devel_release
                status = info['pkgs'][package][release][0]
                if opt and opt.linux and status == 'DNE':
                    continue
                table[cve][pkg].setdefault(rel,status)

            field = 'Priority_' + pkg
            if info.has_key(field):
                priority[cve][pkg] = info[field]
            if opt and opt.debug:
                print >>sys.stderr, "Loaded '%s'" % (pkg)

        # Ignore CVEs that have no packages we're interested in
        if len(table[cve])!=0:
            listcves.append(cve)
    updated_cves = listcves
    return (table, priority, updated_cves)

def is_supported(map, pkg, releases):
    rel = []
    if isinstance(releases, basestring):
        rel.append(releases)
    else:
        rel = releases

    for r in rel:
        if map[r].has_key(pkg) and \
          (map[r][pkg]['section'] == 'main' or \
           map[r][pkg]['section'] == 'restricted'):
            return True
    return False

def is_partner(map, pkg, releases):
    rel = []
    if isinstance(releases, basestring):
        rel.append(releases)
    else:
        rel = releases

    for r in rel:
        if map[r].has_key(pkg) and \
          (map[r][pkg]['pocket'] == 'commercial' or \
           map[r][pkg]['section'] == 'partner'):
            return True
    return False

def is_universe(map, pkg, releases):
    rel = []
    if isinstance(releases, basestring):
        rel.append(releases)
    else:
        rel = releases

    for r in rel:
        if is_supported(map, pkg, releases) or is_partner(map, pkg, releases):
            return False
    return True

