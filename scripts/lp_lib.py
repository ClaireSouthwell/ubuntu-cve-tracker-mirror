#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Lazy-loading LP interface.
import sys

class UCTLaunchpad(object):
    def __init__(self, opt):
        # Global LP connections/links
        self.link = dict()
        self.link['lp'] = None
        self.link['ubuntu'] = None
        self.link['archive'] = None

        # Cached dictionaries
        self.cache = dict()
        self.cache['series'] = dict()

        # For get_release_version
        self.release_pkg_cache = dict()

        # Toggles
        self.debug = hasattr(opt, 'debug') and opt.debug

    def cached(self, field, name):
        if not self.cache.has_key(field):
            raise AttributeError, "UCTLaunchpad has no cache named '%s'" % (field)
        if self.cache[field].has_key(name):
            return self.cache[field][name]
        if field == 'series':
            if self.debug:
                print >>sys.stderr, "API: getSeries(%s) ..." % (name)
            self.cache[field][name] = self.ubuntu.getSeries(name_or_version=name)
        return self.cache[field][name]

    def __getattr__(self, name):
        if not self.link.has_key(name):
            raise AttributeError, "UCTLaunchpad has no attr named '%s'" % (name)
        if self.link[name] != None:
            return self.link[name]
        if name == 'lp':
            if self.debug:
                print >>sys.stderr, "Starting LP API ..."
            try:
                import lpl_common
            except:
                print >>sys.stderr, "lpl_common.py seems to be missing. Please create a symlink from $UQT/common/lpl_common.py to $UCT/scripts/"
                sys.exit(1)
            self.link['lp'] = lpl_common.connect()
            if self.debug:
                print >>sys.stderr, "\tauthenticated to LP."
        elif name == 'ubuntu':
            if self.debug:
                print >>sys.stderr, "Looking up Ubuntu distribution ..."
            self.link['ubuntu'] = self.lp.distributions['ubuntu']
            if self.debug:
                print >>sys.stderr, "\tUbuntu distribution found."
        elif name =='archive':
            if self.debug:
                print >>sys.stderr, "Looking up Ubuntu archive ..."
            self.link['archive'] = self.ubuntu.archives[0]
            if self.debug:
                print >>sys.stderr, "\tUbuntu archive found."
        return self.link[name]

    # Searches all pockets for the first known version of a package. (Since
    # packages can be added to -updates post-release, we need to check all
    # pockets.) To find a version for a specific pocket, just override the list.
    def get_release_version(self, rel, pkg, key='release', pockets=['Release','Updates','Security','Proposed']):
      if not self.release_pkg_cache.has_key(rel) or not self.release_pkg_cache[rel].has_key(pkg) or not self.release_pkg_cache[rel][pkg].has_key(key):
        self.release_pkg_cache.setdefault(rel, dict())
        self.release_pkg_cache[rel].setdefault(pkg, dict())
        for pocket in pockets:
            if self.debug:
                print >>sys.stderr, "API: getPublishedSources(%s, %s, %s) ..." % (rel, pocket, pkg)
            pkgs = self.archive.getPublishedSources(source_name=pkg, distro_series=self.cached('series',rel), pocket=pocket, status='Published', exact_match=True)
            if len(pkgs) < 1:
                if self.debug:
                    print >>sys.stderr, "\tDNE"
                continue
            self.release_pkg_cache[rel][pkg][key] = pkgs[0].source_package_version
            if self.debug:
                print >>sys.stderr, "\t%s" % (self.release_pkg_cache[rel][pkg][key])
            break
      self.release_pkg_cache[rel][pkg].setdefault(key, "~")
      return self.release_pkg_cache[rel][pkg][key]
