#!/usr/bin/env python

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2017 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import datetime
import os
import re
import sys
import optparse
import cve_lib
import time
import json

import source_map

packages = dict()
assignees = dict()
pkg_assignees = dict()
popularity = dict()
pockets = { 'extended' : dict(),
            'ppa' : dict() }

parser = optparse.OptionParser()
parser.add_option("-S", "--skip-devel", help="Show only those CVEs *not* in the current devel release", action="store_true")
parser.add_option("-D", "--only-devel", help="Show only those CVEs in the current devel release", action="store_true")
parser.add_option("-e", "--only-extended", help="Show only packages with extended release status", action="store_true")
parser.add_option("-x", "--not-extended", help="Show only those packages without extended release status", action="store_true")
parser.add_option("-p", "--packages", help="Report only on the given packages", action="append", type="string")
parser.add_option("-P", "--pkgfamily", help="Perform pkg family renamings (use argument multiple times for 'linux' and/or 'xen')", action="append", default=[])
parser.add_option("-X", "--exclude", help="Ignore specified packages", action="append", type="string")
parser.add_option("-r", "--release", help="Report only for the given releases", action="append", type="string")
parser.add_option("-d", "--debug", help="Report debug information while loading", action="store_true")
(opt, args) = parser.parse_args()

map = source_map.load()
releases = cve_lib.all_releases
for eol in cve_lib.eol_releases:
    if eol in releases:
        releases.remove(eol)

if opt.skip_devel and cve_lib.devel_release != '':
    releases.remove(cve_lib.devel_release)

if opt.only_devel:
    releases = [cve_lib.devel_release]

if opt.release:
    releases = opt.release

(cves, uems, rcves) = cve_lib.get_cve_list_and_retired()
table = cve_lib.load_all(cves, uems, rcves)

for cve in sorted(cves):
    if not table.has_key(cve):
        continue

    for pkg in sorted(table[cve]['pkgs'].keys()):
        if opt.exclude and pkg in opt.exclude:
            continue

        found = False
        extended = False
        ppa = False
        for r in releases:
            status = table[cve]['pkgs'][pkg]
            if status.has_key(r):
                if status[r][0].startswith('released'):
                    #print >>sys.stderr, "%s for %s in %s (%s)" % (cve, pkg, r, table[cve][pkg][r])
                    found = True

                    # if has some extended release status or has esm in version
                    # then is considered extended
                    if (status[r][0].startswith('released-') or
                        'esm' in status[r][1]):
                        extended = True
                        if 'esm' in status[r][1]:
                            ppa = True

        if not found:
            continue

        if opt.only_extended and not extended:
            continue

        if opt.not_extended and extended:
            continue

        if extended:
            if pockets['extended'].has_key(pkg):
                pockets['extended'][pkg] += 1
            else:
                pockets['extended'][pkg] = 1
        if ppa:
            if pockets['ppa'].has_key(pkg):
                pockets['ppa'][pkg] += 1
            else:
                pockets['ppa'][pkg] = 1


        if packages.has_key(pkg):
            packages[pkg] += 1
        else:
            packages[pkg] = 1


sys.stdout.write("Updates\tPackage\n")
sys.stdout.write("---------------------------------------------------------------------\n")

for pkg in sorted(packages.keys()):
    sys.stdout.write("%s\t%s" % (str(packages[pkg]), pkg))

    extra_info = []
    for p in pockets.keys():
        if pockets[p].has_key(pkg):
            extra_info.append(p.upper())

    if len(extra_info) > 0:
        sys.stdout.write(" (%s)" % ",".join(extra_info))

    sys.stdout.write("\n")
