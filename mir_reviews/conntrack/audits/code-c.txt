Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./src/mcast.c:44:	m = (struct mcast_sock *) malloc(sizeof(struct mcast_sock));
./src/mcast.c:62:		memcpy(&mreq.ipv6.ipv6mr_multiaddr, &conf->in.inet_addr6,
./src/mcast.c:170:	memcpy(&m->addr.ipv6.sin6_addr,
./src/mcast.c:197:	m = (struct mcast_sock *) malloc(sizeof(struct mcast_sock));
./src/udp.c:28:	m = calloc(sizeof(struct udp_sock), 1);
./src/udp.c:100:	m = calloc(sizeof(struct udp_sock), 1);
./src/udp.c:144:		memcpy(&m->addr.ipv6.sin6_addr, &conf->client.inet_addr6,
./src/date.c:22:	memcpy(tv, &now, sizeof(struct timeval));
./src/nfct-extensions/timeout.c:88:	t = nfct_timeout_alloc();
./src/nfct-extensions/timeout.c:190:	t = nfct_timeout_alloc();
./src/nfct-extensions/timeout.c:323:	t = nfct_timeout_alloc();
./src/nfct-extensions/timeout.c:389:	t = nfct_timeout_alloc();
./src/nfct-extensions/helper.c:98:	t = nfct_helper_alloc();
./src/nfct-extensions/helper.c:211:	t = nfct_helper_alloc();
./src/nfct-extensions/helper.c:228:		p = nfct_helper_policy_alloc();
./src/nfct-extensions/helper.c:301:	t = nfct_helper_alloc();
./src/nfct-extensions/helper.c:395:	t = nfct_helper_alloc();
./src/nfct-extensions/helper.c:565:	t = nfct_helper_alloc();
./src/channel_udp.c:22:	m = calloc(sizeof(struct udp_channel), 1);
./src/sync-ftfw.c:195:			size = sprintf(buf, "control -> seq:%u flags:%u\n",
./src/sync-ftfw.c:201:			size = sprintf(buf, "object -> seq:%u\n", cn->seq);
./src/sync-ftfw.c:216:	size = sprintf(buf, "resent queue (len=%u)\n", queue_len(rs_queue));
./src/multichannel.c:24:	m = calloc(sizeof(struct multichannel), 1);
./src/channel_tcp.c:24:	m = calloc(sizeof(struct tcp_channel), 1);
./src/cthelper.c:223:					calloc(1, cur->helper->priv_data_len);
./src/cthelper.c:228:				memcpy(myct->priv_data, priv_data,
./src/cthelper.c:298:	myct = calloc(1, sizeof(struct myct));
./src/cthelper.c:306:	pktb = pktb_alloc(AF_INET, pkt, pktlen, 256);
./src/cthelper.c:367:	t = nfct_helper_alloc();
./src/cthelper.c:390:		p = nfct_helper_policy_alloc();
./src/cthelper.c:516:	state.cthelper = calloc(1, sizeof(struct ct_helper_state));
./src/event.c:34:	e = calloc(1, sizeof(struct evfd));
./src/external_inject.c:164:	size = sprintf(buf, "external inject:\n"
./src/external_inject.c:247:	size = sprintf(buf, "external inject:\n"
./src/origin.c:34:	nlp = calloc(sizeof(struct origin), 1);
./src/utils.c:122:	memcpy(dst, dbuf, sizeof(dbuf));
./src/utils.c:236:		memcpy(dst, dbuf, sizeof(dbuf));
./src/read_config_yy.c:541:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
./src/read_config_yy.c:601:      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
./src/read_config_yy.c:2922:	strcpy(conf.local.path, (yyvsp[(2) - (2)].string));
./src/read_config_yy.c:3751:		memcpy(tmp.ip, ip.ipv6, sizeof(uint32_t)*4);
./src/read_config_yy.c:3959:	helper_inst = calloc(1, sizeof(struct ctd_helper_instance));
./src/read_config_yy.c:4007:			memcpy(&helper->policy[i], pol,
./src/read_config_yy.c:4032:	e = stack_item_alloc(SYMBOL_HELPER_QUEUE_NUM, sizeof(int));
./src/read_config_yy.c:4047:	e = stack_item_alloc(SYMBOL_HELPER_QUEUE_LEN, sizeof(int));
./src/read_config_yy.c:4090:		e = stack_item_alloc(SYMBOL_HELPER_EXPECT_POLICY_LEAF,
./src/read_config_yy.c:4109:		e = stack_item_alloc(SYMBOL_HELPER_EXPECT_POLICY_LEAF,
./src/cache.c:51:	c = malloc(sizeof(struct cache));
./src/cache.c:56:	strcpy(c->name, name);
./src/cache.c:69:	memcpy(c->feature_type, feature_type, sizeof(feature_type));
./src/cache.c:71:	c->features = malloc(sizeof(struct cache_feature) * j);
./src/cache.c:76:	memcpy(c->features, feature_array, sizeof(struct cache_feature) * j);
./src/cache.c:84:	c->feature_offset = malloc(sizeof(unsigned int) * j);
./src/cache.c:90:	memcpy(c->feature_offset, feature_offset, sizeof(unsigned int) * j);
./src/cache.c:129:	obj = calloc(c->object_size, 1);
./src/cache.c:316:	size = sprintf(buf, "cache %s:\n"
./src/fds.c:33:	fds = (struct fds *) calloc(sizeof(struct fds), 1);
./src/fds.c:63:	item = calloc(sizeof(struct fds_item), 1);
./src/queue.c:36:	b = calloc(sizeof(struct queue), 1);
./src/queue.c:105:	obj = calloc(sizeof(struct queue_object) + size, 1);
./src/filter.c:80:	filter = calloc(sizeof(struct ct_filter), 1);
./src/filter.c:136:static struct ct_filter *__filter_alloc(struct ct_filter *filter)
./src/filter.c:153:	filter = __filter_alloc(filter);
./src/filter.c:160:	filter = __filter_alloc(filter);
./src/filter.c:167:				n = malloc(sizeof(struct ct_filter_ipv4_hnode));
./src/filter.c:170:				memcpy(&n->ip, data, sizeof(uint32_t));
./src/filter.c:179:				n = malloc(sizeof(struct ct_filter_ipv6_hnode));
./src/filter.c:182:				memcpy(n->ipv6, data, sizeof(uint32_t)*4);
./src/filter.c:203:	filter = __filter_alloc(filter);
./src/filter.c:226:	f = __filter_alloc(f);
./src/filter.c:233:	f = __filter_alloc(f);
./src/filter.c:463:	f = calloc(1, sizeof(struct exp_filter));
./src/filter.c:477:static struct exp_filter *exp_filter_alloc(void)
./src/filter.c:493:	f = exp_filter_alloc();
./src/filter.c:503:	item = calloc(1, sizeof(struct exp_filter_item));
./src/cache_timer.c:66:	return sprintf(buf, " [expires in %lds]", tmp.tv_sec);
./src/build.c:42:	memcpy(ptr, data, len);
./src/build.c:49:	memcpy(ptr, nfct_get_attr(ct, a), sizeof(uint8_t));
./src/read_config_lex.c:3879:	return (void *) malloc( size );
./src/helpers/ftp.c:542:		memcpy(&daddr, &cmd.u3, sizeof(cmd.u3));
./src/traffic_stats.c:42:	size = sprintf(buf, "traffic processed:\n");
./src/traffic_stats.c:43:	size += sprintf(buf+size, "%20llu Bytes      ", (unsigned long long)bytes);
./src/traffic_stats.c:44:	size += sprintf(buf+size, "%20llu Pckts\n\n", (unsigned long long)packets);
./src/vector.c:38:	v = calloc(sizeof(struct vector), 1);
./src/vector.c:46:	v->data = calloc(size * DEFAULT_VECTOR_MEMBERS, 1);
./src/vector.c:71:	memcpy(v->data + (v->size * v->cur_elems), data, v->size);
./src/stats-mode.c:34:	state.stats = malloc(sizeof(struct ct_stats_state));
./src/local.c:46:	strcpy(local.sun_path, conf->path);
./src/local.c:63:	strcpy(server->path, conf->path);
./src/local.c:102:	strcpy(local.sun_path, conf->path);
./src/cache-exp.c:61:	memcpy(&a[0], nfct_get_attr(ct, ATTR_IPV6_SRC), sizeof(uint32_t)*4);
./src/cache-exp.c:62:	memcpy(&a[4], nfct_get_attr(ct, ATTR_IPV6_DST), sizeof(uint32_t)*4);
./src/cache-exp.c:100:static void *cache_exp_alloc(void)
./src/cache-exp.c:113:	memcpy(dst, src, nfexp_maxsize());
./src/cache-exp.c:156:		size += sprintf(buf+size, " [active since %lds]",
./src/cache-exp.c:159:	size += sprintf(buf+size, "\n");
./src/tcp.c:34:	m = calloc(sizeof(struct tcp_sock), 1);
./src/tcp.c:165:		memcpy(&m->addr.ipv6.sin6_addr, &c->client.inet_addr6,
./src/tcp.c:212:	m = calloc(sizeof(struct tcp_sock), 1);
./src/process.c:40:	c = calloc(sizeof(struct child_process), 1);
./src/internal_bypass.c:84:	size = sprintf(buf, "internal bypass:\n"
./src/internal_bypass.c:216:	size = sprintf(buf, "internal bypass:\n"
./src/channel_mcast.c:22:	m = calloc(sizeof(struct mcast_channel), 1);
./src/hash.c:39:	h = (struct hashtable *) calloc(size, 1);
./src/conntrack.c:682:	merge = malloc(sizeof(struct option) * (num_new + num_old + 1));
./src/conntrack.c:686:	memcpy(merge, oldopts, num_old * sizeof(struct option));
./src/conntrack.c:978:		memcpy(address->v6, &parse.addr6, sizeof(parse.addr6));
./src/channel.c:59:	b = calloc(sizeof(struct channel_buffer), 1);
./src/channel.c:65:	b->data = malloc(b->size);
./src/channel.c:97:	c = calloc(sizeof(struct channel), 1);
./src/channel.c:169:	error->data = malloc(c->buffer->len);
./src/channel.c:174:	memcpy(error->data, c->buffer->data, c->buffer->len);
./src/channel.c:232:		memcpy(c->buffer->data + c->buffer->len, net, len);
./src/cache-ct.c:61:	memcpy(&a[0], nfct_get_attr(ct, ATTR_IPV6_SRC), sizeof(uint32_t)*4);
./src/cache-ct.c:62:	memcpy(&a[4], nfct_get_attr(ct, ATTR_IPV6_DST), sizeof(uint32_t)*4);
./src/cache-ct.c:108:static void *cache_ct_alloc(void)
./src/cache-ct.c:168:		size += sprintf(buf+size, " [active since %lds]",
./src/cache-ct.c:171:	size += sprintf(buf+size, "\n");
./src/stack.c:18:stack_item_alloc(int type, size_t data_len)
./src/stack.c:22:	e = calloc(1, sizeof(struct stack_item) + data_len);
./src/sync-mode.c:44:static struct nf_conntrack *msg2ct_alloc(struct nethdr *net, size_t remain)
./src/sync-mode.c:62:static struct nf_expect *msg2exp_alloc(struct nethdr *net, size_t remain)
./src/sync-mode.c:117:		ct = msg2ct_alloc(net, remain);
./src/sync-mode.c:123:		ct = msg2ct_alloc(net, remain);
./src/sync-mode.c:129:		ct = msg2ct_alloc(net, remain);
./src/sync-mode.c:135:		exp = msg2exp_alloc(net, remain);
./src/sync-mode.c:141:		exp = msg2exp_alloc(net, remain);
./src/sync-mode.c:147:		exp = msg2exp_alloc(net, remain);
./src/sync-mode.c:170:		memcpy(__net, ptr, remain);
./src/sync-mode.c:366:	state.sync = malloc(sizeof(struct ct_sync_state));
./src/sync-mode.c:506:	size = sprintf(buf, "message tracking:\n"
./src/main.c:339:		strcpy(config_file, DEFAULT_CONFIGFILE);
./include/stack.h:23:struct stack_item *stack_item_alloc(int type, size_t data_len);

== files() ==
./src/nfct-extensions/timeout.c:125:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/timeout.c:273:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/timeout.c:338:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/timeout.c:404:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/timeout.c:454:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:135:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:251:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:344:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:438:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:488:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/nfct-extensions/helper.c:583:	nl = mnl_socket_open(NETLINK_NETFILTER);
./src/channel_udp.c:17:*channel_udp_open(void *conf)
./src/helpers.c:70:	if (dlopen(path, flag) == NULL) {
./src/multichannel.c:16:multichannel_open(struct channel_conf *conf, int len)
./src/multichannel.c:30:		m->channel[i] = channel_open(&conf[i]);
./src/log.c:33:		STATE(log) = fopen(CONFIG(logfile), "a+");
./src/log.c:45:		STATE(stats_log) = fopen(CONFIG(stats).logfile, "a+");
./src/channel_tcp.c:19:*channel_tcp_open(void *conf)
./src/cthelper.c:522:	STATE_CTH(nl) = mnl_socket_open(NETLINK_NETFILTER);
./src/external_inject.c:45:	inject = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/read_config_yy.c:4423:	fp = fopen(filename, "r");
./src/ctnl.c:420:	STATE(resync) = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/ctnl.c:441:		STATE(dump) = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/ctnl.c:470:	STATE(get) = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/ctnl.c:484:	STATE(flush) = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/netlink.c:36:	h = nfct_open(CONFIG(netlink).subsys_id, CONFIG(netlink).groups);
./src/netlink.c:101:	h = nlif_open();
./src/netlink.c:180:	h = nfct_open(CONNTRACK, 0);
./src/expect.c:168:	h = nfct_open(EXPECT, 0);
./src/internal_bypass.c:55:	h = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/internal_bypass.c:186:	h = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/channel_mcast.c:17:*channel_mcast_open(void *conf)
./src/sync-notrack.c:105:	h = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/conntrack.c:1536:	fd = fopen(CT_STATS_PROC, "r");
./src/conntrack.c:1587:static int nfct_mnl_socket_open(void)
./src/conntrack.c:1589:	sock.mnl = mnl_socket_open(NETLINK_NETFILTER);
./src/conntrack.c:2112:			if (nfct_mnl_socket_open() < 0)
./src/conntrack.c:2122:			if (nfct_mnl_socket_open() < 0)
./src/conntrack.c:2133:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2171:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2194:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2209:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2218:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2220:		ith = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2232:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2233:		ith = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2260:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2269:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2281:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2291:		cth = nfct_open(CONNTRACK, 0);
./src/conntrack.c:2301:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2321:			cth = nfct_open(CONNTRACK, nl_events);
./src/conntrack.c:2323:			cth = nfct_open(CONNTRACK,
./src/conntrack.c:2367:			cth = nfct_open(CONNTRACK, nl_events);
./src/conntrack.c:2369:			cth = nfct_open(EXPECT,
./src/conntrack.c:2387:		if (nfct_mnl_socket_open() < 0)
./src/conntrack.c:2405:		fd = fopen(NF_CONNTRACK_COUNT_PROC, "r");
./src/conntrack.c:2419:		cth = nfct_open(EXPECT, 0);
./src/conntrack.c:2432:		if (nfct_mnl_socket_open() < 0)
./src/conntrack.c:2451:		if (nfct_mnl_socket_open() < 0)
./src/channel.c:55:channel_buffer_open(int mtu, int headersiz)
./src/channel.c:84:channel_open(struct channel_conf *cfg)
./src/channel.c:125:		c->buffer = channel_buffer_open(c->channel_ifmtu,
./src/channel.c:134:	c->data = c->ops->open(&cfg->u);
./src/sync-mode.c:413:		multichannel_open(CONFIG(channel), CONFIG(channel_num));
./src/sync-mode.c:454:	STATE_SYNC(commit).h = nfct_open(CONFIG(netlink).subsys_id, 0);
./src/main.c:341:	umask(0177);
./src/main.c:366:	ret = open(CONFIG(lockfile), O_CREAT | O_EXCL | O_TRUNC, 0600);
./include/channel.h:89:struct channel *channel_open(struct channel_conf *conf);
./include/channel.h:115:struct multichannel *multichannel_open(struct channel_conf *conf, int len);

== logging() ==
./src/nfct-extensions/timeout.c:90:		nfct_perror("OOM");
./src/nfct-extensions/timeout.c:95:		nfct_perror("nfct_timeout_nlmsg_parse_payload");
./src/nfct-extensions/timeout.c:117:		nfct_perror("too many arguments");
./src/nfct-extensions/timeout.c:127:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/timeout.c:132:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/timeout.c:138:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/timeout.c:150:		nfct_perror("error");
./src/nfct-extensions/timeout.c:183:		nfct_perror("missing parameters\n"
./src/nfct-extensions/timeout.c:192:		nfct_perror("OOM");
./src/nfct-extensions/timeout.c:203:		nfct_perror("unknown layer 3 protocol");
./src/nfct-extensions/timeout.c:227:		nfct_perror("unknown layer 4 protocol");
./src/nfct-extensions/timeout.c:241:				nfct_perror("state name is NULL");
./src/nfct-extensions/timeout.c:252:				nfct_perror("missing value for this timeout");
./src/nfct-extensions/timeout.c:275:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/timeout.c:280:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/timeout.c:286:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/timeout.c:298:		nfct_perror("error");
./src/nfct-extensions/timeout.c:316:		nfct_perror("missing timeout policy name");
./src/nfct-extensions/timeout.c:319:		nfct_perror("too many arguments");
./src/nfct-extensions/timeout.c:325:		nfct_perror("OOM");
./src/nfct-extensions/timeout.c:340:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/timeout.c:345:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/timeout.c:351:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/timeout.c:363:		nfct_perror("error");
./src/nfct-extensions/timeout.c:382:		nfct_perror("missing timeout policy name");
./src/nfct-extensions/timeout.c:385:		nfct_perror("too many arguments");
./src/nfct-extensions/timeout.c:391:		nfct_perror("OOM");
./src/nfct-extensions/timeout.c:406:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/timeout.c:411:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/timeout.c:417:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/timeout.c:429:		nfct_perror("error");
./src/nfct-extensions/timeout.c:446:		nfct_perror("too many arguments");
./src/nfct-extensions/timeout.c:456:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/timeout.c:461:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/timeout.c:467:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/timeout.c:479:		nfct_perror("error");
./src/nfct-extensions/helper.c:100:		nfct_perror("OOM");
./src/nfct-extensions/helper.c:105:		nfct_perror("nfct_helper_nlmsg_parse_payload");
./src/nfct-extensions/helper.c:127:		nfct_perror("too many arguments");
./src/nfct-extensions/helper.c:137:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:142:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:148:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:160:		nfct_perror("error");
./src/nfct-extensions/helper.c:181:		nfct_perror("missing parameters\n"
./src/nfct-extensions/helper.c:192:		nfct_perror("unknown layer 3 protocol");
./src/nfct-extensions/helper.c:201:		nfct_perror("unsupported layer 4 protocol");
./src/nfct-extensions/helper.c:207:		nfct_perror("that helper is not supported");
./src/nfct-extensions/helper.c:213:		nfct_perror("OOM");
./src/nfct-extensions/helper.c:230:			nfct_perror("OOM");
./src/nfct-extensions/helper.c:253:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:258:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:264:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:276:		nfct_perror("error");
./src/nfct-extensions/helper.c:294:		nfct_perror("missing helper policy name");
./src/nfct-extensions/helper.c:297:		nfct_perror("too many arguments");
./src/nfct-extensions/helper.c:303:		nfct_perror("OOM");
./src/nfct-extensions/helper.c:317:			nfct_perror("unknown layer 3 protocol");
./src/nfct-extensions/helper.c:331:			nfct_perror("unsupported layer 4 protocol");
./src/nfct-extensions/helper.c:346:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:351:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:357:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:369:		nfct_perror("error");
./src/nfct-extensions/helper.c:388:		nfct_perror("missing helper policy name");
./src/nfct-extensions/helper.c:391:		nfct_perror("too many arguments");
./src/nfct-extensions/helper.c:397:		nfct_perror("OOM");
./src/nfct-extensions/helper.c:410:			nfct_perror("unknown layer 3 protocol");
./src/nfct-extensions/helper.c:424:			nfct_perror("unsupported layer 4 protocol");
./src/nfct-extensions/helper.c:440:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:445:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:451:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:463:		nfct_perror("error");
./src/nfct-extensions/helper.c:480:		nfct_perror("too many arguments");
./src/nfct-extensions/helper.c:490:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:495:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:501:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:513:		nfct_perror("error");
./src/nfct-extensions/helper.c:535:		nfct_perror("missing parameters\n"
./src/nfct-extensions/helper.c:546:		nfct_perror("unknown layer 3 protocol");
./src/nfct-extensions/helper.c:555:		nfct_perror("unsupported layer 4 protocol");
./src/nfct-extensions/helper.c:561:		nfct_perror("that helper is not supported");
./src/nfct-extensions/helper.c:567:		nfct_perror("OOM");
./src/nfct-extensions/helper.c:585:		nfct_perror("mnl_socket_open");
./src/nfct-extensions/helper.c:590:		nfct_perror("mnl_socket_bind");
./src/nfct-extensions/helper.c:596:		nfct_perror("mnl_socket_send");
./src/nfct-extensions/helper.c:608:		nfct_perror("error");
./src/sync-ftfw.c:98:static void tx_queue_add_ctlmsg(uint32_t flags, uint32_t from, uint32_t to)
./src/sync-ftfw.c:139:		tx_queue_add_ctlmsg(NET_F_ACK,
./src/sync-ftfw.c:228:		tx_queue_add_ctlmsg(NET_F_RESYNC, 0, 0);
./src/sync-ftfw.c:330:static int digest_msg(const struct nethdr *net)
./src/sync-ftfw.c:406:		ret = digest_msg(net);
./src/sync-ftfw.c:413:			tx_queue_add_ctlmsg(NET_F_ACK, ack_from, exp_seq-1);
./src/sync-ftfw.c:417:		tx_queue_add_ctlmsg(NET_F_NACK, exp_seq, net->seq-1);
./src/sync-ftfw.c:433:		ret = digest_msg(net);
./src/sync-ftfw.c:446:			tx_queue_add_ctlmsg(NET_F_ACK, ack_from, net->seq);
./src/sync-ftfw.c:521:		net = cn->obj->cache->ops->build_msg(cn->obj, type);
./src/sync-alarm.c:140:		net = ca->obj->cache->ops->build_msg(ca->obj, type);
./src/helpers.c:66:			strerror(errno));
./src/helpers.c:71:		fprintf(stderr, "%s: %s\n", path, dlerror());
./src/log.c:37:						strerror(errno));
./src/log.c:49:						strerror(errno));
./src/log.c:102:		vsyslog(priority, format, args);
./src/log.c:140:			syslog(LOG_ERR, "%s", tmp);
./src/log.c:144:			syslog(LOG_INFO, "%s", tmp);
./src/log.c:177:			syslog(LOG_ERR, "%s", tmp);
./src/log.c:181:			syslog(LOG_INFO, "%s", tmp);
./src/cthelper.c:186:		dlog(LOG_ERR, "failed to send verdict: %s", strerror(errno));
./src/cthelper.c:194:pkt_verdict_error(uint16_t queue_num, uint32_t id)
./src/cthelper.c:203:		dlog(LOG_ERR, "failed to send verdict: %s", strerror(errno));
./src/cthelper.c:333:	pkt_verdict_error(queue_num, id);
./src/cthelper.c:348:		dlog(LOG_ERR, "failed to receive message: %s", strerror(errno));
./src/cthelper.c:437:			cur->helper->name, strerror(errno));
./src/external_inject.c:48:		     strerror(errno));
./src/external_inject.c:79:			dlog(LOG_ERR, "inject-add1: %s", strerror(errno));
./src/external_inject.c:84:		dlog(LOG_ERR, "inject-add2: %s", strerror(errno));
./src/external_inject.c:105:			dlog(LOG_ERR, "inject-upd1: %s", strerror(errno));
./src/external_inject.c:120:			dlog(LOG_ERR, "inject-upd2: %s", strerror(errno));
./src/external_inject.c:128:	dlog(LOG_ERR, "inject-upd3: %s", strerror(errno));
./src/external_inject.c:137:			dlog(LOG_ERR, "inject-del: %s", strerror(errno));
./src/external_inject.c:203:			dlog(LOG_ERR, "inject-add1: %s", strerror(errno));
./src/external_inject.c:208:		dlog(LOG_ERR, "inject-add2: %s", strerror(errno));
./src/external_inject.c:220:			dlog(LOG_ERR, "inject-del: %s", strerror(errno));
./src/read_config_yy.c:1147:#define yytable_value_is_error(yytable_value) \
./src/read_config_yy.c:1278:      yyerror (YY_("syntax error: cannot back up")); \
./src/read_config_yy.c:1620:yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
./src/read_config_yy.c:1679:                && !yytable_value_is_error (yytable[yyx + yyn]))
./src/read_config_yy.c:2017:      if (yytable_value_is_error (yyn))
./src/read_config_yy.c:4171:      yyerror (YY_("syntax error"));
./src/read_config_yy.c:4173:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
./src/read_config_yy.c:4198:        yyerror (yymsgp);
./src/read_config_yy.c:4313:  yyerror (YY_("memory exhausted"));
./src/read_config_yy.c:4356:yyerror(char *msg)
./src/ctnl.c:423:		     strerror(errno));
./src/ctnl.c:444:			     strerror(errno));
./src/ctnl.c:473:		     strerror(errno));
./src/ctnl.c:509:			     strerror(errno));
./src/build.c:212:void ct2msg(const struct nf_conntrack *ct, struct nethdr *n)
./src/build.c:329:void exp2msg(const struct nf_expect *exp, struct nethdr *n)
./src/read_config_lex.c:372:static void yy_fatal_error (yyconst char msg[]  );
./src/read_config_lex.c:2107:int yyget_debug (void );
./src/read_config_lex.c:2109:void yyset_debug (int debug_flag  );
./src/read_config_lex.c:2177:#define ECHO if (fwrite( yytext, yyleng, 1, yyout )) yy_fatal_error (strerror (errno));
./src/read_config_lex.c:2194:		if ( c == EOF && ferror( yyin ) ) \
./src/read_config_lex.c:2201:		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
./src/read_config_lex.c:2231:#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
./src/read_config_lex.c:3697:static void yy_fatal_error (yyconst char* msg )
./src/read_config_lex.c:3790:int yyget_debug  (void)
./src/read_config_lex.c:3795:void yyset_debug (int  bdebug )
./src/helpers/ftp.c:91:			pr_debug("Char %u (got %u nums) `%u' unexpected\n",
./src/helpers/ftp.c:96:	pr_debug("Failed to fill %u numbers separated by %c\n",
./src/helpers/ftp.c:114:			pr_debug("get_port: return %d\n", tmp_port);
./src/helpers/ftp.c:120:			pr_debug("get_port: invalid char.\n");
./src/helpers/ftp.c:154:		pr_debug("EPRT: too short\n");
./src/helpers/ftp.c:159:		pr_debug("try_eprt: invalid delimitter.\n");
./src/helpers/ftp.c:165:		pr_debug("EPRT: invalid protocol number.\n");
./src/helpers/ftp.c:169:	pr_debug("EPRT: Got %c%c%c\n", delim, data[1], delim);
./src/helpers/ftp.c:186:	pr_debug("EPRT: Got IP address!\n");
./src/helpers/ftp.c:279:	pr_debug("Pattern matches!\n");
./src/helpers/ftp.c:289:	pr_debug("Skipped up to `%c'!\n", skip);
./src/helpers/ftp.c:295:	pr_debug("Match succeded!\n");
./src/helpers/ftp.c:381:	pr_debug("FTP_NAT: type %i, off %u len %u\n", type, matchoff, matchlen);
./src/helpers/ftp.c:466:		pr_debug("ftp: Conntrackinfo = %u\n", ctinfo);
./src/helpers/ftp.c:481:		pr_debug("nf_conntrack_ftp: wrong seq pos %s(%u) or %s(%u)\n",
./src/helpers/ftp.c:509:	pr_debug("conntrack_ftp: match `%.*s' (%u bytes at %u)\n",
./src/helpers/ftp.c:528:			pr_debug("conntrack_ftp: NOT RECORDING: %pI4 != %pI4\n",
./src/helpers/ftp.c:531:			pr_debug("conntrack_ftp: NOT RECORDING: %pI6 != %pI6\n",
./src/helpers/ftp.c:553:		pr_debug("conntrack_ftp: failed to init expectation\n");
./src/helpers/ftp.c:567:		pr_debug("conntrack_ftp: cannot add expectation: %s\n",
./src/helpers/ftp.c:568:			strerror(errno));
./src/helpers/rpc.c:139:		pr_debug("RPC CALL: too short packet: %u < %u\n",
./src/helpers/rpc.c:146:		pr_debug("RPC CALL: wrong rpcvers %u != %u\n",
./src/helpers/rpc.c:153:		pr_debug("RPC CALL: not portmap %u != %lu\n",
./src/helpers/rpc.c:160:		pr_debug("RPC CALL: wrong portmap version %u != %lu\n",
./src/helpers/rpc.c:167:		pr_debug("RPC CALL: not PMAPPROC_GETPORT %u != %lu\n",
./src/helpers/rpc.c:174:	pr_debug("RPC CALL: cred: %u %u (%u, %u)\n",
./src/helpers/rpc.c:177:		pr_debug("RPC CALL: invalid sized cred %u > %u\n",
./src/helpers/rpc.c:183:		pr_debug("RPC CALL: too short to carry cred: %u < %u, %u\n",
./src/helpers/rpc.c:191:	pr_debug("RPC CALL: verf: %u %u (%u, %u)\n",
./src/helpers/rpc.c:194:		pr_debug("RPC CALL: invalid sized verf %u > %u\n",
./src/helpers/rpc.c:200:		pr_debug("RPC CALL: too short to carry verf: %u < %u, %u\n",
./src/helpers/rpc.c:214:		pr_debug("RPC CALL: invalid size to carry pmap: %u != %u\n",
./src/helpers/rpc.c:224:		pr_debug("RPC CALL: unsupported protocol %u",
./src/helpers/rpc.c:231:		pr_debug("RPC CALL: port is nonzero %u\n",
./src/helpers/rpc.c:235:	pr_debug("RPC CALL: processed: xid %u, prog %u, vers %u, prot %u\n",
./src/helpers/rpc.c:270:		pr_debug("RPC REPL: too short, missing rp_stat: %u < %u\n",
./src/helpers/rpc.c:277:		pr_debug("RPC REPL: not accepted %u != %u\n",
./src/helpers/rpc.c:283:		pr_debug("RPC REPL: too short, missing verf: %u < %u\n",
./src/helpers/rpc.c:289:	pr_debug("RPC REPL: verf: %u %u (%u, %u)\n",
./src/helpers/rpc.c:292:		pr_debug("RPC REPL: invalid sized verf %u > %u\n",
./src/helpers/rpc.c:299:		pr_debug("RPC REPL: invalid size to carry verf and "
./src/helpers/rpc.c:308:		pr_debug("RPC REPL: not success %u != %u\n",
./src/helpers/rpc.c:316:		pr_debug("RPC REPL: port is zero\n");
./src/helpers/rpc.c:319:	pr_debug("RPC REPL: processed: xid %u, prog %u, vers %u, "
./src/helpers/rpc.c:345:		pr_debug("TCP RPC: Conntrackinfo = %u\n", ctinfo);
./src/helpers/rpc.c:357:		pr_debug("RPC: broken header: offset %u%%4 != 0\n", offset);
./src/helpers/rpc.c:380:		pr_debug("RPC: too short packet: %u < %u\n",
./src/helpers/rpc.c:390:		pr_debug("RPC: rm_dir != dir %u != %u\n", rm_dir, dir);
./src/helpers/rpc.c:404:			pr_debug("RPC REPL: XID does not match: %u != %u\n",
./src/helpers/rpc.c:427:			pr_debug("RPC: failed to init expectation\n");
./src/helpers/rpc.c:441:			pr_debug("RPC: cannot add expectation: %s\n",
./src/helpers/rpc.c:442:				 strerror(errno));
./src/helpers/tns.c:87:			pr_debug("Char %u (got %u nums) `%c' unexpected\n",
./src/helpers/tns.c:92:	pr_debug("Failed to fill %u numbers separated by %c\n",
./src/helpers/tns.c:110:			pr_debug("get_port: return %d\n", tmp_port);
./src/helpers/tns.c:118:			pr_debug("get_port: invalid char `%c'\n", data[i]);
./src/helpers/tns.c:145:		pr_debug("HOST= not found\n");
./src/helpers/tns.c:167:		pr_debug("PORT= not found\n");
./src/helpers/tns.c:300:		pr_debug("TNS: Conntrackinfo = %u\n", ctinfo);
./src/helpers/tns.c:305:		pr_debug("TNS: skip client direction\n");
./src/helpers/tns.c:315:		pr_debug("TNS: skip packet with short header\n");
./src/helpers/tns.c:360:		pr_debug("TNS: failed to init expectation\n");
./src/helpers/tns.c:375:		pr_debug("TNS: cannot add expectation: %s\n",
./src/helpers/tns.c:376:			 strerror(errno));
./src/netlink.c:58:				     strerror(errno));
./src/cache-exp.c:203:			dlog(LOG_ERR, "commit-destroy: %s", strerror(errno));
./src/cache-exp.c:207:			dlog(LOG_ERR, "commit-create: %s", strerror(errno));
./src/cache-exp.c:281:cache_exp_build_msg(const struct cache_object *obj, int type)
./src/nfct.c:39:void nfct_perror(const char *msg)
./src/nfct.c:45:			VERSION, msg, strerror(errno));
./src/sync-notrack.c:59:static void tx_queue_add_ctlmsg(uint32_t flags, uint32_t from, uint32_t to)
./src/sync-notrack.c:125:		tx_queue_add_ctlmsg(NET_F_RESYNC, 0, 0);
./src/sync-notrack.c:146:static int digest_msg(const struct nethdr *net)
./src/sync-notrack.c:176:	ret = digest_msg(net);
./src/sync-notrack.c:206:		net = cn->obj->cache->ops->build_msg(cn->obj, type);
./src/conntrack.c:592:exit_error(enum exittype status, const char *msg, ...)
./src/conntrack.c:630:				exit_error(PARAMETER_PROBLEM, 
./src/conntrack.c:636:				exit_error(PARAMETER_PROBLEM, "Illegal "
./src/conntrack.c:728:	return strerror(err);
./src/conntrack.c:810:			exit_error(PARAMETER_PROBLEM,"Bad parameter `%s'", arg);
./src/conntrack.c:816:		exit_error(PARAMETER_PROBLEM, "Bad parameter `%s'", arg);
./src/conntrack.c:837:		exit_error(PARAMETER_PROBLEM, "unknown label '%s'", name);
./src/conntrack.c:889:		exit_error(PARAMETER_PROBLEM, "Invalid commands combination");
./src/conntrack.c:933:		exit_error(PARAMETER_PROBLEM, "unknown type `%s'", table);
./src/conntrack.c:943:		exit_error(PARAMETER_PROBLEM, "mismatched address family");
./src/conntrack.c:999:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1002:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1009:			exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1024:			exit_error(PARAMETER_PROBLEM, "No IP specified");
./src/conntrack.c:1026:			exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1318:		exit_error(OTHER_PROBLEM,
./src/conntrack.c:1400:		exit_error(OTHER_PROBLEM, "out of memory");
./src/conntrack.c:1416:		exit_error(OTHER_PROBLEM,
./src/conntrack.c:1430:		exit_error(OTHER_PROBLEM,
./src/conntrack.c:1591:		perror("mnl_socket_open");
./src/conntrack.c:1595:		perror("mnl_socket_bind");
./src/conntrack.c:1682:		perror("mnl_attr_validate");
./src/conntrack.c:1734:		perror("mnl_attr_validate");
./src/conntrack.c:1776:		perror("mnl_attr_validate");
./src/conntrack.c:1832:	/* we release these objects in the exit_error() path. */
./src/conntrack.c:1834:		exit_error(OTHER_PROBLEM, "out of memory");
./src/conntrack.c:1875:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1885:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1891:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1903:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1925:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1945:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:1951:				exit_error(OTHER_PROBLEM, "out of memory");
./src/conntrack.c:1977:					perror("nfct_labelmap_new");
./src/conntrack.c:2029:				exit_error(OTHER_PROBLEM, "unable to open labelmap file");
./src/conntrack.c:2049:				exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:2058:			exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:2062:			exit_error(PARAMETER_PROBLEM,
./src/conntrack.c:2070:				exit_error(PARAMETER_PROBLEM, "parse error");
./src/conntrack.c:2082:		exit_error(PARAMETER_PROBLEM, "cannot specify `--src-nat' or "
./src/conntrack.c:2094:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./src/conntrack.c:2098:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./src/conntrack.c:2113:				exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2123:				exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2135:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2139:			exit_error(PARAMETER_PROBLEM, "Can't use -z with "
./src/conntrack.c:2146:			exit_error(OTHER_PROBLEM, "OOM");
./src/conntrack.c:2173:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2196:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2211:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2222:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2235:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2241:			exit_error(OTHER_PROBLEM, "OOM");
./src/conntrack.c:2262:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2271:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2283:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2293:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2303:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2330:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2376:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2407:			exit_error(OTHER_PROBLEM, "Can't open %s",
./src/conntrack.c:2411:			exit_error(OTHER_PROBLEM, "Can't read %s",
./src/conntrack.c:2421:			exit_error(OTHER_PROBLEM, "Can't open handler");
./src/conntrack.c:2465:			exit_error(OTHER_PROBLEM, "Can't open /proc interface");
./src/conntrack.c:2481:		exit_error(OTHER_PROBLEM, "Operation failed: %s",
./src/cache-ct.c:214:			dlog(LOG_ERR, "commit-destroy: %s", strerror(errno));
./src/cache-ct.c:218:			dlog(LOG_ERR, "commit-create: %s", strerror(errno));
./src/cache-ct.c:324:cache_ct_build_msg(const struct cache_object *obj, int type)
./src/main.c:122:			nv, strerror(errno));
./src/main.c:130:			d, strerror(errno));
./src/main.c:386:			perror("sched");
./src/main.c:404:		perror("chdir");
./src/main.c:414:			perror("fork has failed: ");
./extensions/libct_proto_gre.c:166:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_gre.c:171:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_tcp.c:160:			exit_error(PARAMETER_PROBLEM,
./extensions/libct_proto_tcp.c:199:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_tcp.c:204:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_sctp.c:171:			exit_error(PARAMETER_PROBLEM,
./extensions/libct_proto_sctp.c:220:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_sctp.c:225:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_udplite.c:171:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_udplite.c:176:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_dccp.c:168:			exit_error(PARAMETER_PROBLEM,
./extensions/libct_proto_dccp.c:192:			exit_error(PARAMETER_PROBLEM,
./extensions/libct_proto_dccp.c:220:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_dccp.c:225:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_udp.c:166:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./extensions/libct_proto_udp.c:171:			exit_error(PARAMETER_PROBLEM, "you have to specify "
./include/conntrack.h:51:void exit_error(enum exittype status, const char *msg, ...);
./include/nfct.h:22:void nfct_perror(const char *msg);
./include/network.h:94:	ct2msg(ct, __hdr);					\
./include/network.h:105:	exp2msg(exp, __hdr);					\
./include/network.h:247:void ct2msg(const struct nf_conntrack *ct, struct nethdr *n);
./include/network.h:275:void exp2msg(const struct nf_expect *exp, struct nethdr *n);
./include/debug.h:18:#define debug(...) do {} while (0)
./include/helper.h:104:#define pr_debug(fmt, arg...) \
./include/helper.h:107:#define pr_debug(fmt, arg...) \

== environment() ==

== privileged() ==
./src/channel.c:110:	if (ioctl(fd, SIOCGIFMTU, &ifr) == -1) {

== networking() ==
./src/mcast.c:50:	case AF_INET:
./src/mcast.c:54:	        m->addr.ipv4.sin_family = AF_INET;
./src/mcast.c:61:	case AF_INET6:
./src/mcast.c:66:		m->addr.ipv6.sin6_family = AF_INET6;
./src/mcast.c:74:	if ((m->fd = socket(conf->ipproto, SOCK_DGRAM, 0)) == -1) {
./src/mcast.c:110:	case AF_INET:
./src/mcast.c:118:	case AF_INET6:
./src/mcast.c:142:	m->addr.ipv4.sin_family = AF_INET;
./src/mcast.c:168:	m->addr.ipv6.sin6_family = AF_INET6;
./src/mcast.c:202:	if ((m->fd = socket(conf->ipproto, SOCK_DGRAM, 0)) == -1) {
./src/mcast.c:232:		case AF_INET:
./src/mcast.c:235:		case AF_INET6:
./src/udp.c:33:	case AF_INET:
./src/udp.c:34:	        m->addr.ipv4.sin_family = AF_INET;
./src/udp.c:40:	case AF_INET6:
./src/udp.c:41:		m->addr.ipv6.sin6_family = AF_INET6;
./src/udp.c:49:	m->fd = socket(conf->ipproto, SOCK_DGRAM, 0);
./src/udp.c:104:	m->fd = socket(conf->ipproto, SOCK_DGRAM, 0);
./src/udp.c:135:	case AF_INET:
./src/udp.c:136:		m->addr.ipv4.sin_family = AF_INET;
./src/udp.c:141:	case AF_INET6:
./src/udp.c:142:		m->addr.ipv6.sin6_family = AF_INET6;
./src/nfct-extensions/timeout.c:199:		l3proto = AF_INET;
./src/nfct-extensions/timeout.c:201:		l3proto = AF_INET6;
./src/nfct-extensions/helper.c:188:		l3proto = AF_INET;
./src/nfct-extensions/helper.c:190:		l3proto = AF_INET6;
./src/nfct-extensions/helper.c:313:			l3proto = AF_INET;
./src/nfct-extensions/helper.c:315:			l3proto = AF_INET6;
./src/nfct-extensions/helper.c:406:			l3proto = AF_INET;
./src/nfct-extensions/helper.c:408:			l3proto = AF_INET6;
./src/nfct-extensions/helper.c:542:		l3proto = AF_INET;
./src/nfct-extensions/helper.c:544:		l3proto = AF_INET6;
./src/cthelper.c:71:	nfg->nfgen_family = AF_UNSPEC;
./src/cthelper.c:306:	pktb = pktb_alloc(AF_INET, pkt, pktlen, 256);
./src/cthelper.c:450:	nfq_nlmsg_cfg_put_cmd(nlh, AF_INET, NFQNL_CFG_CMD_BIND);
./src/cthelper.c:493:	nfq_nlmsg_cfg_put_cmd(nlh, AF_INET, NFQNL_CFG_CMD_PF_UNBIND);
./src/cthelper.c:501:	nfq_nlmsg_cfg_put_cmd(nlh, AF_INET, NFQNL_CFG_CMD_PF_BIND);
./src/read_config_yy.c:2264:	if (!ct_filter_add_ip(STATE(us_filter), &ip, AF_INET)) {
./src/read_config_yy.c:2285:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string), &ip.ipv6) <= 0) {
./src/read_config_yy.c:2293:	if (!ct_filter_add_ip(STATE(us_filter), &ip, AF_INET6)) {
./src/read_config_yy.c:2355:        if (conf.channel[conf.channel_num].u.mcast.ipproto == AF_INET6) {
./src/read_config_yy.c:2362:	conf.channel[conf.channel_num].u.mcast.ipproto = AF_INET;
./src/read_config_yy.c:2374:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string),
./src/read_config_yy.c:2384:	if (conf.channel[conf.channel_num].u.mcast.ipproto == AF_INET) {
./src/read_config_yy.c:2391:	conf.channel[conf.channel_num].u.mcast.ipproto = AF_INET6;
./src/read_config_yy.c:2405:		conf.channel[conf.channel_num].u.mcast.ipproto = AF_INET6;
./src/read_config_yy.c:2422:        if (conf.channel[conf.channel_num].u.mcast.ipproto == AF_INET6) {
./src/read_config_yy.c:2429:	conf.channel[conf.channel_num].u.mcast.ipproto = AF_INET;
./src/read_config_yy.c:2459:	if (conf.channel[conf.channel_num].u.mcast.ipproto == AF_INET6) {
./src/read_config_yy.c:2461:		conf.channel[conf.channel_num].u.mcast.ipproto = AF_INET6;
./src/read_config_yy.c:2576:	conf.channel[conf.channel_num].u.udp.ipproto = AF_INET;
./src/read_config_yy.c:2588:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string),
./src/read_config_yy.c:2597:	conf.channel[conf.channel_num].u.udp.ipproto = AF_INET6;
./src/read_config_yy.c:2612:	conf.channel[conf.channel_num].u.udp.ipproto = AF_INET;
./src/read_config_yy.c:2624:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string),
./src/read_config_yy.c:2633:	conf.channel[conf.channel_num].u.udp.ipproto = AF_INET6;
./src/read_config_yy.c:2759:	conf.channel[conf.channel_num].u.tcp.ipproto = AF_INET;
./src/read_config_yy.c:2771:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string),
./src/read_config_yy.c:2780:	conf.channel[conf.channel_num].u.tcp.ipproto = AF_INET6;
./src/read_config_yy.c:2795:	conf.channel[conf.channel_num].u.tcp.ipproto = AF_INET;
./src/read_config_yy.c:2807:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string),
./src/read_config_yy.c:2816:	conf.channel[conf.channel_num].u.tcp.ipproto = AF_INET6;
./src/read_config_yy.c:3687:		if (!ct_filter_add_netmask(STATE(us_filter), &tmp, AF_INET)) {
./src/read_config_yy.c:3694:		if (!ct_filter_add_ip(STATE(us_filter), &ip, AF_INET)) {
./src/read_config_yy.c:3740:	if (inet_pton(AF_INET6, (yyvsp[(2) - (2)].string), &ip.ipv6) <= 0) {
./src/read_config_yy.c:3753:		if (!ct_filter_add_netmask(STATE(us_filter), &tmp, AF_INET6)) {
./src/read_config_yy.c:3760:		if (!ct_filter_add_ip(STATE(us_filter), &ip, AF_INET6)) {
./src/read_config_yy.c:3935:		l3proto = AF_INET;
./src/read_config_yy.c:3937:		l3proto = AF_INET6;
./src/filter.c:163:		case AF_INET:
./src/filter.c:175:		case AF_INET6:
./src/filter.c:206:		case AF_INET:
./src/filter.c:213:		case AF_INET6:
./src/filter.c:336:		case AF_INET:
./src/filter.c:344:		case AF_INET6:
./src/filter.c:375:	case AF_INET:
./src/filter.c:384:	case AF_INET6:
./src/filter.c:424:	case AF_INET:
./src/filter.c:432:	case AF_INET6:
./src/helpers/ftp.c:163:	if ((l3protonum == PF_INET && data[1] != '1') ||
./src/helpers/ftp.c:164:	    (l3protonum == PF_INET6 && data[1] != '2')) {
./src/helpers/ftp.c:291:	numlen = getnum(data + i, dlen - i, cmd, PF_INET, term);
./src/helpers/ftp.c:397:	nfct_set_attr_u8(nat_tuple, ATTR_L3PROTO, AF_INET);
./src/helpers/ftp.c:527:		if (cmd.l3num == PF_INET) {
./src/helpers/rpc.c:77:	nfct_set_attr_u8(nat_tuple, ATTR_L3PROTO, AF_INET);
./src/helpers/tns.c:216:	nfct_set_attr_u8(nat_tuple, ATTR_L3PROTO, AF_INET);
./src/local.c:35:	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
./src/local.c:45:	local.sun_family = AF_UNIX;
./src/local.c:98:	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
./src/local.c:101:	local.sun_family = AF_UNIX;
./src/netlink.c:149:static const int family = AF_UNSPEC;
./src/cache-exp.c:79:		case AF_INET:
./src/cache-exp.c:82:		case AF_INET6:
./src/expect.c:45:		case AF_INET:
./src/expect.c:46:			nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET);
./src/expect.c:49:			nfct_set_attr_u8(mask, ATTR_L3PROTO, AF_INET);
./src/expect.c:52:		case AF_INET6:
./src/expect.c:53:			nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET6);
./src/expect.c:59:			nfct_set_attr_u8(mask, ATTR_L3PROTO, AF_INET6);
./src/expect.c:70:		case AF_INET:
./src/expect.c:71:			nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET);
./src/expect.c:74:			nfct_set_attr_u8(mask, ATTR_L3PROTO, AF_INET);
./src/expect.c:77:		case AF_INET6:
./src/expect.c:81:			nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET6);
./src/expect.c:84:			nfct_set_attr_u8(mask, ATTR_L3PROTO, AF_INET6);
./src/expect.c:122:	case AF_INET:
./src/expect.c:123:		nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET);
./src/expect.c:127:	case AF_INET6:
./src/expect.c:128:		nfct_set_attr_u8(expected, ATTR_L3PROTO, AF_INET6);
./src/tcp.c:41:	case AF_INET:
./src/tcp.c:42:	        m->addr.ipv4.sin_family = AF_INET;
./src/tcp.c:48:	case AF_INET6:
./src/tcp.c:49:		m->addr.ipv6.sin6_family = AF_INET6;
./src/tcp.c:57:	m->fd = socket(c->ipproto, SOCK_STREAM, 0);
./src/tcp.c:129:	m->fd = socket(c->ipproto, SOCK_STREAM, 0);
./src/tcp.c:156:	case AF_INET:
./src/tcp.c:157:		m->addr.ipv4.sin_family = AF_INET;
./src/tcp.c:162:	case AF_INET6:
./src/tcp.c:163:		m->addr.ipv6.sin6_family = AF_INET6;
./src/internal_bypass.c:52:	u_int32_t family = AF_UNSPEC;
./src/internal_bypass.c:183:	u_int32_t family = AF_UNSPEC;
./src/sync-notrack.c:102:	u_int32_t family = AF_UNSPEC;
./src/conntrack.c:940:	if (*family == AF_UNSPEC)
./src/conntrack.c:956:		return AF_INET;
./src/conntrack.c:958:	else if (inet_pton(AF_INET6, cp, &parse->addr6) > 0)
./src/conntrack.c:959:		return AF_INET6;
./src/conntrack.c:961:	return AF_UNSPEC;
./src/conntrack.c:975:	if ((ret = parse_inetaddr(cp, &parse)) == AF_INET)
./src/conntrack.c:977:	else if (ret == AF_INET6)
./src/conntrack.c:1022:	if (parse_addr(arg, &parse) == AF_UNSPEC) {
./src/conntrack.c:1615:	nfh->nfgen_family = AF_INET;
./src/conntrack.c:1827:	int family = AF_UNSPEC;
./src/conntrack.c:1902:			if (l3protonum == AF_UNSPEC) {
./src/conntrack.c:1907:			if (l3protonum == AF_INET) {
./src/conntrack.c:1911:			} else if (l3protonum == AF_INET6) {
./src/conntrack.c:1924:			if (l3protonum == AF_UNSPEC) {
./src/conntrack.c:1929:			if (l3protonum == AF_INET) {
./src/conntrack.c:1933:			} else if (l3protonum == AF_INET6) {
./src/conntrack.c:1999:			set_family(&family, AF_INET);
./src/conntrack.c:2045:				set_family(&family, AF_INET);
./src/conntrack.c:2047:				set_family(&family, AF_INET6);
./src/conntrack.c:2076:	if (family == AF_UNSPEC)
./src/conntrack.c:2077:		family = AF_INET;
./src/channel.c:103:	fd = socket(AF_INET, SOCK_DGRAM, 0);
./src/cache-ct.c:78:		case AF_INET:
./src/cache-ct.c:81:		case AF_INET6:
./include/linux/netfilter/nfnetlink_queue.h:62:	NFQNL_CFG_CMD_PF_BIND,
./include/linux/netfilter/nfnetlink_queue.h:63:	NFQNL_CFG_CMD_PF_UNBIND,
./include/linux/netfilter/nfnetlink_queue.h:69:	__be16		pf;		/* AF_xxx for PF_[UN]BIND */
./include/linux/netfilter/nfnetlink.h:28:	__u8  nfgen_family;		/* AF_xxx */
./src/mcast.c:74:	if ((m->fd = socket(conf->ipproto, SOCK_DGRAM, 0)) == -1) {
./src/mcast.c:103:	if (bind(m->fd, (struct sockaddr *) &m->addr, m->sockaddr_len) == -1) {
./src/mcast.c:202:	if ((m->fd = socket(conf->ipproto, SOCK_DGRAM, 0)) == -1) {
./src/mcast.c:262:	ret = sendto(m->fd, 
./src/mcast.c:284:        ret = recvfrom(m->fd,
./src/udp.c:49:	m->fd = socket(conf->ipproto, SOCK_DGRAM, 0);
./src/udp.c:79:	if (bind(m->fd, (struct sockaddr *) &m->addr, m->sockaddr_len) == -1) {
./src/udp.c:104:	m->fd = socket(conf->ipproto, SOCK_DGRAM, 0);
./src/udp.c:172:	ret = sendto(m->fd, 
./src/udp.c:194:        ret = recvfrom(m->fd,
./src/nfct-extensions/timeout.c:131:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/timeout.c:137:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/timeout.c:142:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:147:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:279:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/timeout.c:285:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/timeout.c:290:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:295:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:344:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/timeout.c:350:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/timeout.c:355:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:360:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:410:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/timeout.c:416:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/timeout.c:421:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:426:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:460:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/timeout.c:466:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/timeout.c:471:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/timeout.c:476:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:141:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:147:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:152:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:157:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:257:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:263:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:268:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:273:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:350:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:356:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:361:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:366:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:444:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:450:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:455:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:460:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:494:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:500:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:505:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:510:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:589:	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/nfct-extensions/helper.c:595:	if (mnl_socket_sendto(nl, nlh, nlh->nlmsg_len) < 0) {
./src/nfct-extensions/helper.c:600:	ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/nfct-extensions/helper.c:605:		ret = mnl_socket_recvfrom(nl, buf, sizeof(buf));
./src/cthelper.c:185:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:202:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:346:	ret = mnl_socket_recvfrom(STATE_CTH(nl), buf, sizeof(buf));
./src/cthelper.c:423:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:428:	ret = mnl_socket_recvfrom(STATE_CTH(nl), buf, sizeof(buf));
./src/cthelper.c:433:		ret = mnl_socket_recvfrom(STATE_CTH(nl), buf, sizeof(buf));
./src/cthelper.c:452:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:463:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:495:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:503:	if (mnl_socket_sendto(STATE_CTH(nl), nlh, nlh->nlmsg_len) < 0) {
./src/cthelper.c:529:	if (mnl_socket_bind(STATE_CTH(nl), 0, MNL_SOCKET_AUTOPID) < 0) {
./src/event.c:64:		ret = write(evfd->fds[1], &data, sizeof(data));
./src/event.c:75:		ret = read(evfd->fds[0], &data, sizeof(data));
./src/run.c:189:	if (read(fd, &type, sizeof(type)) <= 0) {
./src/read_config_lex.c:235:	 * instead of fread(), to make sure we stop fetching input after
./src/read_config_lex.c:2174: * we now use fwrite().
./src/read_config_lex.c:2177:#define ECHO if (fwrite( yytext, yyleng, 1, yyout )) yy_fatal_error (strerror (errno));
./src/read_config_lex.c:2201:		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
./src/local.c:35:	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
./src/local.c:50:	if (bind(fd, (struct sockaddr *) &local, len) == -1) {
./src/local.c:56:	if (listen(fd, conf->backlog) == -1) {
./src/local.c:98:	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
./src/local.c:105:	if (connect(fd, (struct sockaddr *) &local, len) == -1) {
./src/tcp.c:57:	m->fd = socket(c->ipproto, SOCK_STREAM, 0);
./src/tcp.c:94:	if (bind(m->fd, (struct sockaddr *) &m->addr, m->sockaddr_len) == -1) {
./src/tcp.c:100:	if (listen(m->fd, 1) == -1) {
./src/tcp.c:129:	m->fd = socket(c->ipproto, SOCK_STREAM, 0);
./src/tcp.c:184:	ret = connect(m->fd, (struct sockaddr *)&m->addr, m->sockaddr_len);
./src/tcp.c:204:/* We use this to rate-limit the amount of connect() calls per second. */
./src/tcp.c:279:		/* We rate-limit the amount of connect() calls. */
./src/tcp.c:285:		ret = connect(m->fd, (struct sockaddr *)&m->addr,
./src/tcp.c:306:		ret = sendto(m->fd, data, size, 0,
./src/tcp.c:337:        ret = recvfrom(m->client_fd, data, size, 0,
./src/conntrack.c:1594:	if (mnl_socket_bind(sock.mnl, 0, MNL_SOCKET_AUTOPID) < 0) {
./src/conntrack.c:1636:	res = mnl_socket_sendto(sock.mnl, nlh, nlh->nlmsg_len);
./src/conntrack.c:1640:	res = mnl_socket_recvfrom(sock.mnl, buf, sizeof(buf));
./src/conntrack.c:1647:		res = mnl_socket_recvfrom(sock.mnl, buf, sizeof(buf));
./src/conntrack.c:1662:	res = mnl_socket_sendto(sock.mnl, nlh, nlh->nlmsg_len);
./src/conntrack.c:1666:	res = mnl_socket_recvfrom(sock.mnl, buf, sizeof(buf));
./src/channel.c:103:	fd = socket(AF_INET, SOCK_DGRAM, 0);

== http:// ==
./src/internal_cache.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/nfct-extensions/timeout.c:9: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/nfct-extensions/helper.c:9: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/read_config_yy.h:18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
./src/sync-ftfw.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/sync-alarm.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/helpers.c:8: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/cthelper.c:18: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/external_inject.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/read_config_yy.c:18:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
./src/read_config_yy.c:1637:       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
./src/parse.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/ctnl.c:18: * Part of this code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/cache.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/fds.c:18: * Part of this code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/filter.c:3: * (C) 2011-2012 by Vyatta Inc <http://www.vyatta.com>
./src/run.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/run.c:19: * Part of this code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/build.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/helpers/ftp.c:6: * This port has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/helpers/ftp.c:12: * (C) 2003,2004 USAGI/WIDE Project <http://www.linux-ipv6.org>
./src/helpers/rpc.c:7: * This port has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/helpers/tns.c:5: * Sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/external_cache.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/stats-mode.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/netlink.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/cache-exp.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/cache-exp.c:51:	 * http://www.mail-archive.com/netdev@vger.kernel.org/msg56623.html
./src/expect.c:8: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/internal_bypass.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/nfct.c:9: * This code has been sponsored by Vyatta Inc. <http://www.vyatta.com>
./src/sync-notrack.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/network.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/conntrack.c:3: * (C) 2012 by Intra2net AG <http://www.intra2net.com>
./src/conntrack.c:38: * Part of this code has been funded by Sophos Astaro <http://www.sophos.com>
./src/cache-ct.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/cache-ct.c:51:	 * http://www.mail-archive.com/netdev@vger.kernel.org/msg56623.html
./src/sync-mode.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./src/main.c:3: * (C) 2011 by Vyatta Inc. <http://www.vyatta.com>
./include/jhash.h:11: * http://burtleburtle.net/bob/hash/

== encryption ==

== sql() ==
./src/netlink.c:105:	if (nlif_query(h) == -1) {
./src/netlink.c:153:	return nfct_query(h, NFCT_Q_DUMP, &family);
./src/netlink.c:187:	ret = nfct_query(h, NFCT_Q_DUMP, &family);
./src/netlink.c:212:	if (nfct_query(h, NFCT_Q_GET, tmp) == -1)
./src/netlink.c:262:	ret = nfct_query(h, NFCT_Q_CREATE, ct);
./src/netlink.c:329:	ret = nfct_query(h, NFCT_Q_UPDATE, ct);
./src/netlink.c:337:	return nfct_query(h, NFCT_Q_DESTROY, ct);
./src/netlink.c:353:	ret = nfexp_query(h, NFCT_Q_CREATE, exp);
./src/netlink.c:361:	return nfexp_query(h, NFCT_Q_DESTROY, exp);
./src/netlink.c:375:	if (nfexp_query(h, NFCT_Q_GET, tmp) == -1)
./src/netlink.c:384:	return nfexp_query(h, NFCT_Q_DUMP, &family);
./src/netlink.c:389:	return nfexp_query(h, NFCT_Q_FLUSH, &family);
./src/expect.c:172:	ret = nfexp_query(h, cmd, exp);
./src/internal_bypass.c:61:	ret = nfct_query(h, NFCT_Q_DUMP, &family);
./src/internal_bypass.c:193:	ret = nfexp_query(h, NFCT_Q_DUMP, &family);
./src/sync-notrack.c:111:	ret = nfct_query(h, NFCT_Q_DUMP, &family);
./src/conntrack.c:1316:	res = nfct_query(ith, NFCT_Q_DESTROY, ct);
./src/conntrack.c:1413:	res = nfct_query(ith, NFCT_Q_UPDATE, tmp);
./src/conntrack.c:1422:	res = nfct_query(ith, NFCT_Q_GET, tmp);
./src/conntrack.c:2155:			res = nfct_query(cth, NFCT_Q_DUMP_FILTER_RESET,
./src/conntrack.c:2158:			res = nfct_query(cth, NFCT_Q_DUMP_FILTER, filter_dump);
./src/conntrack.c:2176:		res = nfexp_query(cth, NFCT_Q_DUMP, &family);
./src/conntrack.c:2198:		res = nfct_query(cth, NFCT_Q_CREATE, tmpl.ct);
./src/conntrack.c:2213:		res = nfexp_query(cth, NFCT_Q_CREATE, tmpl.exp);
./src/conntrack.c:2226:		res = nfct_query(cth, NFCT_Q_DUMP, &family);
./src/conntrack.c:2249:		res = nfct_query(cth, NFCT_Q_DUMP_FILTER, filter_dump);
./src/conntrack.c:2264:		res = nfexp_query(cth, NFCT_Q_DESTROY, tmpl.exp);
./src/conntrack.c:2274:		res = nfct_query(cth, NFCT_Q_GET, tmpl.ct);
./src/conntrack.c:2286:		res = nfexp_query(cth, NFCT_Q_GET, tmpl.exp);
./src/conntrack.c:2294:		res = nfct_query(cth, NFCT_Q_FLUSH, &family);
./src/conntrack.c:2304:		res = nfexp_query(cth, NFCT_Q_FLUSH, &family);
./src/conntrack.c:2424:		res = nfexp_query(cth, NFCT_Q_DUMP, &family);

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/sync-ftfw.c:53:/* XXX: alive message expiration configurable */
./src/sync-ftfw.c:396:		/* XXX: flush the resend queues since the other does not 
./src/cthelper.c:305:	/* XXX: 256 bytes enough for possible NAT mangling in helpers? */
./src/cthelper.c:395:		/* FIXME: get existing policy values from the kernel first. */
./src/read_config_yy.c:2213:	 * XXX: The use of Checksum outside of the Multicast clause is broken
./src/read_config_yy.c:2228:	 * XXX: The use of Checksum outside of the Multicast clause is broken
./src/read_config_yy.c:3952:	/* XXX use configure.ac definitions. */
./src/read_config_yy.c:4004:			/* FIXME: First set default policy, then change only
./src/read_config_yy.c:4468:	   one run loop. XXX: no option available to tune this value yet. */
./src/parse.c:455:		.max_size	= 32,	/* XXX: artificial limit */
./src/filter.c:44:/* XXX: These should be configurable, better use a rb-tree */
./src/read_config_lex.c:3365:	/* TODO. We should be able to replace this entire function body
./src/helpers/ftp.c:37:static bool loose; /* XXX: export this as config option. */
./src/helpers/tns.c:126:/* FIXME: handle hostnames */
./src/helpers/tns.c:259:		/* FIXME: recalculate checksum */
./src/netlink.c:251:		/* FIXME: workaround, we should send TCP flags in updates */
./src/netlink.c:318:		/* FIXME: workaround, we should send TCP flags in updates */
./src/netlink.c:370:	/* XXX: we only need the expectation, not the mask and the master. */
./src/cache-exp.c:112:	/* XXX: add nfexp_copy(...) to libnetfilter_conntrack. */
./src/cache-exp.c:126:	 * XXX: Do not dump the entries that are scheduled to expire.
./src/cache-exp.c:180:			/* XXX: Arbitrarily set the timer to one minute, how
./src/sync-notrack.c:32:/* XXX: alive message expiration configurable */
./src/cache-ct.c:133:	 * XXX: Do not dump the entries that are scheduled to expire.
./src/cache-ct.c:191:			/* XXX: Arbitrarily set the timer to one minute, how
./src/sync-mode.c:48:	/* TODO: add stats on ENOMEM errors in the future. */
./src/sync-mode.c:66:	/* TODO: add stats on ENOMEM errors in the future. */
./src/sync-mode.c:163:static char __net[65536];		/* XXX: maximum MTU for IPv4 */

== unsafe input mechanisms ==

