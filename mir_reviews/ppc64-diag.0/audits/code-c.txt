Running: /home/sarnold/bin/audit-code.sh -c C .
Scanning '.'
== subprocess_spawned() ==
./ela/catalogs.cpp:893:	if (!(in = popen(cstr, "r"))) {
./ela/catalogs.cpp:1171:	result = regexec(&regex, msg->message.c_str(), nmatch, pmatch, 0);
./ela/catalogs.cpp:1528:	if (msg[0] == '[' && regexec(&printk_timestamp_regex, msg,
./ela/syslog_to_svclog.cpp:591: * the popen() call.
./ela/syslog_to_svclog.cpp:597:	 * Avoid stuff like popen("tail -F ... file; rm -rf /", "r")
./ela/syslog_to_svclog.cpp:622:	FILE *p = popen(tail_command.c_str(), "r");
./opal_errd/opal_errd.c:333:	rc = system(dump_cmd);
./rtas_errd/servicelog.c:206:				 "filesystem (%llu bytes):\n%s%s", 
./rtas_errd/dump.c:95:	rc = system(system_arg);
./rtas_errd/dump.c:271:	f = popen(cmd_buf, "r");
./rtas_errd/hotplug.c:86:                        rc = execv(DRMGR_PROGRAM, drmgr_args);
./rtas_errd/prrn.c:585:		execl(PRRN_HOTPLUG, "prrn_hotplug", NULL);
./rtas_errd/diag_support.c:67:	*fp = popen(cmd, "r");
./rtas_errd/diag_support.c:70:		dbg("lsvpd_init failed popen (%s)", CMD_LSVPD);
./rtas_errd/diag_support.c:235:	if (system(command) != 0) {
./rtas_errd/ela_msg.h:790:#define V6_ER_30_00 "I/O subsystem (hub, bridge, bus) Informational " \
./rtas_errd/ela_msg.h:794:#define V6_ER_30_10 "I/O subsystem (hub, bridge, bus) Recovered " \
./rtas_errd/ela_msg.h:798:#define V6_ER_30_20 "I/O subsystem (hub, bridge, bus) Predictive " \
./rtas_errd/ela_msg.h:802:#define V6_ER_30_21 "I/O subsystem (hub, bridge, bus) Predictive Error, " \
./rtas_errd/ela_msg.h:806:#define V6_ER_30_22 "I/O subsystem (hub, bridge, bus) Predictive Error, " \
./rtas_errd/ela_msg.h:810:#define V6_ER_30_23 "I/O subsystem (hub, bridge, bus) Predictive Error, " \
./rtas_errd/ela_msg.h:814:#define V6_ER_30_24 "I/O subsystem (hub, bridge, bus) Predictive Error, " \
./rtas_errd/ela_msg.h:818:#define V6_ER_30_40 "I/O subsystem (hub, bridge, bus) Unrecovered Error, " \
./rtas_errd/ela_msg.h:822:#define V6_ER_30_41 "I/O subsystem (hub, bridge, bus) Unrecovered Error, " \
./rtas_errd/ela_msg.h:826:#define V6_ER_30_44 "I/O subsystem (hub, bridge, bus) Unrecovered Error, " \
./rtas_errd/ela_msg.h:830:#define V6_ER_30_45 "I/O subsystem (hub, bridge, bus) Unrecovered Error, " \
./rtas_errd/ela_msg.h:834:#define V6_ER_30_48 "I/O subsystem (hub, bridge, bus) Unrecovered Error, " \
./rtas_errd/ela_msg.h:838:#define V6_ER_30_60 "I/O subsystem (hub, bridge, bus) Error on " \
./rtas_errd/ela_msg.h:842:#define V6_ER_30_61 "I/O subsystem (hub, bridge, bus) Error on " \
./rtas_errd/ela_msg.h:1386:#define V6_EV_30_00  "I/O subsystem (hub, bridge, bus) Not applicable."
./rtas_errd/ela_msg.h:1388:#define V6_EV_30_01  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1391:#define V6_EV_30_08  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1394:#define V6_EV_30_10  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1397:#define V6_EV_30_20  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1400:#define V6_EV_30_21  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1403:#define V6_EV_30_22  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1406:#define V6_EV_30_30  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1409:#define V6_EV_30_40  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1412:#define V6_EV_30_60  "I/O subsystem (hub, bridge, bus) Capacity Upgrade Event."
./rtas_errd/ela_msg.h:1414:#define V6_EV_30_70  "I/O subsystem (hub, bridge, bus) Resource Sparing Event."
./rtas_errd/ela_msg.h:1416:#define V6_EV_30_80  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1419:#define V6_EV_30_D0  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/ela_msg.h:1422:#define V6_EV_30_E0  "I/O subsystem (hub, bridge, bus) " \
./rtas_errd/files.c:75: * intially exec()'ed via check_scanlog_dump(). The buffer will contain 
./rtas_errd/files.c:592:		rc = system(cmd_buf);
./rtas_errd/le/config.c:377:	if (system(system_arg) == -1) {
./rtas_errd/le/config.c:389:	if (system(system_arg)) {
./rtas_errd/epow.c:404:			rc = execv(EPOW_PROGRAM, childargs);
./rtas_errd/config.c:377:	if (system(system_arg) == -1) {
./rtas_errd/config.c:389:	if (system(system_arg)) {
./rtas_errd/guard.c:99:		rc = execv(DRMGR_PROGRAM, drmgr_args);
./rtas_errd/guard.c:213:	 * SIGCHLD handler to default action before doing popen() and
./rtas_errd/guard.c:218:	if ((fp = popen(cmd, "r")) == NULL) {
./lpd/lp_util.c:67:	fp = popen(buf, "r");
./lpd/indicator_ses.c:231:	fp = popen(cmd, "r");
./lpd/indicator_ses.c:365:	fp = popen(cmd, "r");
./lpd/indicator_ses.c:419:	return system(cmd);
./lpd/files.c:284:		rc = system(cmd_buf);
./diags/encl_led.c:88:	fp = popen(cmd, "r");
./diags/encl_util.c:168:	fp = popen(buf, "r");

== memory_management() ==
./ela/date.c:124:			(void) strcpy(fmt, day->fmt);
./ela/catalogs.cpp:156:				sprintf(octal_esc, "\\%o", (unsigned char) c);
./ela/syslog_to_svclog.cpp:215:	(void) strcpy(next, PROC_DEVICE_TREE_DIR);
./ela/syslog_to_svclog.cpp:234:	strcpy(next, LOCATION_CODE_FILE);
./ela/syslog_to_svclog.cpp:419:	svc = (struct sl_event*) malloc(sizeof(*svc));
./ela/syslog_to_svclog.cpp:420:	callout = (struct sl_callout*) malloc(sizeof(*callout));
./ela/syslog_to_svclog.cpp:421:	os_data = (struct sl_data_os*) malloc(sizeof(*os_data));
./opal_errd/opal-elog-parse/opal-src-scn.c:33:	*r_src = (struct opal_src_scn*) malloc(sizeof(struct opal_src_scn));
./opal_errd/opal-elog-parse/opal-src-scn.c:52:	memcpy(src->primary_refcode, bufsrc->primary_refcode,
./opal_errd/opal-elog-parse/opal-src-scn.c:92:	memcpy(primary_refcode_display, src->primary_refcode,
./opal_errd/opal-elog-parse/opal-dh-scn.c:22:	*r_dh = (struct opal_dh_scn *) malloc(sizeof(struct opal_dh_scn));
./opal_errd/opal-elog-parse/opal-dh-scn.c:45:		memcpy(dh->shared.dump_str, dhbuf->shared.dump_str, dh->length_dump_os);
./opal_errd/opal-elog-parse/opal-v6-hdr.c:24:	memcpy(hdr->id, bufhdr->id, 2);
./opal_errd/opal-elog-parse/opal-mtms-struct.h:15:	memcpy(dest->model, src->model, OPAL_SYS_MODEL_LEN);
./opal_errd/opal-elog-parse/opal-mtms-struct.h:16:	memcpy(dest->serial_no, src->serial_no, OPAL_SYS_SERIAL_LEN);
./opal_errd/opal-elog-parse/opal-lr-scn.c:21:	*r_lr = (struct opal_lr_scn *) malloc(sizeof(struct opal_lr_scn));
./opal_errd/opal-elog-parse/print_helpers.c:89:      char *remainder = malloc((written + 1) * sizeof(char));
./opal_errd/opal-elog-parse/opal-sw-scn.c:35:	memcpy(swv1->file_id, swv1buf->file_id, swv1->id_length);
./opal_errd/opal-elog-parse/opal-sw-scn.c:69:	*r_sw = (struct opal_sw_scn *)malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-lp-scn.c:24:	*r_lp = malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-lp-scn.c:46:	memcpy(lp->name, lpbuf->name, lp->length_name);
./opal_errd/opal-elog-parse/opal-ie-scn.c:23:	*r_ie = (struct opal_ie_scn *) malloc(sizeof(struct opal_ie_scn));
./opal_errd/opal-elog-parse/opal-ie-scn.c:42:		memcpy(ie->data.rpc, iebuf->data.rpc, ie->rpc_len);
./opal_errd/opal-elog-parse/opal-mtms-scn.c:27:	*r_mtms = (struct opal_mtms_scn*) malloc(sizeof(struct opal_mtms_scn));
./opal_errd/opal-elog-parse/opal-elog-parse.c:164:	*buf = malloc(bufsz);
./opal_errd/opal-elog-parse/opal-elog-parse.c:213:	memcpy(src, (buffer + ELOG_SRC_OFFSET), sizeof(src));
./opal_errd/opal-elog-parse/opal-event-log.c:8:		malloc(sizeof(struct opal_event_log_scn) * (n + 1));
./opal_errd/opal-elog-parse/opal-event-log.c:24:	memcpy(log[n].id, id, 2);
./opal_errd/opal-elog-parse/opal-ep-scn.c:23:	*r_ep = (struct opal_ep_scn *) malloc(sizeof(struct opal_ep_scn));
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:73:	memcpy(pe->mtms.model, bufsrc->mtms.model, OPAL_SYS_MODEL_LEN);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:74:	memcpy(pe->mtms.serial_no, bufsrc->mtms.serial_no, OPAL_SYS_SERIAL_LEN);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:94:		memcpy(pe->pce, buf + min_length, pe->hdr.length - min_length);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:128:		memcpy(id->part, buf + min_length, OPAL_FRU_ID_PART_MAX);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:142:		memcpy(id->ccin, buf + min_length, OPAL_FRU_ID_CCIN_MAX);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:156:		memcpy(id->serial, buf + min_length, OPAL_FRU_ID_SERIAL_MAX);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:205:	memcpy(fru_scn->location_code, bufsrc->location_code, fru_scn->loc_code_len);
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:249:		memcpy(tmp, id.serial, OPAL_FRU_ID_SERIAL_MAX);
./opal_errd/opal-elog-parse/opal-ch-scn.c:17:	*r_ch = (struct opal_ch_scn*) malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-usr-scn.c:29:	*r_usrhdr = (struct opal_usr_hdr_scn*) malloc(sizeof(struct opal_usr_hdr_scn));
./opal_errd/opal-elog-parse/opal-mtms-struct.c:12:	memcpy(model, mtms.model, OPAL_SYS_MODEL_LEN);
./opal_errd/opal-elog-parse/opal-mtms-struct.c:14:	memcpy(serial_no, mtms.serial_no, OPAL_SYS_SERIAL_LEN);
./opal_errd/opal-elog-parse/opal-mi-scn.c:21:	*r_mi = (struct opal_mi_scn *) malloc(sizeof(struct opal_mi_scn));
./opal_errd/opal-elog-parse/opal-ed-scn.c:22:	*r_ed = (struct opal_ed_scn *) malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-ed-scn.c:29:	memcpy(ed->user_data, edbuf->user_data, hdr->length - 12);
./opal_errd/opal-elog-parse/opal-hm-scn.c:22:	*r_hm = (struct opal_hm_scn *) malloc(sizeof(struct opal_hm_scn));
./opal_errd/opal-elog-parse/opal-ei-scn.c:20:	*r_ei = (struct opal_ei_scn *) malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-priv-hdr-scn.c:33:	*r_privhdr = (struct opal_priv_hdr_scn*) malloc(sizeof(struct opal_priv_hdr_scn));
./opal_errd/opal-elog-parse/opal-ud-scn.c:22:	*r_ud = (struct opal_ud_scn *) malloc(hdr->length);
./opal_errd/opal-elog-parse/opal-ud-scn.c:28:	memcpy(ud->data, bufud->data, hdr->length - sizeof(struct opal_v6_hdr));
./opal_errd/opal-elog-parse/opal-eh-scn.c:17:	*r_eh = (struct opal_eh_scn*) malloc(hdr->length);
./opal_errd/opal_errd.c:123:	errd_path = malloc(sb.st_size + 1);
./opal_errd/opal_errd.c:158:	dump_path = malloc(strlen(errd_path) + strlen(DEFAULT_EXTRACT_DUMP_FNAME) + 1);
./opal_errd/opal_errd.c:164:	strcpy(dump_path, errd_path);
./opal_errd/opal_errd.c:266:	memcpy(src, (buffer + ELOG_SRC_OFFSET), ELOG_SRC_SIZE);
./opal_errd/opal_errd.c:404:	buf = (char*)malloc(bufsz);
./opal_errd/extract_opal_dump.c:67:		strcpy(dfile, "platform.dumpid.PARTIAL");
./opal_errd/extract_opal_dump.c:225:	buf = (char*)malloc(bufsz);
./rtas_errd/ela.c:112:	sprintf(tempnum, "%d", num);
./rtas_errd/ela.c:128:		sprintf(rfc, "%04hX%04hX", event->frus[index].fmsg,
./rtas_errd/ela.c:155:			strcpy(ptr->frus[i].floc, na);
./rtas_errd/ela.c:207:	event->sl_entry->refcode = (char *)malloc(strlen(srn)+1);
./rtas_errd/ela.c:216:			strcpy(ptr->frus[i].floc, na);
./rtas_errd/ela.c:426:	new_reset = (struct epow_reset *)malloc(sizeof(*new_reset));
./rtas_errd/ela.c:563:	event->sl_entry = (struct sl_event *)malloc(sizeof(struct sl_event));
./rtas_errd/ela.c:584:	event->sl_entry->raw_data = (unsigned char *)malloc(event->length);
./rtas_errd/ela.c:585:	memcpy(event->sl_entry->raw_data, event->event_buf, event->length);
./rtas_errd/ela.c:601:			event->loc_codes = (char *)malloc(strlen(loc+4)+1);
./rtas_errd/ela.c:605:			strcpy(event->loc_codes, (loc + 4));
./rtas_errd/ela.c:647:				sprintf(target, "%s fail-offline", loc); 
./rtas_errd/ela.c:1077:				strcpy(e_desc->frus[i++].floc, loc);
./rtas_errd/ela.c:1251:			strcpy(e_desc->frus[i].floc, loc);
./rtas_errd/ela.c:1265:				strcpy(e_desc->frus[i].floc, loc);
./rtas_errd/ela.c:1286:			     calloc(1, sizeof(struct event_description_pre_v6));
./rtas_errd/ela.c:1289:		strcpy(temp_event->dname, e_desc->dname);
./rtas_errd/ela.c:1298:				strcpy(temp_event->frus[i].floc, loc);
./rtas_errd/ela.c:1318:	event->sl_entry->description = (char *)malloc(strlen(e_desc->rmsg)+1);
./rtas_errd/ela.c:1319:	strcpy(event->sl_entry->description, e_desc->rmsg);
./rtas_errd/ela.c:1370:		copyLCB = (char *)malloc(strlen(event->loc_codes) + 1);
./rtas_errd/ela.c:1375:		strcpy(copyLCB, event->loc_codes);
./rtas_errd/ela.c:1494:	offset = sprintf(buffer, fmt, argp);
./rtas_errd/ela.c:1514:					offset += sprintf(buffer + offset, 
./rtas_errd/ela.c:1533:						offset += sprintf(
./rtas_errd/ela.c:1543:		event->sl_entry->refcode = (char *)malloc(
./rtas_errd/ela.c:1545:		strcpy(event->sl_entry->refcode, menu_num_str);
./rtas_errd/ela.c:1548:		event->sl_entry->description = (char *)malloc(strlen(msg)+1);
./rtas_errd/ela.c:1549:		strcpy(event->sl_entry->description, msg);
./rtas_errd/ela.c:1580:			strcpy(e_desc->frus[0].fname, sen->name);
./rtas_errd/ela.c:1581:			strcpy(e_desc->frus[1].fname, sig->name);
./rtas_errd/ela.c:1583:				strcpy(e_desc->frus[2].fname, sen->busname);
./rtas_errd/ela.c:1586:			strcpy(e_desc->frus[0].fname, sig->name);
./rtas_errd/ela.c:1587:			strcpy(e_desc->frus[1].fname, sen->name);
./rtas_errd/ela.c:1589:				strcpy(e_desc->frus[2].fname, sig->busname);
./rtas_errd/ela.c:1593:			strcpy(e_desc->frus[0].fname, sen->name);
./rtas_errd/ela.c:1594:			strcpy(e_desc->frus[1].fname, sig->name);
./rtas_errd/ela.c:1596:				strcpy(e_desc->frus[2].fname, sen->busname);
./rtas_errd/ela.c:1599:			strcpy(e_desc->frus[0].fname, sig->name);
./rtas_errd/ela.c:1600:			strcpy(e_desc->frus[1].fname, sen->name);
./rtas_errd/ela.c:1602:				strcpy(e_desc->frus[2].fname, sig->busname);
./rtas_errd/ela.c:1608:		strcpy(e_desc->frus[0].fname, sig->name);
./rtas_errd/ela.c:1609:		strcpy(e_desc->frus[1].fname, sig->busname);
./rtas_errd/ela.c:1614:		strcpy(e_desc->frus[0].fname, sen->name);
./rtas_errd/ela.c:1615:		strcpy(e_desc->frus[1].fname, sen->busname);
./rtas_errd/ela.c:1618:			strcpy(e_desc->frus[0].fname, sig->busname);
./rtas_errd/ela.c:1622:			strcpy(e_desc->frus[0].fname, sen->busname);
./rtas_errd/ela.c:1650:				strcpy(e_desc->frus[0].floc, loc);
./rtas_errd/ela.c:1651:				strcpy(e_desc->frus[1].floc, loc);
./rtas_errd/ela.c:1654:				strcpy(e_desc->frus[0].floc, loc);
./rtas_errd/ela.c:1658:			strcpy(e_desc->frus[i].floc, loc);
./rtas_errd/ela.c:1702:	buf = (char *)malloc(strlen(event->loc_codes)+4);
./rtas_errd/ela.c:1708:	strcpy(loc1, get_loc_code(event, FIRST_LOC, &nlocs));
./rtas_errd/ela.c:1717:		strcpy(loc2, get_loc_code(event, NEXT_LOC, NULL));
./rtas_errd/ela.c:1722:		strcpy(loc3, get_loc_code(event, NEXT_LOC, NULL));
./rtas_errd/ela.c:1742:					malloc(strlen(loc1) +
./rtas_errd/ela.c:1747:				sprintf(event->loc_codes, "%s %s", loc2, loc1);
./rtas_errd/ela.c:1755:					malloc(strlen(loc1) + 
./rtas_errd/ela.c:1761:				sprintf(event->loc_codes, "%s %s %s", 
./rtas_errd/ela.c:2024:			sprintf(fru_name, "%s", F_POWER_SUPPLY);
./rtas_errd/ela.c:2025:			sprintf(sensor_name, F_EPOW_ONE, F_VOLT_SEN_2,
./rtas_errd/ela.c:2033:				strcpy(e_desc->frus[0].fname, fru_name);
./rtas_errd/ela.c:2034:				strcpy(e_desc->frus[1].fname, sensor_name);
./rtas_errd/ela.c:2040:                       	sprintf(sensor_name, F_EPOW_ONE, F_THERM_SEN,
./rtas_errd/ela.c:2048:                        	strcpy(e_desc->frus[0].fname, sensor_name);
./rtas_errd/ela.c:2054:                       	sprintf(fru_name, F_EPOW_ONE, F_POWER_SUPPLY,
./rtas_errd/ela.c:2057:			sprintf(sensor_name, "%s", F_POW_SEN);
./rtas_errd/ela.c:2064:                        	strcpy(e_desc->frus[0].fname, fru_name);
./rtas_errd/ela.c:2065:				strcpy(e_desc->frus[1].fname, sensor_name);
./rtas_errd/ela.c:2903:		strcpy(event->frus[k].floc, "");
./rtas_errd/ela.c:2904:		strcpy(event->frus[k].fname, "");
./rtas_errd/ela.c:3092:		strcpy(e_desc->frus[j].fname, REFCODE_FNAME);
./rtas_errd/ela.c:3103:				strcpy(e_desc->frus[j].floc, loc);
./rtas_errd/ela.c:3131:				strcpy(e_desc->frus[j].fname, REFCODE_FNAME);
./rtas_errd/servicelog.c:130:		event->sl_entry->callouts = (struct sl_callout *)malloc(
./rtas_errd/servicelog.c:137:		callout->next = (struct sl_callout *)malloc(sizeof(*callout));
./rtas_errd/servicelog.c:148:		callout->procedure = (char *)malloc(strlen(proc) + 1);
./rtas_errd/servicelog.c:152:		callout->location = (char *)malloc(strlen(loc) + 1);
./rtas_errd/servicelog.c:156:		callout->fru = (char *)malloc(strlen(pn) + 1);
./rtas_errd/servicelog.c:160:		callout->serial = (char *)malloc(strlen(sn) + 1);
./rtas_errd/servicelog.c:164:		callout->ccin = (char *)malloc(strlen(ccin) + 1);
./rtas_errd/servicelog.c:200:			memcpy(filename, scn_dump->os_id, scn_dump->id_len);
./rtas_errd/servicelog.c:221:			new_desc = (char *)malloc(new_len);
./rtas_errd/servicelog.c:229:			event->sl_entry->description = (char *)malloc(txtlen+1);
./rtas_errd/dump.c:50:	ret = (char *)malloc(20);
./rtas_errd/dump.c:93:	sprintf(system_arg, "%s %s %s 2>/dev/null", MODPROBE_PROGRAM,
./rtas_errd/dump.c:135:		sprintf(scanlog_filename, "%sscanoutlog.%s",
./rtas_errd/dump.c:140:		sprintf(scanlog_filename, "%sscanoutlog.NOSERIAL",
./rtas_errd/dump.c:148:		sprintf(scanlog_filename_bak, "%s.bak", scanlog_filename);
./rtas_errd/dump.c:171:	dump_buf = malloc(DUMP_BUF_SZ);
./rtas_errd/dump.c:195:	if ((scanlog = malloc(bytes + 1)) != 0)
./rtas_errd/dump.c:296:	memcpy(dump_scn->os_id, filename, DUMP_MAX_FNAME_LEN);
./rtas_errd/v6ela.c:218:	event->sl_entry->refcode = (char *)malloc(strlen(src->primary_refcode)
./rtas_errd/v6ela.c:220:	strcpy(event->sl_entry->refcode, src->primary_refcode);
./rtas_errd/v6ela.c:223:	event->sl_entry->description = (char *)malloc(strlen(msg)+1);
./rtas_errd/v6ela.c:224:	strcpy(event->sl_entry->description, msg);
./rtas_errd/v6ela.c:356:				offset += sprintf(buffer + offset, msg, 
./rtas_errd/v6ela.c:359:				offset += sprintf(buffer + offset, "%s", msg);
./rtas_errd/v6ela.c:366:			offset += sprintf(buffer + offset, "%s%s\n\n",
./rtas_errd/v6ela.c:382:			offset += sprintf(buffer + offset, 
./rtas_errd/v6ela.c:425:				    	tmp_off += sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:431:						    sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:438:						    sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:443:				    	tmp_off += sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:449:				    	tmp_off += sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:453:					tmp_off += sprintf(tmp_buf + tmp_off, 
./rtas_errd/v6ela.c:456:				offset += sprintf(buffer + offset, 
./rtas_errd/v6ela.c:468:		offset += sprintf(buffer + offset, "%s%s\n\n",
./rtas_errd/v6ela.c:475:	event->sl_entry->refcode = (char *)malloc(strlen(menu_num_str)+1);
./rtas_errd/v6ela.c:476:	strcpy(event->sl_entry->refcode, menu_num_str);
./rtas_errd/v6ela.c:478:	event->sl_entry->description = (char *)malloc(strlen(msg)+1);
./rtas_errd/v6ela.c:479:	strcpy(event->sl_entry->description, msg);
./rtas_errd/v6ela.c:506:	event->sl_entry = (struct sl_event *)malloc(sizeof(struct sl_event));
./rtas_errd/v6ela.c:507:	rtas_data = (struct sl_data_rtas *)malloc(sizeof(struct sl_data_rtas));
./rtas_errd/v6ela.c:522:				(char *)malloc(strlen(mt->mtms.model)+1);
./rtas_errd/v6ela.c:524:			strcpy(event->sl_entry->machine_model, mt->mtms.model);
./rtas_errd/v6ela.c:527:				(char *)malloc(strlen(mt->mtms.serial_no)+1);
./rtas_errd/v6ela.c:529:			strcpy(event->sl_entry->machine_serial,
./rtas_errd/v6ela.c:555:	event->sl_entry->raw_data = (unsigned char *)malloc(event->length);
./rtas_errd/v6ela.c:556:	memcpy(event->sl_entry->raw_data, event->event_buf, event->length);
./rtas_errd/extract_platdump.c:170:			sprintf(pathname, "%s%s", d_cfg.platform_dump_path, 
./rtas_errd/extract_platdump.c:208:	dump_buf = malloc(DUMP_BUF_SZ);
./rtas_errd/extract_platdump.c:253:		strcpy(filename, "dumpid.");
./rtas_errd/extract_platdump.c:281:	strcpy(pathname, d_cfg.platform_dump_path);
./rtas_errd/prrn.c:68:	len = sprintf(buf, "# PRRN Event Recieved: %s", ctime(&now));
./rtas_errd/prrn.c:85:	sprintf(drc_path, "%s/%s", path, "ibm,my-drc-index");
./rtas_errd/prrn.c:109:	pm = malloc(sizeof(struct pmap_struct));
./rtas_errd/prrn.c:112:	pm->name = malloc(strlen(name) + 1);
./rtas_errd/prrn.c:113:	sprintf(pm->name, "%s", name);
./rtas_errd/prrn.c:153:	strcpy(path, parent);
./rtas_errd/prrn.c:173:	strcpy(pend, "/ibm,phandle");
./rtas_errd/prrn.c:223:	membuf = malloc(sbuf.st_size);
./rtas_errd/prrn.c:376:				sprintf(cmd,"remove_property %u %s",
./rtas_errd/prrn.c:404:					newcmd = malloc(cmdlen + vd);
./rtas_errd/prrn.c:405:					memcpy(newcmd, longcmd, cmdlen);
./rtas_errd/prrn.c:409:					longcmd = malloc(vd+128);
./rtas_errd/prrn.c:413:					lenpos = sprintf(longcmd,
./rtas_errd/prrn.c:421:				memcpy(longcmd + cmdlen, op, vd);
./rtas_errd/prrn.c:430:					sprintf(longcmd+lenpos,"%06d",proplen);
./rtas_errd/prrn.c:465:		len = sprintf(buf, "# %s %x - %s (%x)\n", type,
./rtas_errd/prrn.c:468:		len = sprintf(buf, "%s %x\n", type, pms->drc_index);
./rtas_errd/prrn.c:498:			len = sprintf(buf, "mem %x\n", pms->drc_index);
./rtas_errd/diag_support.c:66:	sprintf(cmd, "%s 2>/dev/null", CMD_LSVPD);
./rtas_errd/diag_support.c:122:			event->diag_vpd.ds = (char *)malloc(strlen (line) + 1);
./rtas_errd/diag_support.c:126:			strcpy(event->diag_vpd.ds, &line[4]);		
./rtas_errd/diag_support.c:131:			event->diag_vpd.yl = (char *)malloc(strlen (line) + 1);
./rtas_errd/diag_support.c:135:			strcpy(event->diag_vpd.yl, &line[4]);		
./rtas_errd/diag_support.c:140:			event->diag_vpd.fn = (char *)malloc(strlen (line) + 1); 
./rtas_errd/diag_support.c:144:			strcpy(event->diag_vpd.fn, &line[4]);
./rtas_errd/diag_support.c:149:			event->diag_vpd.sn = (char *)malloc(strlen (line) + 1); 
./rtas_errd/diag_support.c:153:			strcpy(event->diag_vpd.sn, &line[4]); 
./rtas_errd/diag_support.c:158:			event->diag_vpd.se = (char *)malloc(strlen (line) + 1); 
./rtas_errd/diag_support.c:162:			strcpy(event->diag_vpd.se, &line[4]);
./rtas_errd/diag_support.c:167:			event->diag_vpd.tm = (char *)malloc(strlen (line) + 1); 
./rtas_errd/diag_support.c:171:			strcpy(event->diag_vpd.tm, &line[4]);
./rtas_errd/diag_support.c:269:		strcpy(ptr, "ibm,loc-code");
./rtas_errd/files.c:184:	scenario_buf = malloc(sbuf.st_size);
./rtas_errd/files.c:204:	scenario_files = malloc(scenario_count * sizeof(char *));
./rtas_errd/files.c:360:		memcpy(buf, &seq_num, sizeof(int));
./rtas_errd/files.c:463:	memcpy(buf, msg, len);
./rtas_errd/files.c:536:		vsprintf(buf, fmt, ap);
./rtas_errd/files.c:550:		len = sprintf(buf, "%s ", ctime(&cal));
./rtas_errd/files.c:556:		len += sprintf(buf, "(Sequence #%d) ",
./rtas_errd/files.c:560:	len += vsprintf(buf + len, fmt, ap);
./rtas_errd/files.c:563:	len += sprintf(buf + len, ".");
./rtas_errd/files.c:590:		sprintf(cmd_buf, "rm -f %s; mv %s %s", rtas_errd_log0,
./rtas_errd/files.c:668:	len = sprintf(buf, "DEBUG: ");
./rtas_errd/files.c:723:	out_buf = malloc(buf_size); 
./rtas_errd/files.c:733:	offset = sprintf(out_buf, 
./rtas_errd/files.c:738:		offset += sprintf(out_buf + offset, "RTAS: %s\n", scanlog);
./rtas_errd/files.c:746: 			offset += sprintf(out_buf + offset, "RTAS %d:", i/16);
./rtas_errd/files.c:749: 			offset += sprintf(out_buf + offset, " ");
./rtas_errd/files.c:751: 		offset += sprintf(out_buf + offset, "%02x", 
./rtas_errd/files.c:755:			offset += sprintf(out_buf + offset, "\n");
./rtas_errd/files.c:758: 		offset += sprintf(out_buf + offset, "\n");
./rtas_errd/files.c:760: 	offset += sprintf(out_buf + offset,
./rtas_errd/files.c:797:	len = sprintf(buf, "%s ", "ppc64-diag:");
./rtas_errd/files.c:800:	len += vsprintf(buf + len, fmt, ap);
./rtas_errd/files.c:840:        size = sprintf(buf, "%d", status);
./rtas_errd/le/config.c:213:	offset += sprintf(buf, "%s", tok);
./rtas_errd/le/config.c:217:		offset += sprintf(buf + offset, " %s", tok);
./rtas_errd/le/config.c:375:	sprintf(system_arg, "/usr/sbin/nvram "
./rtas_errd/le/config.c:386:	sprintf(system_arg, "%s%d", "/usr/sbin/nvram -p common "
./rtas_errd/le/config.c:559:	strcpy(d_cfg.scanlog_dump_path, "/var/log/");
./rtas_errd/le/config.c:560:	strcpy(d_cfg.platform_dump_path, "/var/log/dump/");
./rtas_errd/epow.c:108:	vsprintf(buf, fmt, ap);
./rtas_errd/config.c:213:	offset += sprintf(buf, "%s", tok);
./rtas_errd/config.c:217:		offset += sprintf(buf + offset, " %s", tok);
./rtas_errd/config.c:375:	sprintf(system_arg, "/usr/sbin/nvram "
./rtas_errd/config.c:386:	sprintf(system_arg, "%s%d", "/usr/sbin/nvram -p common "
./rtas_errd/config.c:559:	strcpy(d_cfg.scanlog_dump_path, "/var/log/");
./rtas_errd/config.c:560:	strcpy(d_cfg.platform_dump_path, "/var/log/dump/");
./lpd/lp_util.c:149:			curr = (struct dev_vpd *)malloc(sizeof
./lpd/lp_util.c:153:			curr->next = (struct dev_vpd *)malloc(sizeof
./lpd/indicator_ses.c:251:			curr = (struct loc_code *)malloc(sizeof
./lpd/indicator_ses.c:255:			curr->next = (struct loc_code *)malloc(sizeof
./lpd/files.c:72:	memcpy(buf, msg, len);
./lpd/indicator_rtas.c:50:			  (struct loc_code *)malloc(sizeof(struct loc_code));
./lpd/indicator_rtas.c:54:			  (struct loc_code *)malloc(sizeof(struct loc_code));
./lpd/lp_diag.c:276:				fru = (struct fru *)malloc(sizeof
./lpd/lp_diag.c:280:				fru->next = (struct fru *)malloc(sizeof
./lpd/lp_diag.c:921:	cur_state = (char *)malloc(length);
./lpd/lp_diag.c:922:	prev_state = (char *)malloc(length);
./lpd/lp_diag.c:924:	my_items = (ITEM **)calloc(length, sizeof(ITEM *));
./diags/test/bh_mk_hot_power.c:25:	memcpy(&page, &healthy_page, sizeof(page));
./diags/test/bh_dump_pg2.c:109:	sprintf(dev_sg, "/dev/%s", sg);
./diags/test/bh_vpd.c:89:	memcpy(dest, src, n);
./diags/test/bh_vpd.c:114:	sprintf(dev_sg, "/dev/%s", sg);
./diags/bluehawk.c:37:	sprintf(srn, "%03X-%03X", SAS_SRN, element)
./diags/bluehawk.c:105:		sprintf(invalid_msg, "(UNEXPECTED_STATUS_CODE=%u)", sc);
./diags/bluehawk.c:356:	memcpy(dest, src, n);
./diags/bluehawk.c:434:		strcpy(crit, "Critical");
./diags/bluehawk.c:437:		strcpy(crit, "Non-critical");
./diags/bluehawk.c:609:	strcpy(location, vpd->location);
./diags/bluehawk.c:622:		sprintf(description, "%s fault in RAID enclosure disk %u.%s",
./diags/bluehawk.c:624:		sprintf(loc_suffix, "-P1-D%u", i+1);
./diags/bluehawk.c:636:		sprintf(description,
./diags/bluehawk.c:639:		sprintf(loc_suffix, "-P1-E%u", i+1);
./diags/bluehawk.c:652:		sprintf(description,
./diags/bluehawk.c:656:		sprintf(loc_suffix, "-P1-E%u", i+1);
./diags/bluehawk.c:669:		sprintf(description,
./diags/bluehawk.c:672:		sprintf(loc_suffix, "-P1-E%u", i+1);
./diags/bluehawk.c:686:		sprintf(description,
./diags/bluehawk.c:689:		sprintf(loc_suffix, "-P1-C%u-A1", i+1);
./diags/bluehawk.c:704:		sprintf(description,
./diags/bluehawk.c:709:		sprintf(loc_suffix, "-P1-E%u", i+1);
./diags/bluehawk.c:723:		sprintf(description,
./diags/bluehawk.c:728:		sprintf(loc_suffix, "-P1-C%u", i+1);
./diags/bluehawk.c:740:		sprintf(description,
./diags/bluehawk.c:743:		sprintf(loc_suffix, "-P1-C%u", i+1);
./diags/bluehawk.c:757:		sprintf(description,
./diags/bluehawk.c:760:		sprintf(loc_suffix, "-P1-C%u-T%u", lr+1, t);
./diags/bluehawk.c:773:		sprintf(description,
./diags/bluehawk.c:776:		sprintf(loc_suffix, "-P1-C%u-T3", i+1);
./diags/bluehawk.c:786:		sprintf(description,
./diags/bluehawk.c:789:		strcpy(loc_suffix, "-P1");
./diags/bluehawk_led.c:138:		sprintf(loc_code, "P1-D%u", i+1);
./diags/bluehawk_led.c:139:		sprintf(desc, "disk %u", i+1);
./diags/bluehawk_led.c:144:		sprintf(loc_code, "P1-E%u", i+1);
./diags/bluehawk_led.c:145:		sprintf(desc, "%s power supply", left_right[i]);
./diags/bluehawk_led.c:150:		sprintf(loc_code, "P1-C%u", i+1);
./diags/bluehawk_led.c:151:		sprintf(desc, "%s Enclosure RAID Module", left_right[i]);
./diags/bluehawk_led.c:156:		sprintf(loc_code, "P1-C%u-T3", i+1);
./diags/bluehawk_led.c:157:		sprintf(desc, "%s PCIe controller", left_right[i]);
./diags/bluehawk_led.c:162:		sprintf(loc_code, "P1-C%u-T%u", (i/2)+1, (i%2)+1);
./diags/bluehawk_led.c:163:		sprintf(desc, "%s SAS connector T%d", left_right[i/2], (i%2)+1);
./diags/bluehawk_led.c:168:		sprintf(loc_code, "P1-C%u-A1", i+1);
./diags/bluehawk_led.c:169:		sprintf(desc, "%s fan assembly", left_right[i]);
./diags/diag_encl.c:147:		*callouts = (struct sl_callout *)malloc(sizeof
./diags/diag_encl.c:154:		c->next = (struct sl_callout *)malloc(sizeof
./diags/diag_encl.c:167:		c->procedure = (char *)malloc(strlen(proc_id) + 1);
./diags/diag_encl.c:168:		strcpy(c->procedure, proc_id);
./diags/diag_encl.c:171:		c->location = (char *)malloc(strlen(location) + 1);
./diags/diag_encl.c:172:		strcpy(c->location, location);
./diags/diag_encl.c:175:		c->fru = (char *)malloc(strlen(fru) + 1);
./diags/diag_encl.c:176:		strcpy(c->fru, fru);
./diags/diag_encl.c:179:		c->serial = (char *)malloc(strlen(sn) + 1);
./diags/diag_encl.c:180:		strcpy(c->serial, sn);
./diags/diag_encl.c:183:		c->ccin = (char *)malloc(strlen(ccin) + 1);
./diags/diag_encl.c:184:		strcpy(c->ccin, ccin);
./diags/diag_encl.c:212:	entry = (struct sl_event *)malloc(sizeof(struct sl_event));
./diags/diag_encl.c:219:	encl = (struct sl_data_enclosure *)malloc(
./diags/diag_encl.c:235:	entry->description = (char *)malloc(strlen(text) + 1);
./diags/diag_encl.c:236:	strcpy(entry->description, text);
./diags/diag_encl.c:237:	entry->refcode = (char *)malloc(strlen(refcode) + 1);
./diags/diag_encl.c:238:	strcpy(entry->refcode, refcode);
./diags/diag_encl.c:239:	encl->enclosure_model = (char *)malloc(strlen(vpd->mtm) + 1);
./diags/diag_encl.c:240:	strcpy(encl->enclosure_model, vpd->mtm);
./diags/diag_encl.c:241:	encl->enclosure_serial = (char *)malloc(strlen(vpd->sn) + 1);
./diags/diag_encl.c:242:	strcpy(encl->enclosure_serial, vpd->sn);
./diags/diag_encl.c:279:	strcpy(dot, ".vpd");
./diags/diag_encl.c:319:	cmd_opts.prev_path = (char *) malloc(sizeof(DIAG_ENCL_PREV_PAGES_DIR) +
./diags/diag_encl.c:321:	strcpy(cmd_opts.prev_path, DIAG_ENCL_PREV_PAGES_DIR);
./diags/diag_encl.c:403:	vpd = (struct dev_vpd *)malloc(sizeof(struct dev_vpd));
./diags/encl_util.c:150:	strcpy(vpd->location, vpd->full_loc);
./opal-dump-parse/opal-dump-parse.c:182:	strcpy(dump_path, path);
./ela/catalogs.cpp:738:		exceptions[type] = new ExceptionMsg(type, description, action);
./ela/catalogs.cpp:1164:		pmatch = new regmatch_t[nmatch];
./ela/catalogs.cpp:1346:	DevspecMacro *dm = new DevspecMacro(nm, path);
./ela/catalogs.cpp:1376:	cur_source_file = new string(path);
./ela/catalogs.cpp:1466:			catalog_copy = new CatalogCopy(path,
./ela/syslog_to_svclog.cpp:118:		vpd = new VpdRetriever();

== files() ==
./ela/catalogs.cpp:59:	file = fopen(pathname, "r");
./ela/catalogs.cpp:893:	if (!(in = popen(cstr, "r"))) {
./ela/catalogs.cpp:1679:	orig_file = fopen(orig_path.c_str(), "r");
./ela/catalogs.cpp:1686:	copy_file = fopen(copy_path.c_str(), "w");
./ela/syslog_to_svclog.cpp:179:	fd = open(path, O_RDONLY);
./ela/syslog_to_svclog.cpp:532:	FILE *f = fopen(cpath, "w");
./ela/syslog_to_svclog.cpp:569:		FILE *f = fopen(LAST_EVENT_PATH, "r");
./ela/syslog_to_svclog.cpp:591: * the popen() call.
./ela/syslog_to_svclog.cpp:597:	 * Avoid stuff like popen("tail -F ... file; rm -rf /", "r")
./ela/syslog_to_svclog.cpp:613:	int fd = open(msg_path, O_RDONLY);
./ela/syslog_to_svclog.cpp:622:	FILE *p = popen(tail_command.c_str(), "r");
./ela/syslog_to_svclog.cpp:635:	FILE *f = fopen(msg_path, "r");
./ela/syslog_to_svclog.cpp:776:	result = servicelog_open(&slog, 0);
./ela/syslog_to_svclog.cpp:778:		cerr << "servicelog_open() failed, returning "
./ela/explain_syslog.cpp:169:		msg_file = fopen(msg_path, "r");
./opal_errd/opal-elog-parse/opal-elog-parse.c:170:	platform_log_fd = open(path, O_RDONLY);
./opal_errd/opal_errd.c:353:	fd = open(ack_file, O_WRONLY);
./opal_errd/opal_errd.c:410:	in_fd = open(elog_raw_path, O_RDONLY);
./opal_errd/opal_errd.c:437:	out_fd = open(output_file, O_WRONLY  | O_CREAT,
./opal_errd/opal_errd.c:460:	dir_fd = open(dirname(output_dir), O_RDONLY|O_DIRECTORY);
./opal_errd/extract_opal_dump.c:80:	fd = open(ack_file, O_WRONLY);
./opal_errd/extract_opal_dump.c:231:	in_fd = open(dump_path, O_RDONLY);
./opal_errd/extract_opal_dump.c:258:	out_fd = open(dump_path, O_WRONLY|O_CREAT|O_EXCL, S_IRUSR|S_IRGRP);
./opal_errd/extract_opal_dump.c:274:	dir_fd = open(output_dir, O_RDONLY|O_DIRECTORY);
./opal_errd/extract_opal_dump.c:435:		fd = open(sysfs_path, O_RDONLY|O_DIRECTORY);
./common/platform.c:32:	if((fp = fopen(PLATFORM_FILE, "r")) == NULL)
./rtas_errd/rtas_errd.c:77:	umask(0);
./rtas_errd/rtas_errd.c:85:	i = open("/dev/null", O_RDWR);
./rtas_errd/rtas_errd.c:543:	rc = servicelog_open(&slog, 0);
./rtas_errd/dump.c:46:	fp = fopen(SYSID_FILE, "r");
./rtas_errd/dump.c:157:	in = open(SCANLOG_DUMP_FILE, O_RDONLY);
./rtas_errd/dump.c:164:	out = open(scanlog_filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
./rtas_errd/dump.c:271:	f = popen(cmd_buf, "r");
./rtas_errd/prrn.c:60:	prrn_log_fd = open("/var/log/prrn_log", O_CREAT | O_WRONLY | O_TRUNC,
./rtas_errd/prrn.c:86:	fp = fopen(drc_path, "r");
./rtas_errd/prrn.c:174:	fd = fopen(path, "r");
./rtas_errd/prrn.c:217:	fd = fopen(DRCONF_PATH, "r");
./rtas_errd/prrn.c:271:	fd = open(OFDTPATH, O_WRONLY);
./rtas_errd/diag_support.c:67:	*fp = popen(cmd, "r");
./rtas_errd/diag_support.c:70:		dbg("lsvpd_init failed popen (%s)", CMD_LSVPD);
./rtas_errd/diag_support.c:241:	fp1 = fopen("/tmp/get_dt_files", "r");
./rtas_errd/diag_support.c:251:		fp2 = fopen(loc_file, "r");
./rtas_errd/diag_support.c:270:		fp2 = fopen(loc_file, "r");
./rtas_errd/files.c:170:	fd = open(scenario_file, O_RDONLY);
./rtas_errd/files.c:247:	rtas_errd_log_fd = open(rtas_errd_log, O_RDWR | O_CREAT | O_APPEND,
./rtas_errd/files.c:260:	proc_error_log_fd = open(proc_error_log1, O_RDONLY);
./rtas_errd/files.c:262:		proc_error_log_fd = open(proc_error_log2, O_RDONLY);
./rtas_errd/files.c:273:	platform_log_fd = open(platform_log, O_RDWR | O_SYNC | O_CREAT,
./rtas_errd/files.c:414:				proc_error_log_fd = open(tmp, O_RDONLY);
./rtas_errd/files.c:600:		rtas_errd_log_fd = open(rtas_errd_log, 
./rtas_errd/files.c:826:		epow_status_fd = open(epow_status_file, flags, mode);
./rtas_errd/le/rtas_errd.c:77:	umask(0);
./rtas_errd/le/rtas_errd.c:85:	i = open("/dev/null", O_RDWR);
./rtas_errd/le/rtas_errd.c:503:	rc = servicelog_open(&slog, 0);
./rtas_errd/le/config.c:589:	if ((cfg_fd = open(config_file, O_RDONLY)) < 0) {
./rtas_errd/config.c:589:	if ((cfg_fd = open(config_file, O_RDONLY)) < 0) {
./rtas_errd/update.c:211:	if ((msgs_log_fd = open(messages_log, O_RDONLY)) < 0) {
./rtas_errd/guard.c:145:			if ((fd = open(buffer, O_RDONLY)) < 0 ) {
./rtas_errd/guard.c:213:	 * SIGCHLD handler to default action before doing popen() and
./rtas_errd/guard.c:218:	if ((fp = popen(cmd, "r")) == NULL) {
./rtas_errd/guard.c:276:	if ((fp = fopen("/proc/ppc64/lparcfg", "r")) == NULL) {
./rtas_errd/convert_dt_node_props.c:63:	if ((fd = open("/proc/device-tree/ibm,drc-indexes",
./rtas_errd/convert_dt_node_props.c:83:		if ((fd = open("/proc/device-tree/ibm,drc-names",
./rtas_errd/convert_dt_node_props.c:354:			if ((fd = open(buffer, O_RDONLY)) < 0) {
./rtas_errd/convert_dt_node_props.c:364:					if ((fd = open(buffer, O_RDONLY)) < 0) {
./rtas_errd/convert_dt_node_props.c:392:	if ((fd = open("/proc/device-tree/cpus/ibm,drc-indexes",
./rtas_errd/convert_dt_node_props.c:412:		if ((fd = open("/proc/device-tree/cpus/ibm,drc-names",
./rtas_errd/convert_dt_node_props.c:465:			if ((drc_fd = open(buffer, O_RDONLY)) < 0) {
./rtas_errd/convert_dt_node_props.c:476:					if ((intr_fd = open(buffer, O_RDONLY)) < 0) {
./rtas_errd/convert_dt_node_props.c:503:	if ((fd = open("/proc/device-tree/cpus/ibm,drc-names",
./rtas_errd/convert_dt_node_props.c:529:		if ((fd = open("/proc/device-tree/cpus/ibm,drc-indexes",
./lpd/lp_util.c:67:	fp = popen(buf, "r");
./lpd/servicelog.c:38:	rc = servicelog_open(&slog, 0);
./lpd/indicator_ses.c:231:	fp = popen(cmd, "r");
./lpd/indicator_ses.c:365:	fp = popen(cmd, "r");
./lpd/files.c:308:		lp_error_log_fd = open(lp_error_log_file,
./lpd/files.c:318:	lp_event_log_fd = open(lp_event_log_file,
./diags/test/bh_dump_pg2.c:110:	fd = open(dev_sg, O_RDWR);
./diags/test/test_utils.c:112:	f = fopen(path, "w");
./diags/test/bh_vpd.c:115:	fd = open(dev_sg, O_RDWR);
./diags/bluehawk.c:51:	f = fopen(path, "r");
./diags/bluehawk.c:71:	f = fopen(path, "w");
./diags/encl_led.c:67:	fd = open(dev_sg, O_RDWR);
./diags/encl_led.c:88:	fp = popen(cmd, "r");
./diags/diag_encl.c:246:	rc = servicelog_open(&slog, 0);
./diags/diag_encl.c:281:	f = fopen(vpd_path, "r");
./diags/diag_encl.c:354:	fp = fopen(devsg, "r");
./diags/diag_encl.c:453:				fd = open(devsg, O_RDWR);
./diags/encl_util.c:168:	fp = popen(buf, "r");
./opal-dump-parse/opal-dump-parse.c:191:	fd = open(dump_path, O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP);
./opal-dump-parse/opal-dump-parse.c:380:	if ((dump_fd = open(dump_file, O_RDONLY)) < 0) {

== logging() ==
./ela/catalogs.cpp:33:extern void rrerror(const char *s);
./ela/catalogs.cpp:39:extern void everror(const char *s);
./ela/catalogs.cpp:63:		perror(pathname);
./ela/catalogs.cpp:75:Parser::semantic_error(const string& msg)
./ela/catalogs.cpp:77:	error(msg.c_str());
./ela/catalogs.cpp:359:	parser->semantic_error(name + " statement seen multiple times"
./ela/catalogs.cpp:367:		parser->semantic_error(name
./ela/catalogs.cpp:380:	cur_parser->semantic_error("unrecognized value for " + member + ": "
./ela/catalogs.cpp:514:			parser->semantic_error("device_arg " + arg +
./ela/catalogs.cpp:527:				parser->semantic_error(
./ela/catalogs.cpp:629:		parser->semantic_error(
./ela/catalogs.cpp:643:				parser->semantic_error("unknown reporter: "
./ela/catalogs.cpp:658:			parser->semantic_error("meta_reporter variants "
./ela/catalogs.cpp:688:		cur_parser->semantic_error(
./ela/catalogs.cpp:709:		cur_parser->semantic_error("duplicate reporter name: "
./ela/catalogs.cpp:740:		pc->semantic_error("multiple entries for exception " + type);
./ela/catalogs.cpp:765:		parent->parser->semantic_error("message statement must specify"
./ela/catalogs.cpp:770:		parent->parser->semantic_error("reporter "
./ela/catalogs.cpp:775:			parent->parser->semantic_error("severity specified by"
./ela/catalogs.cpp:815:			parser->semantic_error("logging function not found in"
./ela/catalogs.cpp:878:		parent->parser->semantic_error(
./ela/catalogs.cpp:894:		parent->parser->semantic_error("cannot create regex text,"
./ela/catalogs.cpp:904:		parent->parser->semantic_error(
./ela/catalogs.cpp:935:		(void) regerror(result, &regex, reason, 200);
./ela/catalogs.cpp:936:		parent->parser->semantic_error("cannot compile regex: "
./ela/catalogs.cpp:946:		parser->semantic_error("unknown exception type: " + reason);
./ela/catalogs.cpp:969:			parser->semantic_error("malformed @paste");
./ela/catalogs.cpp:975:			parser->semantic_error(
./ela/catalogs.cpp:1083:			parser->semantic_error("You must specify either "
./ela/catalogs.cpp:1090:			parser->semantic_error("Catalog doesn't provide regex"
./ela/catalogs.cpp:1091:				" for this message (reporter " +
./ela/catalogs.cpp:1107:	parser->semantic_error("regex statement: reporter " + rpt +
./ela/catalogs.cpp:1227:			cur_parser->semantic_error("Adding regex statements "
./ela/catalogs.cpp:1286:		cur_parser->semantic_error("filter op must be '='");
./ela/catalogs.cpp:1319:		cur_parser->semantic_error("duplicate name for text copy: "
./ela/catalogs.cpp:1350:		cur_parser->semantic_error("duplicate devspec entry for " + nm);
./ela/catalogs.cpp:1387:		cur_parser->semantic_error("could not find $" + nm +
./ela/catalogs.cpp:1393:		cur_parser->semantic_error("devspec is not final component of "
./ela/catalogs.cpp:1441:		perror(event_ctlg_dir.c_str());
./ela/catalogs.cpp:1453:			perror(path.c_str());
./ela/catalogs.cpp:1510:		(void) regerror(result, &printk_timestamp_regex, reason, 100);
./ela/catalogs.cpp:1683:		perror(orig_path.c_str());
./ela/catalogs.cpp:1690:		perror(copy_path.c_str());
./ela/syslog_to_svclog.cpp:60:usage_message(FILE *out)
./ela/syslog_to_svclog.cpp:68:	usage_message(stderr);
./ela/syslog_to_svclog.cpp:479:		cerr << servicelog_error(slog) << endl;
./ela/syslog_to_svclog.cpp:500:is_old_message(const char *line)
./ela/syslog_to_svclog.cpp:527:				perror(msg.c_str());
./ela/syslog_to_svclog.cpp:535:			perror(cpath);
./ela/syslog_to_svclog.cpp:540:			perror(cpath);
./ela/syslog_to_svclog.cpp:549:		perror(msg.c_str());
./ela/syslog_to_svclog.cpp:572:				perror(LAST_EVENT_PATH);
./ela/syslog_to_svclog.cpp:615:		perror(msg_path);
./ela/syslog_to_svclog.cpp:624:		perror(tail_command.c_str());
./ela/syslog_to_svclog.cpp:637:		perror(msg_path);
./ela/syslog_to_svclog.cpp:647:				perror("tail -F of message file");
./ela/syslog_to_svclog.cpp:656:	usage_message(stdout);
./ela/syslog_to_svclog.cpp:766:			perror(msg_path);
./ela/syslog_to_svclog.cpp:802:		if (skipping_old_messages && is_old_message(line))
./ela/syslog_to_svclog.cpp:804:		SyslogMessage msg(line);
./ela/catalogs.h:51:	void semantic_error(const string& msg);
./ela/explain_syslog.cpp:23:static void usage_message(FILE *out)
./ela/explain_syslog.cpp:31:	usage_message(stderr);
./ela/explain_syslog.cpp:96:	usage_message(stdout);
./ela/explain_syslog.cpp:156:					perror("syslog file");
./ela/explain_syslog.cpp:171:			perror(msg_path);
./ela/explain_syslog.cpp:226:		SyslogMessage msg(line);
./opal_errd/opal-elog-parse/opal-elog-parse.c:173:			"Skipping....\n", path, strerror(errno));
./opal_errd/opal_errd.c:203:			syslog(LOG_NOTICE, "Failed to allocate memory\n");
./opal_errd/opal_errd.c:215:			syslog(LOG_NOTICE, "Failed to read file\n");
./opal_errd/opal_errd.c:224:			syslog(LOG_NOTICE, "Failed to parse file date\n");
./opal_errd/opal_errd.c:235:				syslog(LOG_NOTICE, "Error removing %s\n",
./opal_errd/opal_errd.c:260:		syslog(LOG_NOTICE, "Insufficent data, cannot parse elog.\n");
./opal_errd/opal_errd.c:287:	syslog(LOG_NOTICE, "LID[%x]::SRC[%s]::%s::%s::%s\n",
./opal_errd/opal_errd.c:292:		syslog(LOG_NOTICE, "Run \'opal-elog-parse -d 0x%x\' "
./opal_errd/opal_errd.c:311:		syslog(LOG_NOTICE, "The command \"%s\" is not executable.\n",
./opal_errd/opal_errd.c:319:		syslog(LOG_NOTICE, "Failed to execute platform dump extractor"
./opal_errd/opal_errd.c:328:		syslog(LOG_NOTICE, "Failed to execute platform dump extractor"
./opal_errd/opal_errd.c:335:		syslog(LOG_NOTICE, "Failed to execute platform dump "
./opal_errd/opal_errd.c:349:		syslog(LOG_ERR, "Path to elog ack file is too big\n");
./opal_errd/opal_errd.c:356:		syslog(LOG_ERR, "Failed to acknowledge elog: %s"
./opal_errd/opal_errd.c:358:		       ack_file, errno, strerror(errno));
./opal_errd/opal_errd.c:364:		syslog(LOG_ERR, "Failed to acknowledge elog: %s"
./opal_errd/opal_errd.c:366:		       ack_file, errno, strerror(errno));
./opal_errd/opal_errd.c:396:		syslog(LOG_ERR, "Path to elog file is too big\n");
./opal_errd/opal_errd.c:406:		syslog(LOG_ERR, "Failed to allocate memory\n");
./opal_errd/opal_errd.c:412:		syslog(LOG_ERR, "Failed to open elog: %s (%d:%s)\n",
./opal_errd/opal_errd.c:413:		       elog_raw_path, errno, strerror(errno));
./opal_errd/opal_errd.c:420:			syslog(LOG_ERR, "Failed to read elog: %s (%d:%s)\n",
./opal_errd/opal_errd.c:421:			       elog_raw_path, errno, strerror(errno));
./opal_errd/opal_errd.c:433:		syslog(LOG_ERR, "Path to elog output file is too big\n");
./opal_errd/opal_errd.c:441:		syslog(LOG_ERR, "Failed to create elog output file: %s (%d:%s)\n",
./opal_errd/opal_errd.c:442:		       output_file, errno, strerror(errno));
./opal_errd/opal_errd.c:448:		syslog(LOG_ERR, "Failed to write elog output file: %s (%d:%s)\n",
./opal_errd/opal_errd.c:449:		       output_file, errno, strerror(errno));
./opal_errd/opal_errd.c:455:		syslog(LOG_ERR, "Failed to sync elog output file: %s (%d:%s)\n",
./opal_errd/opal_errd.c:456:		       output_file, errno, strerror(errno));
./opal_errd/opal_errd.c:463:		syslog(LOG_ERR, "Failed to sync platform elog directory: %s"
./opal_errd/opal_errd.c:464:		       " (%d:%s)\n", output_dir, errno, strerror(errno));
./opal_errd/opal_errd.c:545:			syslog(LOG_WARNING, "Could not find an opal dump extractor tool\n");
./opal_errd/opal_errd.c:550:				syslog(LOG_ERR, "Memory allocation error, extract_opal_dump "
./opal_errd/opal_errd.c:553:			syslog(LOG_WARNING, "Couldn't execute extract_opal_dump "
./opal_errd/opal_errd.c:555:					cmd, errno, strerror(errno));
./opal_errd/opal_errd.c:572:		syslog(LOG_ERR, "Error creating udev object");
./opal_errd/opal_errd.c:578:		syslog(LOG_ERR, "Error creating udev monitor object");
./opal_errd/opal_errd.c:584:		syslog(LOG_ERR, "Error (%d) adding udev match to dump", rc);
./opal_errd/opal_errd.c:590:		syslog(LOG_ERR, "Error (%d) adding udev match to elog", rc);
./opal_errd/opal_errd.c:596:		syslog(LOG_ERR, "Error (%d) enabling recieving on udev", rc);
./opal_errd/opal_errd.c:731:		syslog(LOG_ERR, "sysfs_path for opal dir is too big\n");
./opal_errd/opal_errd.c:739:		syslog(LOG_ERR, "sysfs_path for elogs too big\n");
./opal_errd/opal_errd.c:746:		syslog(LOG_ERR, "Error accessing sysfs: %s (%d: %s)\n",
./opal_errd/opal_errd.c:747:		       sysfs_path, errno, strerror(errno));
./opal_errd/opal_errd.c:757:				syslog(LOG_ERR, "Error creating output directory:"
./opal_errd/opal_errd.c:759:						strerror(errno));
./opal_errd/opal_errd.c:763:			syslog(LOG_ERR, "Error accessing directory: %s (%d: %s)\n",
./opal_errd/opal_errd.c:764:					opt_output_dir, errno, strerror(errno));
./opal_errd/opal_errd.c:771:		syslog(LOG_ERR, "Error setting up inotify (%d:%s)\n",
./opal_errd/opal_errd.c:772:		       errno, strerror(errno));
./opal_errd/opal_errd.c:779:		syslog(LOG_ERR, "Error adding inotify watch for %s (%d: %s)\n",
./opal_errd/opal_errd.c:780:		       sysfs_path, errno, strerror(errno));
./opal_errd/opal_errd.c:792:			syslog(LOG_NOTICE, "Cannot daemonize opal_errd, "
./opal_errd/opal_errd.c:806:			syslog(LOG_NOTICE, "Could not initialize signal handler"
./opal_errd/opal_errd.c:808:			       strerror(errno));
./opal_errd/opal_errd.c:848:	syslog(LOG_NOTICE, "Terminating\n");
./opal_errd/extract_opal_dump.c:83:		syslog(LOG_ERR, "Failed to acknowledge platform dump: %s"
./opal_errd/extract_opal_dump.c:85:		       ack_file, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:91:		syslog(LOG_ERR, "Failed to acknowledge platform dump: %s"
./opal_errd/extract_opal_dump.c:93:		       ack_file, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:110:		syslog(LOG_NOTICE, "Path to dump file (%s) is too big",
./opal_errd/extract_opal_dump.c:119:		syslog(LOG_NOTICE, "Could not delete file \"%s\" "
./opal_errd/extract_opal_dump.c:122:		       dump_path, strerror(errno));
./opal_errd/extract_opal_dump.c:193:			syslog(LOG_NOTICE, "Could not delete file \"%s\" "
./opal_errd/extract_opal_dump.c:196:			dump_path, strerror(errno));
./opal_errd/extract_opal_dump.c:227:		syslog(LOG_ERR, "Failed to allocate memory for dump\n");
./opal_errd/extract_opal_dump.c:234:		syslog(LOG_ERR, "Failed to open platform dump: %s (%d:%s)\n",
./opal_errd/extract_opal_dump.c:235:		       dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:242:			syslog(LOG_ERR, "Failed to read platform dump: %s "
./opal_errd/extract_opal_dump.c:244:			       dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:261:		syslog(LOG_ERR, "Failed to write platform dump: %s (%d:%s)\n",
./opal_errd/extract_opal_dump.c:262:		       dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:268:		syslog(LOG_ERR, "Failed to write platform dump: %s (%d:%s)\n",
./opal_errd/extract_opal_dump.c:269:		       dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:278:		syslog(LOG_ERR, "Failed to sync platform dump: %s (%d:%s)\n",
./opal_errd/extract_opal_dump.c:279:		       dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:286:		syslog(LOG_ERR, "Failed to rename platform dump %s to %s"
./opal_errd/extract_opal_dump.c:288:		       dump_path, final_dump_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:294:		syslog(LOG_ERR, "Failed to sync platform dump directory: %s"
./opal_errd/extract_opal_dump.c:295:		       " (%d:%s)\n", output_dir, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:298:	syslog(LOG_NOTICE, "New platform dump available. File: %s/%s\n",
./opal_errd/extract_opal_dump.c:393:				syslog(LOG_ERR, "Invalid value specified for "
./opal_errd/extract_opal_dump.c:420:		syslog(LOG_ERR, "Error accessing sysfs: %s (%d: %s)\n",
./opal_errd/extract_opal_dump.c:421:		       sysfs_path, errno, strerror(errno));
./opal_errd/extract_opal_dump.c:427:		syslog(LOG_ERR, "Error accessing output dir: %s (%d: %s)\n",
./opal_errd/extract_opal_dump.c:428:		       opt_output_dir, errno, strerror(errno));
./rtas_errd/rtas_errd.c:124:		log_msg(event, "Could not write RTAS event %d to log file %s", 
./rtas_errd/rtas_errd.c:126:		log_msg(event, "Rtas_errd is exiting to preserve the current "
./rtas_errd/rtas_errd.c:179:		log_msg(event, "Could not retrieve extended event data");
./rtas_errd/rtas_errd.c:244:				log_msg(NULL, "Could not read error log file");
./rtas_errd/rtas_errd.c:254:			log_msg(&event, "Could not parse RTAS event");
./rtas_errd/rtas_errd.c:260:			log_msg(&event, "Could not retrieve event header");
./rtas_errd/rtas_errd.c:492:	 * rtas_set_debug(1) if debug level >= 2,
./rtas_errd/rtas_errd.c:493:	 * rtas_set_debug(2) if debug level >= 3, ...
./rtas_errd/rtas_errd.c:496:		rtas_set_debug(debug - 1);
./rtas_errd/rtas_errd.c:511:		log_msg(NULL, "Could not initialize signal handler for "
./rtas_errd/rtas_errd.c:512:			"certian EPOW events (SIGALRM), %s", strerror(errno));
./rtas_errd/rtas_errd.c:521:		log_msg(NULL, "Could not initialize signal handler for "
./rtas_errd/rtas_errd.c:523:			strerror(errno));
./rtas_errd/rtas_errd.c:531:		log_msg(NULL, "Cannot ignore SIGPIPE, %s", strerror(errno));
./rtas_errd/rtas_errd.c:545:		log_msg(NULL, "Could not open the servicelog database, events "
./rtas_errd/rtas_errd.c:547:			strerror(rc));
./rtas_errd/rtas_errd.c:561:		log_msg(NULL, "Librtas returned an error code: %d"
./rtas_errd/rtas_errd.c:580:	log_msg(NULL, "The rtas_errd daemon is exiting");
./rtas_errd/signal.c:70:			log_msg(NULL, "Could not restore SIGCHLD signal "
./rtas_errd/signal.c:72:				strerror(errno));
./rtas_errd/signal.c:92:		log_msg(NULL, "Could not initialize signal handler for"
./rtas_errd/signal.c:93:			"cleaning up child processes, %s", strerror(errno));
./rtas_errd/ela.c:31:static int analyze_io_bus_error(struct event *, int, int);
./rtas_errd/ela.c:445: *	Determine if this error (the input) has been reset by an earilier
./rtas_errd/ela.c:558:		log_msg(event, "Could not retrieve extended event data");
./rtas_errd/ela.c:871:			analyze_io_bus_error(event, 1, error_type);
./rtas_errd/ela.c:1098:analyze_io_bus_error(struct event *event, int version, int error_type)
./rtas_errd/ela.c:2613:			if (analyze_io_bus_error(event, 3, error_type)) {
./rtas_errd/servicelog.c:44:			log_msg(event, "Could not parse RTAS event to "
./rtas_errd/servicelog.c:55:			log_msg(event, "Could not parse RTAS event to "
./rtas_errd/servicelog.c:189:		log_msg(event, "ELA did not generate any data to be logged "
./rtas_errd/servicelog.c:240:		log_msg(event, "Could not log event to servicelog.\n%s\n",
./rtas_errd/servicelog.c:241:			servicelog_error(slog));
./rtas_errd/servicelog.c:243:		log_msg(event, "servicelog key %llu", key);
./rtas_errd/dump.c:86:		log_msg(NULL, "%s module could not be %s, buffer is not long "
./rtas_errd/dump.c:99:		log_msg(NULL, "%s module could not be %s, could not run "
./rtas_errd/dump.c:151:			log_msg(NULL, "Could not rename %s, an existing "
./rtas_errd/dump.c:153:				"dump, %s", scanlog_filename, strerror(errno));
./rtas_errd/dump.c:159:		log_msg(NULL, "Could not open %s for reading, %s", 
./rtas_errd/dump.c:160:			SCANLOG_DUMP_FILE, strerror(errno));
./rtas_errd/dump.c:166:		log_msg(NULL, "Could not open %s for writing, %s", 
./rtas_errd/dump.c:167:			scanlog_filename, strerror(errno));
./rtas_errd/dump.c:173:		log_msg(NULL, "Could not allocate buffer to read in "
./rtas_errd/dump.c:174:			"scanlog dump, %s", strerror(errno));
./rtas_errd/dump.c:181:			log_msg(NULL, "Could not write to %s, %s", 
./rtas_errd/dump.c:182:				scanlog_filename, strerror(errno));
./rtas_errd/dump.c:188:		log_msg(NULL, "Could not read from %s, %s", SCANLOG_DUMP_FILE,
./rtas_errd/dump.c:189:			strerror(errno));
./rtas_errd/dump.c:198:		log_msg(NULL, "Could not allocate space for scanlog filename, "
./rtas_errd/dump.c:200:			"filesystem", strerror(errno)); 
./rtas_errd/dump.c:217:	log_msg(NULL, "Due to previous error a scanlog dump could not be"
./rtas_errd/dump.c:273:		log_msg(event, "Failed to open pipe to %s.",
./rtas_errd/v6ela.c:213:		log_msg(event, "Could not retrieve SRC section to handle "
./rtas_errd/v6ela.c:540:		log_msg(event, "Could not retrieve RTAS extended header "
./rtas_errd/v6ela.c:563:		log_msg(event, "No PH (private header) section in this v6 "
./rtas_errd/v6ela.c:572:		log_msg(event, "No UH (user header) section in this v6 "
./rtas_errd/hotplug.c:81:                        log_msg(NULL, "%s cannot be run to handle a hotplug event, %s",
./rtas_errd/hotplug.c:82:                                DRMGR_PROGRAM, strerror(errno));
./rtas_errd/hotplug.c:89:                        log_msg(NULL, "Couldn not exec %s in response to hotplug event, %s",
./rtas_errd/hotplug.c:90:                                DRMGR_PROGRAM, strerror(errno));
./rtas_errd/dchrp_frus.h:465:				/* Memory Data error (Bad data to memory) */
./rtas_errd/eeh.c:60:		log_msg(event, "Could not retrieve SRC section to check for "
./rtas_errd/eeh.c:87:		log_msg(event, "Could not retrieve the RTAS Event information "
./rtas_errd/extract_platdump.c:45:msg(char *fmt, ...)
./rtas_errd/extract_platdump.c:86:handle_platform_dump_error(int e, char *err_buf, int sz) 
./rtas_errd/extract_platdump.c:139:		snprintf(err_buf, sz, "%sUnknown error (%d)", err, e);
./rtas_errd/extract_platdump.c:173:			msg("Deleting file %s", pathname);
./rtas_errd/extract_platdump.c:175:				msg("Could not delete file \"%s\" "
./rtas_errd/extract_platdump.c:179:					dumpname, strerror(errno));
./rtas_errd/extract_platdump.c:206:	msg("Dump tag: 0x%016LX", dump_tag);
./rtas_errd/extract_platdump.c:210:		msg("Could not allocate buffer to retrieve dump: %s",
./rtas_errd/extract_platdump.c:211:			strerror(errno));
./rtas_errd/extract_platdump.c:216:	msg("Calling rtas_platform_dump, seq 0x%016LX", seq);
./rtas_errd/extract_platdump.c:223:		handle_platform_dump_error(librtas_rc, dump_err, 1024);
./rtas_errd/extract_platdump.c:224:		msg("%s\nThe platform dump header could not be "
./rtas_errd/extract_platdump.c:231:		msg("Platform dump with id: 0x%016LX is either invalid "
./rtas_errd/extract_platdump.c:258:	msg("Suggested filename: %s, prefix size: %d", filename, prefix_size);
./rtas_errd/extract_platdump.c:264:			msg("Could not create %s: %s.\nThe platform dump "
./rtas_errd/extract_platdump.c:267:				strerror(errno));
./rtas_errd/extract_platdump.c:283:	msg("Dump path/filename: %s", pathname);
./rtas_errd/extract_platdump.c:286:		msg("Could not open %s for writing: %s.\nThe platform dump "
./rtas_errd/extract_platdump.c:287:			"could not be retrieved", pathname, strerror(errno));
./rtas_errd/extract_platdump.c:294:		msg("Could not write to %s: %s.\nThe platform dump "
./rtas_errd/extract_platdump.c:295:			"could not be retrieved", pathname, strerror(errno));
./rtas_errd/extract_platdump.c:301:		msg("Calling rtas_platform_dump, seq 0x%016LX", seq);
./rtas_errd/extract_platdump.c:305:			handle_platform_dump_error(librtas_rc, dump_err, 1024);
./rtas_errd/extract_platdump.c:306:			msg("%s\nThe platform dump could not be "
./rtas_errd/extract_platdump.c:319:			msg("Could not write to %s: %s\nThe platform "
./rtas_errd/extract_platdump.c:321:				strerror(errno));
./rtas_errd/extract_platdump.c:331:	msg("Sigalling that the dump has been retrieved, seq 0x%016LX", seq);
./rtas_errd/extract_platdump.c:335:		handle_platform_dump_error(librtas_rc, dump_err, 1024);
./rtas_errd/extract_platdump.c:336:		msg("%s\nThe platform could not be notified to "
./rtas_errd/prrn.c:162:		perror(path);
./rtas_errd/prrn.c:273:		dbg("Failed to open %s: %s", OFDTPATH, strerror(errno));
./rtas_errd/prrn.c:587:		dbg("Failed PRRN Hotplug exec: %s", strerror(errno));
./rtas_errd/rtas_errd.h:112:void log_msg(struct event *, char *, ...);
./rtas_errd/diag_support.c:69:		perror("popen");
./rtas_errd/ela_msg.h:24:#define MSGMEMB12b5 "Memory Data error (Bad data going to memory)"
./rtas_errd/ela_msg.h:312:    "Memory Data error (Bad data going to memory)."
./rtas_errd/files.c:172:		log_msg(NULL, "Could not open scenario file %s, %s", 
./rtas_errd/files.c:173:			scenario_file, strerror(errno));
./rtas_errd/files.c:178:		log_msg(NULL, "Could not get status of scenario file %s, %s", 
./rtas_errd/files.c:179:			scenario_file, strerror(errno));	
./rtas_errd/files.c:186:		log_msg(NULL, "Could not allocate space for RTAS injection "
./rtas_errd/files.c:187:			"scenario, %s", strerror(errno));
./rtas_errd/files.c:206:		log_msg(NULL, "Could not allocate memory for scenario "
./rtas_errd/files.c:207:			"files, %s", strerror(errno));
./rtas_errd/files.c:265:		log_msg(NULL, "Could not open error log file at either %s or "
./rtas_errd/files.c:268:			strerror(errno));
./rtas_errd/files.c:276:		log_msg(NULL, "Could not open log file %s, %s\nThe daemon "
./rtas_errd/files.c:278:			strerror(errno));
./rtas_errd/files.c:347:			log_msg(NULL, "Cannot get status of test file %s, %s",
./rtas_errd/files.c:348:				proc_error_log1, strerror(errno));
./rtas_errd/files.c:355:			log_msg(NULL, "Cannot map test file %s, %s", 
./rtas_errd/files.c:356:				proc_error_log1, strerror(errno));
./rtas_errd/files.c:402:				log_msg(NULL, "Invalid test file");
./rtas_errd/files.c:416:					log_msg(NULL, "Could not open scenario "
./rtas_errd/files.c:418:						strerror(errno));
./rtas_errd/files.c:449:reformat_msg(char *msg)
./rtas_errd/files.c:527:_log_msg(struct event *event, const char *fmt, va_list ap)
./rtas_errd/files.c:568:	len = reformat_msg(buf);
./rtas_errd/files.c:595:			log_msg(NULL, "An error occured during the rotation of "
./rtas_errd/files.c:623:	_log_msg(NULL, fmt, ap);
./rtas_errd/files.c:636:log_msg(struct event *event, char *fmt, ...)
./rtas_errd/files.c:641:	_log_msg(event, fmt, ap);
./rtas_errd/files.c:673:	len = reformat_msg(buf);
./rtas_errd/files.c:725:		log_msg(NULL, "Could not allocate buffer to print RTAS event "
./rtas_errd/files.c:727:			event->seq_num, strerror(errno),
./rtas_errd/files.c:768:		log_msg(NULL, "Writing RTAS event %d to %s failed."
./rtas_errd/files.c:771:			strerror(errno));
./rtas_errd/files.c:828:			log_msg(NULL, "Could not open EPOW status file %s, %s",
./rtas_errd/files.c:829:				epow_status_file, strerror(errno));
./rtas_errd/files.c:835:		log_msg(NULL, "Could not seek in EPOW status file %s, %s",
./rtas_errd/files.c:836:			epow_status_file, strerror(errno));
./rtas_errd/files.c:842:		log_msg(NULL, "Could not write data to EPOW status file %s, %s",
./rtas_errd/files.c:843:			epow_status_file, strerror(errno));
./rtas_errd/files.c:848:		log_msg(NULL, "Could not write data to EPOW status file %s, %s",
./rtas_errd/files.c:849:			epow_status_file, strerror(errno));
./rtas_errd/le/rtas_errd.c:124:		log_msg(event, "Could not write RTAS event %d to log file %s", 
./rtas_errd/le/rtas_errd.c:126:		log_msg(event, "Rtas_errd is exiting to preserve the current "
./rtas_errd/le/rtas_errd.c:179:		log_msg(event, "Could not retrieve extended event data");
./rtas_errd/le/rtas_errd.c:244:				log_msg(NULL, "Could not read error log file");
./rtas_errd/le/rtas_errd.c:254:			log_msg(&event, "Could not parse RTAS event");
./rtas_errd/le/rtas_errd.c:260:			log_msg(&event, "Could not retrieve event header");
./rtas_errd/le/rtas_errd.c:452:	 * rtas_set_debug(1) if debug level >= 2,
./rtas_errd/le/rtas_errd.c:453:	 * rtas_set_debug(2) if debug level >= 3, ...
./rtas_errd/le/rtas_errd.c:456:		rtas_set_debug(debug - 1);
./rtas_errd/le/rtas_errd.c:471:		log_msg(NULL, "Could not initialize signal handler for "
./rtas_errd/le/rtas_errd.c:472:			"certian EPOW events (SIGALRM), %s", strerror(errno));
./rtas_errd/le/rtas_errd.c:481:		log_msg(NULL, "Could not initialize signal handler for "
./rtas_errd/le/rtas_errd.c:483:			strerror(errno));
./rtas_errd/le/rtas_errd.c:491:		log_msg(NULL, "Cannot ignore SIGPIPE, %s", strerror(errno));
./rtas_errd/le/rtas_errd.c:505:		log_msg(NULL, "Could not open the servicelog database, events "
./rtas_errd/le/rtas_errd.c:507:			strerror(rc));
./rtas_errd/le/rtas_errd.c:521:		log_msg(NULL, "Librtas returned an error code: %d"
./rtas_errd/le/rtas_errd.c:540:	log_msg(NULL, "The rtas_errd daemon is exiting");
./rtas_errd/le/signal.c:70:			log_msg(NULL, "Could not restore SIGCHLD signal "
./rtas_errd/le/signal.c:72:				strerror(errno));
./rtas_errd/le/signal.c:92:		log_msg(NULL, "Could not initialize signal handler for"
./rtas_errd/le/signal.c:93:			"cleaning up child processes, %s", strerror(errno));
./rtas_errd/le/rtas_errd.h:112:void log_msg(struct event *, char *, ...);
./rtas_errd/le/config.c:310:		d_cfg.log_msg("Parsing error for configuration file "
./rtas_errd/le/config.c:318:		d_cfg.log_msg("Invalid parameter (%d) specified for the "
./rtas_errd/le/config.c:336:		d_cfg.log_msg("Configuring the Auto Restart Policy to %d",
./rtas_errd/le/config.c:340:		d_cfg.log_msg("Hardware error while attempting to set the "
./rtas_errd/le/config.c:349:		d_cfg.log_msg("Not authorized to set the Auto Restart Policy "
./rtas_errd/le/config.c:353:		d_cfg.log_msg("Parameter error setting the Auto Restart Policy "
./rtas_errd/le/config.c:357:		d_cfg.log_msg("Unknown error (%d) setting the Auto Restart "
./rtas_errd/le/config.c:366:		d_cfg.log_msg("Could not configure the Auto Restart Policy "
./rtas_errd/le/config.c:378:		d_cfg.log_msg("The current system does not support the "
./rtas_errd/le/config.c:390:		d_cfg.log_msg("The Auto Restart Policy could not be configured "
./rtas_errd/le/config.c:397:	d_cfg.log_msg("Configuring the Auto Restart Policy to %d (in NVRAM)",
./rtas_errd/le/config.c:426:			d_cfg.log_msg("Parsing error in configuration "
./rtas_errd/le/config.c:442:				d_cfg.log_msg("Parsing error for "
./rtas_errd/le/config.c:450:				d_cfg.log_msg("Configuring Minimum "
./rtas_errd/le/config.c:461:				d_cfg.log_msg("Parsing error for "
./rtas_errd/le/config.c:469:				d_cfg.log_msg("Configuring Minimum "
./rtas_errd/le/config.c:482:				d_cfg.log_msg("Parsing error for "
./rtas_errd/le/config.c:497:			d_cfg.log_msg("Configuring Scanlog Dump Path to "
./rtas_errd/le/config.c:509:				d_cfg.log_msg("Parsing error for "
./rtas_errd/le/config.c:524:			d_cfg.log_msg("Configuring Platform Dump Path to "
./rtas_errd/le/config.c:538:			d_cfg.log_msg("Configuration error: \"%s\", line %d, "
./rtas_errd/le/config.c:590:		d_cfg.log_msg("Could not open the ppc64-diag configuration "
./rtas_errd/le/config.c:591:			      "file \"%s\", %s", config_file, strerror(errno));
./rtas_errd/le/config.c:596:		d_cfg.log_msg("Could not get status of the ppc64-diag "
./rtas_errd/le/config.c:599:			      "settings", config_file, strerror(errno));
./rtas_errd/le/config.c:612:		d_cfg.log_msg("Could not map ppc64-diag configuration file "
./rtas_errd/le/config.c:615:			      config_file, strerror(errno));
./rtas_errd/le/config.c:624:		d_cfg.log_msg("Due to an error parsing the ppc64-diag "
./rtas_errd/epow.c:111:	log_msg(event, buf);
./rtas_errd/epow.c:178:		log_msg(event, "Could not retrieve EPOW section to handle "
./rtas_errd/epow.c:398:			log_msg(event, "Fork error, %s cannot be run to handle"
./rtas_errd/epow.c:400:				strerror(errno));
./rtas_errd/epow.c:407:			log_msg(event, "Could not exec %s, %s.  Could not "
./rtas_errd/epow.c:409:				strerror(errno));
./rtas_errd/config.c:310:		d_cfg.log_msg("Parsing error for configuration file "
./rtas_errd/config.c:318:		d_cfg.log_msg("Invalid parameter (%d) specified for the "
./rtas_errd/config.c:336:		d_cfg.log_msg("Configuring the Auto Restart Policy to %d",
./rtas_errd/config.c:340:		d_cfg.log_msg("Hardware error while attempting to set the "
./rtas_errd/config.c:349:		d_cfg.log_msg("Not authorized to set the Auto Restart Policy "
./rtas_errd/config.c:353:		d_cfg.log_msg("Parameter error setting the Auto Restart Policy "
./rtas_errd/config.c:357:		d_cfg.log_msg("Unknown error (%d) setting the Auto Restart "
./rtas_errd/config.c:366:		d_cfg.log_msg("Could not configure the Auto Restart Policy "
./rtas_errd/config.c:378:		d_cfg.log_msg("The current system does not support the "
./rtas_errd/config.c:390:		d_cfg.log_msg("The Auto Restart Policy could not be configured "
./rtas_errd/config.c:397:	d_cfg.log_msg("Configuring the Auto Restart Policy to %d (in NVRAM)",
./rtas_errd/config.c:426:			d_cfg.log_msg("Parsing error in configuration "
./rtas_errd/config.c:442:				d_cfg.log_msg("Parsing error for "
./rtas_errd/config.c:450:				d_cfg.log_msg("Configuring Minimum "
./rtas_errd/config.c:461:				d_cfg.log_msg("Parsing error for "
./rtas_errd/config.c:469:				d_cfg.log_msg("Configuring Minimum "
./rtas_errd/config.c:482:				d_cfg.log_msg("Parsing error for "
./rtas_errd/config.c:497:			d_cfg.log_msg("Configuring Scanlog Dump Path to "
./rtas_errd/config.c:509:				d_cfg.log_msg("Parsing error for "
./rtas_errd/config.c:524:			d_cfg.log_msg("Configuring Platform Dump Path to "
./rtas_errd/config.c:538:			d_cfg.log_msg("Configuration error: \"%s\", line %d, "
./rtas_errd/config.c:590:		d_cfg.log_msg("Could not open the ppc64-diag configuration "
./rtas_errd/config.c:591:			      "file \"%s\", %s", config_file, strerror(errno));
./rtas_errd/config.c:596:		d_cfg.log_msg("Could not get status of the ppc64-diag "
./rtas_errd/config.c:599:			      "settings", config_file, strerror(errno));
./rtas_errd/config.c:612:		d_cfg.log_msg("Could not map ppc64-diag configuration file "
./rtas_errd/config.c:615:			      config_file, strerror(errno));
./rtas_errd/config.c:624:		d_cfg.log_msg("Due to an error parsing the ppc64-diag "
./rtas_errd/update.c:212:		log_msg(NULL, "Could not open %s to update RTAS events, %s",
./rtas_errd/update.c:213:			messages_log, strerror(errno));
./rtas_errd/update.c:218:		log_msg(NULL, "Cannot get status of %s to update RTAS events, "
./rtas_errd/update.c:219:			"%s", messages_log, strerror(errno));
./rtas_errd/update.c:230:		log_msg(NULL, "Cannot map %s to update RTAS events", 
./rtas_errd/update.c:240:		log_msg(NULL, "Cannot get status of %s to update RTAS events",
./rtas_errd/update.c:251:		log_msg(NULL, "Cannot map %s to update RTAS events, %s", 
./rtas_errd/update.c:252:			platform_log, strerror(errno));
./rtas_errd/update.c:364:			log_msg(NULL, "Could not update RTAS Event %d to %s", 
./rtas_errd/update.c:367:			log_msg(NULL, "Updating RTAS event %d to %s", 
./rtas_errd/guard.c:71:		log_msg(NULL, "We should not reach this code path "
./rtas_errd/guard.c:93:		log_msg(NULL, "%s cannot be run to handle a predictive CPU "
./rtas_errd/guard.c:94:			"failure, %s", DRMGR_PROGRAM, strerror(errno));
./rtas_errd/guard.c:102:		log_msg(NULL, "Could not exec %s to in response to a "
./rtas_errd/guard.c:104:			strerror(errno));
./rtas_errd/guard.c:146:				log_msg(NULL, "Could not open %s, %s",
./rtas_errd/guard.c:147:					buffer, strerror(errno));
./rtas_errd/guard.c:192:		log_msg(event, "The command \"%s\" does not exist, %s",
./rtas_errd/guard.c:193:			CONVERT_DT_PROPS_PROGRAM, strerror(errno));
./rtas_errd/guard.c:220:			log_msg(event, "Cannot obtain the drc-name for the "
./rtas_errd/guard.c:222:				CONVERT_DT_PROPS_PROGRAM, strerror(errno));
./rtas_errd/guard.c:225:			log_msg(event, "Cannot obtain the drc-name for the "
./rtas_errd/guard.c:227:				CONVERT_DT_PROPS_PROGRAM, strerror(errno));
./rtas_errd/guard.c:235:		log_msg(event, "Cannot obtain the drc-name for the "
./rtas_errd/guard.c:253:		log_msg(event, "Cannot obtain the drc-name for the "
./rtas_errd/guard.c:277:		log_msg(NULL, "Could not open /proc/ppc64/lparcfg, %s",
./rtas_errd/guard.c:278:			strerror(errno));
./rtas_errd/guard.c:286:				log_msg(NULL, "Could not retrieve the value "
./rtas_errd/guard.c:298:	log_msg(NULL, "Could not find the parameter %s in /proc/ppc64/lparcfg",
./rtas_errd/guard.c:322:		log_msg(event, "A CPU could not be guarded off in "
./rtas_errd/guard.c:331:		log_msg(event, "A request was received to deallocate a "
./rtas_errd/guard.c:338:		log_msg(event, "A request was received to deallocate a "
./rtas_errd/guard.c:347:	log_msg(event, "The following CPU has been offlined due to the "
./rtas_errd/guard.c:387:		log_msg(event, "A request was received to deallocate "
./rtas_errd/guard.c:403:		log_msg(event, "A request was received to deallocate "
./rtas_errd/guard.c:421:	log_msg(event, "Entitled capacity in the amount of %d has been "
./rtas_errd/guard.c:451:	log_msg(event, "A request was received to deallocate a memory page, "
./rtas_errd/guard.c:475:		log_msg(event, "A request was received to deallocate a "
./rtas_errd/guard.c:483:		log_msg(event, "A LMB could not be guarded off in "
./rtas_errd/guard.c:490:	log_msg(event, "The following LMB has been offlined due to the "
./rtas_errd/guard.c:543:			log_msg(event, "Could not retrieve CPU section to "
./rtas_errd/guard.c:559:				log_msg(event, "Could not retrieve a Logical "
./lpd/lp_util.c:69:		log_msg("Unable to retrieve the vpd for \"%s\". "
./lpd/lp_util.c:139:			log_msg("Unable to open directory : %s", path);
./lpd/lp_util.c:158:			log_msg("Out of memory");
./lpd/servicelog.c:40:		log_msg("Error opening servicelog db: %s", strerror(rc));
./lpd/servicelog.c:46:		log_msg("Error reading servicelog db :%s",
./lpd/servicelog.c:47:			servicelog_error(slog));
./lpd/indicator_ses.c:75:			log_msg("Unable to open directory : %s", path);
./lpd/indicator_ses.c:233:		log_msg("Unable to get enclosure indicator list. "
./lpd/indicator_ses.c:260:			log_msg("Out of memory");
./lpd/indicator_ses.c:367:		log_msg("Unable to get enclosure LED status. "
./lpd/lp_diag.h:107:void log_msg(const char *, ...);
./lpd/files.c:49:reformat_msg(char *msg, int size)
./lpd/files.c:166:log_msg(const char *fmt, ...)
./lpd/files.c:202:	len = reformat_msg(buf, LP_ERROR_LOG_MAX);
./lpd/files.c:226:		log_msg("Indicator event log file \"%s\" is not available",
./lpd/files.c:240:		log_msg("Insufficient buffer size");
./lpd/files.c:250:		log_msg("Write to indicator event log file \"%s\" failed",
./lpd/files.c:322:		log_msg("Could not open indicator event log file \"%s\"",
./lpd/indicator_rtas.c:58:			log_msg("Out of memory");
./lpd/indicator_rtas.c:107:librtas_error(int error, char *buf, size_t size)
./lpd/indicator_rtas.c:174:			log_msg("Hardware error retrieving indicator indices");
./lpd/indicator_rtas.c:182:			librtas_error(rc, err_buf, RTAS_ERROR_BUF_SIZE);
./lpd/indicator_rtas.c:185:			log_msg("The %s indicators are not supported "
./lpd/indicator_rtas.c:189:				log_msg(",\n%s", err_buf);
./lpd/indicator_rtas.c:199:			librtas_error(rc, err_buf, RTAS_ERROR_BUF_SIZE);
./lpd/indicator_rtas.c:200:			log_msg("Could not retrieve data for %s "
./lpd/indicator_rtas.c:242:		log_msg("Hardware error retrieving the indicator at %s",
./lpd/indicator_rtas.c:246:		log_msg("Busy while retrieving indicator at %s. "
./lpd/indicator_rtas.c:250:		log_msg("The indicator at %s is not implemented", loc->code);
./lpd/indicator_rtas.c:253:		librtas_error(rc, err_buf, RTAS_ERROR_BUF_SIZE);
./lpd/indicator_rtas.c:255:		log_msg("Could not get %ssensor %s indicators,\n%s",
./lpd/indicator_rtas.c:293:		log_msg("Hardware error while setting the indicator at %s",
./lpd/indicator_rtas.c:297:		log_msg("Busy while setting the indicator at %s. "
./lpd/indicator_rtas.c:301:		log_msg("The indicator at %s is not implemented", loc->code);
./lpd/indicator_rtas.c:304:		librtas_error(rc, err_buf, RTAS_ERROR_BUF_SIZE);
./lpd/indicator_rtas.c:306:		log_msg("Could not set %ssensor %s indicators,\n%s",
./lpd/lp_diag.c:149:			log_msg("Unsupported device driver : %s", os->driver);
./lpd/lp_diag.c:157:			log_msg("Unsupported Enclosure model : %s",
./lpd/lp_diag.c:285:				log_msg("Out of memory");
./lpd/lp_diag.c:402:	log_msg("Service event ID = %d", event_id);
./lpd/lp_diag.c:410:		log_msg("Unable to read service event");
./lpd/lp_diag.c:424:		log_msg("Unable to retrieve fault indicators");
./lpd/lp_diag.c:450:		log_msg("Guiding Light mode");
./lpd/lp_diag.c:455:		log_msg("Unable to enable fault indicator");
./lpd/lp_diag.c:498:	log_msg("Repair event ID = %d", repair_id);
./lpd/lp_diag.c:509:		log_msg("Repair event %d did not close any service event(s)",
./lpd/lp_diag.c:523:		log_msg("Unable to retrieve fault indicators");
./lpd/lp_diag.c:567:		log_msg("Guiding Light mode");
./lpd/lp_diag.c:574:		log_msg("Unable to disable fault indicator");
./lpd/lp_diag.c:927:		log_msg("Out of memory");
./lpd/lp_diag.c:1086:		log_msg("Unable to get system attention indicator");
./lpd/lp_diag.c:1091:		log_msg("Unable to get identify indicators");
./lpd/lp_diag.c:1231:		log_msg("Starting LPD UI");
./lpd/lp_diag.c:1236:		log_msg("Service event analysis");
./lpd/lp_diag.c:1241:		log_msg("Repair event analysis");
./lpd/lp_diag.c:1246:	log_msg("%s exiting", program_name);
./diags/test/bh_dump_pg2.c:112:		perror(dev_sg);
./diags/test/bh_dump_pg2.c:117:		perror("get_diagnostic_page");
./diags/test/test_utils.c:114:		perror(path);
./diags/test/test_utils.c:118:		perror(path);
./diags/test/bh_vpd.c:117:		perror(dev_sg);
./diags/test/bh_vpd.c:124:		perror("get_vpd_page");
./diags/test/bh_vpd.c:136:		perror("get_vpd_page");
./diags/test/bh_vpd.c:149:		perror("get_vpd_page");
./diags/bluehawk.c:54:			perror(path);
./diags/bluehawk.c:58:		perror(path);
./diags/bluehawk.c:73:		perror(path);
./diags/bluehawk.c:77:		perror(path);
./diags/bluehawk.c:868:			perror("ioctl - SEND_DIAGNOSTIC");
./diags/encl_led.c:69:		perror(dev_sg);
./diags/diag_encl.c:248:		fprintf(stderr, "%s", servicelog_error(slog));
./diags/diag_encl.c:257:		fprintf(stderr, "%s", servicelog_error(slog));
./diags/diag_encl.c:283:		perror(vpd_path);
./diags/diag_encl.c:356:		perror(devsg);
./opal-dump-parse/opal-dump-parse.c:195:			"\"%s\", %s.\n", dump_path, strerror(errno));
./opal-dump-parse/opal-dump-parse.c:203:			"\"%s\", %s.\n", dump_path, strerror(errno));
./opal-dump-parse/opal-dump-parse.c:210:                       "\"%s\", %s.\n", opt_output_file, strerror(errno));
./opal-dump-parse/opal-dump-parse.c:373:			" file \"%s\", %s.\n", dump_file, strerror(errno));
./opal-dump-parse/opal-dump-parse.c:382:			"\"%s\", %s.\n", dump_file, strerror(errno));
./opal-dump-parse/opal-dump-parse.c:389:				  "\"%s\", %s.\n", dump_file, strerror(errno));

== environment() ==

== privileged() ==
./rtas_errd/dump.c:191:	chmod(scanlog_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
./diags/test/bh_dump_pg2.c:34: * @brief Make the necessary sg ioctl() to retrieve a diagnostic page
./diags/test/bh_dump_pg2.c:74:		rc = ioctl(fd, SG_IO, &hdr);
./diags/test/bh_vpd.c:32: * @brief Make the necessary sg ioctl() to retrieve a VPD page
./diags/test/bh_vpd.c:72:		rc = ioctl(fd, SG_IO, &hdr);
./diags/encl_util.c:33: * @brief Make the necessary sg ioctl() to do the indicated SES command
./diags/encl_util.c:79:		rc = ioctl(fd, SG_IO, &hdr);

== networking() ==
./ela/syslog_to_svclog.cpp:182:	nbytes = read(fd, buf, bufsz);
./ela/syslog_to_svclog.cpp:517:safe_overwrite(const string& data, const string& path, const string& path_bak)
./ela/syslog_to_svclog.cpp:557:		safe_overwrite(msg, LAST_EVENT_PATH, LAST_EVENT_PATH_BAK);
./opal_errd/opal-elog-parse/opal-elog-parse.c:180:		readsz = read(platform_log_fd, *buf, bufsz);
./opal_errd/opal_errd.c:362:	rc = write(fd, "ack\n", 4);
./opal_errd/opal_errd.c:418:		readsz = read(in_fd, buf+sz, bufsz-sz);
./opal_errd/opal_errd.c:446:	sz = write(out_fd, buf, bufsz);
./opal_errd/opal_errd.c:832:				read(fds[INOTIFY_FD].fd, inotifybuf, sizeof(inotifybuf));
./opal_errd/extract_opal_dump.c:89:	rc = write(fd, "ack\n", 4);
./opal_errd/extract_opal_dump.c:240:		readsz = read(in_fd, buf+sz, bufsz-sz);
./opal_errd/extract_opal_dump.c:266:	sz = write(out_fd, buf, bufsz);
./rtas_errd/rtas_errd.c:202:		platform_log_write("Event %d has already been reported, for "
./rtas_errd/rtas_errd.c:204:		platform_log_write("the previous report of this error or the"
./rtas_errd/rtas_errd.c:209:		platform_log_write("Event %d is a recovered error "
./rtas_errd/rtas_errd.c:212:		platform_log_write("available in the servicelog.\n");
./rtas_errd/dump.c:178:	while ((bytes = read(in, dump_buf, DUMP_BUF_SZ)) > 0) {
./rtas_errd/dump.c:179:		rc = write(out, dump_buf, bytes);
./rtas_errd/dump.c:304:	platform_log_write("Platform Dump Notification\n");
./rtas_errd/dump.c:305:	platform_log_write("    Dump Location: %s\n", pathname);
./rtas_errd/eeh.c:83:	platform_log_write("EEH Event Notification\n");
./rtas_errd/eeh.c:89:		platform_log_write("Could not retrieve RTAS Event Date/Time\n");
./rtas_errd/eeh.c:91:		platform_log_write("%02x/%02x/%04x  %02x:%02x:%02x\n", 
./rtas_errd/eeh.c:98:	platform_log_write("Event SRC Code: %s\n", 
./rtas_errd/eeh.c:100:	platform_log_write("    %s\n", event_descs[index].desc);
./rtas_errd/eeh.c:105:		platform_log_write("    Device Location Code: %s\n", 
./rtas_errd/eeh.c:112:		platform_log_write("    No Device Location Code provided.\n");
./rtas_errd/extract_platdump.c:292:	rc = write(out, dump_buf, (size_t)bytes);
./rtas_errd/extract_platdump.c:317:		rc = write(out, dump_buf, (size_t)bytes);
./rtas_errd/prrn.c:49:		return write(prrn_log_fd, buf, len);
./rtas_errd/prrn.c:90:	rc = fread(&drc_index, sizeof(drc_index), 1, fp);
./rtas_errd/prrn.c:178:		if (fread(&phandle, sizeof(phandle), 1, fd) != 1) {
./rtas_errd/prrn.c:227:	fread(membuf, sbuf.st_size, 1, fd);
./rtas_errd/prrn.c:278:	if ((rc = write(fd, cmd, len)) != len)
./rtas_errd/rtas_errd.h:118:int platform_log_write(char *, ...);
./rtas_errd/diag_support.c:104:lsvpd_read(struct event *event, FILE *fp)
./rtas_errd/diag_support.c:208:		if (lsvpd_read(event, fp)) {
./rtas_errd/files.c:192:	len = read(fd, scenario_buf, sbuf.st_size);
./rtas_errd/files.c:432:		len = read(proc_error_log_fd, buf, buflen);
./rtas_errd/files.c:570:	rc = write(rtas_errd_log_fd, buf, len);
./rtas_errd/files.c:766:	rc = write(platform_log_fd, out_buf, offset);
./rtas_errd/files.c:788: * @return return code from write() call
./rtas_errd/files.c:791:platform_log_write(char *fmt, ...)
./rtas_errd/files.c:803:	rc = write(platform_log_fd, &buf, len);
./rtas_errd/files.c:847:        if (write(epow_status_fd, buf, size) < size) {
./rtas_errd/le/rtas_errd.c:202:		platform_log_write("Event %d has already been reported, for "
./rtas_errd/le/rtas_errd.c:204:		platform_log_write("the previous report of this error or the"
./rtas_errd/le/rtas_errd.c:209:		platform_log_write("Event %d is a recovered error "
./rtas_errd/le/rtas_errd.c:212:		platform_log_write("available in the servicelog.\n");
./rtas_errd/le/rtas_errd.h:118:int platform_log_write(char *, ...);
./rtas_errd/guard.c:150:			if ((read(fd, state, 6)) != 0 ) {
./rtas_errd/guard.c:233:	rc = fread(buffer, 1, bufsize, fp);
./rtas_errd/guard.c:350:	platform_log_write("CPU Deallocation Notification\n");
./rtas_errd/guard.c:351:	platform_log_write("(resulting from a predictive CPU failure)\n");
./rtas_errd/guard.c:352:	platform_log_write("    Logical ID: %d\n", cpu_id);
./rtas_errd/guard.c:353:	platform_log_write("    drc-name:   %s\n", drc_name);
./rtas_errd/guard.c:407:		platform_log_write("CPU Deallocation Notification\n");
./rtas_errd/guard.c:408:		platform_log_write("(resulting from a predictive CPU "
./rtas_errd/guard.c:410:		platform_log_write("    number of virtual CPUs "
./rtas_errd/guard.c:412:		platform_log_write("    number of virtual CPUs "
./rtas_errd/guard.c:424:	platform_log_write("Entitled Capacity Deallocation "
./rtas_errd/guard.c:426:	platform_log_write("(resulting from a predictive CPU failure)\n");
./rtas_errd/guard.c:427:	platform_log_write("    entitled capacity units offlined:  "
./rtas_errd/guard.c:429:	platform_log_write("    entitled capacity units remaining: "
./rtas_errd/guard.c:494:	platform_log_write("MEM Deallocation Notification\n");
./rtas_errd/guard.c:495:	platform_log_write("(resulting from a predictive MEM failure)\n");
./rtas_errd/guard.c:496:	platform_log_write("    Logical ID: 0x%08x\n", drc_index);
./rtas_errd/guard.c:497:	platform_log_write("    drc-name:   %s\n", drc_name);
./rtas_errd/convert_dt_node_props.c:71:	read(fd, &index, 4);
./rtas_errd/convert_dt_node_props.c:73:	while ((read(fd, &index, 4)) != 0) {
./rtas_errd/convert_dt_node_props.c:91:		read(fd, &index, 4);
./rtas_errd/convert_dt_node_props.c:96:				if ((read(fd, &ch, 1)) != 1) {
./rtas_errd/convert_dt_node_props.c:105:		while ((read(fd, &ch, 1)) == 1) {
./rtas_errd/convert_dt_node_props.c:358:			while ((read(fd, &temp, 4)) != 0) {
./rtas_errd/convert_dt_node_props.c:369:					if ((read(fd, &temp, 4)) == 4)  {
./rtas_errd/convert_dt_node_props.c:400:	read(fd, &index, 4);
./rtas_errd/convert_dt_node_props.c:402:	while ((read(fd, &index, 4)) != 0) {
./rtas_errd/convert_dt_node_props.c:420:		read(fd, &index, 4);
./rtas_errd/convert_dt_node_props.c:425:				if ((read(fd, &ch, 1)) != 1) {
./rtas_errd/convert_dt_node_props.c:434:		while ((read(fd, &ch, 1)) == 1) {
./rtas_errd/convert_dt_node_props.c:470:			while ((read(drc_fd, &temp, 4)) != 0) {
./rtas_errd/convert_dt_node_props.c:483:						(read(intr_fd, &temp, 4)) == 4)
./rtas_errd/convert_dt_node_props.c:511:	read(fd, &index, 4);
./rtas_errd/convert_dt_node_props.c:515:		while ((rc = read(fd, &ch, 1)) == 1) {
./rtas_errd/convert_dt_node_props.c:546:		if ((read(fd, &index, 4)) == 4)
./lpd/usysident.c:41:		indicator_log_write("System Attention Indicator : %s", \
./lpd/usysident.c:44:		indicator_log_write("%s : %s : %s", loc, \
./lpd/usysident.c:409:		indicator_log_write("All %s Indicators : %s",
./lpd/test/ledtool.c:54:			indicator_log_write("System Attention Indicator : ON");
./lpd/test/ledtool.c:56:			indicator_log_write("%s : Fault : ON", loc_led->code);
./lpd/lp_diag.h:108:int indicator_log_write(const char *, ...);
./lpd/files.c:203:	rc = write(lp_error_log_fd, buf, len);
./lpd/files.c:215: *	return code from write() call
./lpd/files.c:218:indicator_log_write(const char *fmt, ...)
./lpd/files.c:248:	rc = write(lp_event_log_fd, buf, len);
./lpd/lp_diag.c:86:			indicator_log_write("System Attention Indicator :"
./lpd/lp_diag.c:90:			indicator_log_write("System Attention Indicator : %s",
./lpd/lp_diag.c:117:			indicator_log_write("%s : Unable to %s fault indicator",
./lpd/lp_diag.c:121:			indicator_log_write("%s : Fault : %s", loc->code,
./lpd/lp_diag.c:327:			indicator_log_write("Empty location code in callout");
./lpd/lp_diag.c:337:			indicator_log_write("%s does not have fault indicator",
./lpd/lp_diag.c:339:			indicator_log_write("Could not truncate and get "
./lpd/lp_diag.c:345:			indicator_log_write("%s does not have fault indicator",
./lpd/lp_diag.c:347:			indicator_log_write("Truncated location : %s",
./lpd/lp_diag.c:376:		indicator_log_write("%s does not have fault indicator",
./lpd/lp_diag.c:419:	indicator_log_write("---- Service event begin ----");
./lpd/lp_diag.c:425:		indicator_log_write("Unable to retrieve fault indicators");
./lpd/lp_diag.c:443:			indicator_log_write("Empty callout list");
./lpd/lp_diag.c:461:	indicator_log_write(SERVICELOG_EVENT_CMD, event_id);
./lpd/lp_diag.c:462:	indicator_log_write("---- Service event end ----");
./lpd/lp_diag.c:518:	indicator_log_write("---- Repair event begin ----");
./lpd/lp_diag.c:580:	indicator_log_write(SERVICELOG_REPAIR_CMD, repair_id);
./lpd/lp_diag.c:581:	indicator_log_write("---- Repair event end ----");
./lpd/lp_diag.c:777:				indicator_log_write("%s : Identify : %s",
./diags/test/test_utils.c:117:	if (fwrite(pg, sizeof(*pg), 1, f) != 1) {
./diags/bluehawk.c:57:	if (fread(pg, sizeof(*pg), 1, f) != 1) {
./diags/bluehawk.c:76:	if (fwrite(pg, sizeof(*pg), 1, f) != 1) {
./opal-dump-parse/opal-dump-parse.c:199:	sz = write(fd, data + skiboot_start, size);

== http:// ==

== encryption ==

== sql() ==
./lpd/servicelog.c:44:	rc = servicelog_event_query(slog, query, event);

== tmp() ==
./rtas_errd/diag_support.c:233:	char command[]="/usr/bin/find /proc/device-tree -name status -print > /tmp/get_dt_files";
./rtas_errd/diag_support.c:241:	fp1 = fopen("/tmp/get_dt_files", "r");
./rtas_errd/diag_support.c:243:		fprintf(stderr, "open failed on /tmp/get_dt_files\n");
./rtas_errd/diag_support.c:248:		dbg("read from /tmp/get_dt_files, \"%s\"", loc_file);

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./opal_errd/opal-elog-parse/opal-src-fru-scn.c:278:	/* FIXME This printing was to roughly confirm the correctness
./opal_errd/opal-elog-parse/opal-priv-hdr-scn.c:49:	// FIXME: are these ASCII? Need spec clarification
./opal_errd/opal-elog-parse/opal-ud-scn.c:37:	/*FIXME this data should be parsable if documentation appears/exists
./lpd/indicator_ses.c:32: * TODO: This adjustment is appropriate for Bluehawks.  Need to understand
./diags/bluehawk.c:554: * TODO: Figure out how to get VPD for the other warhawk by inquiring via a
./diags/encl_util.c:142: * TODO: This adjustment is appropriate for Bluehawks.  Need to understand

== unsafe input mechanisms ==

