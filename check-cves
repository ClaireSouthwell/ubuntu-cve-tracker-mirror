#!/usr/bin/python

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# (C) 2005-2007 Canonical. Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader
import shutil, subprocess
import optparse, configobj

# load settings, if any
rcfile = os.path.expanduser('~/.check-cves.rc')
if not os.path.exists(rcfile):
    file(rcfile, 'w').write('# Empty config file for check-cves\n')
config = configobj.ConfigObj(rcfile)

parser = optparse.OptionParser()
parser.add_option("-r", "--report", help="Just report CVEs that need checking", action="store_true")
parser.add_option("-k", "--known", help="Only report CVEs already known", action="store_true")
(opt, args) = parser.parse_args()

destdir = "."

# settings for automatic CVE database evaluation
cvexml_url="http://cve.mitre.org/cve/downloads/allitems.xml"

ignore_strings = ["** REJECT **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS",
    "Apple QuickTime", "Cisco", "ActiveX"]

# load embargoed items
EmbargoList = []
if os.path.islink(destdir + '/embargoed'):
    EmbargoList += [cve for cve in os.listdir(destdir + "/embargoed/") if cve.startswith('CVE-') or cve.startswith('EMB-')]

###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def subtract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)

###################

def get_archive_map(rootdir, cachefile = None):
    """Generate a archive map from a Debian-style package archive directory.

    rootdir: path to archive root path
    cachefile: path to a cache file (created if not existing)
    return: mapping: package -> release -> (component, version, path)
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}
    currpkg = None
    currversion = None
    currdir = None

    for release in os.listdir(rootdir + "/dists"):
        if release.split('-')[0] in obsolete_releases:
            continue
        for comp in os.listdir(rootdir + "/dists/" + release):
            compdir = rootdir + "/dists/" + release + "/" + comp
            if not os.path.isdir(compdir):
                continue
            srcfile = compdir + "/source/Sources.gz"
            if not os.path.exists(srcfile):
                print >> sys.stderr, 'ERROR: Sources file %s does not exist, ignoring' % srcfile
                continue
            #print >> sys.stderr, "Scanning", srcfile

            for line in gzip.open(srcfile):
                line = line.strip()
                if not line:
                    if (not currpkg) or (not currversion) or (not currdir):
                        print >> sys.stderr, "Error: end of package record without all data available"
                        sys.exit(1)
                    map.setdefault(currpkg, {})[release] = (comp, currversion, currdir)
                    currpkg = None
                    currversion = None
                    currdir = None
                    continue

                attr = line.split(":", 1)

                if len(attr) < 2:
                    continue

                if attr[0] == "Package":
                    if currpkg:
                        print >> sys.stderr, "Error: read two Packages: lines in a row"
                        sys.exit(1)
                    currpkg = attr[1].strip()

                if attr[0] == "Version":
                    if currversion:
                        print >> sys.stderr, "Error: read two Version: lines in a row"
                        sys.exit(1)
                    currversion = attr[1].strip()
                    # remove epochs
                    colpos = currversion.find(':')
                    if colpos >= 0:
                        currversion = currversion[colpos+1:]

                if attr[0] == "Directory":
                    if currdir:
                        print >> sys.stderr, "Error: read two Directory: lines in a row"
                        sys.exit(1)
                    currdir = attr[1].strip()

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def parse_CVEs(url):
    """Return a list of all CVE numbers mentioned in the given URL."""

    list = []
    cvere = re.compile("((?:CAN|can|CVE|cve)-\d\d\d\d-\d\d\d\d)")
    try:
        text = cache_urllib.urlopen(url).read().splitlines()
        for line in text:
            comment = line.find('#')
            if comment != -1:
                line = line[:comment]
            for cve in cvere.finditer(line):
                list.append(cve.group().upper().replace('CAN', 'CVE', 1))
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

###################

def wordwrap(text, width):
    """
    A word-wrap function that preserves existing line breaks
    and most spaces in the text. Expects that existing line
    breaks are posix newlines (\n).
    """
    return reduce(lambda line, word, width=width: '%s%s%s' %
                  (line,
                   ' \n'[(len(line)-line.rfind('\n')-1
                         + len(word.split('\n',1)[0]
                              ) >= width)],
                   word),
                  text.split(' ')
                 )

def add_CVE_to_tracker(cve, desc, package):
    src = '%s/active/00boilerplate'%(destdir)
    if os.path.exists(src + "." + package):
        src = src + "." + package
    dst = '%s/active/%s'%(destdir,cve)
    template = file(src).readlines()
    cve_file = file(dst,'w')
    for line in template:
        line = line.rstrip()
        if line.startswith('Candidate:'):
            print >>cve_file, 'Candidate: %s'%(cve)
        elif line.startswith('References:'):
            print >>cve_file, 'References:\n http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s'%(cve)
        elif not line.startswith('#'):
            print >>cve_file, line

        if line.startswith('Description:'):
            for desc_line in wordwrap(desc,75).split('\n'):
                print >>cve_file, " %s" % (desc_line)
    cve_file.close()
    return dst

class PercentageFile(object):
    def __init__(self, filename):
        self.size = os.stat(filename)[6]
        self.delivered = 0
        self.f = file(filename)

    def read(self, size=None):
        if size is None:
            data = self.f.read()
        else:
            data = self.f.read(size)

        print >>sys.stdout, '%d%% (%d/%d)\r' % ( (self.delivered * 100) / self.size, self.delivered, self.size ),
        sys.stdout.flush()

        self.delivered += len(data)
        return data

###################

class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore, config):
        # For per-hit processing
        self.curr_cve = None
        self.curr_desc = None
        self.curr_refs = []
        self.curr_chars = ""
        self.ignore = ignore
        self.num_ignored = 0
        self.num_added = 0
        self.num_skipped = 0

        # For long-term (human) processing
        self.cve_list = []
        self.cve_data = dict()
        self.saved_ignore_reason = ""
        self.saved_package = ""
        self.debian = None

        # Load debian CVE states, if configured
        if config.has_key('secure-testing-path'):
            self.load_debian_cves(config['secure-testing-path']+'/data/CVE/list')


    def printReport(self):
        print "\n %4d CVEs added" % self.num_added
        print " %4d CVEs ignored" % self.num_ignored
        print " %4d CVEs skipped" % self.num_skipped
        print "---------------------------"
        print "%5d total CVEs triaged" % (self.num_added + self.num_ignored)

    def startElement(self, name, attrs):
        if name == "item":
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
        if name == "desc" or name == "ref":
            self.curr_chars = ""
        if name == "ref":
            self.curr_url = None
            self.curr_source = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']
            if attrs.has_key('source'):
                self.curr_source = attrs['source']

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
        if name == "ref":
            self.curr_refs += [(self.curr_source,self.curr_chars.encode("ascii", "replace"),self.curr_url)]

        if name == "item":
            self.handle_cve()

    def handle_cve(self):
        # Skip CVEs we know about already
        if self.curr_cve in self.ignore:
            return

        # Skip stuff older than 2005
        if int(self.curr_cve.split("-")[1]) < 2005:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        if self.curr_cve in self.cve_list:
            print >>sys.stderr, "Aborting: saw %s twice!" % (self.curr_cve)

        self.cve_list += [self.curr_cve]
        self.cve_data.setdefault(self.curr_cve,dict())
        self.cve_data[self.curr_cve].setdefault('desc',self.curr_desc)
        self.cve_data[self.curr_cve].setdefault('refs',[]+self.curr_refs)

    def cves(self):
        return self.cve_list

    def load_debian_cves(self, filename):
        cve = None
        self.debian = dict()

        cvelist = file(filename)
        print "Loading %s ..." % (filename)
        count = 0
        for line in cvelist:
            count += 1
            line = line.rstrip()
            try:
                if line.startswith('\t'):
                    if not cve:
                        continue
                    line = line.lstrip()
                    if line.startswith('['):
                        continue
                    if line.startswith('{'):
                        continue
                    if line.startswith('-'):
                        info = line[1:].lstrip().split(' ',1)
                        pkg = info[0]
                        line = ""
                        if len(info)>1:
                            line = info[1]

                        info = line.lstrip().split(' ',1)
                        state = info[0]
                        if state == "":
                            state = "<unfixed>"
                        line = ""
                        if len(info)>1:
                            line = info[1]

                        priority = "needs-triage"
                        bug = None
                        note = None
                        if '(' in line and ')' in line:
                            info = line.split('(')[1].split(')')[0]
                            bits = info.split(';')
                            for bit in bits:
                                bit = bit.strip()
                                if bit.startswith('#'):
                                    bug = bit[1:]
                                else:
                                    priority = bit
                        else:
                            note = line

                        self.debian[cve]['pkgs'].setdefault(pkg,{'priority':priority,'bug':bug,'note':note,'state':state})

                        self.debian[cve]['state'] = 'FOUND'
                    if line.startswith('RESERVED'):
                        self.debian[cve]['state'] = 'RESERVED'
                    if line.startswith('REJECTED'):
                        self.debian[cve]['state'] = 'REJECTED'
                    if line.startswith('NOT-FOR-US'):
                        self.debian[cve]['state'] = line
                    if line.startswith('NOTE'):
                        self.debian[cve]['note']+=[line]
                else:
                    cve = line.split().pop(0)
                    self.debian.setdefault(cve,{'pkgs':dict(), 'state':None, 'note':[]})
            except:
                print >>sys.stderr, "Error parsing line %d: '%s'" % (count, line)
                raise

    def human_process_cve(self, cve):

        # Check if this was once an embargoed issue
        if cve in EmbargoList:
            print '**!!** no longer embargoed **!!**'
            print '==========================details from embargo entry=========================='
            print file(os.path.join('embargoed',cve)).read().rstrip()
            print '=================================end details=================================='
        # Display CVE information
        for ref in self.cve_data[cve]['refs']:
            print ' %s: %s' % (ref[0],ref[1]),
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                print ' %s' % (ref[2]),
            print
        print '%s' % (self.cve_data[cve]['desc'])
        if self.debian and self.debian.has_key(cve):
            print 'Debian: %s' % (self.debian[cve]['state'])
            if len(self.debian[cve]['note']):
                print "\t" + "\n\t".join(self.debian[cve]['note'])
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append(self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append(self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append(self.debian[cve]['pkgs'][pkg]['note'])
                print "\t%s: %s (%s)" % (pkg,self.debian[cve]['pkgs'][pkg]['state'],"; ".join(info))

        response = 'skip'
        reason = ""
        package = ""
        # Skip CVEs that are obviously not about Ubuntu
        for s in ignore_strings:
            if self.cve_data[cve]['desc'].find(s) >= 0 and self.cve_data[cve]['desc'].find("Linux") < 0:
                response = 'ignore'
                reason = 'NFU - ' + s
        # Default to Debian state, if available
        if self.debian and self.debian.has_key(cve) and self.debian[cve]['state']:
            if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                response = 'ignore'
                reason = self.debian[cve]['state'].split(':',1)[1].lstrip()
            if self.debian[cve]['state'] == 'FOUND':
                response = 'add'
                package = " ".join(self.debian[cve]['pkgs'])

        info = ''
        while info == "" or not info[0] in ['i','a','s','q']:
            print 'A)dd to tracker, I)gnore forever, S)kip for now, or Q)uit? [%s] ' % (response),
            info = sys.stdin.readline().strip().lower()
            if info == "":
                info = response

        if info.startswith('q'):
            self.printReport()
            sys.exit(0)
        elif info.startswith('a'):
            self.num_added += 1
            info = ""
            while info == "":
                print 'Package(s) affected? ',
                if package == "":
                    package = self.saved_package
                if package != "":
                    print '[%s] ' % (package),
                info = sys.stdin.readline().strip()
                if info == '':
                    info = package
                self.saved_package = info
            # Add to tracker from 00boilerplate
            dst = add_CVE_to_tracker(cve,self.cve_data[cve]['desc'], info)
            # Tack on package
            cmd = ['./scripts/active_edit','-c',cve]
            for pkg in info.split():
                cmd += ['-p',pkg]
            cmd += ['--yes']
            subprocess.call(cmd)
            # Spawn editor
            editor = os.getenv('EDITOR','vi')
            subprocess.call([editor,dst])
        elif info.startswith('i'):
            self.num_ignored += 1
            info = ""
            while info == "":
                print 'Reason to be ignored? ',
                if reason == "" and self.saved_ignore_reason != "":
                    reason = self.saved_ignore_reason
                if reason != "":
                    print '[%s] ' % (reason),
                info = sys.stdin.readline().strip()
                if info == "":
                    info = reason
                self.saved_ignore_reason = info
            # Append to ignore list
            file('%s/ignored/not-for-us.txt'%(destdir),'a').write('%s # %s\n'%(cve,info))
        elif info.startswith('s'):
            self.num_skipped += 1
        print ''

# CVEIgnoreList is a list of all CVEs we know about already.  These will be
# ignoreda when checking MITRE for new CVEs
CVEIgnoreList  = parse_CVEs(destdir + "/ignored/not-for-us.txt")
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/ignored/") if cve.startswith('CVE-')]
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/retired/") if cve.startswith('CVE-')]
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/active/") if cve.startswith('CVE-')]

if opt.known:
    for cve in sorted(CVEIgnoreList):
        print cve
    sys.exit(0)

parser = xml.sax.make_parser()
handler = CVEHandler(CVEIgnoreList,config)
parser.setContentHandler(handler)
if len(args) == 1:
    cvexml_url = args[0]
print >>sys.stderr, 'Loading %s ...'%(cvexml_url)
if '://' in cvexml_url:
    readable = urllib.urlopen(cvexml_url)
else:
    readable = PercentageFile(cvexml_url)
parser.parse(readable)
print ''

new_cves = handler.cves()
max = len(new_cves)
count = 0
for cve in new_cves:
    count += 1

    if opt.report:
        print cve
        continue

    print '\n***********************************************************************'
    print ' %s    (%d/%d: %d%%)' % (cve, count, max, (count * 100 / max))
    print ' http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve)
    print '***********************************************************************'
    handler.human_process_cve(cve)

handler.printReport()
