;;; cve-mode.el --- major mode for editing CVE files         -*- lexical-binding: t; -*-

;; Copyright (c) 2018 Alex Murray

;; Author: Alex Murray <alex.murray@canonical.com>
;; Maintainer: Alex Murray <alex.murray@canonical.com>
;; URL: https://launchpad.net/ubuntu-cve-tracker
;; Version: 0.1
;; Package-Requires: ((emacs "24.4"))

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;;; Setup

;; (require 'cve-mode)

;;; Code:
(require 'bug-reference)

;;; Forward declaration of optional dependencies
(declare-function flycheck-define-checker "ext:flycheck.el")

(defconst cve-mode-base-path
  (file-name-directory
   (file-truename
    (expand-file-name
     (or load-file-name buffer-file-name))))
  "The directory where cve-mode.el resides (should be $UCT/scripts/).")

(defvar cve-mode-keywords '("Candidate" "PublicDate" "PublicDateAtUSN" "CRD" "References" "Description" "Ubuntu-Description" "Notes" "Bugs" "Priority" "Discovered-by" "Assigned-to"))

(defvar cve-mode-all-releases '("devel" "upstream" "product" "warty" "hoary" "breezy" "dapper" "edgy" "feisty" "gutsy" "hardy" "intrepid" "jaunty" "karmic" "lucid" "maverick" "natty" "oneiric" "precise" "precise/esm" "quantal" "raring" "saucy" "trusty" "utopic" "vivid" "vivid/stable-phone-overlay" "vivid/ubuntu-core" "wily" "xenial" "yakkety" "zesty" "artful" "bionic" "cosmic"))

(defvar cve-mode-releases '("precise/esm" "trusty" "xenial" "bionic" "cosmic" "devel"))

(defvar cve-mode-devel-release "disco")

(defvar cve-mode-statuses '("needs-triage" "needed" "deferred" "pending" "released" "ignored" "not-affected" "DNE"))

(defvar cve-mode-priorities '("negligible" "low" "medium" "high" "critical"))

(defvar cve-mode-tags '("apparmor" "fortify-source" "hardlink-restriction" "heap-protector" "not-ue" "pie" "stack-protector" "symlink-restriction" "universe-binary"))

(defvar cve-mode-cve-id-regexp "\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\)")

(defvar cve-mode-date-regexp "\\([[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}\\)")

(defvar cve-mode-note-regexp "^ \\([[:alnum:]]+\\)> ")

(defvar cve-mode-package-name-regexp "[a-z0-9][a-z0-9+.-]+")

(defvar cve-mode-patch-types '("upstream" "backport" "vendor" "other" "break-fix"))

(defvar cve-mode-patch-regexp (concat "\\(" (regexp-opt cve-mode-patch-types) "\\):"))

(defvar cve-mode-patches-regexp (concat "^\\(\\(Patches\\)_\\(" cve-mode-package-name-regexp "\\)\\):"))

(defvar cve-mode-tags-regexp (concat "\\(\\(Tags\\)_\\("   cve-mode-package-name-regexp "\\)\\): \\(\\(" (regexp-opt cve-mode-tags) "\\) *\\)\+$"))

(defvar cve-mode-keywords-regexp (concat "^\\(" (regexp-opt cve-mode-keywords) "\\):"))

(defvar cve-mode-releases-regexp (concat "^\\(\\(" (regexp-opt cve-mode-all-releases) "\\)" "_"
                                         "\\(" cve-mode-package-name-regexp "\\)"  "\\): \\(" (regexp-opt cve-mode-statuses) "\\)" ))

(defvar cve-mode-priority-regexp (concat "^Priority: \\(" (regexp-opt cve-mode-priorities) "\\)$"))

(defvar cve-mode-font-lock-defaults
  `(((,cve-mode-keywords-regexp 1 font-lock-keyword-face t)
     (,cve-mode-releases-regexp 2 font-lock-function-name-face t)
     (,cve-mode-releases-regexp 3 font-lock-type-face t)
     (,cve-mode-releases-regexp 4 font-lock-variable-name-face t)
     (,cve-mode-priority-regexp 1 font-lock-type-face t)
     (,cve-mode-note-regexp 1 font-lock-type-face t)
     (,cve-mode-patches-regexp 2 font-lock-function-name-face t)
     (,cve-mode-patches-regexp 3 font-lock-type-face t)
     (,cve-mode-tags-regexp 2 font-lock-function-name-face t)
     (,cve-mode-tags-regexp 3 font-lock-type-face t)
     (,cve-mode-tags-regexp 5 font-lock-variable-name-face t)
     (,cve-mode-patch-regexp 1 font-lock-keyword-face t)
     (":" . 'font-lock-builtin-face)
     (">" . 'font-lock-builtin-face)
     ;; CVE Ids
     (,cve-mode-cve-id-regexp 1 font-lock-variable-name-face t)
     (,cve-mode-date-regexp 1 font-lock-variable-name-face t))))

(defvar cve-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; add / and _ as symbol characters
    (modify-syntax-entry ?/ "/" table)
    (modify-syntax-entry ?_ "/" table)
    ;; # is comment start
    (modify-syntax-entry ?# "<" table)
    ;; newline finishes comment line
    (modify-syntax-entry ?\n ">" table)
    table))

(defun cve-mode-completion-at-point ()
  "`completion-at-point' function for cve-mode."
  (let ((bounds (bounds-of-thing-at-point 'symbol)))
    (list (car bounds) ; start
          (cdr bounds) ; end
          (append cve-mode-keywords cve-mode-releases cve-mode-statuses cve-mode-priorities cve-mode-tags)
          :company-docsig #'identity)))

(defun cve-mode-indent-line ()
  "Indent current line in cve-mode."
  (interactive)
  (if (bolp)
      (cve-mode--indent-line)
    (save-excursion
      (cve-mode--indent-line))))

(defun cve-mode--indent-line ()
  "Indent current line in cve-mode."
  (beginning-of-line)
  (cond
   ((or (looking-at cve-mode-keywords-regexp)
        (looking-at cve-mode-releases-regexp)
        (looking-at cve-mode-patches-regexp))
    ;; headings etc indent to 0, otherwise indent to 1 space
    (indent-line-to 0))
   ((or (looking-at cve-mode-patch-regexp))
    (indent-line-to 1))
   (t
    (indent-line-to 1))))

(defun cve-mode-set-priority (&optional priority)
  "Set the current CVE's PRIORITY (prompt if none specified)."
  (interactive
   (list (completing-read "Priority: " cve-mode-priorities)))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward cve-mode-priority-regexp nil t)
          (replace-match priority nil t nil 1)
        (error "Unable to find Priority field in CVE")))))

(defun cve-mode-set-assigned-to (&optional assignee)
  "Assign the current CVE to ASSIGNEE (prompt if none specified)."
  (interactive "sAssignee: ")
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (re-search-forward "^Assigned-to:\\(.*\\)$" nil t)
          ;; ensure a space after the colon
          (replace-match (concat " " assignee) nil t nil 1)
        (error "Unable to find Assigned-to field in CVE")))))

(defun cve-mode-add-note (&optional user note)
  "Add a NOTE by USER to the current CVE (prompt if none specified)."
  (interactive "sUser: \nsNote: ")
  ;; format note across lines
  (setq note
        (with-temp-buffer
          (insert note)
          (let ((fill-column (- 72 (length user) 3)))
            (fill-paragraph)
            (goto-char (point-min))
            (while (not (eobp))
              (insert (format " %s> " user))
              (forward-line))
            (buffer-string))))
  (save-excursion
    (save-restriction
      (goto-char (point-min))
      (if (null (re-search-forward "^Notes:" nil t))
          (error "Unable to find Notes field of CVE")
        ;; now go to the next heading in the CVE so we append to the
        ;; existing Notes
        (re-search-forward "^[A-Z]")
        (beginning-of-line)
        (insert note)
        (insert "\n")))))

(defvar cve-mode--source-packages
  (split-string
   (shell-command-to-string "grep Package: /var/lib/apt/lists/*Sources | awk '{print $2}' | sort | uniq")))

(defvar cve-mode--packages-releases nil)

(defun cve-mode--package-releases (package)
  "Get the list of releases where PACKAGE exists.
Queries umt for PACKAGE as well as looking in "
  (let ((status (assoc-string package cve-mode--packages-releases)))
    (if (not (null status))
        (cdr status)
      (let ((releases nil))
        (with-temp-buffer
          (shell-command (format "umt search \"%s\"" package) (current-buffer))
          (goto-char (point-min))
          (while (re-search-forward (concat "^\\([a-z]\+\\): .*, Pocket:.*, Component: .*$") nil t)
            (let ((release (match-string 1)))
              (push release releases))))
        ;; look for overlay files for specific overlay releases
        (dolist (release cve-mode-releases)
          (when (string-match-p "/" release)
            (let ((overlay-filename (concat
                                     (replace-regexp-in-string "/" "-" release)
                                     "-supported.txt")))
              ;; also get for precise-esm specifically
              (with-temp-buffer
                (insert-file-contents
                 (expand-file-name overlay-filename
                                   (file-name-directory
                                    (directory-file-name
                                     cve-mode-base-path))))
                (when (re-search-forward (concat "^" package "$") nil t)
                  (push release releases))))))
        (add-to-list 'cve-mode--packages-releases `(,package . ,releases))
        (cve-mode--package-releases package)))))

(defun cve-mode-insert-package (&optional package)
  "Add PACKAGE as affected to this CVE.
Status for each release (DNE/needs-triage) will automatically be
added via umt."
  (interactive
   (list (completing-read "Package: " cve-mode--source-packages)))
  ;; check if package is already listed
  (save-excursion
    (goto-char (point-min))
    (when (re-search-forward (format "Patches_%s:" package) nil t)
      (user-error "Package %s is already listed in this CVE" package)))
  ;; get status of package from umt
  (let ((releases (cve-mode--package-releases package)))
    (unless releases
      (user-error "Package %s not found in any releases" package))
    (save-excursion
      (goto-char (point-max))
      (insert "\n")
      (insert (format "Patches_%s:\n" package))
      (insert (format "upstream_%s: needs-triage\n" package))
      (dolist (release cve-mode-releases)
        (insert (format "%s_%s: %s\n" release package
                        (if (seq-contains releases (if (string= release "devel")
                                                       cve-mode-devel-release
                                                     release) #'string=)
                            "needs-triage"
                          "DNE")))))))

(defun cve-mode-fill-paragraph (&optional justify region)
  "Fill paragraph and JUSTIFY with REGION.
This behaves as `fill-paragraph' except that filling does not
cross boundaries of block literals."
  (interactive "*P")
  (save-excursion
    (save-restriction
      (re-search-backward cve-mode-keywords-regexp)
      (let ((beg (progn (beginning-of-line) (forward-line) (point))))
        (when (re-search-forward cve-mode-keywords-regexp nil t)
          (forward-line -1)
          (end-of-line)
          (narrow-to-region beg (point))
          (let ((fill-paragraph-function nil))
            (fill-paragraph justify region)))))))

(defvar cve-mode-map
  (let ((map (make-sparse-keymap)))
    ;; prefix actions with C-c C-v C-mnemonic
    (define-key map (kbd "C-c C-v C-a") #'cve-mode-set-assigned-to)
    (define-key map (kbd "C-c C-v C-i") #'cve-mode-insert-package)
    (define-key map (kbd "C-c C-v C-n") #'cve-mode-add-note)
    (define-key map (kbd "C-c C-v C-p") #'cve-mode-set-priority)
    map)
  "Keymap for `cve-mode'.")

(define-derived-mode cve-mode text-mode "CVE"
  "cve-mode is a major mode for editing CVE files."
  :syntax-table cve-mode-syntax-table
  (setq font-lock-defaults cve-mode-font-lock-defaults)
  (add-to-list 'completion-at-point-functions #'cve-mode-completion-at-point)
  (set (make-local-variable 'comment-start) "#")
  (set (make-local-variable 'comment-end) "")
  (set (make-local-variable 'indent-tabs-mode) nil)
  (set (make-local-variable 'indent-line-function) #'cve-mode-indent-line)
  (set (make-local-variable 'fill-paragraph-function) #'cve-mode-fill-paragraph)
  (set (make-local-variable 'compile-command)
       (concat (file-name-as-directory cve-mode-base-path) "check-syntax "
               (if buffer-file-name
                   (shell-quote-argument buffer-file-name))))
  ;; linkify CVEs via bug-reference-mode
  (set (make-local-variable 'bug-reference-url-format) "https://people.canonical.com/~ubuntu-security/cve/%s.html")
  (set (make-local-variable 'bug-reference-bug-regexp) "\\(\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\)\\)")
  (bug-reference-mode 1)
  ;; linkify URLs
  (goto-address-mode 1))

;; flycheck integration
;; silence byte-compiler warnings
(eval-when-compile
  (require 'flycheck nil t))
(when (require 'flycheck nil t)
  ;; no need to be able to override this
  (defconst flycheck-cve-executable
    (concat (file-name-as-directory cve-mode-base-path) "check-syntax"))

  (flycheck-define-checker cve
    "A checker using check-syntax. "
    :command ("check-syntax" source)
    :error-patterns ((warning line-start "WARNING: " (file-name) ": " line ": " (message) line-end)
                     (error line-start (file-name) ": " line ": " (message) line-end))
    :modes cve-mode)

  (add-to-list 'flycheck-checkers 'cve t))

;;;###autoload
(add-to-list 'auto-mode-alist '("CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\'" . cve-mode))
(add-to-list 'auto-mode-alist '("00boilerplate.*\\'" . cve-mode))

(provide 'cve-mode)
;;; cve-mode.el ends here
