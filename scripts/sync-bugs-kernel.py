#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Fetch the USN database and pass it as the first argument
#  wget http://people.canonical.com/~ubuntu-security/usn/database.pickle
#  ./scripts/sync-bugs-kernel.py database.pickle
#
# This script is intended to sync state between the tracker and LP, as defined
# in the README.
#
import sys, os, os.path, optparse, glob, subprocess
import cve_lib
import urlparse
from lp_lib import UCTLaunchpad

parser = optparse.OptionParser()
parser.add_option("--cve", help="Limit processing to a comma-separated list of CVEs", metavar="CVE[,CVE...]", default=None)
parser.add_option("-u", "--update", help="Update CVEs and LP bugs with state changes", action='store_true')
parser.add_option("--confirm-update", help="Update CVEs and LP bugs with state changes only after confirming actions (enables verbose mode)", action='store_true')
parser.add_option("-v", "--verbose", help="Report logic while processing USNs", action='store_true')
parser.add_option("-d", "--debug", help="Report additional debugging while processing USNs", action='store_true')
parser.add_option("--allow-missing-bugs", help="Do not create missing bugs", action='store_true')
parser.add_option("--allow-missing-tasks", help="Do not create missing tasks", action='store_true')
parser.add_option("--allow-missing-task-nominations", help="Do not create missing task nominations", action='store_true')
(opt, args) = parser.parse_args()

uctlp = UCTLaunchpad(opt)

config = cve_lib.read_config()
ktools = config.get('kernel_team_tools_path',None)
if not ktools:
    raise ValueError, "'kernel_team_tools_path' missing in ~/.ubuntu-cve-tracker.conf"

os.chdir(os.environ['UCT'])
if opt.cve:
    cves = ['active/%s' % (x) for x in opt.cve.split(',')]
else:
    cves = glob.glob('active/CVE-*')

if opt.confirm_update:
    opt.verbose = True

# This doesn't actually work because LP is stupid
def slow_bug_search(cve):
    return None
    if opt.verbose:
        print >>sys.stderr, "Finding LP bugs for %s ..." % (cve)
    for task in uctlp.ubuntu.searchTasks(
                    search_text=cve,
                    status=["New","Confirmed","Triaged","In Progress","Fix Committed","Fix Released"],
                    omit_targeted=False,
                    omit_duplicates=True):
        print task.bug.title


def load_kernel_bugs():
    bugs = dict()
    if opt.verbose:
        print >>sys.stderr, "Finding open LP bugs for kernel ..."
    for task in uctlp.ubuntu.searchTasks(
                    tags=['kernel-cve-tracker','kernel-cve-tracking-bug'],
                    tags_combinator='Any',
                    omit_targeted=False,
                    omit_duplicates=True):
        if not task.bug.title.startswith('CVE-'):
            continue
        cve = task.bug.title[0:13]
        bugs[cve] = task.bug
    if opt.verbose:
        print >>sys.stderr, "\tfound %d" % (len(bugs))
    return bugs

def create_kernel_bug(data):
    when = [int(x) for x in data['PublicDate'].split('-')]
    # FIXME: for now, do not create old bugs...
    if when[0] < 2011 or (when[0] == 2011 and when[1] < 6):
        if opt.debug:
            print >>sys.stderr, "Skipping LP bug for %s (%s) ..." % (data['Candidate'], data['PublicDate'])
        return None
    if not opt.update:
        if opt.verbose:
            print >>sys.stderr, "Want to create LP bug for %s ..." % (data['Candidate'])
        return None
    if opt.verbose:
        print >>sys.stderr, "Creating LP bug for %s ..." % (data['Candidate'])

    bug = None
    os.chdir(ktools)
    p = Popen(['./stable/create-cve-tracker','--verbose','--cve', data['Candidate'][4:]], stdout=PIPE, close_fds=True)
    for line in p.stdout:
        sys.stdout.write(line)
        if line.startswith('http') and 'bugs' in line:
            bug = int(line.strip().split('/')[-1])
    os.chdir(os.environ['UCT'])
    if p.wait() != 0:
        raise ValueError, 'Bug creation failed (rc %d)' % (rc)

    return bug

def set_task_status(taskdict, src, release, state):
    touched = False
    task = taskdict[src][release]
    if task.status != state:
        touched = True
        if not opt.update:
            if opt.verbose:
                print >>sys.stderr, "\twant to update status %s %s %s" % (src, release, state)
            return touched
        if opt.verbose:
            print '\t%s,%s: update status => %s' % (src,release,state)
        task.status=state
        uctlp.save(task)
    return touched

def set_bug_description(bug, description):
    touched = False
    description = description.strip()
    # Do no blow away non-New description with useless description
    if bug.description != 'Placeholder' and description == 'Description needed':
        return touched
    if bug.description != description:
        touched = True
        if not opt.update:
            if opt.verbose:
                print >>sys.stderr, "\twant to update description [%s] -> [%s]" % (bug.description, description)
            return touched
        if opt.verbose:
            print >>sys.stderr, "\tdescription update [%s]" % (description)
        bug.description = description
        uctlp.save(bug)
    return touched

def set_uct_state(data, src, rel, state):
    touched = False
    if data['pkgs'][src][rel][0] != state:
        touched = True
        if not opt.update:
            if opt.verbose:
                print >>sys.stderr, "\twant to update UCT state %s %s %s" % (src, rel, state)
            return touched
        if opt.verbose:
            print '\t%s,%s: update UCT state => %s' % (src,release,state)
        data['pkgs'][src][rel][0] = state
        # FIXME: for now, leave "note" alone
        cve_lib.update_state('active/%s' % (data['Candidate']), src, rel, state, data['pkgs'][src][rel][1])
    return touched

def add_uct_sha(data, src, sha_to_remove):
    if not opt.update:
        if opt.verbose:
            print >>sys.stderr, "\twant to add SHA to %s: %s" % (src, sha)
        return

    if opt.verbose:
        print "\tadding SHA to %s: %s" % (src, sha)

    patchfield = 'Patches_%s' % (src)
    value = data.get(patchfield,'')
    value += "\n break-fix: - %s" % (sha)
    if value.strip() != data.get(patchfield,''):
        data[patchfield] = cve_lib.update_multiline_field('active/%s' % (data['Candidate']), patchfield, value)

def del_uct_sha(data, src, sha_to_remove):
    if not opt.update:
        if opt.verbose:
            print >>sys.stderr, "\twant to delete SHA from %s: %s" % (src, sha)
        return

    if opt.verbose:
        print "\tremoving SHA from %s: %s" % (src, sha)

    shas = []
    broke = dict()
    patchfield = 'Patches_%s' % (src)

    if data.has_key(patchfield):
        for line in data['Patches_%s' % (src)].splitlines():
            if ':' not in line:
                continue
            field, value = line.strip().split(':',1)
            field = field.strip()
            if not field in ['upstream','break-fix']:
                continue
            value = value.strip()
            sha = None
            broken = '-'
            if field == 'upstream':
                sha = value
                if '/' in sha:
                    sha = value.split('/')[-1]
            if field == 'break-fix' and ' ' in value:
                broken, sha = value.split(' ',1)
            if sha and sha != sha_to_remove:
                shas.append(sha)
                broke[sha] = broken

    value = ""
    for sha in shas:
        value += ' break-fix: %s %s\n' % (broke[sha], sha)

    if value.strip() != data.get(patchfield,''):
        data[patchfield] = cve_lib.update_multiline_field('active/%s' % (data['Candidate']), patchfield, value)

# FIXME: there is a lot of copy/paste loop code here to walk the bug
# task vs uct status maps. This should probably be generalized into a
# callable function with some kind of callback system... hmmm.

def sync_to_bug_phase1(bug, tasks, data):
    touched = False
    if opt.verbose:
        print >>sys.stderr, "\tsync to bug (phase 1)"

    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            # Logic for handling the missing tasks has already happened,
            # so unconditionally allow it here to avoid blowing up, since
            # a full abort is not needed.
            continue

        for rel in data['pkgs'][src]:
            release = rel
            if release == 'devel':
                release = cve_lib.devel_release
            if release in ['','upstream']+cve_lib.eol_releases:
                continue

            if not tasks[src].has_key(release):
                continue

            if not tasks[src].has_key(release):
                print >>sys.stderr, "\tmissing task for %s,%s" % (src, release)
                continue

            state = data['pkgs'][src][rel][0]

            if state == 'DNE':
                if set_task_status(tasks, src, release, 'Invalid'): touched = True
            elif state == 'pending' and tasks[src][release].status in ['Invalid','New','Confirmed','Triaged','In Progress']:
                if set_task_status(tasks, src, release, 'Fix Committed'): touched = True
            elif state == 'released':
                if set_task_status(tasks, src, release, 'Fix Released'): touched = True
            elif state == 'not-affected' and tasks[src][release].status == "New":
                if set_task_status(tasks, src, release, 'Invalid'): touched = True
    return touched

def sync_from_bug_phase2(bug, tasks, data):
    touched = False
    if opt.verbose:
        print >>sys.stderr, "\tsync from bug (phase 2)"

    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            # Logic for handling the missing tasks has already happened,
            # so unconditionally allow it here to avoid blowing up, since
            # a full abort is not needed.
            continue

        for rel in data['pkgs'][src]:
            release = rel
            if release == 'devel':
                release = cve_lib.devel_release
            if release in ['','upstream']+cve_lib.eol_releases:
                continue

            if not tasks[src].has_key(release):
                continue

            state = data['pkgs'][src][rel][0]
            status = tasks[src][release].status

            if status in ['Confirmed','Triaged','In Progress']:
                if set_uct_state(data, src, rel, 'needed'): touched = True
            elif status in ['New'] and state != 'needed':
                if set_uct_state(data, src, rel, 'needs-triage'): touched = True
            elif status in ['Invalid'] and not state in ['DNE','ignored']:
                if set_uct_state(data, src, rel, 'not-affected'): touched = True

    for line in bug.description.splitlines():
        line = line.strip()
        if line.startswith('Add-Fixed-by:') or line.startswith('Del-Fixed-by:'):
            touched = True
            value = line.split(':',1)[1].strip()
            if ' ' in value:
                shas = value.split(' ')
            else:
                shas = [value]
            for sha in shas:
                if line.startswith('Del'):
                    del_uct_sha(data, sha)
                else:
                    add_uct_sha(data, sha)
    return touched

def _extract_sha(sha):
    if '/' in sha:
        sha = sha.split('/')[-1]
    if '=' in sha:
        sha = sha.split('=')[-1]
    return sha

def _update_description_from_uct(bug, tasks, data):
    shas = []
    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            # Logic for handling the missing tasks has already happened,
            # so unconditionally allow it here to avoid blowing up, since
            # a full abort is not needed.
            continue

        if data.has_key('Patches_%s' % (src)):
            for line in data['Patches_%s' % (src)].splitlines():
                if ':' not in line:
                    continue
                field, value = line.strip().split(':',1)
                field = field.strip()
                if not field in ['upstream','break-fix']:
                    continue
                value = value.strip()
                broken = None
                sha = None
                if field == 'upstream':
                    sha = _extract_sha(value)
                if field == 'break-fix' and ' ' in value:
                    broken, sha = [_extract_sha(x) for x in value.split(' ',1)]
                if sha:
                    shas.append((broken, sha))

    description = data['Description'].strip().replace('\n',' ').strip()
    if description == "":
        description = "Description needed"
    description += "\n\n"
    for broken, sha in shas:
        if broken and broken != '-':
            description += "Introduced-by: %s\n" % (broken)
        description += "Fixed-by: %s\n" % (sha)
    return set_bug_description(bug, description)

def sync_to_bug_phase3(bug, tasks, data):
    touched = False
    if opt.verbose:
        print >>sys.stderr, "\tsync to bug (phase 3)"

    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            # Logic for handling the missing tasks has already happened,
            # so unconditionally allow it here to avoid blowing up, since
            # a full abort is not needed.
            continue

        for rel in data['pkgs'][src]:
            release = rel
            if release == 'devel':
                release = cve_lib.devel_release
            if release in ['','upstream']+cve_lib.eol_releases:
                continue

            if not tasks[src].has_key(release):
                continue

            state = data['pkgs'][src][rel][0]

            if state == 'needs-triage':
                if set_task_status(tasks, src, release, 'New'): touched = True

    if _update_description_from_uct(bug, tasks, data): touched = True

    return touched

def sync_new_bug(bug, tasks, data):
    touched = False
    if opt.debug:
        print >>sys.stderr, "\tsync new bug"
    shas = []
    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            # Logic for handling the missing tasks has already happened,
            # so unconditionally allow it here to avoid blowing up, since
            # a full abort is not needed.
            continue

        for rel in data['pkgs'][src]:
            release = rel
            if release == 'devel':
                release = cve_lib.devel_release
            if release in ['','upstream']+cve_lib.eol_releases:
                continue

            if not tasks[src].has_key(release):
                continue

            state = data['pkgs'][src][rel][0]
            if tasks[src][release].status != 'New':
                continue
            if state in ['DNE','not-affected']:
                if set_task_status(tasks, src, release, 'Invalid'): touched = True
            elif state == 'pending':
                if set_task_status(tasks, src, release, 'Fix Committed'): touched = True
            elif state == 'released':
                if set_task_status(tasks, src, release, 'Fix Released'): touched = True

    if _update_description_from_uct(bug, tasks, data): touched = True

    return touched

def generate_task_map(bug):
    tasks = dict()
    for task in bug.bug_tasks:
        package, project, release = uctlp.extract_task(task)
        if project.lower() != 'ubuntu':
            print >>sys.stderr, "WARNING: bug %d has task not in ubuntu project" % (bug.id)
            continue
        if release == None:
            # The release-less place-holder
            continue
        package = package.lower()
        tasks.setdefault(package, dict())
        release = release.lower()
        tasks[package].setdefault(release, task)
    return tasks

def refresh_task_packages(bug, tasks):
    refresh = False
    verified_nominations = False
    for src in cve_lib.kernel_srcs:
        if not tasks.has_key(src):
            if opt.allow_missing_tasks:
                if opt.debug:
                    print >>sys.stderr, "\tmissing task for '%s'" % (src)
                continue
            elif not opt.update:
                print >>sys.stderr, "\twant to add missing task for '%s'" % (src)
            if opt.update:
                if opt.verbose:
                    print >>sys.stderr, "\tadding task for '%s'" % (src)
                bug.addTask(target=uctlp.ubuntu.getSourcePackage(name=src))
                refresh = True
            else:
                # If we didn't add, we should not check for nominations...
                continue

        # Since LP attaches nominations across all packages, we only
        # have to do it once, not for each source package in the list.
        if verified_nominations:
            continue
        for rel in cve_lib.releases:
            if rel in cve_lib.eol_releases:
                continue
            if tasks[src].has_key(rel):
                continue

            if opt.allow_missing_task_nominations:
                if opt.debug:
                    print >>sys.stderr, "\tmissing task for %s,%s" % (src, rel)
                    continue
            elif not opt.update:
                print >>sys.stderr, "\twant to add missing task for %s,%s" % (src, rel)
            if opt.update:
                if opt.verbose:
                    print >>sys.stderr, "\tadding task for %s,%s" % (src, rel)
                # FIXME: handle unapproved nominations
                bug.addNomination(target=uctlp.cached('series',rel)).approve()
                refresh = True
        verified_nominations = True

    return refresh


def sync_kernel_bug(bug, data, bugs_field):
    touched = False
    if opt.debug:
        if opt.update:
            print >>sys.stderr, "Syncing LP bug %s with %s ..." % (bug, data['Candidate'])
        else:
            print >>sys.stderr, "Pretending to sync LP bug %s with %s ..." % (bug, data['Candidate'])

    # Rebuild bug list
    if bugs_field != data['Bugs'].strip():
        print "\t'Bugs' field needs updating ..."
        if opt.update:
            cve_lib.update_multiline_field('active/%s' % (data['Candidate']), 'Bugs', bugs_field)

    # Generate task mapping dict(src -> dict( rel -> task ) )
    tasks = generate_task_map(bug)
    if refresh_task_packages(bug, tasks):
        tasks = generate_task_map(bug)

    if bug.description == 'Placeholder':
        # New bug, overwrite stuff
        if sync_new_bug(bug, tasks, data): touched = True
    else:
        # Active bug, overwrite what we can, then pull back the rest
        if sync_to_bug_phase1(bug, tasks, data): touched = True
        if sync_from_bug_phase2(bug, tasks, data): touched = True
        if sync_to_bug_phase3(bug, tasks, data): touched = True

    return touched

# Find only open kernel CVEs
info = dict()
for filename in cves:
    cve = os.path.basename(filename)
    data = cve_lib.load_cve(filename)
    for src in cve_lib.kernel_srcs:
        if not src in data['pkgs']:
            continue
        found = False
        for rel in data['pkgs'][src]:
            if rel == "upstream":
                continue
            if not data['pkgs'][src][rel][0] in cve_lib.status_closed:
                #print "Want %s (%s: %s)" % (cve, src, data['pkgs'][src][rel][0])
                info.setdefault(cve, data)
                found = True
                break
        if found:
            break

# Load LP bugs
buglist = dict()
if not opt.cve:
    buglist = load_kernel_bugs()

# Load kernel CVEs
for cve in sorted(info.keys()):
    # Load bug list
    bugs = []
    bugs_remote = []
    for uri in info[cve]['Bugs'].splitlines():
        uri = uri.strip()
        if uri == "":
            continue
        o = urlparse.urlparse(uri)
        if o.netloc.endswith('launchpad.net'):
            bugs.append(int(uri.split('/')[-1]))
        else:
            bugs_remote.append(uri)

    # Find or create bug
    if len(bugs) == 0:
        if not buglist.has_key(cve):
            found = slow_bug_search(cve)
            if not found:
                found = create_kernel_bug(info[cve])
            if found:
                buglist[cve] = found
        if buglist.has_key(cve):
            bugs = [buglist[cve].id]
        else:
            if opt.allow_missing_bugs:
                if opt.verbose:
                    print "%s: bug needed" % (cve)
                continue
            else:
                raise IndexError, "%s: bug missing!" % (cve)
    elif len(bugs) == 1:
        if not buglist.has_key(cve):
            # Link manually created or closed bugs
            buglist[cve] = uctlp.lp.bugs[bugs[0]]
        if bugs[0] != buglist[cve].id:
            # FIXME: automatically handle duplicates here instead of bailing
            print >>sys.stderr, "%s: bug mismatch! (tracker:%d LP:%d)" % (cve, bugs[0], buglist[cve].id)
            continue
    else:
        # Bail on multiple bugs
        print >>sys.stderr, "%s: more than 1 LP bug: %s" % (cve, " ".join(["%d" % (x) for x in bugs]))
        continue
    bug = bugs[0]

    if opt.verbose:
        print "%s: LP: #%d" % (cve, bug)

    # Rebuild bug list
    bugs_text = "\n".join(bugs_remote+['https://launchpad.net/bugs/%d' % (bug)])
    bugs_text = bugs_text.strip()

    # Synchronize with LP
    saved_update = opt.update
    if opt.confirm_update:
        opt.update = False
    made_changes = sync_kernel_bug(buglist[cve], info[cve], bugs_text)

    if made_changes and opt.confirm_update:
        print "Okay? [y/N] ",
        ans = sys.stdin.readline()
        if ans.strip().lower().startswith('y'):
            opt.update = True
            sync_kernel_bug(buglist[cve], info[cve], bugs_text)
        else:
            print "Continuing ..."

    opt.update = saved_update
