Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./src/ip.cpp:51:    //  Setting this option result in sane behaviour when exec() functions

== memory_management() ==
./src/curve_server.cpp:57:    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);
./src/curve_server.cpp:139:    memcpy (message_nonce, "CurveZMQMESSAGES", 16);
./src/curve_server.cpp:146:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));
./src/curve_server.cpp:151:    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,
./src/curve_server.cpp:154:    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));
./src/curve_server.cpp:169:    memcpy (message, "\x07MESSAGE", 8);
./src/curve_server.cpp:170:    memcpy (message + 8, message_nonce + 16, 8);
./src/curve_server.cpp:171:    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:202:    memcpy (message_nonce, "CurveZMQMESSAGEC", 16);
./src/curve_server.cpp:203:    memcpy (message_nonce + 16, message + 8, 8);
./src/curve_server.cpp:213:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));
./src/curve_server.cpp:216:    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));
./src/curve_server.cpp:220:    memcpy (message_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:236:        memcpy (msg_->data (),
./src/curve_server.cpp:304:    memcpy (cn_client, hello + 80, 32);
./src/curve_server.cpp:310:    memcpy (hello_nonce, "CurveZMQHELLO---", 16);
./src/curve_server.cpp:311:    memcpy (hello_nonce + 16, hello + 112, 8);
./src/curve_server.cpp:315:    memcpy (hello_box + crypto_box_BOXZEROBYTES, hello + 120, 80);
./src/curve_server.cpp:340:    memcpy (cookie_nonce, "COOKIE--", 8);
./src/curve_server.cpp:345:    memcpy (cookie_plaintext + crypto_secretbox_ZEROBYTES,
./src/curve_server.cpp:347:    memcpy (cookie_plaintext + crypto_secretbox_ZEROBYTES + 32,
./src/curve_server.cpp:365:    memcpy (welcome_nonce, "WELCOME-", 8);
./src/curve_server.cpp:370:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES, cn_public, 32);
./src/curve_server.cpp:371:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES + 32,
./src/curve_server.cpp:373:    memcpy (welcome_plaintext + crypto_box_ZEROBYTES + 48,
./src/curve_server.cpp:386:    memcpy (welcome, "\x07WELCOME", 8);
./src/curve_server.cpp:387:    memcpy (welcome + 8, welcome_nonce + 8, 16);
./src/curve_server.cpp:388:    memcpy (welcome + 24, welcome_ciphertext + crypto_box_BOXZEROBYTES, 144);
./src/curve_server.cpp:416:    memcpy (cookie_box + crypto_secretbox_BOXZEROBYTES, initiate + 25, 80);
./src/curve_server.cpp:418:    memcpy (cookie_nonce, "COOKIE--", 8);
./src/curve_server.cpp:419:    memcpy (cookie_nonce + 8, initiate + 9, 16);
./src/curve_server.cpp:448:    memcpy (initiate_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:451:    memcpy (initiate_nonce, "CurveZMQINITIATE", 16);
./src/curve_server.cpp:452:    memcpy (initiate_nonce + 16, initiate + 105, 8);
./src/curve_server.cpp:472:    memcpy (vouch_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:475:    memcpy (vouch_nonce, "VOUCH---", 8);
./src/curve_server.cpp:476:    memcpy (vouch_nonce + 8,
./src/curve_server.cpp:545:    memcpy (ready_nonce, "CurveZMQREADY---", 16);
./src/curve_server.cpp:557:    memcpy (ready, "\x05READY", 6);
./src/curve_server.cpp:559:    memcpy (ready + 6, ready_nonce + 16, 8);
./src/curve_server.cpp:561:    memcpy (ready + 14, ready_box + crypto_box_BOXZEROBYTES,
./src/curve_server.cpp:575:    memcpy (msg_data, "\5ERROR", 6);
./src/curve_server.cpp:577:    memcpy (msg_data + 7, status_code.c_str (), status_code.length ());
./src/curve_server.cpp:596:    memcpy (msg.data (), "1.0", 3);
./src/curve_server.cpp:604:    memcpy (msg.data (), "1", 1);
./src/curve_server.cpp:612:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/curve_server.cpp:620:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/curve_server.cpp:628:    memcpy (msg.data (), options.identity, options.identity_size);
./src/curve_server.cpp:636:    memcpy (msg.data (), "CURVE", 5);
./src/curve_server.cpp:644:    memcpy (msg.data (), key, crypto_box_PUBLICKEYBYTES);
./src/gssapi_mechanism_base.cpp:84:    uint8_t *plaintext_buffer = static_cast <uint8_t *>(malloc(msg_->size ()+1));
./src/gssapi_mechanism_base.cpp:86:    memcpy (plaintext_buffer+1, msg_->data(), msg_->size());
./src/gssapi_mechanism_base.cpp:107:    memcpy (ptr, "\x07MESSAGE", 8);
./src/gssapi_mechanism_base.cpp:115:    memcpy (ptr, wrapped.value, wrapped.length);
./src/gssapi_mechanism_base.cpp:153:    wrapped.value = static_cast <char *> (malloc (alloc_length));
./src/gssapi_mechanism_base.cpp:156:        memcpy(wrapped.value, ptr, wrapped.length);
./src/gssapi_mechanism_base.cpp:181:    memcpy (msg_->data (), static_cast <char *> (plaintext.value)+1, plaintext.length-1);
./src/gssapi_mechanism_base.cpp:207:    memcpy (ptr, "\x08INITIATE", 9);
./src/gssapi_mechanism_base.cpp:215:    memcpy (ptr, token_value_, token_length_);
./src/gssapi_mechanism_base.cpp:250:    *token_value_ = static_cast <char *> (malloc (token_length_ ? token_length_ : 1));
./src/gssapi_mechanism_base.cpp:253:        memcpy(*token_value_, ptr, token_length_);
./src/gssapi_mechanism_base.cpp:268:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/gssapi_mechanism_base.cpp:274:    memcpy (ptr, "\x05READY", 6);
./src/gssapi_mechanism_base.cpp:290:    memcpy (msg_->data (), command_buffer, command_size);
./src/mechanism.cpp:56:    memcpy (msg_->data (), identity.data (), identity.size ());
./src/mechanism.cpp:88:    memcpy (ptr, name, name_len);
./src/mechanism.cpp:93:    memcpy (ptr, value, value_len);
./src/xsub.cpp:233:    memcpy (data + 1, data_, size_);
./src/plain_server.cpp:219:    memcpy (msg_->data (), "\x07WELCOME", 8);
./src/plain_server.cpp:242:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/plain_server.cpp:248:    memcpy (ptr, "\x05READY", 6);
./src/plain_server.cpp:265:    memcpy (msg_->data (), command_buffer, command_size);
./src/plain_server.cpp:277:    memcpy (msg_data, "\5ERROR", 6);
./src/plain_server.cpp:279:    memcpy (msg_data + 7, status_code.c_str (), status_code.length ());
./src/plain_server.cpp:299:    memcpy (msg.data (), "1.0", 3);
./src/plain_server.cpp:307:    memcpy (msg.data (), "1", 1);
./src/plain_server.cpp:315:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/plain_server.cpp:323:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/plain_server.cpp:331:    memcpy (msg.data (), options.identity, options.identity_size);
./src/plain_server.cpp:339:    memcpy (msg.data (), "PLAIN", 5);
./src/plain_server.cpp:347:    memcpy (msg.data (), username.c_str (), username.length ());
./src/plain_server.cpp:355:    memcpy (msg.data (), password.c_str (), password.length ());
./src/mtrie.cpp:107:                malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:280:        next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:367:                next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/mtrie.cpp:383:                next.table = (mtrie_t**) malloc (sizeof (mtrie_t*) * count);
./src/gssapi_client.cpp:55:    service_name = static_cast <char *>(malloc(service_size+1));
./src/gssapi_client.cpp:57:    memcpy(service_name, options_.gss_service_principal.c_str(), service_size+1 );
./src/gssapi_client.cpp:63:        principal_name = static_cast <char *>(malloc(principal_size+1));
./src/gssapi_client.cpp:65:        memcpy(principal_name, options_.gss_principal.c_str(), principal_size+1 );
./src/signaler.cpp:461:        unsigned char *dummy = (unsigned char *) malloc (dummy_size);
./src/msg.cpp:83:            (content_t*) malloc (sizeof (content_t) + size_);
./src/msg.cpp:119:        u.lmsg.content = (content_t*) malloc (sizeof (content_t));
./src/curve_client.cpp:52:    memcpy (public_key, options_.curve_public_key, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:53:    memcpy (secret_key, options_.curve_secret_key, crypto_box_SECRETKEYBYTES);
./src/curve_client.cpp:54:    memcpy (server_key, options_.curve_server_key, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:135:    memcpy (message_nonce, "CurveZMQMESSAGEC", 16);
./src/curve_client.cpp:140:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (mlen));
./src/curve_client.cpp:145:    memcpy (message_plaintext + crypto_box_ZEROBYTES + 1,
./src/curve_client.cpp:148:    uint8_t *message_box = static_cast <uint8_t *> (malloc (mlen));
./src/curve_client.cpp:163:    memcpy (message, "\x07MESSAGE", 8);
./src/curve_client.cpp:164:    memcpy (message + 8, message_nonce + 16, 8);
./src/curve_client.cpp:165:    memcpy (message + 16, message_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:192:    memcpy (message_nonce, "CurveZMQMESSAGES", 16);
./src/curve_client.cpp:193:    memcpy (message_nonce + 16, message + 8, 8);
./src/curve_client.cpp:203:    uint8_t *message_plaintext = static_cast <uint8_t *> (malloc (clen));
./src/curve_client.cpp:206:    uint8_t *message_box = static_cast <uint8_t *> (malloc (clen));
./src/curve_client.cpp:210:    memcpy (message_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:226:        memcpy (msg_->data (),
./src/curve_client.cpp:257:    memcpy (hello_nonce, "CurveZMQHELLO---", 16);
./src/curve_client.cpp:273:    memcpy (hello, "\x05HELLO", 6);
./src/curve_client.cpp:275:    memcpy (hello + 6, "\1\0", 2);
./src/curve_client.cpp:279:    memcpy (hello + 80, cn_public, crypto_box_PUBLICKEYBYTES);
./src/curve_client.cpp:281:    memcpy (hello + 112, hello_nonce + 16, 8);
./src/curve_client.cpp:283:    memcpy (hello + 120, hello_box + crypto_box_BOXZEROBYTES, 80);
./src/curve_client.cpp:304:    memcpy (welcome_box + crypto_box_BOXZEROBYTES, msg_data + 24, 144);
./src/curve_client.cpp:306:    memcpy (welcome_nonce, "WELCOME-", 8);
./src/curve_client.cpp:307:    memcpy (welcome_nonce + 8, msg_data + 8, 16);
./src/curve_client.cpp:317:    memcpy (cn_server, welcome_plaintext + crypto_box_ZEROBYTES, 32);
./src/curve_client.cpp:318:    memcpy (cn_cookie, welcome_plaintext + crypto_box_ZEROBYTES + 32, 16 + 80);
./src/curve_client.cpp:337:    memcpy (vouch_plaintext + crypto_box_ZEROBYTES, cn_public, 32);
./src/curve_client.cpp:338:    memcpy (vouch_plaintext + crypto_box_ZEROBYTES + 32, server_key, 32);
./src/curve_client.cpp:340:    memcpy (vouch_nonce, "VOUCH---", 8);
./src/curve_client.cpp:356:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES,
./src/curve_client.cpp:358:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 32,
./src/curve_client.cpp:360:    memcpy (initiate_plaintext + crypto_box_ZEROBYTES + 48,
./src/curve_client.cpp:378:    memcpy (initiate_nonce, "CurveZMQINITIATE", 16);
./src/curve_client.cpp:391:    memcpy (initiate, "\x08INITIATE", 9);
./src/curve_client.cpp:393:    memcpy (initiate + 9, cn_cookie, 96);
./src/curve_client.cpp:395:    memcpy (initiate + 105, initiate_nonce + 16, 8);
./src/curve_client.cpp:397:    memcpy (initiate + 113, initiate_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:419:    memcpy (ready_box + crypto_box_BOXZEROBYTES,
./src/curve_client.cpp:422:    memcpy (ready_nonce, "CurveZMQREADY---", 16);
./src/curve_client.cpp:423:    memcpy (ready_nonce + 16, msg_data + 6, 8);
./src/trie.cpp:90:                malloc (sizeof (trie_t*) * count);
./src/trie.cpp:227:                next.table = (trie_t**) malloc (sizeof (trie_t*) * count);
./src/trie.cpp:252:                next.table = (trie_t**) malloc (sizeof (trie_t*) * count);
./src/stream.cpp:230:    memcpy (msg_->data (), identity.data (), identity.size ());
./src/stream.cpp:264:    memcpy (prefetched_id.data (), identity.data (), identity.size ());
./src/stream.cpp:298:        memcpy (options.identity, identity.data (), identity.size ());
./src/pgm_sender.cpp:72:    out_buffer = (unsigned char*) malloc (out_buffer_size);
./src/tcp_address.cpp:74:    char *ifr = (char*) malloc (ifr_size);
./src/tcp_address.cpp:159:            memcpy (&source_address, &ifr.ifr_addr,
./src/tcp_address.cpp:163:            memcpy (&address, &ifr.ifr_addr,
./src/tcp_address.cpp:204:                memcpy (&source_address, ifp->ifa_addr,
./src/tcp_address.cpp:208:                memcpy (&address, ifp->ifa_addr,
./src/tcp_address.cpp:255:        memcpy (&ip6_addr.sin6_addr, &in6addr_any, sizeof in6addr_any);
./src/tcp_address.cpp:257:        memcpy (out_addr, &ip6_addr, out_addrlen);
./src/tcp_address.cpp:265:        memcpy (out_addr, &ip4_addr, out_addrlen);
./src/tcp_address.cpp:271:            memcpy (&source_address, out_addr, out_addrlen);
./src/tcp_address.cpp:273:            memcpy (&address, out_addr, out_addrlen);
./src/tcp_address.cpp:325:        memcpy (&source_address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:327:        memcpy (&address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:386:        memcpy (&source_address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:388:        memcpy (&address, res->ai_addr, res->ai_addrlen);
./src/tcp_address.cpp:410:        memcpy (&address.ipv4, sa, sizeof address.ipv4);
./src/tcp_address.cpp:413:        memcpy (&address.ipv6, sa, sizeof address.ipv6);
./src/gssapi_server.cpp:62:        principal_name = static_cast <char *>(malloc(principal_size+1));
./src/gssapi_server.cpp:64:        memcpy(principal_name, options_.gss_principal.c_str(), principal_size+1 );
./src/gssapi_server.cpp:169:    memcpy (msg.data (), "1.0", 3);
./src/gssapi_server.cpp:177:    memcpy (msg.data (), "1", 1);
./src/gssapi_server.cpp:185:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/gssapi_server.cpp:193:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/gssapi_server.cpp:201:    memcpy (msg.data (), options.identity, options.identity_size);
./src/gssapi_server.cpp:209:    memcpy (msg.data (), "GSSAPI", 6);
./src/gssapi_server.cpp:220:    memcpy (msg.data (), principal.value, principal.length);
./src/null_mechanism.cpp:95:        memcpy (msg_data, "\5ERROR", 6);
./src/null_mechanism.cpp:97:        memcpy (msg_data + 7, status_code, sizeof status_code);
./src/null_mechanism.cpp:102:    unsigned char *const command_buffer = (unsigned char *) malloc (512);
./src/null_mechanism.cpp:108:    memcpy (ptr, "\5READY", 6);
./src/null_mechanism.cpp:124:    memcpy (msg_->data (), command_buffer, command_size);
./src/null_mechanism.cpp:233:    memcpy (msg.data (), "1.0", 3);
./src/null_mechanism.cpp:241:    memcpy (msg.data (), "1", 1);
./src/null_mechanism.cpp:249:    memcpy (msg.data (), options.zap_domain.c_str (), options.zap_domain.length ());
./src/null_mechanism.cpp:257:    memcpy (msg.data (), peer_address.c_str (), peer_address.length ());
./src/null_mechanism.cpp:265:    memcpy (msg.data (), options.identity, options.identity_size);
./src/null_mechanism.cpp:273:    memcpy (msg.data (), "NULL", 4);
./src/null_mechanism.cpp:342:    memcpy (status_code, msg [3].data (), sizeof status_code);
./src/ctx.cpp:274:        slots = (mailbox_t **) malloc (sizeof (mailbox_t*) * slot_count);
./src/ctx.cpp:554:        memcpy (id.data (), bind_options.identity, bind_options.identity_size);
./src/zmq_utils.cpp:61:    uint64_t *watch = (uint64_t*) malloc (sizeof (uint64_t));
./src/plain_client.cpp:131:    memcpy (ptr, "\x05HELLO", 6);
./src/plain_client.cpp:135:    memcpy (ptr, username.c_str (), username.length ());
./src/plain_client.cpp:139:    memcpy (ptr, password.c_str (), password.length ());
./src/plain_client.cpp:162:    unsigned char * const command_buffer = (unsigned char *) malloc (512);
./src/plain_client.cpp:168:    memcpy (ptr, "\x08INITIATE", 9);
./src/plain_client.cpp:185:    memcpy (msg_->data (), command_buffer, command_size);
./src/select.cpp:171:        memcpy (&readfds, &source_set_in, sizeof source_set_in);
./src/select.cpp:172:        memcpy (&writefds, &source_set_out, sizeof source_set_out);
./src/select.cpp:173:        memcpy (&exceptfds, &source_set_err, sizeof source_set_err);
./src/tipc_address.cpp:50:        memcpy (&address, sa, sa_len);
./src/raw_decoder.cpp:47:    buffer = (unsigned char *) malloc (bufsize);
./src/raw_decoder.cpp:70:    memcpy (in_progress.data (), data_, size_);
./src/socket_base.cpp:347:        strcpy (static_cast <char *> (optval_), last_endpoint.c_str ());
./src/socket_base.cpp:526:            memcpy (id.data (), options.identity, options.identity_size);
./src/socket_base.cpp:541:                memcpy (id.data (), options.identity, options.identity_size);
./src/socket_base.cpp:553:                memcpy (id.data (), peer.options.identity, peer.options.identity_size);
./src/socket_base.cpp:1361:        memcpy (zmq_msg_data (&msg), addr_.c_str (), addr_.size ());
./src/sub.cpp:65:    memcpy (data + 1, optval_, optvallen_);
./src/stream_engine.cpp:544:                        memcpy (outpos + outsize, "NULL", 4);
./src/stream_engine.cpp:547:                        memcpy (outpos + outsize, "PLAIN", 5);
./src/stream_engine.cpp:550:                        memcpy (outpos + outsize, "GSSAPI", 6);
./src/stream_engine.cpp:553:                        memcpy (outpos + outsize, "CURVE", 5);
./src/stream_engine.cpp:592:        memcpy (tx_msg.data (), options.identity, options.identity_size);
./src/stream_engine.cpp:723:        memcpy (msg_->data (), options.identity, options.identity_size);
./src/stream_engine.cpp:873:        memcpy (msg.data (), credential.data (), credential.size ());
./src/socks.cpp:163:        memcpy (ptr, &sockaddr_in->sin_addr, 4);
./src/socks.cpp:171:        memcpy (ptr, &sockaddr_in6->sin6_addr, 16);
./src/socks.cpp:177:        memcpy (ptr, req.hostname.c_str (), req.hostname.size ());
./src/ipc_address.cpp:50:        memcpy(&address, sa, sa_len);
./src/ipc_address.cpp:69:    strcpy (address.sun_path, path_);
./src/zmq.cpp:368:    memcpy (zmq_msg_data (&msg), buf_, len_);
./src/zmq.cpp:435:        memcpy (zmq_msg_data (&msg), a_[i].iov_base, a_[i].iov_len);
./src/zmq.cpp:492:    memcpy (buf_, zmq_msg_data (&msg), to_copy);
./src/zmq.cpp:547:        a_[i].iov_base = static_cast<char *> (malloc(a_[i].iov_len));
./src/zmq.cpp:552:        memcpy(a_[i].iov_base,static_cast<char *> (zmq_msg_data (&msg)),
./src/zmq.cpp:711:        pollfds = (pollfd*) malloc (nitems_ * sizeof (pollfd));
./src/zmq.cpp:931:            memcpy (&inset, &pollset_in, sizeof (fd_set));
./src/zmq.cpp:932:            memcpy (&outset, &pollset_out, sizeof (fd_set));
./src/zmq.cpp:933:            memcpy (&errset, &pollset_err, sizeof (fd_set));
./src/options.cpp:111:                memcpy (identity, optval_, identity_size);
./src/options.cpp:386:                memcpy (curve_public_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:400:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:410:                memcpy (curve_secret_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:424:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:434:                memcpy (curve_server_key, optval_, CURVE_KEYSIZE);
./src/options.cpp:450:                memcpy (z85_key, (char *) optval_, CURVE_KEYSIZE_Z85);
./src/options.cpp:562:                memcpy (optval_, identity, identity_size);
./src/options.cpp:690:                memcpy (optval_, socks_proxy_address.c_str (), socks_proxy_address.size () + 1);
./src/options.cpp:740:                memcpy (optval_, plain_username.c_str (), plain_username.size () + 1);
./src/options.cpp:748:                memcpy (optval_, plain_password.c_str (), plain_password.size () + 1);
./src/options.cpp:756:                memcpy (optval_, zap_domain.c_str (), zap_domain.size () + 1);
./src/options.cpp:773:                memcpy (optval_, curve_public_key, CURVE_KEYSIZE);
./src/options.cpp:785:                memcpy (optval_, curve_secret_key, CURVE_KEYSIZE);
./src/options.cpp:797:                memcpy (optval_, curve_server_key, CURVE_KEYSIZE);
./src/options.cpp:826:                memcpy (optval_, gss_principal.c_str (), gss_principal.size () + 1);
./src/options.cpp:834:                memcpy (optval_, gss_service_principal.c_str (), gss_service_principal.size () + 1);
./src/pgm_socket.cpp:92:    memcpy (network, network_, port_delim - network_);
./src/pgm_socket.cpp:301:        memcpy (&sa6, &res->ai_recv_addrs[0].gsr_group, sizeof (sa6));
./src/pgm_socket.cpp:378:        pgm_msgv = (pgm_msgv_t*) malloc (sizeof (pgm_msgv_t) * pgm_msgv_len);
./src/xpub.cpp:178:    memcpy (msg_->data (),
./src/xpub.cpp:203:            memcpy (&unsub [1], data_, size_);
./src/router.cpp:328:        memcpy (msg_->data (), identity.data (), identity.size ());
./src/router.cpp:377:    memcpy (prefetched_id.data (), identity.data (), identity.size ());
./tests/test_issue_566.cpp:60:        sprintf (identity, "%09d", cycle);
./tests/test_stream.cpp:146:    memcpy (buffer, "\4\51\5READY", 8);
./tests/test_stream.cpp:147:    memcpy (buffer + 8, "\13Socket-Type\0\0\0\6ROUTER", 22);
./tests/test_stream.cpp:148:    memcpy (buffer + 30, "\10Identity\0\0\0\0", 13);
./tests/test_disconnect_inproc.cpp:36:memcpy(zmq_msg_data(&msg), data, size + 1);
./tests/test_monitor.cpp:60:        *address = (char *) malloc (size + 1);
./tests/test_monitor.cpp:61:        memcpy (*address, data, size);
./tests/test_stream_timeout.cpp:60:        *address = (char *) malloc (size + 1);
./tests/test_stream_timeout.cpp:61:        memcpy (*address, data, size);
./tests/test_iov.cpp:52:        memcpy(data,&i, sizeof(int));
./tests/test_iov.cpp:70:        memcpy(&v,ibuffer[count-1].iov_base,sizeof(int));
./tests/test_inproc_connect.cpp:330:        sprintf (endpts[i], "inproc://foo_%d", i);
./tests/test_security_plain.cpp:123:    strcpy (username, "admin");
./tests/test_security_plain.cpp:126:    strcpy (password, "password");
./tests/test_security_plain.cpp:150:    strcpy (username, "wronguser");
./tests/test_security_plain.cpp:151:    strcpy (password, "wrongpass");
./tests/test_stream_disconnect.cpp:122:    memcpy (zmq_msg_data (&msg), blob_data, blob_size);
./tests/test_stream_disconnect.cpp:129:    memcpy (zmq_msg_data (&msg), dialog [0].text, strlen(dialog [0].text));
./tests/test_stream_disconnect.cpp:192:                memcpy (zmq_msg_data (&data_frame), dialog [step].text,
./tests/test_stream_disconnect.cpp:245:            memcpy (zmq_msg_data (&data_frame), dialog [step].text, zmq_msg_size (&data_frame));
./tests/test_proxy.cpp:71:    sprintf (identity, "%04X-%04X", rand() % 0xFFFF, rand() % 0xFFFF);
./tests/test_proxy.cpp:106:        sprintf(content, "request #%03d", ++request_nbr); // CONTENT_SIZE
./src/socks_connecter.cpp:154:                stream_engine_t *engine = new (std::nothrow)
./src/socks_connecter.cpp:307:    proxy_addr->resolved.tcp_addr = new (std::nothrow) tcp_address_t ();
./src/kqueue.cpp:94:    poll_entry_t *pe = new (std::nothrow) poll_entry_t;
./src/mtrie.cpp:84:            pipes = new (std::nothrow) pipes_t;
./src/mtrie.cpp:143:            next.node = new (std::nothrow) mtrie_t;
./src/mtrie.cpp:151:            next.table [c - min] = new (std::nothrow) mtrie_t;
./src/session_base.cpp:54:        s = new (std::nothrow) req_session_t (io_thread_, active_,
./src/session_base.cpp:68:        s = new (std::nothrow) session_base_t (io_thread_, active_,
./src/session_base.cpp:515:            address_t *proxy_address = new (std::nothrow)
./src/session_base.cpp:525:            tcp_connecter_t *connecter = new (std::nothrow)
./src/session_base.cpp:535:        ipc_connecter_t *connecter = new (std::nothrow) ipc_connecter_t (
./src/session_base.cpp:544:        tipc_connecter_t *connecter = new (std::nothrow) tipc_connecter_t (
./src/session_base.cpp:569:            pgm_sender_t *pgm_sender = new (std::nothrow) pgm_sender_t (
./src/session_base.cpp:581:            pgm_receiver_t *pgm_receiver = new (std::nothrow) pgm_receiver_t (
./src/session_base.cpp:603:            norm_engine_t* norm_sender = new (std::nothrow) norm_engine_t(io_thread, options);
./src/session_base.cpp:614:            norm_engine_t* norm_receiver = new (std::nothrow) norm_engine_t (io_thread, options);
./src/trie.cpp:127:            next.node = new (std::nothrow) trie_t;
./src/trie.cpp:136:            next.table [c - min] = new (std::nothrow) trie_t;
./src/pipe.cpp:50:        upipe1 = new (std::nothrow) upipe_conflate_t ();
./src/pipe.cpp:52:        upipe1 = new (std::nothrow) upipe_normal_t ();
./src/pipe.cpp:57:        upipe2 = new (std::nothrow) upipe_conflate_t ();
./src/pipe.cpp:59:        upipe2 = new (std::nothrow) upipe_normal_t ();
./src/pipe.cpp:62:    pipes_ [0] = new (std::nothrow) pipe_t (parents_ [0], upipe1, upipe2,
./src/pipe.cpp:65:    pipes_ [1] = new (std::nothrow) pipe_t (parents_ [1], upipe2, upipe1,
./src/pipe.cpp:496:        inpipe = new (std::nothrow)
./src/pipe.cpp:499:        inpipe = new (std::nothrow)
./src/pgm_receiver.cpp:237:            it->second.decoder = new (std::nothrow)
./src/tcp_connecter.cpp:141:    stream_engine_t *engine = new (std::nothrow)
./src/tcp_connecter.cpp:224:    addr->resolved.tcp_addr = new (std::nothrow) tcp_address_t ();
./src/tipc_connecter.cpp:124:    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
./src/io_thread.cpp:40:    poller = new (std::nothrow) poller_t (*ctx_);
./src/norm_engine.cpp:416:            rxState = new NormRxStreamState(object, options.maxmsgsize);
./src/norm_engine.cpp:599:    zmq_decoder = new (std::nothrow) v2_decoder_t (in_batch_size, max_msg_size);
./src/tcp_listener.cpp:108:    stream_engine_t *engine = new (std::nothrow)
./src/ctx.cpp:281:        reaper = new (std::nothrow) reaper_t (this, reaper_tid);
./src/ctx.cpp:288:            io_thread_t *io_thread = new (std::nothrow) io_thread_t (this, i);
./src/zmq_utils.cpp:77:    zmq::thread_t* thread = new zmq::thread_t;
./src/ipc_listener.cpp:107:    stream_engine_t *engine = new (std::nothrow)
./src/socket_base.cpp:96:            s = new (std::nothrow) pair_t (parent_, tid_, sid_);
./src/socket_base.cpp:99:            s = new (std::nothrow) pub_t (parent_, tid_, sid_);
./src/socket_base.cpp:102:            s = new (std::nothrow) sub_t (parent_, tid_, sid_);
./src/socket_base.cpp:105:            s = new (std::nothrow) req_t (parent_, tid_, sid_);
./src/socket_base.cpp:108:            s = new (std::nothrow) rep_t (parent_, tid_, sid_);
./src/socket_base.cpp:111:            s = new (std::nothrow) dealer_t (parent_, tid_, sid_);
./src/socket_base.cpp:114:            s = new (std::nothrow) router_t (parent_, tid_, sid_);
./src/socket_base.cpp:117:            s = new (std::nothrow) pull_t (parent_, tid_, sid_);
./src/socket_base.cpp:120:            s = new (std::nothrow) push_t (parent_, tid_, sid_);
./src/socket_base.cpp:123:            s = new (std::nothrow) xpub_t (parent_, tid_, sid_);
./src/socket_base.cpp:126:            s = new (std::nothrow) xsub_t (parent_, tid_, sid_);
./src/socket_base.cpp:129:            s = new (std::nothrow) stream_t (parent_, tid_, sid_);
./src/socket_base.cpp:398:        tcp_listener_t *listener = new (std::nothrow) tcp_listener_t (
./src/socket_base.cpp:417:        ipc_listener_t *listener = new (std::nothrow) ipc_listener_t (
./src/socket_base.cpp:436:         tipc_listener_t *listener = new (std::nothrow) tipc_listener_t (
./src/socket_base.cpp:594:    address_t *paddr = new (std::nothrow) address_t (protocol, address);
./src/socket_base.cpp:639:        paddr->resolved.ipc_addr = new (std::nothrow) ipc_address_t ();
./src/socket_base.cpp:665:        paddr->resolved.tipc_addr = new (std::nothrow) tipc_address_t ();
./src/socket_base.cpp:778:            tcp_address_t *tcp_addr = new (std::nothrow) tcp_address_t ();
./src/stream_engine.cpp:208:        encoder = new (std::nothrow) raw_encoder_t (out_batch_size);
./src/stream_engine.cpp:211:        decoder = new (std::nothrow) raw_decoder_t (in_batch_size);
./src/stream_engine.cpp:226:            metadata = new (std::nothrow) metadata_t (properties);
./src/stream_engine.cpp:575:        encoder = new (std::nothrow) v1_encoder_t (out_batch_size);
./src/stream_engine.cpp:578:        decoder = new (std::nothrow) v1_decoder_t (in_batch_size, options.maxmsgsize);
./src/stream_engine.cpp:622:        encoder = new (std::nothrow) v1_encoder_t (
./src/stream_engine.cpp:626:        decoder = new (std::nothrow) v1_decoder_t (
./src/stream_engine.cpp:638:        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);
./src/stream_engine.cpp:641:        decoder = new (std::nothrow) v2_decoder_t (
./src/stream_engine.cpp:646:        encoder = new (std::nothrow) v2_encoder_t (out_batch_size);
./src/stream_engine.cpp:649:        decoder = new (std::nothrow) v2_decoder_t (
./src/stream_engine.cpp:655:            mechanism = new (std::nothrow)
./src/stream_engine.cpp:663:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:666:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:675:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:678:                mechanism = new (std::nothrow) curve_client_t (options);
./src/stream_engine.cpp:687:                mechanism = new (std::nothrow)
./src/stream_engine.cpp:690:                mechanism = new (std::nothrow) gssapi_client_t (options);
./src/stream_engine.cpp:844:        metadata = new (std::nothrow) metadata_t (properties);
./src/tipc_listener.cpp:92:    stream_engine_t *engine = new (std::nothrow) stream_engine_t (fd, options, endpoint);
./src/zmq.cpp:155:    zmq::ctx_t *ctx = new (std::nothrow) zmq::ctx_t;
./src/epoll.cpp:65:    poll_entry_t *pe = new (std::nothrow) poll_entry_t;
./src/ipc_connecter.cpp:125:    stream_engine_t *engine = new (std::nothrow)
./src/reaper.cpp:39:    poller = new (std::nothrow) poller_t (*ctx_);

== files() ==
./src/curve_server.cpp:318:    int rc = crypto_box_open (hello_plaintext, hello_box,
./src/curve_server.cpp:421:    int rc = crypto_secretbox_open (cookie_plaintext, cookie_box,
./src/curve_server.cpp:455:    rc = crypto_box_open (initiate_plaintext, initiate_box,
./src/curve_server.cpp:479:    rc = crypto_box_open (vouch_plaintext, vouch_box,
./src/curve_client.cpp:309:    int rc = crypto_box_open (welcome_plaintext, welcome_box,
./src/devpoll.cpp:52:    devpoll_fd = open ("/dev/poll", O_RDWR);
./src/tcp_connecter.cpp:164:    const int rc = open ();
./src/tcp_connecter.cpp:214:int zmq::tcp_connecter_t::open ()
./src/tipc_connecter.cpp:146:    int rc = open ();
./src/tipc_connecter.cpp:200:int zmq::tipc_connecter_t::open ()
./src/ipc_connecter.cpp:148:    int rc = open ();
./src/ipc_connecter.cpp:202:int zmq::ipc_connecter_t::open ()
./tweetnacl/src/tweetnacl.c:264:int crypto_secretbox_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *k)
./tweetnacl/src/tweetnacl.c:479:  return crypto_secretbox_open(m,c,d,n,k);
./tweetnacl/src/tweetnacl.c:489:int crypto_box_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *y,const u8 *x)
./tweetnacl/src/tweetnacl.c:788:int crypto_sign_open(u8 *m,u64 *mlen,const u8 *sm,u64 n,const u8 *pk)
./tweetnacl/src/tweetnacl_base.h:43:int crypto_box_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *y,const u8 *x);
./tweetnacl/src/tweetnacl_base.h:46:int crypto_secretbox_open(u8 *m,const u8 *c,u64 d,const u8 *n,const u8 *k);
./tweetnacl/src/tweetnacl.h:43:extern int crypto_box_curve25519xsalsa20poly1305_tweet_open(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *,const unsigned char *);
./tweetnacl/src/tweetnacl.h:190:extern int crypto_secretbox_xsalsa20poly1305_tweet_open(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *);
./tweetnacl/src/tweetnacl.h:213:extern int crypto_sign_ed25519_tweet_open(unsigned char *,unsigned long long *,const unsigned char *,unsigned long long,const unsigned char *);
./tweetnacl/contrib/randombytes/devurandom.c:16:      fd = open("/dev/urandom",O_RDONLY);

== logging() ==
./src/socks_connecter.cpp:116:            error ();
./src/socks_connecter.cpp:122:                 error ();
./src/socks_connecter.cpp:127:                     error ();
./src/socks_connecter.cpp:142:            error ();
./src/socks_connecter.cpp:148:                error ();
./src/socks_connecter.cpp:173:        error ();
./src/socks_connecter.cpp:185:            error ();
./src/socks_connecter.cpp:197:            error ();
./src/socks_connecter.cpp:209:            error ();
./src/socks_connecter.cpp:266:void zmq::socks_connecter_t::error ()
./src/curve_server.cpp:93:            rc = produce_error (msg_);
./src/curve_server.cpp:569:int zmq::curve_server_t::produce_error (msg_t *msg_) const
./src/curve_server.cpp:590:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:598:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:606:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:614:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:622:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:630:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:638:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:645:    rc = session->write_zap_msg (&msg);
./src/curve_server.cpp:661:        rc = session->read_zap_msg (&msg [i]);
./src/gssapi_mechanism_base.cpp:73:int zmq::gssapi_mechanism_base_t::encode_message (msg_t *msg_)
./src/gssapi_mechanism_base.cpp:123:int zmq::gssapi_mechanism_base_t::decode_message (msg_t *msg_)
./src/gssapi_mechanism_base.cpp:294:        return encode_message (msg_);
./src/gssapi_mechanism_base.cpp:302:        const int rc = decode_message (msg_);
./src/xsub.cpp:37:    has_message (false),
./src/plain_server.cpp:73:            rc = produce_error (msg_);
./src/plain_server.cpp:271:int zmq::plain_server_t::produce_error (msg_t *msg_) const
./src/plain_server.cpp:293:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:301:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:309:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:317:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:325:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:333:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:341:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:349:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:356:    rc = session->write_zap_msg (&msg);
./src/plain_server.cpp:372:        rc = session->read_zap_msg (&msg [i]);
./src/session_base.cpp:124:int zmq::session_base_t::pull_msg (msg_t *msg_)
./src/session_base.cpp:136:int zmq::session_base_t::push_msg (msg_t *msg_)
./src/session_base.cpp:148:int zmq::session_base_t::read_zap_msg (msg_t *msg_)
./src/session_base.cpp:163:int zmq::session_base_t::write_zap_msg (msg_t *msg_)
./src/session_base.cpp:205:        rc = pull_msg (&msg);
./src/session_base.cpp:391:void zmq::session_base_t::engine_error (
./src/gssapi_client.cpp:151:      return encode_message (msg_);
./src/gssapi_client.cpp:161:      return decode_message (msg_);
./src/msg.cpp:48://  Check whether the sizes of public representation of the message (zmq_msg_t)
./src/msg.cpp:49://  and private representation of the message (zmq::msg_t) match.
./src/msg.cpp:336:bool zmq::msg_t::is_cmsg ()
./src/curve_client.cpp:110:        rc = process_error (msg_data, msg_size);
./src/curve_client.cpp:442:int zmq::curve_client_t::process_error (
./src/stream.cpp:104:        //  If we have malformed message (prefix with no subsequent message)
./src/pgm_sender.cpp:187:            int rc = session->pull_msg (&msg);
./src/pgm_sender.cpp:191:            encoder.load_msg (&msg);
./src/pgm_receiver.cpp:130:    int rc = session->push_msg (it->second.decoder->msg ());
./src/pgm_receiver.cpp:278:        rc = session->push_msg (decoder->msg ());
./src/pgm_receiver.cpp:301:    while (session->pull_msg (&msg) == 0)
./src/gssapi_server.cpp:163:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:171:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:179:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:187:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:195:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:203:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:211:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:221:    rc = session->write_zap_msg (&msg);
./src/gssapi_server.cpp:238:        rc = session->read_zap_msg (&msg [i]);
./src/gssapi_server.cpp:301:      return encode_message (msg_);
./src/gssapi_server.cpp:311:      return decode_message (msg_);
./src/norm_engine.cpp:16:   tx_first_msg(true), tx_more_bit(false), 
./src/norm_engine.cpp:290:                if (-1 == zmq_session->pull_msg(&tx_msg))
./src/norm_engine.cpp:296:                zmq_encoder.load_msg(&tx_msg);
./src/norm_engine.cpp:458:                case -1: // decoding error (shouldn't happen w/ NORM, but ...)
./src/norm_engine.cpp:539:                int rc = zmq_session->push_msg(msg);
./src/norm_engine.cpp:649:                // decoder error (reset decoder and state variables)
./src/null_mechanism.cpp:227:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:235:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:243:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:251:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:259:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:267:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:274:    rc = session->write_zap_msg (&msg);
./src/null_mechanism.cpp:290:        rc = session->read_zap_msg (&msg [i]);
./src/plain_client.cpp:87:        rc = process_error (cmd_data, data_size);
./src/plain_client.cpp:204:int zmq::plain_client_t::process_error (
./src/socket_base.cpp:1357:        zmq_sendmsg (monitor_socket, &msg, ZMQ_SNDMORE);
./src/socket_base.cpp:1362:        zmq_sendmsg (monitor_socket, &msg, 0);
./src/tcp.cpp:162:    //  we'll get an error (this may happen during the speculative write).
./src/tcp.cpp:215:    //  we'll get an error (this may happen during the speculative read).
./src/stream_engine.cpp:98:    next_msg (&stream_engine_t::identity_msg),
./src/stream_engine.cpp:99:    process_msg (&stream_engine_t::process_identity_msg),
./src/stream_engine.cpp:100:    io_error (false),
./src/stream_engine.cpp:313:            error (connection_error);
./src/stream_engine.cpp:318:                error (connection_error);
./src/stream_engine.cpp:336:        rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:345:            error (protocol_error);
./src/stream_engine.cpp:376:            encoder->load_msg (&tx_msg);
./src/stream_engine.cpp:441:    int rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:446:            error (protocol_error);
./src/stream_engine.cpp:458:        rc = (this->*process_msg) (decoder->msg ());
./src/stream_engine.cpp:467:        error (connection_error);
./src/stream_engine.cpp:470:        error (protocol_error);
./src/stream_engine.cpp:490:            error (connection_error);
./src/stream_engine.cpp:495:                error (connection_error);
./src/stream_engine.cpp:571:           error (protocol_error);
./src/stream_engine.cpp:593:        encoder->load_msg (&tx_msg);
./src/stream_engine.cpp:618:           error (protocol_error);
./src/stream_engine.cpp:634:           error (protocol_error);
./src/stream_engine.cpp:695:            error (protocol_error);
./src/stream_engine.cpp:718:int zmq::stream_engine_t::identity_msg (msg_t *msg_)
./src/stream_engine.cpp:728:int zmq::stream_engine_t::process_identity_msg (msg_t *msg_)
./src/stream_engine.cpp:732:        int rc = session->push_msg (msg_);
./src/stream_engine.cpp:796:        error (protocol_error);
./src/stream_engine.cpp:810:        const int rc = session->push_msg (&identity);
./src/stream_engine.cpp:849:    return session->pull_msg (msg_);
./src/stream_engine.cpp:854:    return session->push_msg (msg_);
./src/stream_engine.cpp:875:        rc = session->push_msg (&msg);
./src/stream_engine.cpp:890:    if (session->pull_msg (msg_) == -1)
./src/stream_engine.cpp:905:    if (session->push_msg (msg_) == -1) {
./src/stream_engine.cpp:915:    const int rc = session->push_msg (msg_);
./src/stream_engine.cpp:921:int zmq::stream_engine_t::write_subscription_msg (msg_t *msg_)
./src/stream_engine.cpp:930:    rc = session->push_msg (&subscription);
./src/stream_engine.cpp:938:void zmq::stream_engine_t::error (error_reason_t reason)
./src/stream_engine.cpp:951:    session->engine_error (reason);
./src/stream_engine.cpp:972:    error (timeout_error);
./src/req.cpp:263:int zmq::req_session_t::push_msg (msg_t *msg_)
./src/req.cpp:269:            return session_base_t::push_msg (msg_);
./src/req.cpp:274:            return session_base_t::push_msg (msg_);
./src/req.cpp:277:            return session_base_t::push_msg (msg_);
./src/err.cpp:66:        return strerror (errno_);
./src/err.cpp:89:const char *zmq::wsa_error()
./src/err.cpp:210:void zmq::win_error (char *buffer_, size_t buffer_size_)
./src/zmq.cpp:100:const char *zmq_strerror (int errnum_)
./src/zmq.cpp:343:s_sendmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:353:int zmq_sendmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:371:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:397:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:438:        rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:454:s_recvmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:463:int zmq_recvmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:480:    int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:536:        int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:590:    int result = s_sendmsg (s, msg_, flags_);
./src/zmq.cpp:601:    int result = s_recvmsg (s, msg_, flags_);
./src/zmq.cpp:644:            return (((zmq::msg_t*) msg_)->is_cmsg ()) ||
./src/router.cpp:195:        //  If we have malformed message (prefix with no subsequent message)
./tests/test_system.cpp:47:        throw std::runtime_error("Could not start WSA");
./tests/test_disconnect_inproc.cpp:34:zmq_msg_init(&msg) && printf("zmq_msg_init: %s\n", zmq_strerror(errno)); \
./tests/test_disconnect_inproc.cpp:35:zmq_msg_init_size (&msg, size + 1) && printf("zmq_msg_init_size: %s\n",zmq_strerror(errno)); \
./tests/test_disconnect_inproc.cpp:47:    (pubSocket = zmq_socket(context, ZMQ_XPUB))         || printf("zmq_socket: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:48:    (subSocket = zmq_socket(context, ZMQ_SUB))          || printf("zmq_socket: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:49:    zmq_setsockopt(subSocket, ZMQ_SUBSCRIBE, "foo", 3)  && printf("zmq_setsockopt: %s\n",zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:51:    zmq_bind(pubSocket, "inproc://someInProcDescriptor") && printf("zmq_bind: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:52:    //zmq_bind(pubSocket, "tcp://127.0.0.1:30010") && printf("zmq_bind: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:104:            zmq_connect(subSocket, "inproc://someInProcDescriptor") && printf("zmq_connect: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:105:            //zmq_connect(subSocket, "tcp://127.0.0.1:30010") && printf("zmq_connect: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:108:            zmq_disconnect(subSocket, "inproc://someInProcDescriptor") && printf("zmq_disconnect(%d): %s\n", errno, zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:109:            //zmq_disconnect(subSocket, "tcp://127.0.0.1:30010") && printf("zmq_disconnect: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:116:        zmq_msg_send (&channelEnvlp, pubSocket, ZMQ_SNDMORE) >= 0 || printf("zmq_msg_send: %s\n",zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:117:        zmq_msg_close(&channelEnvlp) && printf("zmq_msg_close: %s\n",zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:121:        zmq_msg_send (&message, pubSocket, 0) >= 0 || printf("zmq_msg_send: %s\n",zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:122:        zmq_msg_close(&message) && printf("zmq_msg_close: %s\n",zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:129:    zmq_close(pubSocket) && printf("zmq_close: %s", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:130:    zmq_close(subSocket) && printf("zmq_close: %s", zmq_strerror(errno));
./tests/test_conflate.cpp:61:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./tests/test_hwm.cpp:79:int count_msg (int send_hwm, int recv_hwm, TestType testType)
./tests/test_hwm.cpp:159:    return count_msg(send_hwm, recv_hwm, BIND_FIRST);
./tests/test_hwm.cpp:164:    return count_msg(send_hwm, recv_hwm, CONNECT_FIRST);
./tests/test_reqrep_device_tipc.cpp:79:        rc = zmq_recvmsg (router, &msg, 0);
./tests/test_reqrep_device_tipc.cpp:85:        rc = zmq_sendmsg (dealer, &msg, rcvmore ? ZMQ_SNDMORE : 0);
./tests/test_reqrep_device_tipc.cpp:117:        rc = zmq_recvmsg (dealer, &msg, 0);
./tests/test_reqrep_device_tipc.cpp:122:        rc = zmq_sendmsg (router, &msg, rcvmore ? ZMQ_SNDMORE : 0);
./tests/test_srcfd.cpp:71:    zmq_recvmsg(rep, &msg, 0);
./perf/remote_lat.cpp:61:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:67:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:73:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:79:        printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:87:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_lat.cpp:89:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:92:        rc = zmq_recvmsg (s, &msg, 0);
./perf/remote_lat.cpp:94:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:107:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:119:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/remote_lat.cpp:125:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:57:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:63:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:69:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:75:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:80:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:82:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:89:        rc = zmq_sendmsg (s, &msg, 0);
./perf/local_lat.cpp:91:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:98:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:106:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/local_lat.cpp:112:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:64:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:70:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:78:            printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:85:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:87:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:92:            printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:99:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:137:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:143:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:149:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:163:        printf ("error in pthread_create: %s\n", zmq_strerror (rc));
./perf/inproc_thr.cpp:170:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:177:    rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:179:        printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:190:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:192:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:207:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:225:        printf ("error in pthread_join: %s\n", zmq_strerror (rc));
./perf/inproc_thr.cpp:232:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_thr.cpp:238:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:58:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:64:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:73:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:80:            printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:83:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_thr.cpp:85:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:90:            printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:97:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/remote_thr.cpp:103:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:60:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:66:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:75:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:81:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:85:    rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:87:        printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:98:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:100:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:115:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:130:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/local_thr.cpp:136:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:62:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:68:        printf ("error in zmq_connect: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:74:        printf ("error in zmq_msg_init: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:79:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:81:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:84:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:86:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:93:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:99:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:136:        printf ("error in zmq_init: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:142:        printf ("error in zmq_socket: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:148:        printf ("error in zmq_bind: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:162:        printf ("error in pthread_create: %s\n", zmq_strerror (rc));
./perf/inproc_lat.cpp:169:        printf ("error in zmq_msg_init_size: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:180:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:182:            printf ("error in zmq_sendmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:185:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:187:            printf ("error in zmq_recvmsg: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:200:        printf ("error in zmq_msg_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:220:        printf ("error in pthread_join: %s\n", zmq_strerror (rc));
./perf/inproc_lat.cpp:229:        printf ("error in zmq_close: %s\n", zmq_strerror (errno));
./perf/inproc_lat.cpp:235:        printf ("error in zmq_term: %s\n", zmq_strerror (errno));
./builds/msvc/errno.cpp:12:char* strerror(int errno)
./include/zmq.h:169:ZMQ_EXPORT const char *zmq_strerror (int errnum);
./include/zmq.h:414:ZMQ_EXPORT int zmq_sendmsg (void *s, zmq_msg_t *msg, int flags);
./include/zmq.h:415:ZMQ_EXPORT int zmq_recvmsg (void *s, zmq_msg_t *msg, int flags);

== environment() ==

== privileged() ==
./src/tcp_address.cpp:69:    int rc = ioctl (fd, SIOCGLIFNUM, (char*) &ifn);
./src/tcp_address.cpp:83:    rc = ioctl (fd, SIOCGLIFCONF, (char*) &ifc);
./src/tcp_address.cpp:92:            rc = ioctl (fd, SIOCGLIFADDR, (char*) ifrp);
./src/tcp_address.cpp:144:    const int rc = ioctl (sd, SIOCGIFADDR, (caddr_t) &ifr, sizeof ifr);
./src/devpoll.cpp:175:        int n = ioctl (devpoll_fd, DP_POLL, &poll_req);
./src/ip.cpp:91:    int rc = ioctl (s_, FIONBIO, &nonblock);

== networking() ==
./src/socks_connecter.cpp:321:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/socks_connecter.cpp:332:    if (tcp_addr->family () == AF_INET6)
./src/signaler.cpp:401:    listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:417:    addr.sin_family = AF_INET;
./src/signaler.cpp:422:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:522:    //  Whilst OpenVMS supports socketpair - it maps to AF_INET only.  Further,
./src/signaler.cpp:530:    lcladdr.sin_family = AF_INET;
./src/signaler.cpp:534:    int listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:555:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:577:    int rc = socketpair (AF_UNIX, SOCK_STREAM, 0, sv);
./src/tcp_address.cpp:62:    const int fd = open_socket (AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:67:    ifn.lifn_family = AF_INET;
./src/tcp_address.cpp:79:    ifc.lifc_family = AF_INET;
./src/tcp_address.cpp:86:    //  Find the interface with the specified name and AF_INET family.
./src/tcp_address.cpp:94:            if (ifrp->lifr_addr.ss_family == AF_INET) {
./src/tcp_address.cpp:135:    const int sd = open_socket (ipv6_ ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:155:    if ((family == AF_INET || (ipv6_ && family == AF_INET6))
./src/tcp_address.cpp:160:                    (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:164:                    (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:201:        if ((family == AF_INET || (ipv6_ && family == AF_INET6))
./src/tcp_address.cpp:205:                        (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:209:                        (family == AF_INET) ? sizeof (struct sockaddr_in)
./src/tcp_address.cpp:254:        ip6_addr.sin6_family = AF_INET6;
./src/tcp_address.cpp:262:        ip4_addr.sin_family = AF_INET;
./src/tcp_address.cpp:294:    req.ai_family = ipv6_? AF_INET6: AF_INET;
./src/tcp_address.cpp:297:    req.ai_socktype = SOCK_STREAM;
./src/tcp_address.cpp:309:    if (req.ai_family == AF_INET6)
./src/tcp_address.cpp:347:    req.ai_family = ipv6_? AF_INET6: AF_INET;
./src/tcp_address.cpp:351:    req.ai_socktype = SOCK_STREAM;
./src/tcp_address.cpp:359:    if (req.ai_family == AF_INET6)
./src/tcp_address.cpp:409:    if (sa->sa_family == AF_INET && sa_len >= (socklen_t) sizeof address.ipv4)
./src/tcp_address.cpp:412:    if (sa->sa_family == AF_INET6 && sa_len >= (socklen_t) sizeof address.ipv6)
./src/tcp_address.cpp:476:        if (source_address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:482:        if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:493:    if (address.generic.sa_family != AF_INET
./src/tcp_address.cpp:494:    &&  address.generic.sa_family != AF_INET6) {
./src/tcp_address.cpp:508:    if (address.generic.sa_family == AF_INET6) {
./src/tcp_address.cpp:528:    if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:541:    if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:597:        if (address.generic.sa_family == AF_INET6)
./src/tcp_address.cpp:609:            (address.generic.sa_family == AF_INET6 && mask > 128) ||
./src/tcp_address.cpp:610:            (address.generic.sa_family != AF_INET6 && mask > 32)
./src/tcp_address.cpp:623:    if (address.generic.sa_family != AF_INET
./src/tcp_address.cpp:624:    &&  address.generic.sa_family != AF_INET6) {
./src/tcp_address.cpp:640:    if (address.generic.sa_family == AF_INET6) {
./src/tcp_address.cpp:665:        if (ss->sa_family == AF_INET6) {
./src/tcp_connecter.cpp:237:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:240:    if (s == zmq::retired_fd && tcp_addr->family () == AF_INET6
./src/tcp_connecter.cpp:250:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:265:    if (tcp_addr->family () == AF_INET6)
./src/tipc_connecter.cpp:205:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tcp_listener.cpp:169:    s = open_socket (address.family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:172:    if (s == zmq::retired_fd && address.family () == AF_INET6
./src/tcp_listener.cpp:178:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:198:    if (address.family () == AF_INET6)
./src/ipc_listener.cpp:171:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ip.cpp:53:#if defined ZMQ_HAVE_SOCK_CLOEXEC
./src/ip.cpp:54:    type_ |= SOCK_CLOEXEC;
./src/ip.cpp:66:    //  If there's no SOCK_CLOEXEC, let's try the second best option. Note that
./src/ip.cpp:69:#if !defined ZMQ_HAVE_SOCK_CLOEXEC && defined FD_CLOEXEC
./src/tipc_address.cpp:49:    if (sa->sa_family == AF_TIPC)
./src/tipc_address.cpp:68:        address.family = AF_TIPC;
./src/tipc_address.cpp:84:    address.family = AF_TIPC;
./src/tipc_address.cpp:95:    if (address.family != AF_TIPC) {
./src/stream_engine.cpp:119:    if (family == PF_UNIX) {
./src/stream_engine.cpp:130:    if (family == PF_UNIX) {
./src/socks.cpp:159:    if (rc == 0 && res->ai_family == AF_INET) {
./src/socks.cpp:167:    if (rc == 0 && res->ai_family == AF_INET6) {
./src/tipc_listener.cpp:132:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/ipc_address.cpp:49:    if (sa->sa_family == AF_UNIX)
./src/ipc_address.cpp:68:    address.sun_family = AF_UNIX;
./src/ipc_address.cpp:78:    if (address.sun_family != AF_UNIX) {
./src/pgm_socket.cpp:98:    hints.ai_family = AF_UNSPEC;
./src/pgm_socket.cpp:150:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_UDP,
./src/pgm_socket.cpp:178:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_PGM,
./src/pgm_socket.cpp:299:    if (AF_INET6 == sa_family) {
./src/pgm_socket.cpp:351:		if (AF_INET6 != sa_family)
./src/ipc_connecter.cpp:207:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./tests/test_system.cpp:84:        handle [count] = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_curve.cpp:246:    ip4addr.sin_family = AF_INET;
./tests/test_security_curve.cpp:251:     inet_pton(AF_INET, "127.0.0.1", &ip4addr.sin_addr);
./tests/test_security_curve.cpp:254:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_null.cpp:159:    ip4addr.sin_family = AF_INET;
./tests/test_security_null.cpp:164:     inet_pton(AF_INET, "127.0.0.1", &ip4addr.sin_addr);
./tests/test_security_null.cpp:167:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_plain.cpp:165:    ip4addr.sin_family = AF_INET;
./tests/test_security_plain.cpp:170:     inet_pton(AF_INET, "127.0.0.1", &ip4addr.sin_addr);
./tests/test_security_plain.cpp:173:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/lb.cpp:103:        if (pipes [current]->write (msg_))
./src/lb.cpp:149:        if (pipes [current]->check_write ())
./src/fq.cpp:98:        bool fetched = pipes [current]->read (msg_);
./src/fq.cpp:144:        if (pipes [current]->check_read ())
./src/socks_connecter.cpp:69:    socket = session->get_socket ();
./src/socks_connecter.cpp:83:        initiate_connect ();
./src/socks_connecter.cpp:219:void zmq::socks_connecter_t::initiate_connect ()
./src/socks_connecter.cpp:263:    initiate_connect ();
./src/socks_connecter.cpp:321:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/socks_connecter.cpp:339:    // Set the socket to non-blocking mode so that we get async connect().
./src/socks_connecter.cpp:340:    unblock_socket (s);
./src/socks_connecter.cpp:354:        rc = ::bind (s, tcp_addr->src_addr (), tcp_addr->src_addrlen ());
./src/socks_connecter.cpp:362:    rc = ::connect (s, tcp_addr->addr (), tcp_addr->addrlen ());
./src/socks_connecter.cpp:432:    tune_tcp_socket (s);
./src/socks_connecter.cpp:443:    const int rc = closesocket (s);
./src/curve_server.cpp:502:    rc = session->zap_connect ();
./src/object.cpp:77:        process_activate_read ();
./src/object.cpp:81:        process_activate_write (cmd_.args.activate_write.msgs_read);
./src/object.cpp:104:        process_bind (cmd_.args.bind.pipe);
./src/object.cpp:183:void zmq::object_t::destroy_socket (socket_base_t *socket_)
./src/object.cpp:185:    ctx->destroy_socket (socket_);
./src/object.cpp:188:zmq::io_thread_t *zmq::object_t::choose_io_thread (uint64_t affinity_)
./src/object.cpp:190:    return ctx->choose_io_thread (affinity_);
./src/object.cpp:237:void zmq::object_t::send_bind (own_t *destination_, pipe_t *pipe_,
./src/object.cpp:250:void zmq::object_t::send_activate_read (pipe_t *destination_)
./src/object.cpp:258:void zmq::object_t::send_activate_write (pipe_t *destination_,
./src/object.cpp:373:void zmq::object_t::process_bind (pipe_t *)
./src/object.cpp:378:void zmq::object_t::process_activate_read ()
./src/object.cpp:383:void zmq::object_t::process_activate_write (uint64_t)
./src/xsub.cpp:236:    bool sent = pipe->write (&msg);
./src/poll.cpp:120:    ctx.start_thread (worker, worker_routine, this);
./src/plain_server.cpp:195:    int rc = session->zap_connect ();
./src/kqueue.cpp:158:    ctx.start_thread (worker, worker_routine, this);
./src/session_base.cpp:90:    socket (socket_),
./src/session_base.cpp:91:    io_thread (io_thread_),
./src/session_base.cpp:126:    if (!pipe || !pipe->read (msg_)) {
./src/session_base.cpp:138:    if (pipe && pipe->write (msg_)) {
./src/session_base.cpp:155:    if (!zap_pipe->read (msg_)) {
./src/session_base.cpp:170:    const bool ok = zap_pipe->write (msg_);
./src/session_base.cpp:259:        pipe->check_read ();
./src/session_base.cpp:288:zmq::socket_base_t *zmq::session_base_t::get_socket ()
./src/session_base.cpp:299:int zmq::session_base_t::zap_connect ()
./src/session_base.cpp:328:    send_bind (peer.socket, new_pipes [1], false);
./src/session_base.cpp:336:        bool ok = zap_pipe->write (&id);
./src/session_base.cpp:382:        send_bind (socket, pipes [1]);
./src/session_base.cpp:409:                reconnect ();
./src/session_base.cpp:420:        pipe->check_read ();
./src/session_base.cpp:423:        zap_pipe->check_read ();
./src/session_base.cpp:458:            pipe->check_read ();
./src/session_base.cpp:477:void zmq::session_base_t::reconnect ()
./src/session_base.cpp:508:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/signaler.cpp:128:        unblock_socket (w);
./src/signaler.cpp:129:        unblock_socket (r);
./src/signaler.cpp:148:        rc = closesocket (w);
./src/signaler.cpp:150:        rc = closesocket (r);
./src/signaler.cpp:176:    ssize_t sz = write (w, &inc, sizeof (inc));
./src/signaler.cpp:281:    ssize_t sz = read (r, &dummy, sizeof (dummy));
./src/signaler.cpp:288:        ssize_t sz2 = write (w, &inc, sizeof (inc));
./src/signaler.cpp:401:    listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:422:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:437:    rc = bind (listener, (const struct sockaddr*) &addr, sizeof addr);
./src/signaler.cpp:447:        rc = listen (listener, 1);
./src/signaler.cpp:451:        rc = connect (*w_, (struct sockaddr*) &addr, sizeof addr);
./src/signaler.cpp:484:    closesocket (listener);
./src/signaler.cpp:511:            rc = closesocket (*w_);
./src/signaler.cpp:534:    int listener = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:544:    rc = bind (listener, (struct sockaddr*) &lcladdr, sizeof lcladdr);
./src/signaler.cpp:552:    rc = listen (listener, 1);
./src/signaler.cpp:555:    *w_ = open_socket (AF_INET, SOCK_STREAM, 0);
./src/signaler.cpp:564:    rc = connect (*w_, (struct sockaddr*) &lcladdr, sizeof lcladdr);
./src/mailbox.cpp:38:    const bool ok = cpipe.read (NULL);
./src/mailbox.cpp:61:    cpipe.write (cmd_, false);
./src/mailbox.cpp:72:        if (cpipe.read (cmd_))
./src/mailbox.cpp:93:    const bool ok = cpipe.read (cmd_);
./src/stream.cpp:116:                if (!current_out->check_write ()) {
./src/stream.cpp:160:        bool ok = current_out->write (msg_);
./src/pgm_sender.cpp:55:    pgm_socket (false, options_),
./src/dealer.cpp:57:        rc = pipe_->write (&probe_msg_);
./src/tcp_address.cpp:62:    const int fd = open_socket (AF_INET, SOCK_DGRAM, 0);
./src/tcp_address.cpp:135:    const int sd = open_socket (ipv6_ ? AF_INET6 : AF_INET, SOCK_DGRAM, 0);
./src/devpoll.cpp:65:    ssize_t rc = write (devpoll_fd, &pfd, sizeof pfd);
./src/devpoll.cpp:139:    ctx.start_thread (worker, worker_routine, this);
./src/pipe.cpp:84:    msgs_read (0),
./src/pipe.cpp:86:    peers_msgs_read (0),
./src/pipe.cpp:128:bool zmq::pipe_t::check_read ()
./src/pipe.cpp:136:    if (!inpipe->check_read ()) {
./src/pipe.cpp:145:        bool ok = inpipe->read (&msg);
./src/pipe.cpp:154:bool zmq::pipe_t::read (msg_t *msg_)
./src/pipe.cpp:162:    if (!inpipe->read (msg_)) {
./src/pipe.cpp:186:        send_activate_write (peer, msgs_read);
./src/pipe.cpp:191:bool zmq::pipe_t::check_write ()
./src/pipe.cpp:206:bool zmq::pipe_t::write (msg_t *msg_)
./src/pipe.cpp:208:    if (unlikely (!check_write ()))
./src/pipe.cpp:213:    outpipe->write (*msg_, more);
./src/pipe.cpp:225:        while (outpipe->unwrite (&msg)) {
./src/pipe.cpp:240:        send_activate_read (peer);
./src/pipe.cpp:243:void zmq::pipe_t::process_activate_read ()
./src/pipe.cpp:251:void zmq::pipe_t::process_activate_write (uint64_t msgs_read_)
./src/pipe.cpp:269:    while (outpipe->read (&msg)) {
./src/pipe.cpp:353:        while (inpipe->read (&msg)) {
./src/pipe.cpp:432:        outpipe->write (msg, false);
./src/pgm_receiver.cpp:51:    pgm_socket (true, options_),
./src/gssapi_server.cpp:128:        int rc = session->zap_connect ();
./src/tcp_connecter.cpp:77:    socket = session->get_socket ();
./src/tcp_connecter.cpp:126:    const fd_t fd = connect ();
./src/tcp_connecter.cpp:134:    tune_tcp_socket (fd);
./src/tcp_connecter.cpp:237:    s = open_socket (tcp_addr->family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:250:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_connecter.cpp:272:    // Set the socket to non-blocking mode so that we get async connect().
./src/tcp_connecter.cpp:273:    unblock_socket (s);
./src/tcp_connecter.cpp:287:        rc = ::bind (s, tcp_addr->src_addr (), tcp_addr->src_addrlen ());
./src/tcp_connecter.cpp:293:    rc = ::connect (s, tcp_addr->addr (), tcp_addr->addrlen ());
./src/tcp_connecter.cpp:314:zmq::fd_t zmq::tcp_connecter_t::connect ()
./src/tcp_connecter.cpp:374:    const int rc = closesocket (s);
./src/tipc_connecter.cpp:67:    socket = session-> get_socket();
./src/tipc_connecter.cpp:113:    fd_t fd = connect ();
./src/tipc_connecter.cpp:205:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tipc_connecter.cpp:210:    unblock_socket (s);
./src/tipc_connecter.cpp:212:    int rc = ::connect (
./src/tipc_connecter.cpp:239:zmq::fd_t zmq::tipc_connecter_t::connect ()
./src/null_mechanism.cpp:62:    &&  session->zap_connect () == 0)
./src/thread.cpp:55:    descriptor = (HANDLE) CreateThread (NULL, 0,
./src/tcp_listener.cpp:67:    socket (socket_)
./src/tcp_listener.cpp:101:    tune_tcp_socket (fd);
./src/tcp_listener.cpp:114:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/tcp_listener.cpp:131:    int rc = closesocket (s);
./src/tcp_listener.cpp:169:    s = open_socket (address.family (), SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:178:        s = open_socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/tcp_listener.cpp:225:    rc = bind (s, address.addr (), address.addrlen ());
./src/tcp_listener.cpp:237:    rc = listen (s, options.backlog);
./src/tcp_listener.cpp:314:            int rc = closesocket (sock);
./src/ctx.cpp:58:int clipped_maxsocket(int max_requested)
./src/ctx.cpp:74:    max_sockets (clipped_maxsocket (ZMQ_MAX_SOCKETS_DFLT)),
./src/ctx.cpp:127:        zmq::socket_base_t *s = create_socket (ZMQ_PAIR);
./src/ctx.cpp:128:        s->bind (p->first.c_str ());
./src/ctx.cpp:204:    &&  optval_ >= 1 && optval_ == clipped_maxsocket (optval_)) {
./src/ctx.cpp:247:        rc = clipped_maxsocket (65535);
./src/ctx.cpp:261:zmq::socket_base_t *zmq::ctx_t::create_socket (int type_)
./src/ctx.cpp:338:void zmq::ctx_t::destroy_socket (class socket_base_t *socket_)
./src/ctx.cpp:363:void zmq::ctx_t::start_thread (thread_t &thread_, thread_fn *tfn_, void *arg_) const
./src/ctx.cpp:374:zmq::io_thread_t *zmq::ctx_t::choose_io_thread (uint64_t affinity_)
./src/ctx.cpp:514:        const bool ok = pending_connection_.bind_pipe->read (&msg);
./src/ctx.cpp:548:        pending_connection_.connect_pipe->send_bind (bind_socket_, pending_connection_.bind_pipe, false);
./src/ctx.cpp:556:        bool written = pending_connection_.bind_pipe->write (&id);
./src/pair.cpp:88:    if (!pipe || !pipe->write (msg_)) {
./src/pair.cpp:109:    if (!pipe || !pipe->read (msg_)) {
./src/pair.cpp:127:    return pipe->check_read ();
./src/pair.cpp:135:    return pipe->check_write ();
./src/ipc_listener.cpp:72:    socket (socket_)
./src/ipc_listener.cpp:113:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/ipc_listener.cpp:171:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ipc_listener.cpp:178:    rc = bind (s, address.addr (), address.addrlen ());
./src/ipc_listener.cpp:186:    rc = listen (s, options.backlog);
./src/select.cpp:150:    ctx.start_thread (worker, worker_routine, this);
./src/ip.cpp:49:zmq::fd_t zmq::open_socket (int domain_, int type_, int protocol_)
./src/ip.cpp:57:    fd_t s = socket (domain_, type_, protocol_);
./src/ip.cpp:83:void zmq::unblock_socket (fd_t s_)
./src/ip.cpp:87:    int rc = ioctlsocket (s_, FIONBIO, &nonblock);
./src/socket_base.cpp:152:    monitor_socket (NULL),
./src/socket_base.cpp:355:int zmq::socket_base_t::bind (const char *addr_)
./src/socket_base.cpp:386:        return connect (addr_);
./src/socket_base.cpp:391:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/socket_base.cpp:458:int zmq::socket_base_t::connect (const char *addr_)
./src/socket_base.cpp:528:            bool written = new_pipes [0]->write (&id);
./src/socket_base.cpp:543:                bool written = new_pipes [0]->write (&id);
./src/socket_base.cpp:555:                bool written = new_pipes [1]->write (&id);
./src/socket_base.cpp:563:            send_bind (peer.socket, new_pipes [1], false);
./src/socket_base.cpp:588:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/socket_base.cpp:1076:void zmq::socket_base_t::process_bind (pipe_t *pipe_)
./src/socket_base.cpp:1178:        destroy_socket (this);
./src/socket_base.cpp:1260:    monitor_socket = zmq_socket (get_ctx (), ZMQ_PAIR);
./src/socket_base.cpp:1271:    rc = zmq_bind (monitor_socket, addr_);
./src/socket_base.cpp:1357:        zmq_sendmsg (monitor_socket, &msg, ZMQ_SNDMORE);
./src/socket_base.cpp:1362:        zmq_sendmsg (monitor_socket, &msg, 0);
./src/dist.cpp:157:            if(!write (pipes [i], msg_))
./src/dist.cpp:173:        if (!write (pipes [i], msg_)) {
./src/dist.cpp:191:bool zmq::dist_t::write (pipe_t *pipe_, msg_t *msg_)
./src/dist.cpp:193:    if (!pipe_->write (msg_)) {
./src/tcp.cpp:49:void zmq::tune_tcp_socket (fd_t s_)
./src/tcp.cpp:155:int zmq::tcp_write (fd_t s_, const void *data_, size_t size_)
./src/tcp.cpp:208:int zmq::tcp_read (fd_t s_, void *data_, size_t size_)
./src/stream_engine.cpp:93:    greeting_bytes_read (0),
./src/stream_engine.cpp:106:    socket (NULL)
./src/stream_engine.cpp:112:    unblock_socket (s);
./src/stream_engine.cpp:160:        int rc = closesocket (s);
./src/stream_engine.cpp:199:    socket = session-> get_socket ();
./src/stream_engine.cpp:311:        const int rc = tcp_read (s, inpos, bufsize);
./src/stream_engine.cpp:398:    const int nbytes = tcp_write (s, outpos, outsize);
./src/stream_engine.cpp:487:        const int n = tcp_read (s, greeting_recv + greeting_bytes_read,
./src/socks.cpp:78:    const int rc = tcp_write (
./src/socks.cpp:100:    : bytes_read (0)
./src/socks.cpp:106:    const int rc = tcp_read (fd_, buf + bytes_read, 2 - bytes_read);
./src/socks.cpp:193:    const int rc = tcp_write (
./src/socks.cpp:216:    : bytes_read (0)
./src/socks.cpp:237:    const int rc = tcp_read (fd_, buf + bytes_read, n);
./src/tipc_listener.cpp:57:    socket (socket_)
./src/tipc_listener.cpp:97:    io_thread_t *io_thread = choose_io_thread (options.affinity);
./src/tipc_listener.cpp:132:    s = open_socket (AF_TIPC, SOCK_STREAM, 0);
./src/tipc_listener.cpp:139:    rc = bind (s, address.addr (), address.addrlen ());
./src/tipc_listener.cpp:144:    rc = listen (s, options.backlog);
./src/zmq.cpp:243:void *zmq_socket (void *ctx_, int type_)
./src/zmq.cpp:250:    zmq::socket_base_t *s = ctx->create_socket (type_);
./src/zmq.cpp:298:int zmq_bind (void *s_, const char *addr_)
./src/zmq.cpp:305:    int result = s->bind (addr_);
./src/zmq.cpp:309:int zmq_connect (void *s_, const char *addr_)
./src/zmq.cpp:316:    int result = s->connect (addr_);
./src/zmq.cpp:320:int zmq_unbind (void *s_, const char *addr_)
./src/zmq.cpp:330:int zmq_disconnect (void *s_, const char *addr_)
./src/zmq.cpp:343:s_sendmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:353:int zmq_sendmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:371:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:397:    rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:438:        rc = s_sendmsg (s, &msg, flags_);
./src/zmq.cpp:454:s_recvmsg (zmq::socket_base_t *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:463:int zmq_recvmsg (void *s_, zmq_msg_t *msg_, int flags_)
./src/zmq.cpp:480:    int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:536:        int nbytes = s_recvmsg (s, &msg, flags_);
./src/zmq.cpp:590:    int result = s_sendmsg (s, msg_, flags_);
./src/zmq.cpp:601:    int result = s_recvmsg (s, msg_, flags_);
./src/epoll.cpp:132:    ctx.start_thread (worker, worker_routine, this);
./src/pgm_socket.cpp:150:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_UDP,
./src/pgm_socket.cpp:178:        if (!pgm_socket (&sock, sa_family, SOCK_SEQPACKET, IPPROTO_PGM,
./src/pgm_socket.cpp:362:    if (!pgm_connect (sock, &pgm_error)) {
./src/ipc_connecter.cpp:68:    socket = session-> get_socket();
./src/ipc_connecter.cpp:114:    fd_t fd = connect ();
./src/ipc_connecter.cpp:207:    s = open_socket (AF_UNIX, SOCK_STREAM, 0);
./src/ipc_connecter.cpp:212:    unblock_socket (s);
./src/ipc_connecter.cpp:215:    int rc = ::connect (
./src/ipc_connecter.cpp:244:zmq::fd_t zmq::ipc_connecter_t::connect ()
./src/xpub.cpp:69:    while (pipe_->read (&sub)) {
./src/router.cpp:79:        rc = pipe_->write (&probe_msg_);
./src/router.cpp:210:                if (!current_out->check_write ()) {
./src/router.cpp:258:        bool ok = current_out->write (msg_);
./src/router.cpp:424:        ok = pipe_->read (&msg);
./tests/test_issue_566.cpp:47:    void *router = zmq_socket (ctx1, ZMQ_ROUTER);
./tests/test_issue_566.cpp:51:    rc = zmq_bind (router, "tcp://127.0.0.1:5555");
./tests/test_issue_566.cpp:58:        void *dealer = zmq_socket (ctx2, ZMQ_DEALER);
./tests/test_issue_566.cpp:66:        rc = zmq_connect (dealer, "tcp://127.0.0.1:5555");
./tests/test_connect_rid.cpp:43:    rbind = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_connect_rid.cpp:47:    ret = zmq_bind (rbind, bindip);
./tests/test_connect_rid.cpp:51:    rconn1 = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_connect_rid.cpp:59:    ret = zmq_connect (rconn1, bindip);
./tests/test_connect_rid.cpp:65:    ret = zmq_connect (rconn1, bindip);
./tests/test_connect_rid.cpp:89:    ret = zmq_unbind (rbind, bindip);
./tests/test_connect_rid.cpp:109:    rbind = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_connect_rid.cpp:113:    ret = zmq_bind (rbind, bindip);
./tests/test_connect_rid.cpp:117:    rconn1 = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_connect_rid.cpp:131:    ret = zmq_connect (rconn1, bindip);
./tests/test_connect_rid.cpp:137:    ret = zmq_connect (rconn1, bindip);
./tests/test_connect_rid.cpp:175:    ret = zmq_unbind (rbind, bindip);
./tests/test_spec_req.cpp:37:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_spec_req.cpp:40:    int rc = zmq_bind (req, bind_address);
./tests/test_spec_req.cpp:46:        rep [peer] = zmq_socket (ctx, ZMQ_REP);
./tests/test_spec_req.cpp:53:        rc = zmq_connect (rep [peer], connect_address);
./tests/test_spec_req.cpp:80:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_spec_req.cpp:86:    rc = zmq_bind (req, bind_address);
./tests/test_spec_req.cpp:93:        router [i] = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_spec_req.cpp:104:        rc = zmq_connect (router [i], connect_address);
./tests/test_spec_req.cpp:146:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_spec_req.cpp:149:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_spec_req.cpp:152:    int rc = zmq_bind (req, bind_address);
./tests/test_spec_req.cpp:155:    rc = zmq_connect (router, connect_address);
./tests/test_spec_req.cpp:205:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_ctx_destroy.cpp:47:    void *socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_ctx_destroy.cpp:67:    void *socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_proxy_single_socket.cpp:41:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_proxy_single_socket.cpp:43:    int rc = zmq_bind (rep, "tcp://127.0.0.1:5563");
./tests/test_proxy_single_socket.cpp:47:    void *control = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy_single_socket.cpp:51:    rc = zmq_connect (control, "inproc://control");
./tests/test_proxy_single_socket.cpp:74:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_proxy_single_socket.cpp:76:    int rc = zmq_connect (req, "tcp://127.0.0.1:5563");
./tests/test_proxy_single_socket.cpp:80:    void *control = zmq_socket (ctx, ZMQ_PUB);
./tests/test_proxy_single_socket.cpp:82:    rc = zmq_bind (control, "inproc://control");
./tests/test_connect_resolve.cpp:38:    void *sock = zmq_socket (ctx, ZMQ_PUB);
./tests/test_connect_resolve.cpp:41:    int rc = zmq_connect (sock, "tcp://localhost:1234");
./tests/test_connect_resolve.cpp:44:    rc = zmq_connect (sock, "tcp://[::1]:4506");
./tests/test_connect_resolve.cpp:47:    rc = zmq_connect (sock, "tcp://localhost:invalid");
./tests/test_connect_resolve.cpp:50:    rc = zmq_connect (sock, "tcp://in val id:1234");
./tests/test_connect_resolve.cpp:53:    rc = zmq_connect (sock, "tcp://");
./tests/test_connect_resolve.cpp:56:    rc = zmq_connect (sock, "tcp://192.168.0.200:*");
./tests/test_connect_resolve.cpp:59:    rc = zmq_connect (sock, "invalid://localhost:1234");
./tests/test_filter_ipc.cpp:73:    void *sb = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_filter_ipc.cpp:86:    void *sc = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_filter_ipc.cpp:105:        int rc = zmq_bind (sb, endpoint);
./tests/test_filter_ipc.cpp:108:        rc = zmq_connect (sc, endpoint);
./tests/test_stream.cpp:61:    void *stream = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream.cpp:67:    rc = zmq_bind (stream, "tcp://127.0.0.1:5556");
./tests/test_stream.cpp:71:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_stream.cpp:75:    rc = zmq_connect (dealer, "tcp://localhost:5556");
./tests/test_stream.cpp:202:    void *server = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream.cpp:204:    rc = zmq_bind (server, "tcp://127.0.0.1:9070");
./tests/test_stream.cpp:207:    void *client = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream.cpp:209:    rc = zmq_connect (client, "tcp://localhost:9070");
./tests/test_router_mandatory_tipc.cpp:43:    void *sa = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_router_mandatory_tipc.cpp:46:    int rc = zmq_bind (sa, "tipc://{15560,0,0}");
./tests/test_system.cpp:52:    return closesocket (fd);
./tests/test_system.cpp:74:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_system.cpp:75:    if (zmq_bind (dealer, "tcp://127.0.0.1:5670") == -1) {
./tests/test_system.cpp:84:        handle [count] = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_spec_pushpull.cpp:37:    void *push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_spec_pushpull.cpp:40:    int rc = zmq_bind (push, bind_address);
./tests/test_spec_pushpull.cpp:46:        pulls [peer] = zmq_socket (ctx, ZMQ_PULL);
./tests/test_spec_pushpull.cpp:53:        rc = zmq_connect (pulls [peer], connect_address);
./tests/test_spec_pushpull.cpp:85:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_spec_pushpull.cpp:88:    int rc = zmq_bind (pull, bind_address);
./tests/test_spec_pushpull.cpp:95:        pushs [peer] = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_spec_pushpull.cpp:98:        rc = zmq_connect (pushs [peer], connect_address);
./tests/test_spec_pushpull.cpp:165:    void *sc = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_spec_pushpull.cpp:184:void test_destroy_queue_on_disconnect (void *ctx)
./tests/test_spec_pushpull.cpp:186:    void *A = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_spec_pushpull.cpp:193:    rc = zmq_bind (A, bind_address);
./tests/test_spec_pushpull.cpp:196:    void *B = zmq_socket (ctx, ZMQ_PULL);
./tests/test_spec_pushpull.cpp:202:    rc = zmq_connect (B, connect_address);
./tests/test_spec_pushpull.cpp:215:    rc = zmq_disconnect (B, connect_address);
./tests/test_spec_pushpull.cpp:240:    rc = zmq_connect (B, connect_address);
./tests/test_spec_pushpull.cpp:296:        // test_destroy_queue_on_disconnect (ctx);
./tests/test_reqrep_device.cpp:39:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_reqrep_device.cpp:41:    int rc = zmq_bind (dealer, "tcp://127.0.0.1:5560");
./tests/test_reqrep_device.cpp:43:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_reqrep_device.cpp:45:    rc = zmq_bind (router, "tcp://127.0.0.1:5561");
./tests/test_reqrep_device.cpp:49:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_device.cpp:51:    rc = zmq_connect (rep, "tcp://127.0.0.1:5560");
./tests/test_reqrep_device.cpp:55:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_device.cpp:57:    rc = zmq_connect (req, "tcp://127.0.0.1:5561");
./tests/test_req_correlate.cpp:38:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_req_correlate.cpp:41:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_req_correlate.cpp:52:    rc = zmq_connect (req, "tcp://localhost:5555");
./tests/test_req_correlate.cpp:55:    rc = zmq_bind (router, "tcp://127.0.0.1:5555");
./tests/test_ctx_options.cpp:55:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_unbind_wildcard.cpp:30:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:32:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:35:    int rc = zmq_bind (sb, "tcp://*:5555");
./tests/test_unbind_wildcard.cpp:43:    rc = zmq_connect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:48:    rc = zmq_disconnect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:50:    rc = zmq_unbind (sb, endpoint);
./tests/test_unbind_wildcard.cpp:59:    sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:61:    sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:69:    rc = zmq_bind (sb, "tcp://*:5556");
./tests/test_unbind_wildcard.cpp:77:    rc = zmq_connect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:82:    rc = zmq_disconnect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:84:    rc = zmq_unbind (sb, endpoint);
./tests/test_unbind_wildcard.cpp:93:    sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:95:    sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:98:    rc = zmq_bind (sb, "tcp://127.0.0.1:*");
./tests/test_unbind_wildcard.cpp:106:    rc = zmq_connect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:111:    rc = zmq_disconnect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:113:    rc = zmq_unbind (sb, endpoint);
./tests/test_unbind_wildcard.cpp:122:    sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:124:    sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:132:    rc = zmq_bind (sb, "tcp://127.0.0.1:*");
./tests/test_unbind_wildcard.cpp:140:    rc = zmq_connect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:145:    rc = zmq_disconnect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:147:    rc = zmq_unbind (sb, endpoint);
./tests/test_unbind_wildcard.cpp:157:        sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:159:        sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:167:        rc = zmq_bind (sb, "tcp://[::1]:*");
./tests/test_unbind_wildcard.cpp:175:        rc = zmq_connect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:180:        rc = zmq_disconnect (sc, endpoint);
./tests/test_unbind_wildcard.cpp:182:        rc = zmq_unbind (sb, endpoint);
./tests/test_unbind_wildcard.cpp:192:    sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:194:    sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:197:    rc = zmq_bind (sb, "tcp://127.0.0.1:5557");
./tests/test_unbind_wildcard.cpp:199:    rc = zmq_connect (sc, "tcp://127.0.0.1:5557");
./tests/test_unbind_wildcard.cpp:204:    rc = zmq_disconnect (sc, "tcp://127.0.0.1:5557");
./tests/test_unbind_wildcard.cpp:206:    rc = zmq_unbind (sb, "tcp://127.0.0.1:5557");
./tests/test_unbind_wildcard.cpp:215:    sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:217:    sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:225:    rc = zmq_bind (sb, "tcp://127.0.0.1:5558");
./tests/test_unbind_wildcard.cpp:227:    rc = zmq_connect (sc, "tcp://127.0.0.1:5558");
./tests/test_unbind_wildcard.cpp:232:    rc = zmq_disconnect (sc, "tcp://127.0.0.1:5558");
./tests/test_unbind_wildcard.cpp:234:    rc = zmq_unbind (sb, "tcp://127.0.0.1:5558");
./tests/test_unbind_wildcard.cpp:244:        sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_wildcard.cpp:246:        sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_unbind_wildcard.cpp:254:        rc = zmq_bind (sb, "tcp://[::1]:5559");
./tests/test_unbind_wildcard.cpp:256:        rc = zmq_connect (sc, "tcp://[::1]:5559");
./tests/test_unbind_wildcard.cpp:261:        rc = zmq_disconnect (sc, "tcp://[::1]:5559");
./tests/test_unbind_wildcard.cpp:263:        rc = zmq_unbind (sb, "tcp://[::1]:5559");
./tests/test_router_mandatory_hwm.cpp:48:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_router_mandatory_hwm.cpp:62:    rc = zmq_bind (router, "tcp://127.0.0.1:5560");
./tests/test_router_mandatory_hwm.cpp:66:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_router_mandatory_hwm.cpp:74:    rc = zmq_connect (dealer, "tcp://127.0.0.1:5560");
./tests/test_many_sockets.cpp:45:        void *socket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_many_sockets.cpp:54:        void *socket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_many_sockets.cpp:71:        void *socket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_many_sockets.cpp:81:        void *socket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_router_mandatory.cpp:37:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_router_mandatory.cpp:40:    int rc = zmq_bind (router, "tcp://127.0.0.1:5560");
./tests/test_router_mandatory.cpp:59:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_router_mandatory.cpp:63:    rc = zmq_connect (dealer, "tcp://127.0.0.1:5560");
./tests/test_invalid_rep.cpp:39:    void *router_socket = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_invalid_rep.cpp:42:    void *req_socket = zmq_socket (ctx, ZMQ_REQ);
./tests/test_invalid_rep.cpp:50:    rc = zmq_bind (router_socket, "inproc://hi");
./tests/test_invalid_rep.cpp:52:    rc = zmq_connect (req_socket, "inproc://hi");
./tests/test_xpub_nodrop.cpp:39:    void *pub = zmq_socket (ctx, ZMQ_PUB);
./tests/test_xpub_nodrop.cpp:41:    int rc = zmq_bind (pub, "inproc://soname");
./tests/test_xpub_nodrop.cpp:54:    void *sub = zmq_socket (ctx, ZMQ_SUB);
./tests/test_xpub_nodrop.cpp:56:    rc = zmq_connect (sub, "inproc://soname");
./tests/test_disconnect_inproc.cpp:47:    (pubSocket = zmq_socket(context, ZMQ_XPUB))         || printf("zmq_socket: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:48:    (subSocket = zmq_socket(context, ZMQ_SUB))          || printf("zmq_socket: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:51:    zmq_bind(pubSocket, "inproc://someInProcDescriptor") && printf("zmq_bind: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:52:    //zmq_bind(pubSocket, "tcp://127.0.0.1:30010") && printf("zmq_bind: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:104:            zmq_connect(subSocket, "inproc://someInProcDescriptor") && printf("zmq_connect: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:105:            //zmq_connect(subSocket, "tcp://127.0.0.1:30010") && printf("zmq_connect: %s\n", zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:108:            zmq_disconnect(subSocket, "inproc://someInProcDescriptor") && printf("zmq_disconnect(%d): %s\n", errno, zmq_strerror(errno));
./tests/test_disconnect_inproc.cpp:109:            //zmq_disconnect(subSocket, "tcp://127.0.0.1:30010") && printf("zmq_disconnect: %s\n", zmq_strerror(errno));
./tests/test_getsockopt_memset.cpp:41:    void *sb = zmq_socket (ctx, ZMQ_PUB);
./tests/test_getsockopt_memset.cpp:43:    int rc = zmq_bind (sb, "inproc://a");
./tests/test_getsockopt_memset.cpp:46:    void *sc = zmq_socket (ctx, ZMQ_SUB);
./tests/test_getsockopt_memset.cpp:48:    rc = zmq_connect (sc, "inproc://a");
./tests/test_hwm_pubsub.cpp:41:    void *pub_socket = zmq_socket (ctx, ZMQ_PUB);
./tests/test_hwm_pubsub.cpp:43:    rc = zmq_bind (pub_socket, "inproc://a");
./tests/test_hwm_pubsub.cpp:47:    void *sub_socket = zmq_socket (ctx, ZMQ_SUB);
./tests/test_hwm_pubsub.cpp:49:    rc = zmq_connect (sub_socket, "inproc://a");
./tests/test_hwm_pubsub.cpp:104:    void *pub_socket = zmq_socket (ctx, ZMQ_PUB);
./tests/test_hwm_pubsub.cpp:106:    rc = zmq_bind (pub_socket, "inproc://a");
./tests/test_hwm_pubsub.cpp:110:    void *sub_socket = zmq_socket (ctx, ZMQ_SUB);
./tests/test_hwm_pubsub.cpp:112:    rc = zmq_connect (sub_socket, "inproc://a");
./tests/test_timeo.cpp:38:    void *frontend = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_timeo.cpp:40:    int rc = zmq_bind (frontend, "inproc://timeout_test");
./tests/test_timeo.cpp:62:    void *backend = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_timeo.cpp:64:    rc = zmq_connect (backend, "inproc://timeout_test");
./tests/test_reqrep_ipc.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_ipc.cpp:40:    int rc = zmq_bind (sb, "ipc:///tmp/tester");
./tests/test_reqrep_ipc.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_ipc.cpp:45:    rc = zmq_connect (sc, "ipc:///tmp/tester");
./tests/test_pair_tcp.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_tcp.cpp:40:    int rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
./tests/test_pair_tcp.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_tcp.cpp:45:    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
./tests/test_security_curve.cpp:123:    void *handler = zmq_socket (ctx, ZMQ_REP);
./tests/test_security_curve.cpp:125:    rc = zmq_bind (handler, "inproc://zeromq.zap.01");
./tests/test_security_curve.cpp:130:    void *server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:139:    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
./tests/test_security_curve.cpp:143:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:151:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:160:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:168:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:175:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:183:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:190:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:198:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:209:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:217:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:224:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:226:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_curve.cpp:233:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_curve.cpp:254:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_curve.cpp:255:    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));
./tests/test_security_curve.cpp:271:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_sub_forward.cpp:39:    void *xpub = zmq_socket (ctx, ZMQ_XPUB);
./tests/test_sub_forward.cpp:41:    int rc = zmq_bind (xpub, "tcp://127.0.0.1:5560");
./tests/test_sub_forward.cpp:43:    void *xsub = zmq_socket (ctx, ZMQ_XSUB);
./tests/test_sub_forward.cpp:45:    rc = zmq_bind (xsub, "tcp://127.0.0.1:5561");
./tests/test_sub_forward.cpp:49:    void *pub = zmq_socket (ctx, ZMQ_PUB);
./tests/test_sub_forward.cpp:51:    rc = zmq_connect (pub, "tcp://127.0.0.1:5561");
./tests/test_sub_forward.cpp:55:    void *sub = zmq_socket (ctx, ZMQ_SUB);
./tests/test_sub_forward.cpp:57:    rc = zmq_connect (sub, "tcp://127.0.0.1:5560");
./tests/test_spec_router.cpp:37:    void *receiver = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_spec_router.cpp:44:    rc = zmq_bind (receiver, bind_address);
./tests/test_spec_router.cpp:50:        senders [peer] = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_router.cpp:62:        rc = zmq_connect (senders [peer], connect_address);
./tests/test_spec_router.cpp:111:void test_destroy_queue_on_disconnect (void *ctx)
./tests/test_spec_router.cpp:113:    void *A = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_spec_router.cpp:120:    rc = zmq_bind (A, bind_address);
./tests/test_spec_router.cpp:123:    void *B = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_router.cpp:129:    rc = zmq_connect (B, connect_address);
./tests/test_spec_router.cpp:140:    rc = zmq_disconnect (B, connect_address);
./tests/test_spec_router.cpp:163:    rc = zmq_connect (B, connect_address);
./tests/test_spec_router.cpp:207:        // test_destroy_queue_on_disconnect (ctx);
./tests/test_conflate.cpp:41:    void* s_in = zmq_socket (ctx, ZMQ_PULL);
./tests/test_conflate.cpp:48:    rc = zmq_bind (s_in, bind_to);
./tests/test_conflate.cpp:51:    void* s_out = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_conflate.cpp:54:    rc = zmq_connect (s_out, bind_to);
./tests/test_pair_ipc.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_ipc.cpp:40:    int rc = zmq_bind (sb, "ipc:///tmp/tester");
./tests/test_pair_ipc.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_ipc.cpp:45:    rc = zmq_connect (sc, "ipc:///tmp/tester");
./tests/test_metadata.cpp:88:    void *handler = zmq_socket (ctx, ZMQ_REP);
./tests/test_metadata.cpp:90:    int rc = zmq_bind (handler, "inproc://zeromq.zap.01");
./tests/test_metadata.cpp:94:    void *server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_metadata.cpp:96:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_metadata.cpp:100:    rc = zmq_bind (server, "tcp://127.0.0.1:9001");
./tests/test_metadata.cpp:102:    rc = zmq_connect (client, "tcp://127.0.0.1:9001");
./tests/test_hwm.cpp:43:    void *bind_socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_hwm.cpp:45:    rc = zmq_bind (bind_socket, "inproc://a");
./tests/test_hwm.cpp:49:    void *connect_socket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_hwm.cpp:51:    rc = zmq_connect (connect_socket, "inproc://a");
./tests/test_hwm.cpp:90:        bind_socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_hwm.cpp:94:        rc = zmq_bind (bind_socket, "inproc://a");
./tests/test_hwm.cpp:98:        connect_socket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_hwm.cpp:102:        rc = zmq_connect (connect_socket, "inproc://a");
./tests/test_hwm.cpp:108:        connect_socket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_hwm.cpp:112:        rc = zmq_connect (connect_socket, "inproc://a");
./tests/test_hwm.cpp:116:        bind_socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_hwm.cpp:120:        rc = zmq_bind (bind_socket, "inproc://a");
./tests/test_hwm.cpp:174:    void *connect_socket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_hwm.cpp:178:    rc = zmq_connect (connect_socket, "inproc://a");
./tests/test_hwm.cpp:191:    void *bind_socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_hwm.cpp:195:    rc = zmq_bind (bind_socket, "inproc://a");
./tests/test_hwm.cpp:222:    void *bind_socket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_hwm.cpp:226:    rc = zmq_bind (bind_socket, "inproc://a");
./tests/test_hwm.cpp:240:    void *connect_socket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_hwm.cpp:244:    rc = zmq_connect (connect_socket, "inproc://a");
./tests/test_abstract_ipc.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_abstract_ipc.cpp:40:    int rc = zmq_bind (sb, "ipc://@tmp-tester");
./tests/test_abstract_ipc.cpp:50:    void *sc = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_abstract_ipc.cpp:52:    rc = zmq_connect (sc, "ipc://@tmp-tester");
./tests/test_monitor.cpp:75:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_monitor.cpp:77:    void *server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_monitor.cpp:92:    void *client_mon = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_monitor.cpp:94:    void *server_mon = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_monitor.cpp:98:    rc = zmq_connect (client_mon, "inproc://monitor-client");
./tests/test_monitor.cpp:100:    rc = zmq_connect (server_mon, "inproc://monitor-server");
./tests/test_monitor.cpp:104:    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
./tests/test_monitor.cpp:106:    rc = zmq_connect (client, "tcp://127.0.0.1:9998");
./tests/test_pair_tipc.cpp:42:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_tipc.cpp:44:    int rc = zmq_bind (sb, "tipc://{5560,0,0}");
./tests/test_pair_tipc.cpp:47:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_tipc.cpp:49:    rc = zmq_connect (sc, "tipc://{5560,0}");
./tests/test_security_null.cpp:94:    void *handler = zmq_socket (ctx, ZMQ_REP);
./tests/test_security_null.cpp:96:    int rc = zmq_bind (handler, "inproc://zeromq.zap.01");
./tests/test_security_null.cpp:104:    void *server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:106:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:108:    rc = zmq_bind (server, "tcp://127.0.0.1:9000");
./tests/test_security_null.cpp:110:    rc = zmq_connect (client, "tcp://127.0.0.1:9000");
./tests/test_security_null.cpp:119:    server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:121:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:125:    rc = zmq_bind (server, "tcp://127.0.0.1:9001");
./tests/test_security_null.cpp:127:    rc = zmq_connect (client, "tcp://127.0.0.1:9001");
./tests/test_security_null.cpp:134:    server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:136:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:140:    rc = zmq_bind (server, "tcp://127.0.0.1:9002");
./tests/test_security_null.cpp:142:    rc = zmq_connect (client, "tcp://127.0.0.1:9002");
./tests/test_security_null.cpp:149:    server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_null.cpp:153:    rc = zmq_bind (server, "tcp://127.0.0.1:9003");
./tests/test_security_null.cpp:167:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_null.cpp:168:    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof ip4addr);
./tests/test_diffserv.cpp:43:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_diffserv.cpp:47:    rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
./tests/test_diffserv.cpp:53:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_diffserv.cpp:58:    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
./tests/test_term_endpoint_tipc.cpp:54:    void *push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint_tipc.cpp:56:    rc = zmq_bind (push, ep);
./tests/test_term_endpoint_tipc.cpp:58:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint_tipc.cpp:60:    rc = zmq_connect (pull, name);
./tests/test_term_endpoint_tipc.cpp:70:    rc = zmq_unbind (push, ep);
./tests/test_term_endpoint_tipc.cpp:96:    push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint_tipc.cpp:98:    rc = zmq_connect (push, name);
./tests/test_term_endpoint_tipc.cpp:100:    pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint_tipc.cpp:102:    rc = zmq_bind (pull, ep);
./tests/test_term_endpoint_tipc.cpp:112:    rc = zmq_disconnect (push, name);
./tests/test_req_relaxed.cpp:38:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_req_relaxed.cpp:48:    rc = zmq_bind (req, "tcp://127.0.0.1:5555");
./tests/test_req_relaxed.cpp:54:        rep [peer] = zmq_socket (ctx, ZMQ_REP);
./tests/test_req_relaxed.cpp:61:        rc = zmq_connect (rep [peer], "tcp://localhost:5555");
./tests/test_msg_flags.cpp:39:    void *sb = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_msg_flags.cpp:42:    int rc = zmq_bind (sb, "inproc://a");
./tests/test_msg_flags.cpp:45:    void *sc = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_msg_flags.cpp:48:    rc = zmq_connect (sc, "inproc://a");
./tests/test_spec_rep.cpp:37:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_spec_rep.cpp:44:    rc = zmq_bind (rep, bind_address);
./tests/test_spec_rep.cpp:50:        reqs [peer] = zmq_socket (ctx, ZMQ_REQ);
./tests/test_spec_rep.cpp:56:        rc = zmq_connect (reqs [peer], connect_address);
./tests/test_spec_rep.cpp:103:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_spec_rep.cpp:106:    int rc = zmq_bind (rep, bind_address);
./tests/test_spec_rep.cpp:109:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_rep.cpp:112:    rc = zmq_connect (dealer, connect_address);
./tests/test_proxy_terminate.cpp:42:    void *frontend = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy_terminate.cpp:46:    rc = zmq_bind (frontend, "tcp://127.0.0.1:15564");
./tests/test_proxy_terminate.cpp:50:    void *backend = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_proxy_terminate.cpp:52:    rc = zmq_bind (backend, "tcp://127.0.0.1:15563");
./tests/test_proxy_terminate.cpp:56:    void *control = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy_terminate.cpp:60:    rc = zmq_connect (control, "inproc://control");
./tests/test_proxy_terminate.cpp:85:    void *control = zmq_socket (ctx, ZMQ_PUB);
./tests/test_proxy_terminate.cpp:87:    int rc = zmq_bind (control, "inproc://control");
./tests/test_proxy_terminate.cpp:94:    void *publisher = zmq_socket (ctx, ZMQ_PUB);
./tests/test_proxy_terminate.cpp:96:    rc = zmq_connect (publisher, "tcp://127.0.0.1:15564");
./tests/test_reqrep_inproc.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_inproc.cpp:40:    int rc = zmq_bind (sb, "inproc://a");
./tests/test_reqrep_inproc.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_inproc.cpp:45:    rc = zmq_connect (sc, "inproc://a");
./tests/test_bind_src_address.cpp:38:    void *sock = zmq_socket (ctx, ZMQ_PUB);
./tests/test_bind_src_address.cpp:41:    int rc = zmq_connect (sock, "tcp://127.0.0.1:0;localhost:1234");
./tests/test_bind_src_address.cpp:44:    rc = zmq_connect (sock, "tcp://localhost:5555;localhost:1235");
./tests/test_bind_src_address.cpp:47:    rc = zmq_connect (sock, "tcp://lo:5555;localhost:1235");
./tests/test_stream_timeout.cpp:77:    void *stream = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream_timeout.cpp:83:    rc = zmq_connect (stream, "tcp://localhost:5557");
./tests/test_stream_timeout.cpp:87:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_stream_timeout.cpp:110:    void *dealer_mon = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_stream_timeout.cpp:118:    rc = zmq_connect (dealer_mon, "inproc://monitor-dealer");
./tests/test_stream_timeout.cpp:122:    rc = zmq_bind (dealer, "tcp://127.0.0.1:5557");
./tests/test_stream_timeout.cpp:145:test_stream_handshake_timeout_connect (void)
./tests/test_stream_timeout.cpp:154:    void *stream = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream_timeout.cpp:160:    rc = zmq_bind (stream, "tcp://127.0.0.1:5556");
./tests/test_stream_timeout.cpp:164:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_stream_timeout.cpp:187:    void *dealer_mon = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_stream_timeout.cpp:195:    rc = zmq_connect (dealer_mon, "inproc://monitor-dealer");
./tests/test_stream_timeout.cpp:199:    rc = zmq_connect (dealer, "tcp://localhost:5556");
./tests/test_stream_timeout.cpp:225:    test_stream_handshake_timeout_connect ();
./tests/test_sub_forward_tipc.cpp:49:    void *xpub = zmq_socket (ctx, ZMQ_XPUB);
./tests/test_sub_forward_tipc.cpp:51:    int rc = zmq_bind (xpub, "tipc://{5560,0,0}");
./tests/test_sub_forward_tipc.cpp:53:    void *xsub = zmq_socket (ctx, ZMQ_XSUB);
./tests/test_sub_forward_tipc.cpp:55:    rc = zmq_bind (xsub, "tipc://{5561,0,0}");
./tests/test_sub_forward_tipc.cpp:59:    void *pub = zmq_socket (ctx, ZMQ_PUB);
./tests/test_sub_forward_tipc.cpp:61:    rc = zmq_connect (pub, "tipc://{5561,0}");
./tests/test_sub_forward_tipc.cpp:65:    void *sub = zmq_socket (ctx, ZMQ_SUB);
./tests/test_sub_forward_tipc.cpp:67:    rc = zmq_connect (sub, "tipc://{5560,0}");
./tests/test_reqrep_device_tipc.cpp:47:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_reqrep_device_tipc.cpp:49:    int rc = zmq_bind (dealer, "tipc://{5560,0,0}");
./tests/test_reqrep_device_tipc.cpp:51:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_reqrep_device_tipc.cpp:53:    rc = zmq_bind (router, "tipc://{5561,0,0}");
./tests/test_reqrep_device_tipc.cpp:57:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_device_tipc.cpp:59:    rc = zmq_connect (rep, "tipc://{5560,0}");
./tests/test_reqrep_device_tipc.cpp:63:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_device_tipc.cpp:65:    rc = zmq_connect (req, "tipc://{5561,0}");
./tests/test_reqrep_device_tipc.cpp:79:        rc = zmq_recvmsg (router, &msg, 0);
./tests/test_reqrep_device_tipc.cpp:85:        rc = zmq_sendmsg (dealer, &msg, rcvmore ? ZMQ_SNDMORE : 0);
./tests/test_reqrep_device_tipc.cpp:117:        rc = zmq_recvmsg (dealer, &msg, 0);
./tests/test_reqrep_device_tipc.cpp:122:        rc = zmq_sendmsg (router, &msg, rcvmore ? ZMQ_SNDMORE : 0);
./tests/test_iov.cpp:87:    void *sb = zmq_socket (ctx, ZMQ_PULL);
./tests/test_iov.cpp:90:    rc = zmq_bind (sb, "inproc://a");
./tests/test_iov.cpp:94:    void *sc = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_iov.cpp:96:    rc = zmq_connect (sc, "inproc://a");
./tests/test_inproc_connect.cpp:35:    void *connectSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:37:    int rc = zmq_connect (connectSocket, "inproc://sink");
./tests/test_inproc_connect.cpp:56:    void *connectSocket = zmq_socket (ctx, ZMQ_SUB);
./tests/test_inproc_connect.cpp:58:    int rc = zmq_connect (connectSocket, endpt);
./tests/test_inproc_connect.cpp:66:static void simult_bind (void *payload)
./tests/test_inproc_connect.cpp:73:    void *bindSocket = zmq_socket (ctx, ZMQ_PUB);
./tests/test_inproc_connect.cpp:75:    int rc = zmq_bind (bindSocket, endpt);
./tests/test_inproc_connect.cpp:83:void test_bind_before_connect ()
./tests/test_inproc_connect.cpp:89:    void *bindSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:91:    int rc = zmq_bind (bindSocket, "inproc://bbc");
./tests/test_inproc_connect.cpp:95:    void *connectSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:97:    rc = zmq_connect (connectSocket, "inproc://bbc");
./tests/test_inproc_connect.cpp:124:void test_connect_before_bind ()
./tests/test_inproc_connect.cpp:130:    void *connectSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:132:    int rc = zmq_connect (connectSocket, "inproc://cbb");
./tests/test_inproc_connect.cpp:140:    void *bindSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:142:    rc = zmq_bind (bindSocket, "inproc://cbb");
./tests/test_inproc_connect.cpp:171:    void *connectSocket = zmq_socket (ctx, ZMQ_PUB);
./tests/test_inproc_connect.cpp:173:    int rc = zmq_connect (connectSocket, "inproc://cbbps");
./tests/test_inproc_connect.cpp:181:    void *bindSocket = zmq_socket (ctx, ZMQ_SUB);
./tests/test_inproc_connect.cpp:185:    rc = zmq_bind (bindSocket, "inproc://cbbps");
./tests/test_inproc_connect.cpp:227:        connectSocket [i] = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_inproc_connect.cpp:229:        rc = zmq_connect (connectSocket [i], "inproc://multiple");
./tests/test_inproc_connect.cpp:238:    void *bindSocket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_inproc_connect.cpp:240:    rc = zmq_bind (bindSocket, "inproc://multiple");
./tests/test_inproc_connect.cpp:285:    void *bindSocket = zmq_socket (ctx, ZMQ_PULL);
./tests/test_inproc_connect.cpp:287:    rc = zmq_bind (bindSocket, "inproc://sink");
./tests/test_inproc_connect.cpp:357:    void *sc = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_inproc_connect.cpp:360:    int rc = zmq_connect (sc, "inproc://identity");
./tests/test_inproc_connect.cpp:363:    void *sb = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_inproc_connect.cpp:366:    rc = zmq_bind (sb, "inproc://identity");
./tests/test_inproc_connect.cpp:412:    void *connectSocket = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_inproc_connect.cpp:414:    int rc = zmq_connect (connectSocket, "inproc://a");
./tests/test_inproc_connect.cpp:425:void test_unbind ()
./tests/test_inproc_connect.cpp:431:    void *bindSocket1 = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:433:    int rc = zmq_bind (bindSocket1, "inproc://unbind");
./tests/test_inproc_connect.cpp:435:    zmq_unbind (bindSocket1, "inproc://unbind");
./tests/test_inproc_connect.cpp:439:    void *bindSocket2 = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:441:    rc = zmq_bind (bindSocket2, "inproc://unbind");
./tests/test_inproc_connect.cpp:445:    void *connectSocket = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_inproc_connect.cpp:447:    rc = zmq_connect (connectSocket, "inproc://unbind");
./tests/test_inproc_connect.cpp:478:    test_bind_before_connect ();
./tests/test_inproc_connect.cpp:479:    test_connect_before_bind ();
./tests/test_inproc_connect.cpp:486:    test_unbind ();
./tests/test_srcfd.cpp:53:    void *rep = zmq_socket (ctx, ZMQ_REP);
./tests/test_srcfd.cpp:55:    void *req = zmq_socket (ctx, ZMQ_REQ);
./tests/test_srcfd.cpp:58:    rc = zmq_bind(rep, "tcp://127.0.0.1:5560");
./tests/test_srcfd.cpp:61:    rc = zmq_connect(req, "tcp://127.0.0.1:5560");
./tests/test_srcfd.cpp:71:    zmq_recvmsg(rep, &msg, 0);
./tests/test_shutdown_stress_tipc.cpp:48:        rc = zmq_connect (s, "tipc://{5560,0}");
./tests/test_shutdown_stress_tipc.cpp:77:        s1 = zmq_socket (ctx, ZMQ_PUB);
./tests/test_shutdown_stress_tipc.cpp:80:        rc = zmq_bind (s1, "tipc://{5560,0,0}");
./tests/test_shutdown_stress_tipc.cpp:84:            s2 = zmq_socket (ctx, ZMQ_SUB);
./tests/test_connect_delay_tipc.cpp:51:    // of the messages getting queued, as connect() creates a
./tests/test_connect_delay_tipc.cpp:56:    void *to = zmq_socket(context, ZMQ_PULL);
./tests/test_connect_delay_tipc.cpp:63:    rc = zmq_bind (to, "tipc://{6555,0,0}");
./tests/test_connect_delay_tipc.cpp:67:    void *from = zmq_socket (context, ZMQ_PUSH);
./tests/test_connect_delay_tipc.cpp:73:    rc = zmq_connect (from, "tipc://{5556,0}");
./tests/test_connect_delay_tipc.cpp:76:    rc = zmq_connect (from, "tipc://{6555,0}");
./tests/test_connect_delay_tipc.cpp:120:    to = zmq_socket (context, ZMQ_PULL);
./tests/test_connect_delay_tipc.cpp:122:    rc = zmq_bind (to, "tipc://{5560,0,0}");
./tests/test_connect_delay_tipc.cpp:130:    from = zmq_socket (context, ZMQ_PUSH);
./tests/test_connect_delay_tipc.cpp:143:    rc = zmq_connect (from, "tipc://{5561,0}");
./tests/test_connect_delay_tipc.cpp:146:    rc = zmq_connect (from, "tipc://{5560,0}");
./tests/test_connect_delay_tipc.cpp:182:    void *backend = zmq_socket (context, ZMQ_DEALER);
./tests/test_connect_delay_tipc.cpp:184:    void *frontend = zmq_socket (context, ZMQ_DEALER);
./tests/test_connect_delay_tipc.cpp:196:    rc = zmq_bind (backend, "tipc://{5560,0,0}");
./tests/test_connect_delay_tipc.cpp:198:    rc = zmq_connect (frontend, "tipc://{5560,0}");
./tests/test_connect_delay_tipc.cpp:222:    backend = zmq_socket (context, ZMQ_DEALER);
./tests/test_connect_delay_tipc.cpp:226:    rc = zmq_bind (backend, "tipc://{5560,0,0}");
./tests/test_security_plain.cpp:47:    void *zap = zmq_socket (ctx, ZMQ_REP);
./tests/test_security_plain.cpp:49:    int rc = zmq_bind (zap, "inproc://zeromq.zap.01");
./tests/test_security_plain.cpp:107:    void *server = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_plain.cpp:114:    rc = zmq_bind (server, "tcp://127.0.0.1:9998");
./tests/test_security_plain.cpp:121:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_plain.cpp:129:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_plain.cpp:137:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_plain.cpp:142:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_plain.cpp:148:    client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_security_plain.cpp:156:    rc = zmq_connect (client, "tcp://localhost:9998");
./tests/test_security_plain.cpp:173:    s = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
./tests/test_security_plain.cpp:174:    rc = connect (s, (struct sockaddr*) &ip4addr, sizeof (ip4addr));
./tests/test_ipc_wildcard.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_ipc_wildcard.cpp:40:    int rc = zmq_bind (sb, "ipc://*");
./tests/test_ipc_wildcard.cpp:48:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_ipc_wildcard.cpp:50:    rc = zmq_connect (sc, endpoint);
./tests/test_stream_empty.cpp:37:    void *stream = zmq_socket (ctx, ZMQ_STREAM);
./tests/test_stream_empty.cpp:39:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_stream_empty.cpp:42:    int rc = zmq_bind (stream, "tcp://127.0.0.1:5555");
./tests/test_stream_empty.cpp:44:    rc = zmq_connect (dealer, "tcp://127.0.0.1:5555");
./tests/test_stream_disconnect.cpp:72:    sockets [SERVER] = zmq_socket (context, ZMQ_STREAM);
./tests/test_stream_disconnect.cpp:73:    rc = zmq_bind (sockets [SERVER], "tcp://0.0.0.0:6666");
./tests/test_stream_disconnect.cpp:76:    sockets [CLIENT] = zmq_socket (context, ZMQ_STREAM);
./tests/test_stream_disconnect.cpp:77:    rc = zmq_connect (sockets [CLIENT], "tcp://localhost:6666");
./tests/test_proxy.cpp:57:    void *client = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_proxy.cpp:61:    void *control = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy.cpp:65:    rc = zmq_connect (control, "inproc://control");
./tests/test_proxy.cpp:74:    rc = zmq_connect (client, "tcp://127.0.0.1:5563");
./tests/test_proxy.cpp:129:    void *frontend = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_proxy.cpp:131:    int rc = zmq_bind (frontend, "tcp://127.0.0.1:5563");
./tests/test_proxy.cpp:135:    void *backend = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_proxy.cpp:137:    rc = zmq_bind (backend, "inproc://backend");
./tests/test_proxy.cpp:141:    void *control = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy.cpp:145:    rc = zmq_connect (control, "inproc://control");
./tests/test_proxy.cpp:175:    void *worker = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_proxy.cpp:177:    int rc = zmq_connect (worker, "inproc://backend");
./tests/test_proxy.cpp:181:    void *control = zmq_socket (ctx, ZMQ_SUB);
./tests/test_proxy.cpp:185:    rc = zmq_connect (control, "inproc://control");
./tests/test_proxy.cpp:238:    void *control = zmq_socket (ctx, ZMQ_PUB);
./tests/test_proxy.cpp:240:    int rc = zmq_bind (control, "inproc://control");
./tests/test_router_handover.cpp:37:    void *router = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_router_handover.cpp:40:    int rc = zmq_bind (router, "tcp://127.0.0.1:5560");
./tests/test_router_handover.cpp:49:    void *dealer_one = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_router_handover.cpp:53:    rc = zmq_connect (dealer_one, "tcp://127.0.0.1:5560");
./tests/test_router_handover.cpp:67:    void *dealer_two = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_router_handover.cpp:71:    rc = zmq_connect (dealer_two, "tcp://127.0.0.1:5560");
./tests/test_unbind_inproc.cpp:28:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_unbind_inproc.cpp:30:    int rc = zmq_bind (sb, "inproc://a");
./tests/test_unbind_inproc.cpp:33:    rc = zmq_unbind (sb, "inproc://a");
./tests/test_last_endpoint.cpp:34:    int rc = zmq_bind (s, endpoint);
./tests/test_last_endpoint.cpp:49:    void *sb = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_probe_router.cpp:39:    void *server = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_probe_router.cpp:41:    int rc = zmq_bind (server, "tcp://127.0.0.1:5560");
./tests/test_probe_router.cpp:45:    void *client = zmq_socket (ctx, ZMQ_ROUTER);
./tests/test_probe_router.cpp:52:    rc = zmq_connect (client, "tcp://localhost:5560");
./tests/test_reqrep_tipc.cpp:42:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_tipc.cpp:44:    int rc = zmq_bind (sb, "tipc://{5560,0,0}");
./tests/test_reqrep_tipc.cpp:47:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_tipc.cpp:49:    rc = zmq_connect (sc, "tipc://{5560,0}");
./tests/test_pair_inproc.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_inproc.cpp:40:    int rc = zmq_bind (sb, "inproc://a");
./tests/test_pair_inproc.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_PAIR);
./tests/test_pair_inproc.cpp:45:    rc = zmq_connect (sc, "inproc://a");
./tests/test_fork.cpp:43:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_fork.cpp:45:    int rc = zmq_bind (pull, address);
./tests/test_fork.cpp:58:        void *push = zmq_socket (child_ctx, ZMQ_PUSH);
./tests/test_fork.cpp:60:        rc = zmq_connect (push, address);
./tests/test_term_endpoint.cpp:47:    void *push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint.cpp:49:    rc = zmq_bind (push, ep);
./tests/test_term_endpoint.cpp:51:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint.cpp:53:    rc = zmq_connect (pull, ep);
./tests/test_term_endpoint.cpp:63:    rc = zmq_unbind (push, ep);
./tests/test_term_endpoint.cpp:84:    push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint.cpp:86:    rc = zmq_connect (push, ep);
./tests/test_term_endpoint.cpp:88:    pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint.cpp:90:    rc = zmq_bind (pull, ep);
./tests/test_term_endpoint.cpp:100:    rc = zmq_disconnect (push, ep);
./tests/test_term_endpoint.cpp:121:    push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint.cpp:123:    rc = zmq_bind (push, ep_wc_tcp);
./tests/test_term_endpoint.cpp:126:    pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint.cpp:128:    rc = zmq_bind (pull, ep_wc_ipc);
./tests/test_term_endpoint.cpp:135:    rc = zmq_unbind (push, buf);
./tests/test_term_endpoint.cpp:140:    rc = zmq_unbind (pull, buf);
./tests/test_term_endpoint.cpp:147:    push = zmq_socket (ctx, ZMQ_PUSH);
./tests/test_term_endpoint.cpp:149:    rc = zmq_bind (push, ep_wc_tcp);
./tests/test_term_endpoint.cpp:152:    pull = zmq_socket (ctx, ZMQ_PULL);
./tests/test_term_endpoint.cpp:154:    rc = zmq_bind (pull, ep_wc_ipc);
./tests/test_term_endpoint.cpp:159:    rc = zmq_unbind (push, ep_wc_tcp);
./tests/test_term_endpoint.cpp:162:    rc = zmq_unbind (pull, ep_wc_ipc);
./tests/test_immediate.cpp:42:    // of the messages getting queued, as connect() creates a
./tests/test_immediate.cpp:47:    void *to = zmq_socket(context, ZMQ_PULL);
./tests/test_immediate.cpp:54:    rc = zmq_bind (to, "tcp://127.0.0.1:6555");
./tests/test_immediate.cpp:58:    void *from = zmq_socket (context, ZMQ_PUSH);
./tests/test_immediate.cpp:64:    rc = zmq_connect (from, "tcp://localhost:5556");
./tests/test_immediate.cpp:67:    rc = zmq_connect (from, "tcp://localhost:6555");
./tests/test_immediate.cpp:111:    to = zmq_socket (context, ZMQ_PULL);
./tests/test_immediate.cpp:113:    rc = zmq_bind (to, "tcp://127.0.0.1:5560");
./tests/test_immediate.cpp:121:    from = zmq_socket (context, ZMQ_PUSH);
./tests/test_immediate.cpp:134:    rc = zmq_connect (from, "tcp://localhost:5561");
./tests/test_immediate.cpp:137:    rc = zmq_connect (from, "tcp://localhost:5560");
./tests/test_immediate.cpp:173:    void *backend = zmq_socket (context, ZMQ_DEALER);
./tests/test_immediate.cpp:175:    void *frontend = zmq_socket (context, ZMQ_DEALER);
./tests/test_immediate.cpp:187:    rc = zmq_bind (backend, "tcp://127.0.0.1:5560");
./tests/test_immediate.cpp:189:    rc = zmq_connect (frontend, "tcp://localhost:5560");
./tests/test_immediate.cpp:213:    backend = zmq_socket (context, ZMQ_DEALER);
./tests/test_immediate.cpp:217:    rc = zmq_bind (backend, "tcp://127.0.0.1:5560");
./tests/test_shutdown_stress.cpp:40:        rc = zmq_connect (s, "tcp://127.0.0.1:5560");
./tests/test_shutdown_stress.cpp:66:        s1 = zmq_socket (ctx, ZMQ_PUB);
./tests/test_shutdown_stress.cpp:69:        rc = zmq_bind (s1, "tcp://127.0.0.1:5560");
./tests/test_shutdown_stress.cpp:73:            s2 = zmq_socket (ctx, ZMQ_SUB);
./tests/test_spec_dealer.cpp:37:    void *dealer = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:40:    int rc = zmq_bind (dealer, bind_address);
./tests/test_spec_dealer.cpp:46:        rep [peer] = zmq_socket (ctx, ZMQ_REP);
./tests/test_spec_dealer.cpp:53:        rc = zmq_connect (rep [peer], connect_address);
./tests/test_spec_dealer.cpp:87:    void *receiver = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:94:    rc = zmq_bind (receiver, bind_address);
./tests/test_spec_dealer.cpp:100:        senders [peer] = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:106:        rc = zmq_connect (senders [peer], connect_address);
./tests/test_spec_dealer.cpp:145:void test_destroy_queue_on_disconnect (void *ctx)
./tests/test_spec_dealer.cpp:147:    void *A = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:150:    int rc = zmq_bind (A, bind_address);
./tests/test_spec_dealer.cpp:153:    void *B = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:156:    rc = zmq_connect (B, connect_address);
./tests/test_spec_dealer.cpp:163:    rc = zmq_disconnect (B, connect_address);
./tests/test_spec_dealer.cpp:186:    rc = zmq_connect (B, connect_address);
./tests/test_spec_dealer.cpp:210:    void *sc = zmq_socket (ctx, ZMQ_DEALER);
./tests/test_spec_dealer.cpp:257:        // test_destroy_queue_on_disconnect (ctx);
./tests/test_reqrep_tcp.cpp:38:    void *sb = zmq_socket (ctx, ZMQ_REP);
./tests/test_reqrep_tcp.cpp:40:    int rc = zmq_bind (sb, "tcp://127.0.0.1:5560");
./tests/test_reqrep_tcp.cpp:43:    void *sc = zmq_socket (ctx, ZMQ_REQ);
./tests/test_reqrep_tcp.cpp:45:    rc = zmq_connect (sc, "tcp://127.0.0.1:5560");
./perf/remote_lat.cpp:65:    s = zmq_socket (ctx, ZMQ_REQ);
./perf/remote_lat.cpp:71:    rc = zmq_connect (s, connect_to);
./perf/remote_lat.cpp:87:        rc = zmq_sendmsg (s, &msg, 0);
./perf/remote_lat.cpp:92:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:61:    s = zmq_socket (ctx, ZMQ_REP);
./perf/local_lat.cpp:67:    rc = zmq_bind (s, bind_to);
./perf/local_lat.cpp:80:        rc = zmq_recvmsg (s, &msg, 0);
./perf/local_lat.cpp:89:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:62:    s = zmq_socket (ctx_, ZMQ_PUSH);
./perf/inproc_thr.cpp:68:    rc = zmq_connect (s, "inproc://thr_test");
./perf/inproc_thr.cpp:85:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_thr.cpp:141:    s = zmq_socket (ctx, ZMQ_PULL);
./perf/inproc_thr.cpp:147:    rc = zmq_bind (s, "inproc://thr_test");
./perf/inproc_thr.cpp:177:    rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_thr.cpp:190:        rc = zmq_recvmsg (s, &msg, 0);
./perf/remote_thr.cpp:62:    s = zmq_socket (ctx, ZMQ_PUSH);
./perf/remote_thr.cpp:71:    rc = zmq_connect (s, connect_to);
./perf/remote_thr.cpp:83:        rc = zmq_sendmsg (s, &msg, 0);
./perf/local_thr.cpp:64:    s = zmq_socket (ctx, ZMQ_PULL);
./perf/local_thr.cpp:73:    rc = zmq_bind (s, bind_to);
./perf/local_thr.cpp:85:    rc = zmq_recvmsg (s, &msg, 0);
./perf/local_thr.cpp:98:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:60:    s = zmq_socket (ctx_, ZMQ_REP);
./perf/inproc_lat.cpp:66:    rc = zmq_connect (s, "inproc://lat_test");
./perf/inproc_lat.cpp:79:        rc = zmq_recvmsg (s, &msg, 0);
./perf/inproc_lat.cpp:84:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:140:    s = zmq_socket (ctx, ZMQ_REQ);
./perf/inproc_lat.cpp:146:    rc = zmq_bind (s, "inproc://lat_test");
./perf/inproc_lat.cpp:180:        rc = zmq_sendmsg (s, &msg, 0);
./perf/inproc_lat.cpp:185:        rc = zmq_recvmsg (s, &msg, 0);
./builds/zos/test_fork.cpp:45:    void *pull = zmq_socket (ctx, ZMQ_PULL);
./builds/zos/test_fork.cpp:47:    int rc = zmq_bind (pull, address);
./builds/zos/test_fork.cpp:60:        void *push = zmq_socket (child_ctx, ZMQ_PUSH);
./builds/zos/test_fork.cpp:62:        rc = zmq_connect (push, address);
./include/zmq.h:353:ZMQ_EXPORT void *zmq_socket (void *, int type);
./include/zmq.h:359:ZMQ_EXPORT int zmq_bind (void *s, const char *addr);
./include/zmq.h:360:ZMQ_EXPORT int zmq_connect (void *s, const char *addr);
./include/zmq.h:361:ZMQ_EXPORT int zmq_unbind (void *s, const char *addr);
./include/zmq.h:362:ZMQ_EXPORT int zmq_disconnect (void *s, const char *addr);
./include/zmq.h:414:ZMQ_EXPORT int zmq_sendmsg (void *s, zmq_msg_t *msg, int flags);
./include/zmq.h:415:ZMQ_EXPORT int zmq_recvmsg (void *s, zmq_msg_t *msg, int flags);
./tweetnacl/contrib/randombytes/devurandom.c:25:    i = read(fd,x,i);

== http:// ==
./src/lb.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/fq.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/socks_connecter.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/curve_server.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/gssapi_mechanism_base.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/object.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/mechanism.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/xsub.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/poll.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/plain_server.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/kqueue.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/mtrie.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/poller_base.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/session_base.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pull.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/gssapi_client.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/signaler.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/msg.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/curve_client.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/trie.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/mailbox.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/stream.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pgm_sender.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/dealer.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tcp_address.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/proxy.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/devpoll.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pipe.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pgm_receiver.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/gssapi_server.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tcp_connecter.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tipc_connecter.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/io_thread.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/precompiled.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/v2_decoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/address.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/v1_encoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/null_mechanism.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/thread.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/v2_encoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/v1_decoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tcp_listener.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/ctx.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/raw_encoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/io_object.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/own.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pub.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/zmq_utils.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/plain_client.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pair.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/ipc_listener.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/select.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/ip.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tipc_address.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/raw_decoder.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/socket_base.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/sub.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/dist.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/push.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tcp.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/stream_engine.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/socks.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/tipc_listener.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/rep.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/req.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/ipc_address.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/err.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/random.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/zmq.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/options.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/epoll.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/pgm_socket.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/ipc_connecter.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/xpub.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/router.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/clock.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/reaper.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/metadata.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tools/curve_keygen.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_issue_566.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_connect_rid.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_spec_req.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_ctx_destroy.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_proxy_single_socket.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_connect_resolve.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_filter_ipc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_stream.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_router_mandatory_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_system.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_spec_pushpull.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_device.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_req_correlate.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_ctx_options.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_unbind_wildcard.cpp:17:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_router_mandatory_hwm.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_many_sockets.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_router_mandatory.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_invalid_rep.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_xpub_nodrop.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_disconnect_inproc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_getsockopt_memset.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_hwm_pubsub.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_timeo.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_ipc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_pair_tcp.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_security_curve.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_sub_forward.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_spec_router.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_conflate.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_pair_ipc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_metadata.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_hwm.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_abstract_ipc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_monitor.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_pair_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_security_null.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_diffserv.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_term_endpoint_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_req_relaxed.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_msg_flags.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_spec_rep.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_proxy_terminate.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_inproc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_bind_src_address.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_stream_timeout.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_sub_forward_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_device_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_iov.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_inproc_connect.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_srcfd.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_shutdown_stress_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_connect_delay_tipc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_security_plain.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_ipc_wildcard.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_stream_empty.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_capabilities.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_stream_disconnect.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_proxy.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_router_handover.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_unbind_inproc.cpp:17:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_last_endpoint.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_probe_router.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_tipc.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_pair_inproc.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_fork.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_term_endpoint.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_immediate.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_shutdown_stress.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_spec_dealer.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./tests/test_reqrep_tcp.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/remote_lat.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/local_lat.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/inproc_thr.cpp:29:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/remote_thr.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/local_thr.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./perf/inproc_lat.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./builds/zos/test_fork.cpp:27:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./include/zmq.h:17:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./include/zmq_utils.h:17:    along with this program.  If not, see <http://www.gnu.org/licenses/>.

== encryption ==
./src/tcp_address.cpp:500:    //  https://github.com/zeromq/libzmq/commit/1824574f9b5a8ce786853320e3ea09fe1f822bc4
./tests/test_issue_566.cpp:35://  Fixed by https://github.com/zeromq/libzmq/commit/be25cf.

== sql() ==

== tmp() ==
./tests/test_reqrep_ipc.cpp:40:    int rc = zmq_bind (sb, "ipc:///tmp/tester");
./tests/test_reqrep_ipc.cpp:45:    rc = zmq_connect (sc, "ipc:///tmp/tester");
./tests/test_pair_ipc.cpp:40:    int rc = zmq_bind (sb, "ipc:///tmp/tester");
./tests/test_pair_ipc.cpp:45:    rc = zmq_connect (sc, "ipc:///tmp/tester");

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/gssapi_mechanism_base.cpp:51:    /// FIXME remove? in_buf (),
./src/gssapi_mechanism_base.cpp:151:    // TODO: instead of malloc/memcpy, can we just do: wrapped.value = ptr;
./src/xsub.cpp:143:    //  TODO: This can result in infinite loop in the case of continuous
./src/xsub.cpp:183:    //  TODO: This can result in infinite loop in the case of continuous
./src/session_base.cpp:454:        //  TODO: Should this go into pipe_t::terminate ?
./src/trie.cpp:147:    //  TODO: Shouldn't an error be reported if the key does not exist?
./src/mailbox.cpp:45:    //  TODO: Retrieve and deallocate commands inside the cpipe.
./src/stream.cpp:106:        //  TODO: The connections should be killed instead.
./src/tcp_address.cpp:58:    //  TODO: Unused parameter, IPv6 support not implemented for Solaris.
./src/pgm_receiver.cpp:168:    //  TODO: This loop can effectively block other engines in the same I/O
./src/io_thread.cpp:75:    //  TODO: Do we want to limit number of commands I/O thread can
./src/tcp_listener.cpp:95:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/ipc_listener.cpp:100:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/ipc_listener.cpp:151:        char buffer [12] = "2134XXXXXX";
./src/socket_base.cpp:478:        //  TODO: inproc connect is specific with respect to creating pipes
./src/tipc_listener.cpp:85:    //  TODO: Handle specific errors like ENFILE/EMFILE etc.
./src/tipc_listener.cpp:183:    /*FIXME Accept filters?*/
./src/req.cpp:158:        // TODO: Failing this check should also close the connection with the peer!
./src/req.cpp:190:    //  TODO: Duplicates should be removed here.
./src/err.cpp:92:    //  TODO: This is not a generic way to handle this...
./src/err.cpp:101:    //  TODO:  It seems that list of Windows socket errors is longer than this.
./src/zmq.cpp:413:// TODO: this function has no man page
./src/zmq.cpp:490:    //  TODO: Build in a notification mechanism to report the overflows.
./src/zmq.cpp:514:// TODO: this function has no man page
./src/options.cpp:382:            //  TODO: refactor repeated code for these three options
./src/router.cpp:197:        //  TODO: The connections should be killed instead.
./src/router.cpp:365:    //  TODO: handle the situation when the peer changes its identity.
./tests/test_stream.cpp:270:    // FIXME: why does this block? Bug in STREAM disconnect notification?
./tests/test_spec_rep.cpp:70:    // TODO: following test fails randomly on some boxes
./tests/test_stream_disconnect.cpp:135:    // TODO: make sure this loop doesn't loop forever if something is wrong

== unsafe input mechanisms ==
./src/zmq.cpp:662:const char *zmq_msg_gets (zmq_msg_t *msg_, const char *property_)
./tests/test_stream.cpp:91:    assert (streq (zmq_msg_gets (&identity, "Peer-Address"), "127.0.0.1"));
./tests/test_stream.cpp:99:    assert (streq (zmq_msg_gets (&identity, "Peer-Address"), "127.0.0.1"));
./tests/test_stream.cpp:108:    assert (streq (zmq_msg_gets (&identity, "Peer-Address"), "127.0.0.1"));
./tests/test_metadata.cpp:110:    assert (streq (zmq_msg_gets (&msg, "Hello"), "World"));
./tests/test_metadata.cpp:111:    assert (streq (zmq_msg_gets (&msg, "Socket-Type"), "DEALER"));
./tests/test_metadata.cpp:112:    assert (streq (zmq_msg_gets (&msg, "User-Id"), "anonymous"));
./tests/test_metadata.cpp:113:    assert (streq (zmq_msg_gets (&msg, "Peer-Address"), "127.0.0.1"));
./tests/test_metadata.cpp:114:    assert (zmq_msg_gets (&msg, "No Such") == NULL);
./include/zmq.h:226:ZMQ_EXPORT const char *zmq_msg_gets (zmq_msg_t *msg, const char *property);

