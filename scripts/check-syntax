#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

# Set CVE_ALLOW_NEWER_PKGS=1 to skip new package checks
import glob, sys, optparse, cve_lib, os, re
import usn_lib
import pprint

import source_map
source = source_map.load()

def ever_existed(pkg):
    for rel in cve_lib.releases:
        if rel in cve_lib.eol_releases:
            continue
        if source.has_key(rel) and source[rel].has_key(pkg):
            return True
    return False

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose", help="Enable verbose reporting", action='store_true')
parser.add_option("-d", "--debug", help="Enable debug reporting", action='store_true')
parser.add_option("-u", "--usn-db", dest="usndb", help="Enable USN database on DB", metavar="DB")
parser.add_option("-n", "--newer", help="Allow versions newer than what is in the archive", action='store_true')
parser.add_option("-s", "--strict", help="Be extra strict in syntax", action='store_true')
(opt, args) = parser.parse_args()

all_okay = True
cves_updated = False

supported_releases = []
for rel in cve_lib.releases:
    if not rel in cve_lib.eol_releases + [cve_lib.devel_release]:
        supported_releases.append(rel)
supported_releases.append('devel')

cves = dict()
if opt.usndb:
    usn_db = usn_lib.load_database(opt.usndb)
    reverted = usn_lib.get_reverted()

    # create a dictionary of key=CVE value=USNs
    for usn in usn_db:
        if not usn_db[usn].has_key('cves'):
            continue
        for cve in usn_db[usn]['cves']:
            if not cve.startswith('CVE-'):
                continue
            if reverted.has_key(usn) and cve in reverted[usn]:
                continue
            if not cves.has_key(cve):
                cves[cve] = []
                cves[cve].append(usn)
            else:
                cves[cve].append(usn)

check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
if os.path.islink(cve_lib.embargoed_dir):
    check_dirs.append(cve_lib.embargoed_dir)

add_path = False
if len(args) == 0:
    for dir in check_dirs:
        for cve in sorted(glob.glob('%s/CVE-*' % (dir))):
            args += [cve]
else:
    add_path = True

ignored = cve_lib.parse_CVEs_from_uri('ignored/not-for-us.txt')

# Date patterns for formatted as YYYY-MM-DD HH:MM:SS
date_only_pat = re.compile(r'^20[0-9][0-9]-[01][0-9]-[0-3][0-9]$')
date_time_pat = re.compile(r'^20[0-9][0-9]-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9](| [A-Z]+)$')
for cve in args:
    cvepath = cve
    if add_path:
        if re.match(r'EMB-', cve):
            cvepath = os.path.join(cve_lib.embargoed_dir, cve)
        else:
            cvepath = os.path.join(cve_lib.active_dir, cve)
    cve = os.path.basename(cvepath)

    cve_okay = True
    try:
        data = cve_lib.load_cve(cvepath, opt.strict)
    except ValueError, e:
        print >>sys.stderr, e
        all_okay = False
        continue

    if cve in ignored:
        print >>sys.stderr, "%s: duplicate CVE found in not-for-us.txt" % (cvepath)
        all_okay = False
    matches = set()
    for dir in [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir, cve_lib.embargoed_dir]:
        if os.path.exists(os.path.join(dir,cve)):
            matches.add(dir)
    if len(matches)>1:
        print >>sys.stderr, "%s: found in multiple classes: %s" % (cve, ", ".join(sorted(matches)))
        all_okay = False

    supported = []
    for pkg in sorted(data['pkgs'].keys()):
        # Verify have supported release for each package
        if os.path.exists(os.path.join(cve_lib.active_dir, cve)):
            for rel in supported_releases:
                if not rel in sorted(data['pkgs'][pkg].keys()):
                    print >>sys.stderr, "%s: %s missing supported release '%s'" % (cvepath, pkg, rel)
                    cve_okay = False

        # Verify packages exist for releases
        for release in sorted(data['pkgs'][pkg].keys()):
            rel = release

            # Handle just after release, but before devel has opened
            if rel == 'devel' and cve_lib.devel_release == '':
                continue

            # Adjust devel release name
            if rel == 'devel':
                rel = cve_lib.devel_release
            # Don't syntax check upstream
            if rel == 'upstream':
                continue
            # Don't syntax check end-of-lifed releases
            if rel in cve_lib.eol_releases:
                continue

            # Skip devel checks on retired CVEs
            if release == 'devel':
                if cvepath.startswith('retired/'):
                    # but first check to ensure that state is not open
                    if data['pkgs'][pkg][release][0] in ['needed', 'needs-triage']:
                        print >>sys.stderr, "%s: retired but %s is listed as unfixed for '%s'" % (cve, pkg, rel)
                        cve_okay = False
                    continue

            # Skip DNE's
            if data['pkgs'][pkg][release][0] == 'DNE':
                if source[rel].has_key(pkg):
                    # TODO: remove this when partner archive is back in sync
                    # sigh, partner archive mirrors are out of date since removing sun-java6
                    if pkg == 'sun-java6' and source[rel][pkg]['section'] == 'partner':
                        continue
                    print >>sys.stderr, "%s: package '%s' DOES exist in '%s'!" % (cvepath,pkg,rel)
                    cve_okay = False
                continue

            # Check that package exists in a given release
            if not ever_existed(pkg):
                if os.path.exists(os.path.join(cve_lib.active_dir, cve)):
                    # forcibly skip linux-lts-backport packages since we
                    # want to track them before they end up fully in the archive
                    if pkg.startswith('linux-lts-backport-'):
                        continue
                    print >>sys.stderr, "%s: unknown package '%s'" % (cvepath, pkg)
                    cve_okay = False
            else:
                if not source[rel].has_key(pkg):
                    if os.path.exists(os.path.join(cve_lib.active_dir, cve)):
                        print >>sys.stderr, "%s: package '%s' not in '%s'" % (cve, pkg, rel)
                        cve_okay = False
                elif opt.newer == False:
                    # Validate the version is <= version in release
                    if data['pkgs'][pkg][release][0] == 'released':
                        released = data['pkgs'][pkg][release][1]
                        if source_map.version_compare(released,source[rel][pkg]['version'])>0:
                            print >>sys.stderr, "%s: %s has %s > %s (in %s)" % (cvepath, pkg, released, source[rel][pkg]['version'], rel)
                            cve_okay = False

            # Is this package unfixed and considered supported?
            if not data['pkgs'][pkg][release][0] in ['released','not-affected'] and cve_lib.is_supported(source, pkg, rel, data):
                supported.append("%s/%s" % (pkg, rel))

    # Verify priority for any CVE with a supported package
    if len(supported) and 'active/' in cvepath and (not data.has_key('Priority') or data['Priority'] not in cve_lib.priorities):
        print >>sys.stderr, "%s: Priority missing with supported packages (%s)" % (cvepath,", ".join(supported))
        cve_okay = False

    # check for CVE reference
    if re.match('^CVE-\d+-\d+$',cve):
        found = False
        if data.has_key('References'):
            mitre_ref = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
            if mitre_ref in data['References']:
                found = True
        if not found:
            print >>sys.stderr, "WARNING: %s: does not contain reference to %s" % (cvepath, mitre_ref)
            cve_okay = False

    # check for URLs if using the USN database
    if opt.usndb and not cvepath.startswith('ignored/') and \
       cves.has_key(cve) and \
       len(cves[cve]) > 0:
        if data.has_key('References'):
            for usn in cves[cve]:
                found = False
                usn_ref = "http://www.ubuntu.com/usn/usn-" + usn
                text = data['References'].strip()
                if len(text) != 0:
                    for line in text.split('\n'):
                        if line == usn_ref:
                            found = True
                if not found:
                    print >>sys.stderr, "%s: does not contain reference to %s" % (cvepath, usn_ref)
                    cve_okay = False

    for d in ['PublicDate', 'PublicDateAtUSN', 'CRD']:
        if data.has_key(d) and data[d] not in ['', 'unknown']:
            if date_only_pat.search(data[d]) == None and date_time_pat.search(data[d]) == None:
                print >>sys.stderr, "%s: does not contain a valid %s '%s' (need YYYY-MM-DD HH:MM:SS [TIMEZONE]" % (cvepath, d, data[d])
                cve_okay = False

    # Check to make sure all patch references match the type:reference
    # pattern
    for key in data.keys():
        if "Patches_" in key and len(data[key]) > 0:
            for line in re.split('\n', data[key]):
                patch_type = re.split(":", line)[0]
                if re.search("http", patch_type):
                    print >>sys.stderr, "%s: patch reference %s doesn't contain a type modifier (e.g. upstream:)" % (cvepath, key)
                    cve_okay = False

    # Report on failures
    if not cve_okay:
        all_okay = False
    elif opt.debug:
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint(data)

    # update eol status
    for pkg in sorted(data['pkgs'].keys()):
        if cve_lib.lts_unsupported(source, cvepath, pkg) != "":
            cves_updated = True

if cves_updated:
    print >>sys.stderr, "CVEs updated. Please run again."
    all_okay = False

if all_okay and opt.verbose:
    print 'OK: %d CVEs' % (len(args))
# Invert boolean for unix exit code
sys.exit(not all_okay)
