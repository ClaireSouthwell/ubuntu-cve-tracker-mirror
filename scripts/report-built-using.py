#!/usr/bin/python
#  Copyright (C) 2015 Canonical Ltd.
#  Authors: Jamie Strandboge <jamie@ubuntu.com>
#
#  This script is distributed under the terms and conditions of the GNU General
#  Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
#  for details.

import cve_lib
import optparse
import source_map
import sys

usage = "Usage: %prog [options] srcpkg1 srcpkg2 ..."
parser = optparse.OptionParser(usage=usage)
parser.add_option("--release",
                  help="Show packages for specified release",
                  metavar="RELEASE")
parser.add_option("--component",
                  help="Show packages for specified component",
                  metavar="COMPONENT")
(opt, args) = parser.parse_args()

if len(args) == 0:
    print >>sys.stderr, "ERROR: must supply source package name(s)"
    sys.exit(1)

pmap = source_map.load(data_type='packages')
releases = cve_lib.releases

for eol in cve_lib.eol_releases:
    if eol in releases:
        releases.remove(eol)

if opt.release:
    releases = [opt.release]

# Build this up only once
built_using = dict()
for rel in pmap.keys():
    if rel not in releases:
        continue

    for pkg in pmap[rel]:
        if 'built-using' in pmap[rel][pkg]:
            # Built-Using for a binary in the Packages file lists the
            # originating source package of the embedded binary
            section = pmap[rel][pkg]['section']
            if opt.component and section != opt.component:
                continue

            pocket = rel
            if pmap[rel][pkg]['pocket'] != '':
                pocket += "-%s" % pmap[rel][pkg]['pocket']

            for (s, c, v) in map(lambda x: x.split(' ', 3),
                                 pmap[rel][pkg]['built-using']):
                v = v.rstrip(')')
                if s not in built_using:
                    built_using[s] = dict()
                if v not in built_using[s]:
                    built_using[s][v] = dict()
                if section not in built_using[s][v]:
                    built_using[s][v][section] = dict()
                if pocket not in built_using[s][v][section]:
                    built_using[s][v][section][pocket] = []
                if pkg not in built_using[s][v][section][pocket]:
                    built_using[s][v][section][pocket].append(
                        (pkg, pmap[rel][pkg]['version']))

source_format = '%-35s'
pocket_format = '%-15s'
component_format = '%-11s'
usedby_format = '%-35s'

out = ""
for src in args:
    if src in built_using:
        for version in sorted(built_using[src]):
            for section in sorted(built_using[src][version]):
                for pocket in sorted(built_using[src][version][section]):
                    for s, v in sorted(
                            built_using[src][version][section][pocket]):
                        out += source_format % ("%s (%s)" % (src, version))
                        out += pocket_format % pocket
                        out += component_format % section
                        out += usedby_format % s
                        out += '\n'

if out != '':
    header = source_format % "Source (version)"
    header += pocket_format % "Pocket"
    header += component_format % "Component"
    header += usedby_format % "Used by"
    header += "\n" + "-" * 80
    print header
    print out,
