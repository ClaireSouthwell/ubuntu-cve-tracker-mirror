#!/usr/bin/python

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader
import shutil, subprocess
import optparse, configobj

# load settings, if any
rcfile = os.path.expanduser('~/.check-cves.rc')
if not os.path.exists(rcfile):
    file(rcfile, 'w').write('# Empty config file for check-cves\n')
config = configobj.ConfigObj(rcfile)

parser = optparse.OptionParser()
parser.add_option("-r", "--report", help="Just report CVEs that need checking", action="store_true")
parser.add_option("-k", "--known", help="Only report CVEs already known", action="store_true")
parser.add_option("-R", "--refresh", help="Refresh CVE descriptions", action="store_true")
(opt, args) = parser.parse_args()

destdir = "."

# settings for automatic CVE database evaluation
cvexml_url="http://cve.mitre.org/cve/downloads/allitems.xml"

ignore_strings = ["** REJECT **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS",
    "Apple QuickTime", "Cisco", "ActiveX", "Joomla!"]

# load embargoed items
EmbargoList = []
if os.path.islink(destdir + '/embargoed'):
    EmbargoList += [cve for cve in os.listdir(destdir + "/embargoed/") if cve.startswith('CVE-') or cve.startswith('EMB-')]

###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def subtract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)

###################

def parse_CVEs(url):
    """Return a list of all CVE numbers mentioned in the given URL."""

    list = []
    cvere = re.compile("((?:CAN|can|CVE|cve)-\d\d\d\d-\d\d\d\d)")
    try:
        text = cache_urllib.urlopen(url).read().splitlines()
        for line in text:
            comment = line.find('#')
            if comment != -1:
                line = line[:comment]
            for cve in cvere.finditer(line):
                list.append(cve.group().upper().replace('CAN', 'CVE', 1))
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

###################

def wordwrap(text, width):
    """
    A word-wrap function that preserves existing line breaks
    and most spaces in the text. Expects that existing line
    breaks are posix newlines (\n).
    """
    return reduce(lambda line, word, width=width: '%s%s%s' %
                  (line,
                   ' \n'[(len(line)-line.rfind('\n')-1
                         + len(word.split('\n',1)[0]
                              ) >= width)],
                   word),
                  text.split(' ')
                 )

def _wrap_desc(desc):
    return wordwrap(desc,75)

def add_CVE_to_tracker(cve, desc, package):
    src = '%s/active/00boilerplate'%(destdir)
    if os.path.exists(src + "." + package):
        src = src + "." + package
    dst = '%s/active/%s'%(destdir,cve)
    template = file(src).readlines()
    cve_file = file(dst,'w')
    for line in template:
        line = line.rstrip()
        if line.startswith('Candidate:'):
            print >>cve_file, 'Candidate: %s'%(cve)
        elif line.startswith('References:'):
            print >>cve_file, 'References:\n http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s'%(cve)
        elif not line.startswith('#'):
            print >>cve_file, line

        if line.startswith('Description:'):
            for desc_line in _wrap_desc(desc).split('\n'):
                print >>cve_file, " %s" % (desc_line)
    cve_file.close()
    return dst

class PercentageFile(object):
    def __init__(self, filename):
        self.size = os.stat(filename)[6]
        self.delivered = 0
        self.f = file(filename)

    def read(self, size=None):
        if size is None:
            data = self.f.read()
        else:
            data = self.f.read(size)

        print >>sys.stdout, '%d%% (%d/%d)\r' % ( (self.delivered * 100) / self.size, self.delivered, self.size ),
        sys.stdout.flush()

        self.delivered += len(data)
        return data

###################

class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore, config):
        # For per-hit processing
        self.curr_cve = None
        self.curr_desc = None
        self.curr_refs = []
        self.curr_chars = ""
        self.ignore = ignore
        self.num_ignored = 0
        self.num_added = 0
        self.num_skipped = 0

        # For long-term (human) processing
        self.cve_list = []
        self.cve_data = dict()
        self.saved_ignore_reason = ""
        self.saved_package = ""
        self.debian = None

        # Load debian CVE states, if configured
        if config.has_key('secure-testing-path'):
            self.load_debian_cves(config['secure-testing-path']+'/data/CVE/list')


    def printReport(self):
        print "\n %4d CVEs added" % self.num_added
        print " %4d CVEs ignored" % self.num_ignored
        print " %4d CVEs skipped" % self.num_skipped
        print "---------------------------"
        print "%5d total CVEs triaged" % (self.num_added + self.num_ignored)

    def startElement(self, name, attrs):
        if name == "item":
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
        if name == "desc" or name == "ref":
            self.curr_chars = ""
        if name == "ref":
            self.curr_url = None
            self.curr_source = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']
            if attrs.has_key('source'):
                self.curr_source = attrs['source']

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
        if name == "ref":
            self.curr_refs += [(self.curr_source,self.curr_chars.encode("ascii", "replace"),self.curr_url)]

        if name == "item":
            self.handle_cve()

    def handle_cve(self):
        # Skip CVEs we know about already
        if self.curr_cve in self.ignore:
            return

        # Skip stuff older than 2005
        if int(self.curr_cve.split("-")[1]) < 2005:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        if self.curr_cve in self.cve_list:
            print >>sys.stderr, "Aborting: saw %s twice!" % (self.curr_cve)

        self.cve_list += [self.curr_cve]
        self.cve_data.setdefault(self.curr_cve,dict())
        self.cve_data[self.curr_cve].setdefault('desc',self.curr_desc)
        self.cve_data[self.curr_cve].setdefault('refs',[]+self.curr_refs)

    def cves(self):
        return self.cve_list

    def load_debian_cves(self, filename):
        cve = None
        self.debian = dict()

        cvelist = file(filename)
        print "Loading %s ..." % (filename)
        count = 0
        for line in cvelist:
            count += 1
            line = line.rstrip()
            try:
                if line.startswith('\t'):
                    if not cve:
                        continue
                    line = line.lstrip()
                    if line.startswith('['):
                        continue
                    if line.startswith('{'):
                        continue
                    if line.startswith('-'):
                        info = line[1:].lstrip().split(' ',1)
                        pkg = info[0]
                        line = ""
                        if len(info)>1:
                            line = info[1]

                        info = line.lstrip().split(' ',1)
                        state = info[0]
                        if state == "":
                            state = "<unfixed>"
                        line = ""
                        if len(info)>1:
                            line = info[1]

                        priority = "needs-triage"
                        bug = None
                        note = None
                        if '(' in line and ')' in line:
                            info = line.split('(')[1].split(')')[0]
                            bits = info.split(';')
                            for bit in bits:
                                bit = bit.strip()
                                if bit.startswith('#'):
                                    bug = bit[1:]
                                else:
                                    priority = bit
                        else:
                            note = line
                        if priority == 'unimportant':
                            priority = 'negligible'

                        self.debian[cve]['pkgs'].setdefault(pkg,{'priority':priority,'bug':bug,'note':note,'state':state})

                        self.debian[cve]['state'] = 'FOUND'
                    if line.startswith('RESERVED'):
                        self.debian[cve]['state'] = 'RESERVED'
                    if line.startswith('REJECTED'):
                        self.debian[cve]['state'] = 'REJECTED'
                    if line.startswith('NOT-FOR-US'):
                        self.debian[cve]['state'] = line
                    if line.startswith('NOTE'):
                        self.debian[cve]['note']+=[line]
                else:
                    cve = line.split().pop(0)
                    self.debian.setdefault(cve,{'pkgs':dict(), 'state':None, 'note':[]})
            except:
                print >>sys.stderr, "Error parsing line %d: '%s'" % (count, line)
                raise

    def human_process_cve(self, cve):

        # Check if this was once an embargoed issue
        if cve in EmbargoList:
            print '**!!** no longer embargoed **!!**'
            print '==========================details from embargo entry=========================='
            print file(os.path.join('embargoed',cve)).read().rstrip()
            print '=================================end details=================================='
        # Display CVE information
        for ref in self.cve_data[cve]['refs']:
            print ' %s: %s' % (ref[0],ref[1]),
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                print ' %s' % (ref[2]),
            print
        print '%s' % (self.cve_data[cve]['desc'])
        if self.debian and self.debian.has_key(cve):
            print 'Debian: %s' % (self.debian[cve]['state'])
            if len(self.debian[cve]['note']):
                print "\t" + "\n\t".join(self.debian[cve]['note'])
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append(self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append(self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append(self.debian[cve]['pkgs'][pkg]['note'])
                print "\t%s: %s (%s)" % (pkg,self.debian[cve]['pkgs'][pkg]['state'],"; ".join(info))

        response = 'skip'
        reason = ""
        package = ""
        dosearch = True
        # Skip CVEs that are obviously not about Ubuntu
        for s in ignore_strings:
            if self.cve_data[cve]['desc'].find(s) >= 0 and self.cve_data[cve]['desc'].find("Linux") < 0:
                response = 'ignore'
                reason = 'NFU - ' + s
                dosearch = False
        # Default to Debian state, if available
        if self.debian and self.debian.has_key(cve) and self.debian[cve]['state']:
            if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                response = 'ignore'
                reason = self.debian[cve]['state'].split(':',1)[1].lstrip()
                dosearch = False
            if self.debian[cve]['state'] == 'FOUND':
                response = 'add'
                package = " ".join(self.debian[cve]['pkgs'])
                dosearch = False

        info = ''
        while info == "" or not info[0] in ['i','a','s','q']:
            print 'A)dd to tracker, I)gnore forever, S)kip for now, or Q)uit? [%s] ' % (response),
            info = sys.stdin.readline().strip().lower()
            if info == "":
                info = response

        if info.startswith('q'):
            self.printReport()
            sys.exit(0)
        elif info.startswith('a'):
            self.num_added += 1
            info = ""
            while info == "":
                print 'Package(s) affected? ',
                if package == "":
                    package = self.saved_package
                if package != "":
                    print '[%s] ' % (package),
                info = sys.stdin.readline().strip()
                if info == '':
                    info = package
                self.saved_package = info
            # Add to tracker from 00boilerplate
            dst = add_CVE_to_tracker(cve,self.cve_data[cve]['desc'], info)
            # Tack on package
            cmd = ['./scripts/active_edit','-c',cve]
            for pkg in info.split():
                cmd += ['-p',pkg]
            cmd += ['--yes']
            subprocess.call(cmd)
            # Spawn editor
            editor = os.getenv('EDITOR','vi')
            subprocess.call([editor,dst])
        elif info.startswith('i'):
            self.num_ignored += 1

            if dosearch:
                query = ''    
                while query == "":
                    print "Search ignored ('q' to skip search): ",
                    query = sys.stdin.readline().strip()
                if query != "q":
                    lines = file('%s/ignored/not-for-us.txt'%(destdir),'r').readlines()
                    pat = re.compile(r'' + query, re.IGNORECASE)
                    nfound = 0
                    print "Ignored: "
                    for line in lines:
                        if pat.search(line):
                            nfound += 1
                            print "   " + line,
                    if nfound > 0:
                        reason = query
                    else:
                        print "    (none found)"

            info = ""
            while info == "":
                print 'Reason to be ignored? ',
                if reason == "" and self.saved_ignore_reason != "":
                    reason = self.saved_ignore_reason
                if reason != "":
                    print '[%s] ' % (reason),
                info = sys.stdin.readline().strip()
                if info == "":
                    info = reason
                self.saved_ignore_reason = info
            # Append to ignore list
            file('%s/ignored/not-for-us.txt'%(destdir),'a').write('%s # %s\n'%(cve,info))
        elif info.startswith('s'):
            self.num_skipped += 1
        print ''

# CVEIgnoreList is a list of all CVEs we know about already.  These will be
# ignored when checking MITRE for new CVEs
CVEIgnoreList  = parse_CVEs(destdir + "/ignored/not-for-us.txt")
CVEKnownList   = []
CVEKnownList += [cve for cve in os.listdir(destdir + "/ignored/") if cve.startswith('CVE-')]
CVEKnownList += [cve for cve in os.listdir(destdir + "/retired/") if cve.startswith('CVE-')]
CVEKnownList += [cve for cve in os.listdir(destdir + "/active/") if cve.startswith('CVE-')]
if not opt.refresh:
    CVEIgnoreList += CVEKnownList

if opt.known:
    for cve in sorted(CVEIgnoreList):
        print cve
    sys.exit(0)

parser = xml.sax.make_parser()
handler = CVEHandler(CVEIgnoreList,config)
parser.setContentHandler(handler)
if len(args) == 1:
    cvexml_url = args[0]
print >>sys.stderr, 'Loading %s ...'%(cvexml_url)
if '://' in cvexml_url:
    readable = urllib.urlopen(cvexml_url)
else:
    readable = PercentageFile(cvexml_url)
parser.parse(readable)
print ''

if opt.refresh:
    import cve_lib
    for cve in sorted(CVEKnownList):
        desc = ""
        try:
            desc = handler.cve_data[cve]['desc'].strip()
        except:
            #print >>sys.stderr, '%s not listed in XML' % (cve)
            continue

        cvefile = ""
        for status in ['active','retired','ignored']:
            check = '%s/%s/%s' % (destdir, status, cve)
            if os.path.exists(check):
                cvefile = check
                break
        if cvefile == "":
            print >>sys.stderr, 'local dirs missing %s?!' % (cve)
            continue

        ret, data = cve_lib.load_cve(cvefile)
        if ret != cve_lib.EXIT_OKAY:
            print >>sys.stderr, 'failed to load %s' % (cvefile)
            continue
        print cve
        cve_lib.update_description(cvefile,_wrap_desc(desc))
    sys.exit(0)

new_cves = handler.cves()
max = len(new_cves)
count = 0
for cve in new_cves:
    count += 1

    if opt.report:
        print cve
        continue

    print '\n***********************************************************************'
    print ' %s    (%d/%d: %d%%)' % (cve, count, max, (count * 100 / max))
    print ' http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve)
    print '***********************************************************************'
    handler.human_process_cve(cve)

handler.printReport()
