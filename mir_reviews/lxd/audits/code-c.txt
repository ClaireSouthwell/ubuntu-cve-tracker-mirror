Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:436:** The sqlite3_exec() interface is a convenience wrapper around
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:441:** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:445:** sqlite3_exec() is not NULL, then it is invoked for each result row
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:447:** sqlite3_exec() is relayed through to the 1st argument of each
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:448:** callback invocation.  ^If the callback pointer to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:453:** sqlite3_exec(), then execution of the current statement stops and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:454:** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:459:** of sqlite3_exec() after the error message string is no longer needed.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:460:** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:461:** occur, then sqlite3_exec() sets the pointer in its 5th parameter to
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:464:** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:468:** ^The 2nd argument to the sqlite3_exec() callback function is the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:469:** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:473:** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:474:** sqlite3_exec() callback is an array of pointers to strings where each
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:478:** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:486:** <li> The application must insure that the 1st parameter to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:489:**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:491:**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:494:SQLITE_API int sqlite3_exec(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2026:** ^Calling [sqlite3_exec()] or [sqlite3_step()] recursively does
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2303:** [sqlite3_exec()].  The sqlite3_get_table() routine does not have access
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2306:** wrapper layer outside of the internal [sqlite3_exec()] call are not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2375:**  sqlite3_exec(db, zSQL, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2403:**  sqlite3_exec(db, zSQL, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2734:** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3352:** calls [sqlite3_exec()], then the following SQL statement would
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5902:** A virtual filesystem (VFS) is an [sqlite3_vfs] object
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27376:  ** file system (on OSX), so failure indicates that FULLFSYNC
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68336:** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69068:  ** statement to expire.  (Perhaps the function called sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:72503:      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84446:    rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:85108:** means that the SQL statement will never-run - the sqlite3_exec() call
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:87302:  ** they will persist after the current sqlite3_exec() call returns.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:96031:SQLITE_API int sqlite3_exec(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:100043:      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106021:** interface routine of sqlite3_exec().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106042:  int rc;            /* Return code from sqlite3_exec() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106151:  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121818:** Return the number of changes in the most recent call to sqlite3_exec().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126265:    *pRc = sqlite3_exec(db, zSql, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141248:  rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141252:      int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141255:      sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141256:      sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144384:    rc = sqlite3_exec(pRtree->db, zCreate, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146473:    rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146585:    rc = sqlite3_exec(db, zCreate, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:321:** The sqlite3_exec() interface is a convenience wrapper around
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:326:** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:330:** sqlite3_exec() is not NULL, then it is invoked for each result row
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:332:** sqlite3_exec() is relayed through to the 1st argument of each
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:333:** callback invocation.  ^If the callback pointer to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:338:** sqlite3_exec(), then execution of the current statement stops and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:339:** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:344:** of sqlite3_exec() after the error message string is no longer needed.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:345:** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:346:** occur, then sqlite3_exec() sets the pointer in its 5th parameter to
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:349:** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:353:** ^The 2nd argument to the sqlite3_exec() callback function is the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:354:** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:358:** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:359:** sqlite3_exec() callback is an array of pointers to strings where each
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:363:** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:371:** <li> The application must insure that the 1st parameter to sqlite3_exec()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:374:**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:376:**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:379:SQLITE_API int sqlite3_exec(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1911:** ^Calling [sqlite3_exec()] or [sqlite3_step()] recursively does
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2188:** [sqlite3_exec()].  The sqlite3_get_table() routine does not have access
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2191:** wrapper layer outside of the internal [sqlite3_exec()] call are not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2260:**  sqlite3_exec(db, zSQL, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2288:**  sqlite3_exec(db, zSQL, 0, 0, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2619:** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3237:** calls [sqlite3_exec()], then the following SQL statement would
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5787:** A virtual filesystem (VFS) is an [sqlite3_vfs] object
./dist/src/github.com/mattn/go-sqlite3/_example/mod_regexp/sqlite3_mod_regexp.c:16:    rc = pcre_exec(re, NULL, target, strlen(target), 0, 0, vec, 500); 

== memory_management() ==
./dist/src/gopkg.in/lxc/go-lxc.v2/lxc-binding.c:94:	char* value = (char*)malloc(sizeof(char)*len + 1);
./dist/src/gopkg.in/lxc/go-lxc.v2/lxc-binding.c:123:	char* value = (char*)malloc(sizeof(char)*len + 1);
./dist/src/gopkg.in/lxc/go-lxc.v2/lxc-binding.c:136:	char* value = (char*)malloc(sizeof(char)*len + 1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:456:** from [sqlite3_malloc()] and passed back through the 5th parameter.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:523:#define SQLITE_NOMEM        7   /* A malloc() failed */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:989:** [sqlite3_malloc()] and the result is stored in the char* variable
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1038:** written into memory obtained from [sqlite3_malloc()].  The caller should
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1104:** Mutexes are created using [sqlite3_mutex_alloc()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1523:** malloc(), realloc() and free() functions from the standard C library.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1535:** Every memory allocation request coming in through [sqlite3_malloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1674:** [sqlite3_malloc()] will be used to obtain the memory needed.</dd>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1692:** SQLite goes to [sqlite3_malloc()] for the additional storage space.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1704:** to using its default memory allocator (the system malloc() implementation),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1895:** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2298:** [sqlite3_malloc()] happens within sqlite3_get_table(), the calling
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2327:** results into memory obtained from [sqlite3_malloc()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2330:** NULL pointer if [sqlite3_malloc()] is unable to allocate enough
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2425:** Windows VFS uses native malloc() and free() for some operations.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2427:** ^The sqlite3_malloc() routine returns a pointer to a block
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2429:** ^If sqlite3_malloc() is unable to obtain sufficient free
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2431:** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2435:** by sqlite3_malloc() or sqlite3_realloc() releases that memory so
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2443:** was not obtained from sqlite3_malloc() or sqlite3_realloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2450:** sqlite3_malloc(N) where N is the second parameter to sqlite3_realloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2462:** ^The memory returned by sqlite3_malloc() and sqlite3_realloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2473:** the system malloc() and free() directly when converting
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2482:** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2489:SQLITE_API void *sqlite3_malloc(int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2497:** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2506:** added by SQLite in its implementation of [sqlite3_malloc()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2508:** routines that [sqlite3_malloc()] may call.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3535:** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3650:** ^If sqlite3_malloc() fails during the processing of either routine
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4568:** from [sqlite3_malloc()] before it returns.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5298:** obtained from [sqlite3_malloc()]. The calling function
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5965:** ^The sqlite3_mutex_alloc() routine allocates a new
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5969:** to sqlite3_mutex_alloc() is one of these integer constants:
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5983:** cause sqlite3_mutex_alloc() to create
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5993:** ^The other allowed parameters to sqlite3_mutex_alloc() (anything other
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6003:** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6045:SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6084:**   <li>  [sqlite3_mutex_alloc()] </li>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6106:** ^xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6166:** The [sqlite3_mutex_alloc()] interface takes a single argument
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6176:#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6322:** using [sqlite3_malloc()], either directly or indirectly.  The
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6323:** figure includes calls made to [sqlite3_malloc()] by the application
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6332:** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6351:** buffer and where forced to overflow to [sqlite3_malloc()].  The
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6374:** buffer and where forced to overflow to [sqlite3_malloc()].  The values
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:7919:**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:7922:**     SQLITE_MEMDEBUG               // Debugging version of system malloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:8594:** underlying malloc() implemention might return us 4-byte aligned
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:10208:** sqlite3_malloc() to obtain space for the file-handle structure.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:10275:#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:10391:  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:11387:#define EP_Static    0x008000 /* Held in memory not obtained from malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:12362:** obtain space from malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:13985:  char *zMalloc;      /* Dynamic buffer allocated by sqlite3_malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15638:  if( pTm ) memcpy(&sNow, pTm, sizeof(sNow));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15703:** So we test the effects of a malloc() failing and the sqlite3OsXXX()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15706:** The following functions are instrumented for malloc() failure 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15975:  void *p = sqlite3_malloc(10);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16283:#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16295:#define SQLITE_MALLOC(x)             malloc(x)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16340:** Like malloc(), but remember the size of the allocation
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16773:  p = malloc(totalSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16793:      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16802:      memcpy(z, mem.zTitle, mem.nTitle);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16869:    memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16975:  memcpy(mem.zTitle, zTitle, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17065:** use of malloc(). The SQLite user supplies a block of memory
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17573:    return sqlite3_malloc(nBytes);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17587:      memcpy(p, pPrior, nOld);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17589:      memcpy(p, pPrior, nBytes);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17754:** use of malloc(). The application gives SQLite a block of memory
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18142:    memcpy(p, pPrior, nOld);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18363:    memcpy(pTo, pFrom, offsetof(sqlite3_mutex_methods, xMutexAlloc));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18364:    memcpy(&pTo->xMutexFree, &pFrom->xMutexFree,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18397:SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18575:** The sqlite3_mutex_alloc() routine allocates a new
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18766:** The sqlite3_mutex_alloc() routine allocates a new
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18770:** to sqlite3_mutex_alloc() is one of these integer constants:
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18783:** The first two constants cause sqlite3_mutex_alloc() to create
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18793:** The other allowed parameters to sqlite3_mutex_alloc() each return
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18802:** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19260:** The sqlite3_mutex_alloc() routine allocates a new
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19264:** to sqlite3_mutex_alloc() is one of these integer constants:
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19277:** The first two constants cause sqlite3_mutex_alloc() to create
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19287:** The other allowed parameters to sqlite3_mutex_alloc() each return
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19296:** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19747:** Allocate memory.  This routine is like sqlite3_malloc() except that it
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19759:    ** this amount.  The only way to reach the limit is with sqlite3_malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19777:SQLITE_API void *sqlite3_malloc(int n){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:19897:** sqlite3Malloc() or sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20067:** In other words, if a subsequent malloc (ex: "b") worked, it is assumed
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20128:        memcpy(pNew, p, db->lookaside.sz);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20177:    memcpy(zNew, z, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20189:    memcpy(zNew, z, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20218:** function. However, if a malloc() failure has occurred since the previous
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20221:** If the first argument, db, is not NULL and a malloc() error has occurred,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20999:      if( zOld==0 && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21029:    memcpy(&p->zText[p->nChar], z, N);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21048:  memcpy(&p->zText[p->nChar], z, N);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21072:        p->zText = sqlite3_malloc(p->nChar+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21075:        memcpy(p->zText, p->zBase, p->nChar+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21163:** Print into memory obtained from sqlite3_malloc().  Omit the internal
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21181:** Print into memory obtained from sqlite3_malloc()().  Omit the internal
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21402:  memcpy(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21409:  memcpy(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:21686:  ** from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:23241:  memcpy(&a, &x, 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:23362:** The hash table might fail to resize if sqlite3_malloc() fails or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24816:  pNew = sqlite3_malloc( sizeof(*pNew) + (n+1) );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24819:  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25212:    pInode = sqlite3_malloc( sizeof(*pInode) );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25217:    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27110:  ** data from the memory mapping using memcpy().  */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27113:      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27117:      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27245:  ** data from the memory mapping using memcpy().  */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27248:      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27252:      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27715:      char *zTFile = sqlite3_malloc( pFile->pVfs->mxPathname );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28146:  p = sqlite3_malloc( sizeof(*p) );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28174:    pShmNode = sqlite3_malloc( sizeof(*pShmNode) + nShmFilename );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28192:    pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28384:        pMem = sqlite3_malloc(szRegion);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29213:    pNew->lockingContext = pCtx = sqlite3_malloc( sizeof(*pCtx) );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29243:    zLockFile = (char *)sqlite3_malloc(nFilename);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29495:    memcpy(zDb, zPath, nDb);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29620:      pUnused = sqlite3_malloc(sizeof(*pUnused));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30007:      memcpy(zBuf, &t, sizeof(t));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30008:      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30410:    pUnused = sqlite3_malloc(sizeof(*pUnused));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30443:  pNew = (unixFile *)sqlite3_malloc(sizeof(*pNew));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30726:            memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30776:        memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30902:** Store the conch filename in memory obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30918:  *pConchPath = conchPath = (char *)sqlite3_malloc(len + 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30922:  memcpy(conchPath, dbPath, len+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30938:  memcpy(&conchPath[i+1], "-conch", 7);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30997:    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:31033:  pCtx = sqlite3_malloc( sizeof(*pCtx) );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:32862:    memcpy(zDbgBuf, zBuf, nMin);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:32878:    memcpy(zDbgBuf, zBuf, nMin);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:33176:** obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:33234:** sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:33260:** returned string is obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:33277:** returned string is obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34070:  ** data from the memory mapping using memcpy().  */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34073:      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34078:      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34142:  ** data from the memory mapping using memcpy().  */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34145:      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34150:      memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35135:    pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36892:    memcpy(&zBuf[n], &x, sizeof(x));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36897:    memcpy(&zBuf[n], &pid, sizeof(pid));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36903:    memcpy(&zBuf[n], &cnt, sizeof(cnt));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36909:    memcpy(&zBuf[n], &cnt, sizeof(cnt));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36916:    memcpy(&zBuf[n], &i, sizeof(i));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:37343:      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:37383:    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:37474:  pTmpSpace = sqlite3_malloc(BITVEC_SZ);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:38713:    pcache1.grp.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_LRU);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:38714:    pcache1.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_PMEM);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:41283:    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42095:  ** not be in the pager cache. Later: if a malloc() or IO error occurs
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42192:    memcpy(pData, (u8*)aData, pPager->pageSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42222:      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42300:  ** sqlite3_malloc() and pointed to by zMasterJournal.   Also obtain
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42518:** If an I/O or malloc() error occurs, the journal-file is not deleted
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42776:      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:43975:        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44132:        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44507:    memcpy(pPager->zFilename, zPathname, nPathname);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44508:    if( nUri ) memcpy(&pPager->zFilename[nPathname+1], zUri, nUri);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44509:    memcpy(pPager->zJournal, zPathname, nPathname);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44510:    memcpy(&pPager->zJournal[nPathname], "-journal\000", 8+2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44514:    memcpy(pPager->zWal, zPathname, nPathname);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44515:    memcpy(&pPager->zWal[nPathname], "-wal\000", 4+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45861:          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46671:    ** to a malloc() or IO failure), clear the bit in the pInJournal[]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46972:  ** (e.g. due to malloc() failure), return an error code.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:47746:  memcpy((void *)&aHdr[1], (void *)&pWal->hdr, sizeof(WalIndexHdr));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:47748:  memcpy((void *)&aHdr[0], (void *)&pWal->hdr, sizeof(WalIndexHdr));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:47776:  memcpy(&aFrame[8], pWal->hdr.aSalt, 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:48222:    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:48244:    aFrame = (u8 *)sqlite3_malloc(szFrame);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:48522:  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49015:  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49017:  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49032:    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49601:    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49863:    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:52289:  memcpy(&temp[cbrk], &data[cbrk], usableSize - cbrk);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:52322:    memcpy(&data[cbrk], &temp[pc], size);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:52402:          memcpy(&data[addr], &data[pc], 2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:52523:    memcpy(&data[hdr+1], &data[pbegin], 2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:52974:        memcpy(zFullPathname, zFilename, sqlite3Strlen30(zFilename)+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:53760:  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55072:    memcpy(pPayload, pBuf, nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55075:    memcpy(pBuf, pPayload, nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55265:          memcpy(aSave, aWrite, 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55268:          memcpy(aWrite, aSave, 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56238:        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56262:            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56268:            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56291:          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56293:          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56358:            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56801:      memcpy(pPayload, pSrc, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56910:      memcpy(pTemp+nSkip, pCell+nSkip, sz-nSkip);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56939:    memcpy(&data[idx+nSkip], pCell+nSkip, sz-nSkip);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:56991:    memcpy(&data[cellbody], apCell[i], sz);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57196:    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57197:    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57391:          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57447:    memcpy(pOld, apOld[i], sizeof(MemPage));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57449:    memcpy(pOld->aData, apOld[i]->aData, pBt->pageSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57479:      memcpy(pTemp, apDiv[i], sz);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57488:        memcpy(apCell[nCell], &pOld->aData[8], 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57697:        memcpy(&pNew->aData[8], pCell, 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57744:    memcpy(&apNew[nNew-1]->aData[8], zChild, 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57950:  memcpy(pChild->aiOvfl, pRoot->aiOvfl,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:57952:  memcpy(pChild->apOvfl, pRoot->apOvfl,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:58202:      memcpy(newCell, oldCell, 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:59970:      memcpy(zOut, zIn, nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:60500:** SQLITE_NOMEM may be returned if a malloc() fails during conversion
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:60565:    memcpy(pMem->zMalloc, pMem->z, pMem->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:60581:** malloc().  In this way, we know that the memory is safe to be
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:60725:    memcpy(pMem, &ctx.s, sizeof(ctx.s));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61074:  memcpy(pTo, pFrom, MEMCELLSIZE);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61092:  memcpy(pTo, pFrom, MEMCELLSIZE);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61118:  memcpy(pTo, pFrom, sizeof(Mem));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61190:    memcpy(pMem->z, z, nAlloc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61943:** The zWhere string must have been obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:61981:** Zero is returned if a malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:62486:** the string is made into memory obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:62746:          memcpy(&zTemp[i],",...",4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:62753:        memcpy(&zTemp[i], zColl, n+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:63039:    /* This happens if a malloc() inside a call to sqlite3_column_text() or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:63430:    memcpy(p->azVar, pParse->azVar, p->nzVar*sizeof(p->azVar[0]));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:64644:      memcpy(&v, &pMem->r, sizeof(v));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:64662:    memcpy(buf, pMem->z, len);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:64751:        memcpy(&pMem->r, &x, sizeof(x));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66149:  /* Check that malloc() has not failed. If it has, return early. */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66524:** select list of a SELECT statement) that may cause a malloc() failure. If 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66525:** malloc() has failed, the threads mallocFailed flag is cleared and the result
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66541:  /* If malloc() failed during an encoding conversion within an
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66561:  ** need to call malloc() to expand the result of a zeroblob() 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:67540:** already. Return non-zero if a malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68012:    /* This happens if a malloc() inside a call to sqlite3_column_text() or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68622:    memcpy(pOut, pIn1, sizeof(Mem));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68785:** to avoid a memcpy().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68810:    memcpy(pOut->z, pIn2->z, pIn2->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:68812:  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69022:  memcpy(&ctx.s, pOut, sizeof(Mem));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69040:    /* Even though a malloc() has failed, the implementation of the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69061:  memcpy(pOut, &ctx.s, sizeof(Mem));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69145:      memcpy(&uA, &iA, sizeof(uA));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69153:      memcpy(&iA, &uA, sizeof(iA));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69227:** equivalent of sprintf().  Blob values are unchanged and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:70293:        memcpy(pNew->zName, zName, nName+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73878:  /* Jump to here if a malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74609:    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74625:      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75042:    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75168:    memcpy(pNew->pVal, pVal->z, pVal->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75444:  memcpy(pOut->z, pKey, nKey);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75576:    memcpy(zBuf, &p->zBuf[iOfst], iAmt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75599:      memcpy(&p->zBuf[iOfst], zBuf, iAmt);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75828:    memcpy(zOut, &pChunk->zChunk[iChunkOffset], nCopy);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75865:      FileChunk *pNew = sqlite3_malloc(sizeof(FileChunk));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75880:    memcpy(&p->endpoint.pChunk->zChunk[iChunkOffset], zWrite, iSpace);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:76266:  ** allowing it to be repopulated by the memcpy() on the following line.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:76273:  memcpy(pExpr, pDup, sizeof(*pExpr));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78041:        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78453:        memcpy(zAlloc, p, nNewSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78456:        memcpy(zAlloc, p, nSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78468:        memcpy(zToken, p->u.zToken, nToken);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:79630:    memcpy(out, in, 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:82660:  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:82978:  sqlite3 *db;              /* Database connection, for malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:83002:    memcpy(p->u.aRowid, pData, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:83029:  memcpy(pTo->anEq, pFrom->anEq, sizeof(tRowcnt)*p->nCol);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:83030:  memcpy(pTo->anLt, pFrom->anLt, sizeof(tRowcnt)*p->nCol);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:83031:  memcpy(pTo->anDLt, pFrom->anDLt, sizeof(tRowcnt)*p->nCol);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84357:    memcpy(pSample->p, sqlite3_column_blob(pStmt, 4), pSample->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84584:    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:85548:  memcpy(saveBuf, &pParse->nVar, SAVE_SZ);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:85553:  memcpy(&pParse->nVar, saveBuf, SAVE_SZ);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:85751:    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:86831:    memcpy(&zStmt[k], zType, len);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:86851:  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:86854:  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:86857:  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:87845:  memcpy(z, pTo->z, pTo->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:87873:      memcpy(z, pToCol->a[i].zName, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:88275:  memcpy(pIndex->zName, zName, nName+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:88329:      memcpy(zExtra, zColl, nColl);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:88577:  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:88700:** A new IdList is returned, or NULL if malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:89607:      memcpy(pColl, pColl2, sizeof(CollSeq));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:89717:      memcpy(pColl[0].zName, zName, nName);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:89721:      /* If a malloc() failure occurred in sqlite3HashInsert(), it will 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:89956:    memcpy(pBest->zName, zName, nName);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91244:** Allocate nByte bytes of space using sqlite3_malloc(). If the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91246:** the database handle that malloc() has failed and return NULL.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91884:  zOut = z = sqlite3_malloc( argc*4+1 );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92038:      memcpy(&zOut[j], zRep, nRep);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92044:  memcpy(&zOut[j], &zStr[i], nStr-i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92495:  /* The memcpy() statement assumes that the wildcard characters are
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92499:  memcpy(aWc, pDef->pUserData, 3);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:93861:      memcpy((char *)pStep->target.z, zFrom, nFrom);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:96024:** malloc() and make *pzErrMsg point to that message.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:96130:      memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97098:      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97124:    zAltEntry = sqlite3_malloc(ncFile+30);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97129:    memcpy(zAltEntry, "sqlite3_", 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97138:    memcpy(zAltEntry+iEntry, "_init", 6);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97146:      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97173:    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:98003:    memcpy(pI64, &value, sizeof(value));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106099:        z = sqlite3_malloc( n );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106101:        memcpy(z, argv[i], n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106116:** malloc() for space to hold the result and return the entire results
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106120:** from malloc().  But the caller cannot free this memory directly.  
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106145:  res.azResult = sqlite3_malloc(sizeof(char*)*res.nAlloc );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:106586:    memcpy(z, pName->z, pName->n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108530:      memcpy(zCopy, zName, nName+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:109490:  memcpy(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName)+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:110117:  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:110126:  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:110259:    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113376:      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113379:        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113683:  memcpy(zType, "...", 4);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113802:  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113818:  memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113819:  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:115501:        memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:120562:** memory obtained from sqlite3_malloc() and to make *pzErrMsg point to that
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121228:  /* Initialize the malloc() system and the recursive pInitMutex mutex.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121325:    memcpy(&y, &x, 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121372:    ** to be NULL or point to memory that was obtained from sqlite3_malloc(),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121452:      /* Retrieve the current malloc() implementation */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121613:** space for the lookaside memory is obtained from sqlite3_malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:122429:** that if a malloc() fails in sqlite3_create_function(), an error code
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:122995:    /* A malloc() may have failed within the call to sqlite3_value_text16()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123009:** passed to this function, we assume a malloc() failed during sqlite3_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123299:    zFile = sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123453:    zFile = sqlite3_malloc(nUri+2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123455:    memcpy(zFile, zUri, nUri);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123574:  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123603:  ** conversions. The only error that can occur here is a malloc() failure.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123910:** malloc() failure, but SQLite now does this automatically.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:124221:    ** Register hooks to call to indicate which malloc() failures 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:124792:          memcpy(pNew, aArg, nArg*sizeof(void *));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125838:** The aMI array is allocated using sqlite3_malloc(). It should be freed 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126513:** The pointer returned points to memory obtained from sqlite3_malloc(). It
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126521:  zRet = sqlite3_malloc(nRet);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126551:** The pointer returned points to a buffer allocated by sqlite3_malloc(). It
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126608:** The pointer returned points to a buffer allocated by sqlite3_malloc(). It
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126697:  aIndex = sqlite3_malloc(sizeof(struct Fts3Index) * nIndex);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126780:    azCol = (const char **)sqlite3_malloc(sizeof(char *) * nCol + nStr);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126788:        memcpy(p, zCol, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126862:  aCol = (const char **)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126865:    azNotindexed = (char **)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127059:  p = (Fts3Table*)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127084:  memcpy(p->aIndex, aIndex, sizeof(struct Fts3Index) * nIndex);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127094:  memcpy(zCsr, argv[2], nName);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127097:  memcpy(zCsr, argv[1], nDb);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127105:    memcpy(zCsr, z, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127365:  *ppCsr = pCsr = (sqlite3_vtab_cursor *)sqlite3_malloc(sizeof(Fts3Cursor));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127529:    memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127681:    memcpy(p, *ppPoslist, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127719:    memcpy(p, *ppPoslist, n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128190:  aOut = sqlite3_malloc(n1+n2+FTS3_VARINT_MAX-1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128405:    ** buffer using memcpy(). */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128406:    pTS->aaOutput[0] = sqlite3_malloc(nDoclist);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128409:      memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128621:  pSegcsr = sqlite3_malloc(sizeof(Fts3MultiSegReader));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129178:  memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129535:  pHash = sqlite3_malloc(sizeof(Fts3Hash));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129652:** sqlite3_malloc(). This function takes responsibility for eventually
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129823:      aOut = (char *)sqlite3_malloc(nPoslist+8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:130188:        char *aDoclist = sqlite3_malloc(nByte+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:130190:        memcpy(aDoclist, a[p->nToken-1].pList, nByte+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:130576:    aTC = (Fts3TokenAndCost *)sqlite3_malloc(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:130882:      aTmp = sqlite3_malloc(nTmp*2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:131224:      pE->aMI = (u32 *)sqlite3_malloc(pTab->nColumn * 3 * sizeof(u32));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:131641:  p = (Fts3auxTable *)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:131651:  memcpy((char *)p->pFts3Tab->zDb, zDb, nDb);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:131652:  memcpy((char *)p->pFts3Tab->zName, zFts3, nFts3);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:131764:  pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132213:** Allocate nByte bytes of memory using sqlite3_malloc(). If successful,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132218:  void *pRet = sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132308:        memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132423:        memcpy(&zTemp[nTemp], zByte, nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132451:      memcpy(zBuf, zTemp, nTemp);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132890:    apLeaf = (Fts3Expr **)sqlite3_malloc(sizeof(Fts3Expr *) * nMaxDepth);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133198:      memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133208:** sqlite3_malloc(). It is the responsibility of the caller to use 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133317:  azCol = (char **)sqlite3_malloc(nCol*sizeof(char *));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133415:  void *p = sqlite3_malloc(n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133745:    memcpy((void*)new_elem->pKey, pKey, nKey);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133828:  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133858:  c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134790:      memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134980:  t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135035:  c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135274:    *pazDequote = azDequote = sqlite3_malloc(sizeof(char *)*argc + nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135282:        memcpy(pSpace, argv[i], n+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135345:    pTab = (Fts3tokTable *)sqlite3_malloc(sizeof(Fts3tokTable));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135415:  pCsr = (Fts3tokCursor *)sqlite3_malloc(sizeof(Fts3tokCursor));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135498:    pCsr->zInput = sqlite3_malloc(nByte+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135502:      memcpy(pCsr->zInput, zByte, nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135800:  char *aData;                    /* Pointer to block from malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136252:    p = sqlite3_malloc(sizeof(*p) + 100);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136772:** NULL, then a buffer is allocated using sqlite3_malloc() and populated
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136820:      char *aByte = sqlite3_malloc(nByte + FTS3_NODE_PADDING);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136989:  memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137203:  pReader = (Fts3SegReader *)sqlite3_malloc(sizeof(Fts3SegReader) + nExtra);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137219:    memcpy(pReader->aNode, zRoot, nRoot);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137332:    pReader = (Fts3SegReader *)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137339:      memcpy(pReader->ppNextElem, aElem, nElem*sizeof(Fts3HashElem *));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137618:        pTree->aData = (char *)sqlite3_malloc(nReq);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137630:      memcpy(&pTree->aData[nData], &zTerm[nPrefix], nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137644:        memcpy(pTree->zTerm, zTerm, nTerm);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137662:  pNew = (SegmentNode *)sqlite3_malloc(sizeof(SegmentNode) + p->nNodeSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137809:    pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137815:    pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137894:  memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137897:  memcpy(&pWriter->aData[nData], aDoclist, nDoclist);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:137916:    memcpy(pWriter->zTerm, zTerm, nTerm);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:138224:  memcpy(pMsr->aBuffer, pList, nList);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:138568:              memcpy(&pCsr->aBuffer[nDoclist], pList, nList);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:138933:  pBlob = sqlite3_malloc( 10*p->nColumn );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:138983:  a = sqlite3_malloc( (sizeof(u32)+10)*nStat );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139103:      aSz = (u32 *)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139174:  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139319:      memcpy(&p->term.a[nPrefix], &p->aNode[p->iOff], nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139423:        memcpy(&pBlk->a[pBlk->n], &zTerm[nPrefix], nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139426:        memcpy(pNode->key.a, zTerm, nTerm);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139499:  memcpy(pPrev->a, zTerm, nTerm);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139506:  memcpy(&pNode->a[pNode->n], &zTerm[nPrefix], nSuffix);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139511:    memcpy(&pNode->a[pNode->n], aDoclist, nDoclist);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139842:        memcpy(pNode->block.a, aRoot, nRoot);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139854:          memcpy(pNode->key.a, reader.term.a, reader.term.n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139864:              memcpy(pNode->block.a, aBlock, nBlock);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:140328:          memcpy(pHint->a, aHint, nHint);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:140409:  pWriter = (IncrmergeWriter *)sqlite3_malloc(nAlloc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141009:  pRet = (char *)sqlite3_malloc(p->pList->nData);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141016:  memcpy(pRet, &p->pList->aData[nSkip], *pnData);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141029:  pDeferred = sqlite3_malloc(sizeof(*pDeferred));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141142:  aSzDel = sqlite3_malloc( sizeof(aSzDel[0])*(p->nColumn+1)*2 );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141693:  ** the required space using malloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141696:  sIter.aPhrase = (SnippetPhrase *)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:141775:  memcpy(&pStr->z[pStr->n], zAppend, nAppend);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:142213:  aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:142435:    pCsr->aMatchinfo = (u32 *)sqlite3_malloc(sizeof(u32)*nMatchinfo + nArg + 1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:142440:    memcpy(pCsr->zMatchinfo, zArg, nArg+1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:142632:  sCtx.aTerm = (TermOffset *)sqlite3_malloc(sizeof(TermOffset)*nToken);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:143014:  pNew = (unicode_tokenizer *) sqlite3_malloc(sizeof(unicode_tokenizer));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:143063:  pCsr = (unicode_cursor *)sqlite3_malloc(sizeof(unicode_cursor));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144042:  pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144086:      pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode)+pRtree->iNodeSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144096:        memcpy(pNode->zData, zBlob, pRtree->iNodeSize);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144401:  pCsr = (RtreeCursor *)sqlite3_malloc(sizeof(RtreeCursor));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144475:    memcpy(&c.u,a,4);                                           \
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144483:    memcpy(&c.u,a,4);                                           \
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145042:  pInfo = (sqlite3_rtree_query_info*)sqlite3_malloc( sizeof(*pInfo)+nBlob );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145047:  memcpy(pBlob, sqlite3_value_blob(pValue), nBlob);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145113:      pCsr->aConstraint = sqlite3_malloc(sizeof(RtreeConstraint)*argc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145352:  memcpy(&cell, p, sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145534:    memcpy(aSpare, aLeft, sizeof(int)*nLeft);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145603:    memcpy(aSpare, aLeft, sizeof(int)*nLeft);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145660:  aaSorted = (int **)sqlite3_malloc(nByte);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145694:      memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145695:      memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145724:  memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145725:  memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145781:  aCell = sqlite3_malloc((sizeof(RtreeCell)+sizeof(int))*(nCell+1));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:145792:  memcpy(&aCell[nCell], pCell, sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146069:  aCell = (RtreeCell *)sqlite3_malloc(n * (
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146084:      memcpy(&aCell[ii], pCell, sizeof(RtreeCell));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146729:  pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree)+nDb+nName+2);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146741:  memcpy(pRtree->zDb, argv[1], nDb);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146742:  memcpy(pRtree->zName, argv[2], nName);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146932:  pBlob = (RtreeMatchArg *)sqlite3_malloc(nBlob);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146963:  pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146988:  pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147362:  zOutput = sqlite3_malloc(nOutput);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147582:  p = (IcuTokenizer *)sqlite3_malloc(sizeof(IcuTokenizer)+n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147590:    memcpy(p->zLocale, argv[0], n);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147639:  pCsr = (IcuCursor *)sqlite3_malloc(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:341:** from [sqlite3_malloc()] and passed back through the 5th parameter.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:408:#define SQLITE_NOMEM        7   /* A malloc() failed */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:874:** [sqlite3_malloc()] and the result is stored in the char* variable
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:923:** written into memory obtained from [sqlite3_malloc()].  The caller should
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:989:** Mutexes are created using [sqlite3_mutex_alloc()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1408:** malloc(), realloc() and free() functions from the standard C library.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1420:** Every memory allocation request coming in through [sqlite3_malloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1559:** [sqlite3_malloc()] will be used to obtain the memory needed.</dd>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1577:** SQLite goes to [sqlite3_malloc()] for the additional storage space.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1589:** to using its default memory allocator (the system malloc() implementation),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1780:** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2183:** [sqlite3_malloc()] happens within sqlite3_get_table(), the calling
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2212:** results into memory obtained from [sqlite3_malloc()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2215:** NULL pointer if [sqlite3_malloc()] is unable to allocate enough
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2310:** Windows VFS uses native malloc() and free() for some operations.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2312:** ^The sqlite3_malloc() routine returns a pointer to a block
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2314:** ^If sqlite3_malloc() is unable to obtain sufficient free
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2316:** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2320:** by sqlite3_malloc() or sqlite3_realloc() releases that memory so
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2328:** was not obtained from sqlite3_malloc() or sqlite3_realloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2335:** sqlite3_malloc(N) where N is the second parameter to sqlite3_realloc().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2347:** ^The memory returned by sqlite3_malloc() and sqlite3_realloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2358:** the system malloc() and free() directly when converting
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2367:** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2374:SQLITE_API void *sqlite3_malloc(int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2382:** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2391:** added by SQLite in its implementation of [sqlite3_malloc()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2393:** routines that [sqlite3_malloc()] may call.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3420:** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3535:** ^If sqlite3_malloc() fails during the processing of either routine
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4453:** from [sqlite3_malloc()] before it returns.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5183:** obtained from [sqlite3_malloc()]. The calling function
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5850:** ^The sqlite3_mutex_alloc() routine allocates a new
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5854:** to sqlite3_mutex_alloc() is one of these integer constants:
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5868:** cause sqlite3_mutex_alloc() to create
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5878:** ^The other allowed parameters to sqlite3_mutex_alloc() (anything other
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5888:** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5930:SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5969:**   <li>  [sqlite3_mutex_alloc()] </li>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5991:** ^xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6051:** The [sqlite3_mutex_alloc()] interface takes a single argument
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6061:#define SQLITE_MUTEX_STATIC_MEM       3  /* sqlite3_malloc() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6207:** using [sqlite3_malloc()], either directly or indirectly.  The
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6208:** figure includes calls made to [sqlite3_malloc()] by the application
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6217:** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6236:** buffer and where forced to overflow to [sqlite3_malloc()].  The
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6259:** buffer and where forced to overflow to [sqlite3_malloc()].  The values
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:23:  MEMFILE* mf = (MEMFILE*) malloc(sizeof(MEMFILE));
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:43:    mf->data = (char*) malloc(block);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:47:    memcpy(mf->data + mf->size, ptr, block);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:57:  buf = (char*) malloc(mf->size + 1);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:58:  memcpy(buf, mf->data, mf->size);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:69:  *ppVTab = (sqlite3_vtab *) sqlite3_malloc(sizeof(sqlite3_vtab));
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:135:  cursor *c = (cursor *)sqlite3_malloc(sizeof(cursor));
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:124:  picojson::value* v = new picojson::value;
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:136:    u_.string_ = new std::string(s);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:140:    u_.array_ = new array(a);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:144:    u_.object_ = new object(o);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:148:    u_.string_ = new std::string(s);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:152:    u_.string_ = new std::string(s, len);

== files() ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:335:** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:418:** from [sqlite3_open()], [sqlite3_open16()], or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1161:** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1204:** analogous to the O_EXCL and O_CREAT flags of the POSIX open()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1407:** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1409:** initialized when [sqlite3_open()] is called if it has not be initialized
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:1784:** passed to [sqlite3_open()], [sqlite3_open_v2()], [sqlite3_open16()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2767:** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2776:** of the sqlite3_open() routines.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2779:** sqlite3_open() or sqlite3_open_v2() is called and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2786:** The sqlite3_open_v2() interface works like sqlite3_open()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2807:** sqlite3_open() and sqlite3_open16().</dd>)^
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2844:** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2978:** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2981:** sqlite3_open() or sqlite3_open_v2().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2984:** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, various
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2989:SQLITE_API int sqlite3_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3231:** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4743:** called right after sqlite3_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5088:** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5355:** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5693:** ^Objects of this type are created by [sqlite3_blob_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5749:** ^The [sqlite3_blob_open()] interface will fail for a [WITHOUT ROWID]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5760:SQLITE_API int sqlite3_blob_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5780:** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5786:** [sqlite3_blob_reopen()] on an aborted blob handle immediately return
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5792:SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5814:** by a failed call to [sqlite3_blob_open()]) is a harmless no-op.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5827:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5853:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5869:** writing (the flags parameter to [sqlite3_blob_open()] was zero),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5891:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:16999:  out = fopen(zFilename, "w");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:17645:    out = fopen(zFilename, "w");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:18264:    out = fopen(zFilename, "w");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:23927:  int openFlags;                      /* The flags specified at open() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24232:** Different Unix systems declare open() in different ways.  Same use
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24233:** open(const char*,int,mode_t).  Others use open(const char*,int,...).
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24240:  return open(zFile, flags, mode);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24476:** Invoke open().  Do so multiple times, until it either succeeds or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24492:static int robust_open(const char *z, int f, mode_t m){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24879:**       int fd1 = open("./file1", O_RDWR|O_CREAT, 0644);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24880:**       int fd2 = open("./file2", O_RDWR|O_CREAT, 0644);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27436:    fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28204:      pShmNode->h = robust_open(zShmFilename, openFlags, (sStat.st_mode&0777));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29266:      pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29405:  ** almost certain that an open() call on the same path will also fail.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29410:  ** Even if a subsequent open() call does succeed, the consequences of
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29438:** and a value suitable for passing as the third argument to open(2) is
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29443:** an indication to robust_open() to create the file using
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29541:  int fd = -1;                   /* File descriptor returned by open() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29542:  int openFlags = 0;             /* Flags to pass to open() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29647:  ** open(). These must be calculated even if open() is not called, as
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29666:    fd = robust_open(zName, openFlags, openMode);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29675:      fd = robust_open(zName, openFlags, openMode);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29925:  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30003:    fd = robust_open("/dev/urandom", O_RDONLY, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30416:    fd = robust_open(path, openFlags, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30420:        fd = robust_open(path, openFlags, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30426:    fd = robust_open(path, openFlags, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30550:  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL), 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30827:        fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:39807:/* Used by readers to open (lock) and close (unlock) a snapshot.  A 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:40089:**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:43004:  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45337:** If the journal file is already open (as it may be in exclusive mode),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:51241:** sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:64290:    FILE *out = fopen("vdbe_profile.out", "a");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73934:  int flags;              /* Copy of "flags" passed to sqlite3_blob_open() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73945:** This function is used by both blob_open() and blob_reopen(). It seeks
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73958:** calls to sqlite3_blob_read(), blob_write() or blob_reopen() will 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74015:SQLITE_API int sqlite3_blob_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74240:** sqlite3_blob_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74344:SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121172:** sqlite3_open().  
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123009:** passed to this function, we assume a malloc() failed during sqlite3_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123246:** user to API functions sqlite3_open() or sqlite3_open_v2(), and for database
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123479:** sqlite3_open() and sqlite3_open16(). The database filename "zFilename"  
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123752:SQLITE_API int sqlite3_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136805:    rc = sqlite3_blob_reopen(p->pSegments, iBlockid);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136811:    rc = sqlite3_blob_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147254:**     uregex_open()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147279:    pExpr = uregex_open(zPattern, -1, 0, 0, &status);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147383:** a UCollator structure previously allocated using ucol_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147392:** a UCollator structure previously allocated using ucol_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147446:  pUCollator = ucol_open(zLocale, &status);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147670:  pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:220:** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:303:** from [sqlite3_open()], [sqlite3_open16()], or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1046:** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1089:** analogous to the O_EXCL and O_CREAT flags of the POSIX open()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1292:** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1294:** initialized when [sqlite3_open()] is called if it has not be initialized
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:1669:** passed to [sqlite3_open()], [sqlite3_open_v2()], [sqlite3_open16()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2652:** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2661:** of the sqlite3_open() routines.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2664:** sqlite3_open() or sqlite3_open_v2() is called and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2671:** The sqlite3_open_v2() interface works like sqlite3_open()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2692:** sqlite3_open() and sqlite3_open16().</dd>)^
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2729:** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2863:** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2866:** sqlite3_open() or sqlite3_open_v2().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2869:** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, various
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2874:SQLITE_API int sqlite3_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3116:** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4628:** called right after sqlite3_open().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4973:** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5240:** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5578:** ^Objects of this type are created by [sqlite3_blob_open()]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5634:** ^The [sqlite3_blob_open()] interface will fail for a [WITHOUT ROWID]
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5645:SQLITE_API int sqlite3_blob_open(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5665:** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5671:** [sqlite3_blob_reopen()] on an aborted blob handle immediately return
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5677:SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5699:** by a failed call to [sqlite3_blob_open()]) is a harmless no-op.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5712:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5738:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5754:** writing (the flags parameter to [sqlite3_blob_open()] was zero),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5776:** by a prior successful call to [sqlite3_blob_open()] and which has not
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:22:memfopen() {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:97:my_open(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor) {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:105:  mf = memfopen();

== logging() ==
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:27:void inject_message(void *opdata, const char *accountname, const char *protocol, const char *recipient, const char *message) {
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:37:int display_otr_message(void *opdata, const char *accountname, const char *protocol, const char *username, const char *msg) {
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:69:void log_message(void *opdata, const char *message) {
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:122:    perror("creating temp file");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2308:** [sqlite3_errmsg()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2774:** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3060:** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-language
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3088:SQLITE_API const char *sqlite3_errmsg(sqlite3*);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3783:** ^[SQLITE_ERROR] means that a run-time error (such as a constraint
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3785:** the VM. More information may be found by calling [sqlite3_errmsg()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4499:** ^The sqlite3_result_error() and sqlite3_result_error16() functions
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4502:** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4504:** message string from sqlite3_result_error() as UTF-8. ^SQLite
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4506:** byte order.  ^If the third parameter to sqlite3_result_error()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4509:** ^If the third parameter to sqlite3_result_error() or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4512:** ^The sqlite3_result_error() and sqlite3_result_error16()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4518:** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:4586:SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5256:** in the [database connection] (to be retrieved using sqlite3_errmsg()).)^
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5351:** point to an appropriate error message (obtained from [sqlite3_mprintf()])
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5728:** accessible via [sqlite3_errcode()] and [sqlite3_errmsg()] and related
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6220:** or [sqlite3_errmsg()].  The underlying xFileControl method might
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6887:** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:12941:SQLITE_PRIVATE    void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15049:    sqlite3_result_error(pCtx, "local time unavailable", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:23044:** used as an argument to sqlite3_errmsg() or sqlite3_close().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25013:** errno and, if possible, the human-readable equivalent from strerror() or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25029:  char *zErr;                     /* Message from strerror() or equivalent */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25033:  ** the strerror() function to obtain the human-readable error message
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25062:  /* Non-threadsafe build, use strerror(). */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:25063:  zErr = strerror(iErrno);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:26577:             path, tErrno, strerror(tErrno)));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29939:  zErr = dlerror();
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30367:                     buf, strerror(err), lockPath, getpid()));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30540:    sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30546:    sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30805:                      cmode, code, strerror(code));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30812:                    err, code, strerror(code));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:31905: * The size of the buffer used by sqlite3_win32_write_debug().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:32854:SQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:37033:** sqlite3_errmsg(), possibly making IO errors easier to debug.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:40143:**    The ERROR state is entered when an IO or disk-full error (including
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:41713:static int pager_error(Pager *pPager, int rc){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:43855:      pager_error(pPager, pagerSyncHotJournal(pPager));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44344:  return pager_error(pPager, rc); 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44974:        pager_error(pPager, rc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46156:  return pager_error(pPager, rc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46225:  ** cache. So call pager_error() on the way out to make any error persistent.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46227:  return pager_error(pPager, rc);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:47037:** error (SQLITE_BUSY) is returned and the log connection is not closed.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:47610:** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:50757:**   A unrecoverable error (an I/O error or a malloc failure) has occurred
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:64197:** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:65735:SQLITE_PRIVATE void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:65806:** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:65832:** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:65987:SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66272:    ** sqlite3_errmsg() and sqlite3_errcode().
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66346:  sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:71844:    sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73349:  if( pVTab ) sqlite3VtabImportErrmsg(p, pVTab->pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73400:  sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73477:    sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73529:  sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73582:  sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73619:    sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73684:    sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74001:      zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84601:    sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84705:    sqlite3_result_error(context, zErrDyn, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:84764:  sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91008:          sqlite3_result_error(context, "integer overflow", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91635:    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:91647:      sqlite3_result_error(context, 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92212:    sqlite3_result_error(context, zErrMsg, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92268:      sqlite3_result_error(context,"integer overflow",-1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:96127:    int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:96130:      memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:99804:          corruptSchema(pData, argv[0], sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108134:    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108149:    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:109303:      sqlite3VtabImportErrmsg(p, pVtab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:119706:static void yy_syntax_error(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:119840:        yy_syntax_error(yypParser,yymajor,yyminorunion);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:119882:      yy_syntax_error(yypParser,yymajor,yyminorunion);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:119897:        yy_syntax_error(yypParser,yymajor,yyminorunion);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:122938:SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123274:  char **pzErrMsg                 /* OUT: Error message (if rc!=SQLITE_OK) */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129174:    sqlite3_result_error(pContext, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:129204:    sqlite3_result_error(pContext, 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133098:  char **pzErr                        /* OUT: Error message (sqlite3_malloc) */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133290:    sqlite3_result_error(context, 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133302:    sqlite3_result_error(context, "No such tokenizer module", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:133341:    sqlite3_result_error(context, "Error parsing expression", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134497:      sqlite3_result_error(context, "argument type mismatch", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134503:      sqlite3_result_error(context, "out of memory", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134510:      sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134687:    sqlite3_result_error(context, "insufficient arguments", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134701:    sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134742:    sqlite3_result_error(context, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134838:  assert( 0==strcmp(sqlite3_errmsg(db), "unknown tokenizer: nosuchtokenizer") );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139473:** If an error (i.e. OOM condition) occurs, an SQLite error code is
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:140825:** Or, if an error (e.g. an OOM or IO error) occurs, return an SQLite 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:142759:        sqlite3_result_error(pContext, zErr, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146671:      *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146680:      *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146753:      *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146771:        *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:146863:    sqlite3_result_error(ctx, "Invalid argument to rtreedepth()", -1); 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147186:    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147201:      sqlite3_result_error(context, 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147227:  sqlite3_result_error(pCtx, zBuf, -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147458:    sqlite3_result_error(p, "Error registering collation function", -1);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2193:** [sqlite3_errmsg()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2659:** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2945:** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-language
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2973:SQLITE_API const char *sqlite3_errmsg(sqlite3*);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3668:** ^[SQLITE_ERROR] means that a run-time error (such as a constraint
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3670:** the VM. More information may be found by calling [sqlite3_errmsg()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4384:** ^The sqlite3_result_error() and sqlite3_result_error16() functions
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4387:** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4389:** message string from sqlite3_result_error() as UTF-8. ^SQLite
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4391:** byte order.  ^If the third parameter to sqlite3_result_error()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4394:** ^If the third parameter to sqlite3_result_error() or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4397:** ^The sqlite3_result_error() and sqlite3_result_error16()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4403:** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:4471:SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5141:** in the [database connection] (to be retrieved using sqlite3_errmsg()).)^
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5236:** point to an appropriate error message (obtained from [sqlite3_mprintf()])
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5613:** accessible via [sqlite3_errcode()] and [sqlite3_errmsg()] and related
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6105:** or [sqlite3_errmsg()].  The underlying xFileControl method might
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6772:** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/or
./dist/src/github.com/mattn/go-sqlite3/_example/mod_regexp/sqlite3_mod_regexp.c:18:      sqlite3_result_error(context, errstr, 0);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:746:  inline void set_last_error(const std::string& s) {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:750:  inline const std::string& get_last_error() {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:787:  picojson::set_last_error(std::string());
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/picojson.h:790:    picojson::set_last_error(err);

== environment() ==
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:114:  if (getenv("TMP")) {
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:115:    tmpdir = getenv("TMP");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29314:  if( !azDirs[1] ) azDirs[1] = getenv("SQLITE_TMPDIR");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29315:  if( !azDirs[2] ) azDirs[2] = getenv("TMPDIR");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29739:    char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35896:       0, /* getenv("SQLITE_TMPDIR") */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35897:       0, /* getenv("TMPDIR") */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35898:       0, /* getenv("TMP") */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35899:       0, /* getenv("TEMP") */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35900:       0, /* getenv("USERPROFILE") */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35910:    if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35911:    if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35912:    if( !azDirs[2] ) azDirs[2] = getenv("TMP");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35913:    if( !azDirs[3] ) azDirs[3] = getenv("TEMP");
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35914:    if( !azDirs[4] ) azDirs[4] = getenv("USERPROFILE");
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:103:  char* cert_file = getenv("SSL_CERT_FILE");

== privileged() ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:7958:** recursive mutexes on most Unix systems and fchmod() on OpenBSD.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24244:** On some systems, calls to fchown() will trigger a message in a security
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24245:** log if they come from non-root processes.  So avoid calling fchown() if
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24248:static int posixFchown(int fd, uid_t uid, gid_t gid){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24249:  return geteuid() ? 0 : fchown(fd,uid,gid);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24339:#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24361:#define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24519:        osFchmod(fd, m);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28115:** or a chroot() might cause two different processes on the same
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28214:      osFchown(pShmNode->h, sStat.st_uid, sStat.st_gid);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29687:      osFchown(fd, uid, gid);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30797:            osFchmod(conchFile->h, cmode);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30800:              rc = osFchmod(conchFile->h, cmode);

== networking() ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125010:** exceeds LEAF_MAX bytes (default 2048).  New data which itself is
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135868:#define SQL_MAX_LEAF_NODE_ESTIMATE    29
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:139949:  rc = fts3SqlStmt(p, SQL_MAX_LEAF_NODE_ESTIMATE, &pLeafEst, 0);
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:124:  write(fd, kPrivateKeyData, sizeof(kPrivateKeyData)-1);
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:128:  otrl_privkey_read(userstate, private_key_file);
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:162:      write(1, newmessage, strlen(newmessage));
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:163:      write(1, "\n", 1);
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:166:      write(1, "?OTRv2?\n", 8);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:2891:**     "rw", then the database is opened for read-write (but not create) 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3564:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3591:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3602:** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:3607:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5695:** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5738:** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5785:** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5849:** ^(On success, sqlite3_blob_read() returns SQLITE_OK.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5857:** See also: [sqlite3_blob_write()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5859:SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5887:** ^(On success, sqlite3_blob_write() returns SQLITE_OK.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5895:** See also: [sqlite3_blob_read()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:5897:SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:7774:** device characteristics (sector-size and atomic write() support),
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:10866:** deleted and the sqlite3_vtab* handles are not xDisconnect()ed 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:12933:SQLITE_PRIVATE    void sqlite3VtabDisconnect(sqlite3 *db, Table *p);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:20227:  ** mutex here. Otherwise the read (and possible write) of db->mallocFailed 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24310:#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24327:#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27045:    got = osPread(id->h, pBuf, cnt, offset);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27161:  do{ rc = osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:27545:    ** use read() and write() to access data beyond this point from now on.  
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30544:  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30555:  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30621:        int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:34259:  ** use read() and write() to access data beyond this point from now on.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45510:static int pager_write(PgHdr *pPg){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45642:** The difference between this function and pager_write() is that this
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45702:            rc = pager_write(pPage);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45737:    rc = pager_write(pDbPage);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:53228:    ** data is passed to system call write(). So to avoid this error,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55232:        ** range of data that is being read (eOp==0) or written (eOp!=0).
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:59483:** Return non-zero if a read (or write) transaction is active.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:62964:      ** with no indexes using a single prepared INSERT statement, bind() 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66772:static int vdbeUnbind(Vdbe *p, int i){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66828:  rc = vdbeUnbind(p, i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66862:  rc = vdbeUnbind(p, i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66875:  rc = vdbeUnbind(p, i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66885:  rc = vdbeUnbind(p, i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66945:  rc = vdbeUnbind(p, i);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73948:** sqlite3_blob_read() or sqlite3_blob_write() access the specified row.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73958:** calls to sqlite3_blob_read(), blob_write() or blob_reopen() will 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74035:  ** uses it to implement the blob_read(), blob_write() and 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74312:SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74319:SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:75494:** be used to service read() and write() requests. The actual file
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108603:** reaches zero, call the xDisconnect() method to delete the object.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108616:      p->pModule->xDisconnect(p);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:108669:SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121878:        if( IsVirtual(pTab) ) sqlite3VtabDisconnect(db, pTab);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121920:  ** will not have called the xDisconnect() method on any virtual
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:126217:** The xDisconnect() virtual table method.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136828:        rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136856:  rc = sqlite3_blob_read(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:144362:static int rtreeDisconnect(sqlite3_vtab *pVtab){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:2776:**     "rw", then the database is opened for read-write (but not create) 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3449:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3476:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3487:** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:3492:** See also: [sqlite3_bind_blob|sqlite3_bind()],
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5580:** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5623:** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5670:** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5734:** ^(On success, sqlite3_blob_read() returns SQLITE_OK.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5742:** See also: [sqlite3_blob_write()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5744:SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5772:** ^(On success, sqlite3_blob_write() returns SQLITE_OK.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5780:** See also: [sqlite3_blob_read()].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5782:SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:38:memfwrite(char* ptr, size_t size, size_t nmemb, void* stream) {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:64:my_connect(sqlite3 *db, void *pAux, int argc, const char * const *argv, sqlite3_vtab **ppVTab, char **c) {
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:76:  return my_connect(db, pAux, argc, argv, ppVTab, c);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:79:static int my_disconnect(sqlite3_vtab *pVTab) {

== http:// ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:214:** <a href="http://www.fossil-scm.org/">Fossil configuration management
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:14949:** See http://msdn.microsoft.com/en-us/library/a442x3ye(VS.80).aspx.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30146:** and writers [http://sqlite.org/lockingv3.html].  The five file locking
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30165:** [http://nfs.sourceforge.net/#faq_a8], which does not effectively
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30168:** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:49885:    **     http://localhost:591/sqlite/info/ff5be73dee
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:104268:** http://www.sqlite.org/src/info/6709574d2a
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:113423:    ** See ticket http://www.sqlite.org/src/info/f2369304e4
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:121549:      ** http://support.microsoft.com/kb/47961
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:124209:      ** http://support.microsoft.com/kb/47961
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:143430:  ** http://www.unicode.org for details.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:147339:** http://www.icu-project.org/userguide/posix.html#case_mappings
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:99:** <a href="http://www.fossil-scm.org/">Fossil configuration management

== encryption ==
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:103:  char* cert_file = getenv("SSL_CERT_FILE");
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:107:  curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 1);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:108:  curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2);
./dist/src/github.com/mattn/go-sqlite3/_example/mod_vtable/sqlite3_mod_vtable.cc:110:  curl_easy_setopt(curl, CURLOPT_URL, "https://api.github.com/repositories");

== sql() ==
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:11697:#define SF_MaybeConvert    0x0400  /* Need convertCompoundSelectToSubquery() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:11883:  u8 hasCompound;      /* Need to invoke convertCompoundSelectToSubquery() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:11928:  u32 nQueryLoop;      /* Est number of iterations of a query (10*log2(N)) */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:79127:** for the duration of the query (i.e. the SELECT within the (...)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:103224:**     coA: coroutine for left query (A)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:103225:**     coB: coroutine for right query (B)
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:103773:static int flattenSubquery(
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:104054:    ** outer query (the middle slot) is used by the subquery.  The next
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:104274:static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:105084:** count(*) query ("SELECT count(*) FROM pTab").
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:105228:    if( flattenSubquery(pParse, p, i, isAgg, isAggSub) ){
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:109746:** correspond to the subquery(s) of OR-clause processing.  Only the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:112199:  ** range query (e.g. col > ?) is assumed to match 1/4 of the rows in the
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:128680:  int iColumn,                    /* Column to query (or -ve for all columns) */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:130479:  **   a. The cheapest token in the entire query (i.e. the one visited by the

== tmp() ==
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:113:  const char *tmpdir = "/tmp";
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:28112:** Another approach to is to use files in /dev/shm or /dev/tmp or an
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29304:     "/var/tmp",
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29305:     "/usr/tmp",
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29306:     "/tmp",
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:30324:  len = strlcpy(lPath, "/tmp/", maxLen);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35901:       "/var/tmp",
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35902:       "/usr/tmp",
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35903:       "/tmp",

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./dist/src/golang.org/x/crypto/otr/libotr_test_helper.c:119:  snprintf(private_key_file, sizeof(private_key_file), "%s/libotr_test_helper_privatekeys-XXXXXX", tmpdir);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6093:** The only difference is that the public sqlite3_XXX functions enumerated
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6908:** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:6929:** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], or
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:8834:/* TODO: This definition is just included so other modules compile. It
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:15703:** So we test the effects of a malloc() failing and the sqlite3OsXXX()
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:24696:  ** the default SQLITE_IOERR_XXX code will be returned. */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:29380:** zPath with SQLITE_OPEN_XXX flags matching those passed as the second
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:35727:    /* FIXME:  If Windows truly always prevents truncating or deleting a
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:36044:  **   "<temporary_directory>/etilqs_XXXXXXXXXXXXXXX\0\0"
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:40477:**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42270:** TODO: This function allocates a single block of memory to load
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42396:    /* TODO: Is it safe to use Pager.dbFileSize here? */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:42554:  ** TODO: Technically the following is an error because it assumes that
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44161:** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:44376:** various SQLITE_IO_XXX errors.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45133:  int flags           /* PAGER_GET_XXX flags */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45400:      /* TODO: Check if all of these are really required. */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:45905:** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:46994:** not support the xShmXXX() methods, return an error code. *pbOpen is
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:50717:  u8 eState;                /* One of the CURSOR_XXX constants (see below) */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:50800:** The PTRMAP_XXX identifiers below are the valid types.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:55936:  /* TODO: What if the cursor is in CURSOR_REQUIRESEEK but all table entries
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:59698:** This file contains the implementation of the sqlite3_backup_XXX() 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:59733:**     * Via the sqlite3_backup_XXX() API function backup_step() and 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:59744:**   The other sqlite3_backup_XXX() API functions, backup_remaining() and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:63722:    zMaster = sqlite3MPrintf(db, "%s-mjXXXXXX9XXz", zMainFile);
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:63896:** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66522:** This function is called after invoking an sqlite3_value_XXX function on a 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:66542:  ** sqlite3_column_XXX API, then set the return code of the statement to
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:69041:    ** user function may have called an sqlite3_result_XXX() function
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:71531:** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:73144:** PAGER_JOURNALMODE_XXX values. If changing between the various rollback
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:74909:** Free any cursor components allocated by sqlite3VdbeSorterXXX routines.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78390:** mask containing EXPRDUP_XXX flags.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:78541:** The flags parameter contains a combination of the EXPRDUP_XXX flags.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:88301:  ** TODO:  Add a test to make sure that the same column is not named
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:90653:    /* TODO: Could use temporary registers here. Also could attempt to
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:92714:** TODO: How should dropping a table be handled? How should renaming a 
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:93163:  WhereInfo *pWInfo;              /* Context used by sqlite3WhereXXX() */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97419:** The next block of code, including the PragTyp_XXXX macro definitions and
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97469:  u8 ePragTyp;              /* PragTyp_XXX value */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:97470:  u8 mPragFlag;             /* Zero or more PragFlag_XXX values */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:98061:** Parameter eMode must be one of the PAGER_JOURNALMODE_XXX constants
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:98398:    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:99407:    }else{                        /* "PRAGMA encoding = XXX" */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:101662:/* No-op versions of the explainXXX() functions and macros. */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:101700:/* No-op versions of the explainXXX() functions and macros. */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:103688:**   (7)  The subquery has a FROM clause.  TODO:  For subqueries without
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:109126:** description of the error and an SQLITE_XXX error code is returned.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:123271:  unsigned int *pFlags,           /* IN/OUT: SQLITE_OPEN_XXX flags */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125018:** TODO(shess) It may be useful for blocking decisions to be more
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125136:** TODO(shess) That said, it would be nice to have a better query-side
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125217:/* TODO(shess) Only used for SQLITE_OK and SQLITE_DONE at this time.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125318:  /* TODO(shess) current implementation requires pInput to be
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125842:  int eType;                 /* One of the FTSQUERY_XXX values defined below */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:125937:  /* Used internally by sqlite3Fts3SegReaderXXX() calls */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:127144:  ** database. TODO: For xConnect(), it could verify that said tables exist.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:132608:  ** TODO: Strangely, it is not possible to associate a column specifier
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:134984:  /* TODO(shess) Delimiters need to remain the same from run to run,
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135106:        /* TODO(shess) This needs expansion to handle UTF-8
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135808:** within the fts3SegWriterXXX() family of functions described above.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:135894:  int eStmt,                      /* One of the SQL_XXX constants above */
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.c:136473:  /* TODO(shess) Explore whether partially flushing the buffer on
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:5978:** The only difference is that the public sqlite3_XXX functions enumerated
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6793:** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.
./dist/src/github.com/mattn/go-sqlite3/code/sqlite3-binding.h:6814:** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], or

== unsafe input mechanisms ==

