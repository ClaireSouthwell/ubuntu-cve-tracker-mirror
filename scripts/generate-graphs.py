#!/usr/bin/env python
#
# This script generates graphs and raw number data (read from a USN database).
# By default, it expects to use the "-all" database to produce full historical
# information. Note that source package data before source-package tracking
# was done in the USN database is inaccurate (before July 2007), and is
# approximated.
#
# Files are generated in a given target directory, one file per
# combination:
#  - per-release, all time
#  - per-release, last 12 months
#  - all releases, all time
#  - all releases, last 12 months
# The data is summed per-month, and built using the following multipliers:
#  - USNs published
#  - unique CVEs fixed
#  - unique source packages
#  - regressions fixed
#  - CVEs across srcpkgs (if CVE applied to multiple source packages, count it
#    multiple times)
#  - CVEs across srcpkgs across USNs (each distinct fix counted)
# File naming convention is DATASRCS_RELEASE_TIME.dat
# For example:
#  - CVE-srcpkg-USN_lucid_12.dat
#  - CVE_all_all.dat
# Plot files are named with the .plot extension, and include merged views
# for the per-release plots, named "merged". For example:
#  - CVE-srcpkg_merged_12.plot
# Graph images (.png) follow the same naming convention as the plot files.
# Additionally, an index.html is generated as an overview file for available
# graphs.
#
# Copyright (C) 2008-2011 Canonical, Ltd
# Author: Kees Cook <kees@ubuntu.com>
# License: GPLv3
import sys, time, usn_lib, cve_lib
import optparse
import subprocess

import pprint
pp = pprint.PrettyPrinter(indent=4)

parser = optparse.OptionParser()
parser.add_option("--target", help="Into which directory to write the data files", metavar="DIR", action='store')
parser.add_option("-D", "--database", help="Specify location of USN data (default 'database-all.pickle')", default="database-all.pickle")
(opt, args) = parser.parse_args()

if opt.target == None:
    print >>sys.stderr, "Must specify --target"
    sys.exit(1)

config = cve_lib.read_config()
db = usn_lib.load_database(opt.database)
# info is: [release][datasrc][month] = set() of unique datasrc items,
# where month is int(YYYYMM). See "establish_release()" for initialization.
info = dict()
details = {
    'USN': "USNs published per month",
    'CVE': "unique CVEs fixed per month",
    'srcpkg': "unique Source Packages fixed per month",
    'regression': "Regressions fixed per month",
    'CVE-srcpkg': "distinct CVE fixes published (regardless of USN) per month",
    'CVE-srcpkg-USN': "distinct CVE fixes published per month",
}
datasrcs = details.keys()

def establish_release(rel, when):
    if not info.has_key(rel):
        info.setdefault(rel, dict())
    for datasrc in datasrcs:
        info[rel].setdefault(datasrc, dict())
        info[rel][datasrc].setdefault(when, set())

def base_path(source, release, span, ext=""):
    return '%s/%s_%s_%s.%s' % (opt.target, source, release, span, ext)

# collect file descriptors instead of open/closing on every line
fds = dict()
def write_report(release, source, month, span, count):
    # File naming convention is DATASRCS_RELEASE_TIME.dat
    filepath = base_path(source, release, span, 'dat')
    if not filepath in fds:
        fds[filepath] = open(filepath, 'w')
    fds[filepath].write('%d %d\n' % (month, count))

def build_plot(release, source, span):
    basepath = base_path(source, release, span)
    datpath = basepath + 'dat'
    cmdpath = basepath + 'plot'
    imgpath = basepath + 'png'
    output = open(cmdpath, 'w')
    print >>output, 'set term png small size 800,600'
    print >>output, 'set output "%s"' % (imgpath)
    print >>output, 'set xdata time'
    print >>output, 'set timefmt "%Y%m"'
    print >>output, 'set format x "  %b %Y"'
    print >>output, 'set xtics out rotate'
    print >>output, 'set key top right'
    title = details[source] + ' ('
    if release == 'all':
        title += "all releases"
    else:
        title += release
    if span == 'all':
        pass
    elif span == '12':
        title += ', last 12 months'
    else:
        raise ValueError, "Unknown span '%s'" % (span)
    title += ')'
    print >>output, 'set title "%s"' % (title)
    print >>output, 'plot "%s" using 1:2 with filledcurve x1 lc rgb "blue" title "%s"' % (datpath, 'count')
    output.close()
    subprocess.call(['gnuplot',cmdpath])

def build_merged_plot(releases, source, span):
    basepath = base_path(source, 'merged', span)
    cmdpath = basepath + 'plot'
    imgpath = basepath + 'png'
    output = open(cmdpath, 'w')
    print >>output, 'set term png small size 800,600'
    print >>output, 'set output "%s"' % (imgpath)
    print >>output, 'set xdata time'
    print >>output, 'set timefmt "%Y%m"'
    print >>output, 'set format x "  %b %Y"'
    print >>output, 'set xtics out rotate'
    print >>output, 'set key top left'
    title = details[source] + ' (all releases'
    if span == 'all':
        pass
    elif span == '12':
        title += ', last 12 months'
    else:
        raise ValueError, "Unknown span '%s'" % (span)
    title += ')'
    print >>output, 'set title "%s"' % (title)
    plots = []
    for rel in releases:
        datpath = base_path(source, rel, span, 'dat')
        #if not os.path.exists(datpath):
        #    continue
        plots.append(' "%s" using 1:2 with line title "%s"' % (datpath, rel),)
    print >>output, 'plot %s' % (', '.join(plots))
    output.close()
    subprocess.call(['gnuplot',cmdpath])

# collect data sets
for usn in sorted(db.keys()):
    when = int(time.strftime('%Y%m', time.gmtime(int(db[usn]['timestamp']))))

    cves = set()

    regressions = set()
    if 'egression' in db[usn]['title']:
        regressions.add(usn)

    if len(regressions) == 0 and db[usn].has_key('cves'):
        for cve in db[usn]['cves']:
            # Skip non-CVEs
            if cve.startswith('CVE-') or cve.startswith('CAN-'):
                cves.add(cve)

    srcs = set()
    for rel in db[usn]['releases']:
        if db[usn]['releases'][rel].has_key('sources'):
            for src in db[usn]['releases'][rel]['sources']:
                srcs.add(src)
        else:
            # Assume that the early USNs updated a single srcpkg, so assume
            # that each USN was a unique src package.
            srcs.add('unknown-srcpkg_%s' % (usn))

    for rel in db[usn]['releases'].keys() + ['all']:
        establish_release(rel, when)
        info[rel]['USN'][when].add(usn)
        info[rel]['CVE'][when].update(cves)
        info[rel]['srcpkg'][when].update(srcs)
        info[rel]['regression'][when].update(regressions)
        for src in srcs:
            for cve in cves:
                info[rel]['CVE-srcpkg'][when].add('%s_%s' % (cve, src))
                info[rel]['CVE-srcpkg-USN'][when].add('%s_%s_%s' % (cve, src, usn))

# write out data set sums
for rel in info:
    for datasrc in datasrcs:
        months = sorted(info[rel][datasrc])
        past = months[-1] - 100
        for when in months:
            # Handle raw data
            count = len(info[rel][datasrc][when])
            write_report(rel, datasrc, when, 'all', count)
            if when > past:
                write_report(rel, datasrc, when, '12', count)

# explicitly close all raw data fds
for name in fds:
    fds[name].close()


# plot the data
for datasrc in datasrcs:
    releases = []
    for rel in info:
        for span in ['all','12']:
            build_plot(rel, datasrc, span)
        if rel in ['all']:
            continue
        releases.append(rel)
    for span in ['all','12']:
        build_merged_plot(releases, datasrc, span)
