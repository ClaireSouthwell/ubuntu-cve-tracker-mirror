Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./src/libsodium/crypto_generichash/blake2/ref/blake2b-compress-avx2.h:19:    memcpy(&v, p, sizeof v);
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:135:  memcpy( P->salt, salt, BLAKE2B_SALTBYTES );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:141:  memcpy( P->personal, personal, BLAKE2B_PERSONALBYTES );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:246:    memcpy( block, key, keylen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:287:    memcpy( block, key, keylen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:304:      memcpy( S->buf + left, in, fill ); /* Fill buffer */
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:308:      memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES ); /* Shift buffer left */
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:315:      memcpy( S->buf + left, in, inlen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:336:    memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:345:  memcpy( out, &S->h[0], outlen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:353:    memcpy( out, buffer, outlen );
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:421:    memcpy(&val, &stream.rnd32[stream.rnd32_outleft], sizeof val);
./src/libsodium/crypto_auth/hmacsha512256/cp/hmac_hmacsha512256.c:37:    memcpy(out, out0, 32);
./src/libsodium/crypto_sign/ed25519/ref10/keypair.c:73:    memcpy(curve25519_sk, h, crypto_scalarmult_curve25519_BYTES);
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:59:    memcpy(sm, sig, 32);
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:60:    memcpy(sm + 32 + mlen, sig + 32, 32);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:195:    memcpy(&out, in, sizeof (limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:200:    memcpy(out, &in, sizeof (limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:315:  memcpy(origx, x, 5 * sizeof(limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:319:  memcpy(origxprime, xprime, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:324:  memcpy(origxprime, xxprime, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:374:  memcpy(nqpqx, q, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:408:  memcpy(resultx, nqx, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:409:  memcpy(resultz, nqz, sizeof(limb) * 5);
./src/libsodium/crypto_pwhash/argon2/argon2.c:106:    out = (uint8_t *) malloc(hashlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:137:        memcpy(hash, out, hashlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:195:    ctx.ad = (uint8_t *) malloc(ctx.adlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:196:    ctx.salt = (uint8_t *) malloc(ctx.saltlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:197:    ctx.out = (uint8_t *) malloc(ctx.outlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:204:    out = (uint8_t *) malloc(ctx.outlen);
./src/libsodium/crypto_pwhash/argon2/argon2-encoding.c:358:    memcpy(str, &tmp[i], (sizeof tmp) - i);
./src/libsodium/crypto_pwhash/argon2/argon2-encoding.c:382:        memcpy(dst, str, pp_len + 1);                                          \
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:44:    memcpy(dst->v, src->v, sizeof(uint64_t) * ARGON2_QWORDS_IN_BLOCK);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:89:    *region = (block_region *)malloc(sizeof(block_region));  /*2. Try to allocate region*/
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:104:    memcpy(&memory, &base, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:109:    memcpy(&memory, &base, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:115:    } else if ((base = malloc(memory_size + 63)) != NULL) {
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:118:        memcpy(&memory, &aligned, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c:153:        (uint64_t *)malloc(sizeof(uint64_t) * (instance->segment_length));
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:55:        memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:60:            memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:65:            memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:70:        memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:74:        memcpy(out, out_buffer, toproduce);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:145:        (uint64_t *)malloc(sizeof(uint64_t) * instance->segment_length);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:172:    memcpy(state, ((instance->region->memory + prev_offset)->v), ARGON2_BLOCK_SIZE);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/crypto_scrypt-common.c:169:    memcpy(dst, setting, prefixlen + saltlen);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:64:        memcpy(&hctx, &PShctx, sizeof(crypto_auth_hmacsha256_state));
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:68:        memcpy(T, U, 32);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:85:        memcpy(&buf[i * 32], T, clen);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/scrypt_platform.c:56:    else if ((base = (uint8_t *) malloc(size + 63)) != NULL) {
./src/libsodium/crypto_box/crypto_box_seal.c:34:    memcpy(c, epk, crypto_box_PUBLICKEYBYTES);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:534:    memcpy(H, ctx->H, sizeof H);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:538:    memcpy(&n2[0], npub, 3 * 4);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:544:        memcpy(&fb[0], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:546:        memcpy(&fb[8], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:678:    memcpy(&n2[0], npub, 3 * 4);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:685:        memcpy(&fb[0], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:687:        memcpy(&fb[8], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:690:    memcpy(H, ctx->H, sizeof H);
./src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c:103:    memcpy(&iv_low, iv, 4);
./src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c:104:    memcpy(&iv_high, iv + 4, 4);
./src/libsodium/sodium/utils.c:527:_sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:529:    return malloc(size > (size_t) 0U ? size : (size_t) 1U);
./src/libsodium/sodium/utils.c:533:_sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:559:    memcpy(unprotected_ptr + unprotected_size, canary, sizeof canary);
./src/libsodium/sodium/utils.c:566:    memcpy(canary_ptr, canary, sizeof canary);
./src/libsodium/sodium/utils.c:567:    memcpy(base_ptr, &unprotected_size, sizeof unprotected_size);
./src/libsodium/sodium/utils.c:576:sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:580:    if ((ptr = _sodium_malloc(size)) == NULL) {
./src/libsodium/sodium/utils.c:599:    return sodium_malloc(total_size);
./src/libsodium/sodium/utils.c:624:    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);
./src/libsodium/sodium/utils.c:660:    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);
./src/libsodium/include/sodium/utils.h:70:/* WARNING: sodium_malloc() and sodium_allocarray() are not general-purpose
./src/libsodium/include/sodium/utils.h:93: * sodium_malloc() can be used to allocate any libsodium data structure,
./src/libsodium/include/sodium/utils.h:97: * either 357 or 361 bytes. For this reason, when using sodium_malloc() to
./src/libsodium/include/sodium/utils.h:100: * state = sodium_malloc((crypto_generichash_statebytes() + (size_t) 63U)
./src/libsodium/include/sodium/utils.h:105:void *sodium_malloc(const size_t size)
./src/libsodium/include/sodium/private/common.h:14:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:34:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:53:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:69:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:86:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:107:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:123:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:141:    memcpy(dst, &w, sizeof w);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:65:    memcpy(&tmp, m, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:80:    if (bytes &  8) { memcpy(dst, src, 8); src += 8; dst += 8; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:81:    if (bytes &  4) { memcpy(dst, src, 4); src += 4; dst += 4; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:82:    if (bytes &  2) { memcpy(dst, src, 2); src += 2; dst += 2; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:105:    memcpy(&t0, key, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:106:    memcpy(&t1, key + 8, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:120:    memcpy(&st->pad[0], key + 16, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:121:    memcpy(&st->pad[1], key + 24, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:607:        memcpy(&h, &st->pad[0], 16);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:622:    memcpy(&mac[0], &h0, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:623:    memcpy(&mac[8], &h1, 8);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:95:    memcpy(S, state, 32);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:203:    memcpy(state->state, sha256_initstate, sizeof sha256_initstate);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:222:        memcpy(&state->buf[r], in, inlen);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:225:    memcpy(&state->buf[r], in, 64 - r);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:235:    memcpy(state->buf, in, inlen); /* inlen < 64 */
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:95:    memcpy(S, state, 64);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:225:    memcpy(state->state, sha512_initstate, sizeof sha512_initstate);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:252:        memcpy(&state->buf[r], src, inlen);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:255:    memcpy(&state->buf[r], src, 128 - r);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:265:    memcpy(state->buf, src, inlen); /* inlen < 128 */
./test/default/verify1.c:14:    v16 = (unsigned char *) sodium_malloc(16);
./test/default/verify1.c:15:    v16x = (unsigned char *) sodium_malloc(16);
./test/default/verify1.c:16:    v32 = (unsigned char *) sodium_malloc(32);
./test/default/verify1.c:17:    v32x = (unsigned char *) sodium_malloc(32);
./test/default/verify1.c:18:    v64 = (unsigned char *) sodium_malloc(64);
./test/default/verify1.c:19:    v64x = (unsigned char *) sodium_malloc(64);
./test/default/verify1.c:25:        memcpy(v16x, v16, 16);
./test/default/verify1.c:26:        memcpy(v32x, v32, 32);
./test/default/verify1.c:27:        memcpy(v64x, v64, 64);
./test/default/box_seal.c:18:    m = (unsigned char *) sodium_malloc(m_len);
./test/default/box_seal.c:19:    m2 = (unsigned char *) sodium_malloc(m_len);
./test/default/box_seal.c:20:    c = (unsigned char *) sodium_malloc(c_len);
./test/default/scalarmult.c:25:        (unsigned char *) sodium_malloc(crypto_scalarmult_BYTES);
./test/default/scalarmult.c:27:        (unsigned char *) sodium_malloc(crypto_scalarmult_BYTES);
./test/default/scalarmult.c:29:        (unsigned char *) sodium_malloc(crypto_scalarmult_BYTES);
./test/default/box7.c:21:    m = (unsigned char *) sodium_malloc(mlen_max);
./test/default/box7.c:22:    c = (unsigned char *) sodium_malloc(mlen_max);
./test/default/box7.c:23:    m2 = (unsigned char *) sodium_malloc(mlen_max);
./test/default/generichash.c:1304:    key = (unsigned char *) sodium_malloc(crypto_generichash_KEYBYTES_MAX);
./test/default/generichash.c:1305:    out = (unsigned char *) sodium_malloc(crypto_generichash_BYTES_MAX);
./test/default/generichash.c:1306:    expected_out = (unsigned char *) sodium_malloc(crypto_generichash_BYTES_MAX);
./test/default/generichash.c:1317:        in = (unsigned char *) sodium_malloc(in_len);
./test/default/secretbox_easy.c:34:    c = (unsigned char *) sodium_malloc(131 + crypto_secretbox_MACBYTES + 1);
./test/default/secretbox_easy.c:35:    mac = (unsigned char *) sodium_malloc(crypto_secretbox_MACBYTES);
./test/default/secretbox_easy.c:55:    memcpy(c + 1, m, 131);
./test/default/secretbox_easy.c:62:    memcpy(c, m, 131);
./test/default/secretbox_easy.c:69:    memcpy(c, m, 131);
./test/default/secretbox.c:46:    memcpy(c, m, 163);
./test/default/aead_aes256gcm.c:3101:    key = (unsigned char *) sodium_malloc(crypto_aead_aes256gcm_KEYBYTES);
./test/default/aead_aes256gcm.c:3102:    nonce = (unsigned char *) sodium_malloc(crypto_aead_aes256gcm_NPUBBYTES);
./test/default/aead_aes256gcm.c:3103:    mac = (unsigned char *) sodium_malloc(crypto_aead_aes256gcm_ABYTES);
./test/default/aead_aes256gcm.c:3115:        message = (unsigned char *) sodium_malloc(message_len);
./test/default/aead_aes256gcm.c:3120:        ad = (unsigned char *) sodium_malloc(ad_len);
./test/default/aead_aes256gcm.c:3126:        expected_ciphertext = (unsigned char *) sodium_malloc(ciphertext_len);
./test/default/aead_aes256gcm.c:3135:        ciphertext = (unsigned char *) sodium_malloc(ciphertext_len);
./test/default/aead_aes256gcm.c:3136:        detached_ciphertext = (unsigned char *) sodium_malloc(detached_ciphertext_len);
./test/default/aead_aes256gcm.c:3148:            hex = (char *) sodium_malloc((size_t) found_ciphertext_len * 2 + 1);
./test/default/aead_aes256gcm.c:3162:            hex = (char *) sodium_malloc((size_t) found_ciphertext_len * 2 + 1);
./test/default/aead_aes256gcm.c:3169:        decrypted = (unsigned char *) sodium_malloc(message_len);
./test/default/sodium_utils2.c:39:    if (sodium_malloc(SIZE_MAX - 1U) != NULL) {
./test/default/sodium_utils2.c:42:    if (sodium_malloc(0U) == NULL) {
./test/default/sodium_utils2.c:56:    sodium_free(sodium_malloc(0U));
./test/default/sodium_utils2.c:60:        buf = sodium_malloc(size);
./test/default/sodium_utils2.c:78:    buf = sodium_malloc(size);
./test/default/pwhash.c:199:        out = (char *) sodium_malloc(strlen(tests[i].out) + 1U);
./test/default/pwhash.c:201:        memcpy(out, tests[i].out, strlen(tests[i].out) + 1U);
./test/default/pwhash.c:202:        passwd = (char *) sodium_malloc(strlen(tests[i].passwd) + 1U);
./test/default/pwhash.c:204:        memcpy(passwd, tests[i].passwd, strlen(tests[i].passwd) + 1U);
./test/default/pwhash.c:225:    salt = (char *) sodium_malloc(crypto_pwhash_SALTBYTES);
./test/default/pwhash.c:226:    str_out = (char *) sodium_malloc(crypto_pwhash_STRBYTES);
./test/default/pwhash.c:227:    str_out2 = (char *) sodium_malloc(crypto_pwhash_STRBYTES);
./test/default/pwhash.c:228:    memcpy(salt, ">A 16-bytes salt", crypto_pwhash_SALTBYTES);
./test/default/box_easy2.c:32:    m = (unsigned char *) sodium_malloc(m_size);
./test/default/box_easy2.c:33:    m2 = (unsigned char *) sodium_malloc(m2_size);
./test/default/box_easy2.c:34:    c = (unsigned char *) sodium_malloc(c_size);
./test/default/box_easy2.c:35:    alicepk = (unsigned char *) sodium_malloc(crypto_box_PUBLICKEYBYTES);
./test/default/box_easy2.c:36:    alicesk = (unsigned char *) sodium_malloc(crypto_box_SECRETKEYBYTES);
./test/default/box_easy2.c:37:    bobpk = (unsigned char *) sodium_malloc(crypto_box_PUBLICKEYBYTES);
./test/default/box_easy2.c:38:    bobsk = (unsigned char *) sodium_malloc(crypto_box_SECRETKEYBYTES);
./test/default/box_easy2.c:39:    mac = (unsigned char *) sodium_malloc(crypto_box_MACBYTES);
./test/default/box_easy2.c:40:    nonce = (unsigned char *) sodium_malloc(crypto_box_NONCEBYTES);
./test/default/box_easy2.c:41:    k1 = (unsigned char *) sodium_malloc(crypto_box_BEFORENMBYTES);
./test/default/box_easy2.c:42:    k2 = (unsigned char *) sodium_malloc(crypto_box_BEFORENMBYTES);
./test/default/box_easy2.c:65:    memcpy(c, m, mlen);
./test/default/secretbox_easy2.c:17:    m = (unsigned char *) sodium_malloc(mlen);
./test/default/secretbox_easy2.c:18:    m2 = (unsigned char *) sodium_malloc(mlen);
./test/default/secretbox_easy2.c:19:    c = (unsigned char *) sodium_malloc(crypto_secretbox_MACBYTES + mlen);
./test/default/secretbox_easy2.c:20:    nonce = (unsigned char *) sodium_malloc(crypto_secretbox_NONCEBYTES);
./test/default/secretbox_easy2.c:21:    k = (unsigned char *) sodium_malloc(crypto_secretbox_KEYBYTES);
./test/default/secretbox_easy2.c:22:    mac = (unsigned char *) sodium_malloc(crypto_secretbox_MACBYTES);
./test/default/secretbox_easy2.c:48:    memcpy(c, m, mlen);
./test/default/chacha20.c:41:            part = (unsigned char *) sodium_malloc(plen);
./test/default/chacha20.c:120:            part = (unsigned char *) sodium_malloc(plen);
./test/default/sodium_utils3.c:48:    buf = sodium_malloc(size);
./test/default/box8.c:22:    m = (unsigned char *) sodium_malloc(mlen_max);
./test/default/box8.c:23:    c = (unsigned char *) sodium_malloc(mlen_max);
./test/default/box8.c:24:    m2 = (unsigned char *) sodium_malloc(mlen_max);
./test/default/sign.c:1087:        memcpy(skpk, test_data[i].sk, crypto_sign_SEEDBYTES);
./test/default/sign.c:1088:        memcpy(skpk + crypto_sign_SEEDBYTES, test_data[i].pk,
./test/default/sign.c:1155:    memcpy(sm, test_data[i].m, i);
./test/default/scalarmult6.c:23:    k = (unsigned char *) sodium_malloc(crypto_scalarmult_BYTES);
./test/default/scalarmult6.c:24:    bobsk = (unsigned char *) sodium_malloc(crypto_scalarmult_SCALARBYTES);
./test/default/scalarmult6.c:25:    alicepk = (unsigned char *) sodium_malloc(crypto_scalarmult_SCALARBYTES);
./test/default/scalarmult6.c:28:    memcpy(bobsk, bobsk_, crypto_scalarmult_SCALARBYTES);
./test/default/scalarmult6.c:29:    memcpy(alicepk, alicepk_, crypto_scalarmult_SCALARBYTES);
./test/default/aead_chacha20poly1305.c:24:    unsigned char *c = (unsigned char *) sodium_malloc(CLEN);
./test/default/aead_chacha20poly1305.c:25:    unsigned char *detached_c = (unsigned char *) sodium_malloc(MLEN);
./test/default/aead_chacha20poly1305.c:26:    unsigned char *mac = (unsigned char *) sodium_malloc(crypto_aead_chacha20poly1305_ABYTES);
./test/default/aead_chacha20poly1305.c:27:    unsigned char *m2 = (unsigned char *) sodium_malloc(MLEN);
./test/default/aead_chacha20poly1305.c:133:    memcpy(c, m, MLEN);
./test/default/aead_chacha20poly1305.c:189:    unsigned char *m = (unsigned char *) sodium_malloc(MLEN);
./test/default/aead_chacha20poly1305.c:195:    unsigned char *c = (unsigned char *) sodium_malloc(CLEN);
./test/default/aead_chacha20poly1305.c:196:    unsigned char *detached_c = (unsigned char *) sodium_malloc(MLEN);
./test/default/aead_chacha20poly1305.c:197:    unsigned char *mac = (unsigned char *) sodium_malloc(crypto_aead_chacha20poly1305_ietf_ABYTES);
./test/default/aead_chacha20poly1305.c:198:    unsigned char *m2 = (unsigned char *) sodium_malloc(MLEN);
./test/default/aead_chacha20poly1305.c:205:    memcpy(m, MESSAGE, MLEN);
./test/default/aead_chacha20poly1305.c:304:    memcpy(c, m, MLEN);
./test/default/pwhash_scrypt.c:273:        out = (char *) sodium_malloc(strlen(tests[i].out) + 1U);
./test/default/pwhash_scrypt.c:275:        memcpy(out, tests[i].out, strlen(tests[i].out) + 1U);
./test/default/pwhash_scrypt.c:276:        passwd = (char *) sodium_malloc(strlen(tests[i].passwd) + 1U);
./test/default/pwhash_scrypt.c:278:        memcpy(passwd, tests[i].passwd, strlen(tests[i].passwd) + 1U);
./test/default/pwhash_scrypt.c:299:        sodium_malloc(crypto_pwhash_scryptsalsa208sha256_SALTBYTES);
./test/default/pwhash_scrypt.c:301:        sodium_malloc(crypto_pwhash_scryptsalsa208sha256_STRBYTES);
./test/default/pwhash_scrypt.c:303:        sodium_malloc(crypto_pwhash_scryptsalsa208sha256_STRBYTES);
./test/default/pwhash_scrypt.c:304:    memcpy(salt, "[<~A 32-bytes salt for scrypt~>]",
./test/default/sodium_utils.c:22:    memcpy(buf2, buf1, sizeof buf2);
./test/default/sodium_utils.c:103:        memcpy(buf1, buf2, bin_len);
./test/default/sodium_utils.c:122:    memcpy(buf2, buf1, bin_len);
./test/default/sodium_utils.c:135:    memcpy(buf2, buf1, bin_len);
./src/libsodium/randombytes/randombytes.c:79:                        var buf = new Uint32Array(1);

== files() ==
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:133:randombytes_salsa20_random_random_dev_open(void)
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:147:        fd = open(*device, O_RDONLY);
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:238:         randombytes_salsa20_random_random_dev_open()) == -1) {
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:111:randombytes_sysrandom_random_dev_open(void)
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:125:        fd = open(*device, O_RDONLY);
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:208:         randombytes_sysrandom_random_dev_open()) == -1) {
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:66:int crypto_sign_edwards25519sha512batch_open(unsigned char *m,
./src/libsodium/crypto_sign/ed25519/ref10/open.c:128:crypto_sign_ed25519_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/crypto_sign/crypto_sign.c:56:crypto_sign_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/crypto_sign/crypto_sign.c:60:    return crypto_sign_ed25519_open(m, mlen_p, sm, smlen, pk);
./src/libsodium/crypto_box/crypto_box_seal.c:46:crypto_box_seal_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_box/crypto_box.c:103:crypto_box_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_box/crypto_box.c:107:    return crypto_box_curve25519xsalsa20poly1305_open(m, c, clen, n, pk, sk);
./src/libsodium/crypto_box/curve25519xsalsa20poly1305/ref/box_curve25519xsalsa20poly1305.c:24:int crypto_box_curve25519xsalsa20poly1305_open(
./src/libsodium/crypto_box/curve25519xsalsa20poly1305/ref/after_curve25519xsalsa20poly1305.c:21:  return crypto_secretbox_xsalsa20poly1305_open(m,c,clen,n,k);
./src/libsodium/crypto_secretbox/xsalsa20poly1305/ref/box_xsalsa20poly1305.c:20:int crypto_secretbox_xsalsa20poly1305_open(
./src/libsodium/crypto_secretbox/crypto_secretbox.c:49:crypto_secretbox_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_secretbox/crypto_secretbox.c:53:    return crypto_secretbox_xsalsa20poly1305_open(m, c, clen, n, k);
./src/libsodium/include/sodium/crypto_box_curve25519xsalsa20poly1305.h:58:int crypto_box_curve25519xsalsa20poly1305_open(unsigned char *m,
./src/libsodium/include/sodium/crypto_secretbox_xsalsa20poly1305.h:44:int crypto_secretbox_xsalsa20poly1305_open(unsigned char *m,
./src/libsodium/include/sodium/crypto_box.h:127:int crypto_box_seal_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_box.h:149:int crypto_box_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_secretbox.h:75:int crypto_secretbox_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_sign_ed25519.h:36:int crypto_sign_ed25519_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/include/sodium/crypto_sign.h:56:int crypto_sign_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/include/sodium/crypto_sign_edwards25519sha512batch.h:38:int crypto_sign_edwards25519sha512batch_open(unsigned char *m,
./test/default/cmptest.h:41:    if ((fp_res = fopen(TEST_NAME_RES, "w+")) == NULL) {
./test/default/cmptest.h:42:        perror("fopen(" TEST_NAME_RES ")");
./test/default/cmptest.h:52:    if ((fp_out = fopen(TEST_NAME_OUT, "r")) == NULL) {
./test/default/cmptest.h:53:        perror("fopen(" TEST_NAME_OUT ")");
./test/default/secretbox8.c:26:            if (crypto_secretbox_open(m2, c, mlen + crypto_secretbox_ZEROBYTES,
./test/default/secretbox2.c:38:    if (crypto_secretbox_open(m, c, 163, nonce, firstkey) == 0) {
./test/default/box_seal.c:26:    if (crypto_box_seal_open(m2, c, c_len, pk, sk) != 0) {
./test/default/box_seal.c:27:        printf("crypto_box_seal_open() failure\n");
./test/default/box_seal.c:32:    printf("%d\n", crypto_box_seal_open(m, c, 0U, pk, sk));
./test/default/box_seal.c:33:    printf("%d\n", crypto_box_seal_open(m, c, c_len - 1U, pk, sk));
./test/default/box_seal.c:34:    printf("%d\n", crypto_box_seal_open(m, c, c_len, sk, pk));
./test/default/box7.c:32:        if (crypto_box_open(m2, c, mlen + crypto_box_ZEROBYTES, n, alicepk,
./test/default/box2.c:50:    if (crypto_box_open(m, c, 163, nonce, alicepk, bobsk) == 0) {
./test/default/box2.c:58:    ret = crypto_box_open(m, c, 163, nonce, small_order_p, bobsk);
./test/default/box_easy2.c:53:        printf("open() failed");
./test/default/box_easy2.c:61:            printf("short open() should have failed");
./test/default/secretbox_easy2.c:37:            printf("short open() should have failed\n");
./test/default/box8.c:39:            if (crypto_box_open(m2, c, mlen + crypto_box_ZEROBYTES, n, alicepk,
./test/default/secretbox7.c:22:        if (crypto_secretbox_open(m2, c, mlen + crypto_secretbox_ZEROBYTES, n,
./test/default/sign.c:1099:        if (crypto_sign_open(m, NULL, sm, smlen, test_data[i].pk) != 0) {
./test/default/sign.c:1100:            printf("crypto_sign_open() failure: [%u]\n", i);
./test/default/sign.c:1105:        if (crypto_sign_open(m, &mlen, sm, smlen, test_data[i].pk) != -1) {
./test/default/sign.c:1106:            printf("crypto_sign_open(): signature [%u] is malleable\n", i);
./test/default/sign.c:1110:        if (crypto_sign_open(m, &mlen, sm, smlen, test_data[i].pk) != 0) {
./test/default/sign.c:1111:            printf("crypto_sign_open(): signature [%u] is not malleable\n", i);
./test/default/sign.c:1120:        if (crypto_sign_open(m, &mlen, sm, smlen, test_data[i].pk) == 0) {
./test/default/sign.c:1124:        if (crypto_sign_open(m, &mlen, sm, i % crypto_sign_BYTES,
./test/default/sign.c:1159:    if (crypto_sign_open(sm, &mlen, sm, smlen, test_data[i].pk) != 0) {
./test/default/sign.c:1160:        printf("crypto_sign_open() with overlap failed\n");
./test/default/sign.c:1163:        printf("crypto_sign_open() with overlap failed (content)\n");

== logging() ==
./test/default/cmptest.h:42:        perror("fopen(" TEST_NAME_RES ")");
./test/default/cmptest.h:53:        perror("fopen(" TEST_NAME_OUT ")");

== environment() ==

== privileged() ==

== networking() ==
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:106:safe_read(const int fd, void * const buf_, size_t size)
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:114:        while ((readnb = read(fd, buf, size)) < (ssize_t) 0 &&
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:296:               safe_read(stream.random_data_source_fd, m0,
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:302:        safe_read(stream.random_data_source_fd, m0,
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:85:safe_read(const int fd, void * const buf_, size_t size)
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:93:        while ((readnb = read(fd, buf, size)) < (ssize_t) 0 &&
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:283:        safe_read(stream.random_data_source_fd, buf, size) != (ssize_t) size) {
./src/libsodium/sodium/utils.c:437:_mprotect_readwrite(void *ptr, size_t size)
./src/libsodium/sodium/utils.c:626:    _mprotect_readwrite(base_ptr, total_size);
./src/libsodium/sodium/utils.c:679:sodium_mprotect_readwrite(void *ptr)
./src/libsodium/include/sodium/utils.h:122:int sodium_mprotect_readwrite(void *ptr);
./test/default/sodium_utils2.c:81:    sodium_mprotect_readwrite(buf);
./test/default/sodium_utils3.c:51:    sodium_mprotect_readwrite(buf);

== http:// ==
./src/libsodium/crypto_generichash/blake2/ref/blake2b-load-sse2.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:11:   [CC0](http://creativecommons.org/publicdomain/zero/1.0), the
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:13:   the [Apache Public License 2.0](http://www.apache.org/licenses/LICENSE-2.0),
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2-impl.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2b-load-sse41.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:8: * http://code.google.com/p/curve25519-donna/
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:15: *   http://cr.yp.to/ecdh.html
./src/libsodium/crypto_pwhash/argon2/argon2-impl.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-core.h:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2.h:9: * with this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.

== encryption ==
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:12:   [OpenSSL Licence](https://www.openssl.org/source/license.html), or
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:205:   <https://software.intel.com/sites/default/files/managed/72/cc/clmul-wp-rev-2.02-2014-04-20.pdf>
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:316:   <https://software.intel.com/sites/default/files/managed/72/cc/clmul-wp-rev-2.02-2014-04-20.pdf>
./src/libsodium/sodium/core.c:17:# warning Use releases available at https://download.libsodium.org/libsodium/releases/ instead.
./test/default/pwhash_scrypt_ll.c:5:/* Tarsnap test vectors, see: https://www.tarsnap.com/scrypt/scrypt.pdf */

== sql() ==

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/libsodium/crypto_stream/aes128ctr/portable/common.h:460:  shufb(x, ROTB) /* TODO: Make faster */

== unsafe input mechanisms ==

