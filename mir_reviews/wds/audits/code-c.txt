Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./p2p/information-element.cpp:89:            memcpy (element, array->bytes + pos, subelement_size);
./p2p/information-element.cpp:148:        memcpy (array->bytes + pos, element, P2P::SubelementSize[element->id]);
./p2p/information-element.cpp:163:        sprintf(hex,"%02X", array->bytes[i]);
./p2p/information-element.h:133:        memcpy (bytes, in_bytes, length);
./libwds/source/init_state.cpp:40:    rtsp::Options* options = new rtsp::Options("*");
./libwds/source/session_state.cpp:45:    rtsp::SetParameter* set_param = new rtsp::SetParameter("rtsp://localhost/wfd1.0");
./libwds/source/session_state.cpp:47:    auto payload = new rtsp::PropertyMapPayload();
./libwds/source/session_state.cpp:73:    auto transport = new rtsp::TransportHeader();
./libwds/source/source.cpp:183:  auto payload = new rtsp::PropertyMapPayload();
./libwds/source/cap_negotiation_state.cpp:68:  GetParameter* get_param = new GetParameter("rtsp://localhost/wfd1.0");
./libwds/source/cap_negotiation_state.cpp:135:  SetParameter* set_param = new SetParameter("rtsp://localhost/wfd1.0");
./libwds/source/cap_negotiation_state.cpp:139:  auto payload = new rtsp::PropertyMapPayload();
./libwds/sink/init_state.cpp:62:    auto options = new rtsp::Options("*");
./libwds/sink/session_state.cpp:61:  auto setup = new rtsp::Setup(ToSinkMediaManager(manager_)->GetPresentationUrl());
./libwds/sink/session_state.cpp:62:  auto transport = new rtsp::TransportHeader();
./libwds/sink/session_state.cpp:89:    rtsp::Play* play = new rtsp::Play(ToSinkMediaManager(manager_)->GetPresentationUrl());
./libwds/sink/sink.cpp:153:  auto message = new WfdMessage(manager_->GetPresentationUrl());
./libwds/sink/cap_negotiation_state.cpp:66:  auto reply_payload = new rtsp::PropertyMapPayload();
./libwds/sink/cap_negotiation_state.cpp:159:    auto payload = new rtsp::PropertyErrorPayload();
./libwds/sink/streaming_state.cpp:73:    rtsp::Play* play = new rtsp::Play(ToSinkMediaManager(manager_)->GetPresentationUrl());
./libwds/sink/streaming_state.cpp:102:    rtsp::Teardown* teardown = new rtsp::Teardown(ToSinkMediaManager(manager_)->GetPresentationUrl());
./libwds/sink/streaming_state.cpp:129:    rtsp::Pause* pause = new rtsp::Pause(ToSinkMediaManager(manager_)->GetPresentationUrl());
./mirac_network/mirac-broker.cpp:254:  TimerCallbackData* data = new TimerCallbackData(this);
./p2p/information-element.h:127:        bytes = new uint8_t[length];
./p2p/information-element.h:132:        bytes = new uint8_t[length];

== files() ==
./libwds/rtsp/tests/wdsfuzzer.cpp:62:  if (input_stream.is_open()) {

== logging() ==
./desktop_source/mirac_broker_source.cpp:35:void MiracBrokerSource::got_message(const std::string& message) {
./desktop_source/mirac_broker_source.h:42:  virtual void got_message(const std::string& message) override;
./libwds/rtsp/driver.cpp:51:void wds_error(void* scanner, std::unique_ptr<wds::rtsp::Message>& message,
./libwds/rtsp/driver.cpp:71:    header_set_debug(enable_debug, scanner);
./libwds/rtsp/driver.cpp:79:      error_set_debug(enable_debug, scanner);
./libwds/rtsp/driver.cpp:85:      message_set_debug(enable_debug, scanner);
./libwds/rtsp/driver.cpp:93:    message_set_debug(enable_debug, scanner);
./libwds/rtsp/driver.h:46:void wds_error (void* scanner, std::unique_ptr<wds::rtsp::Message>& message, const char* error_message);
./mirac_network/mirac-gst-bus-handler.cpp:36:        gst_message_parse_error (message, &err, &debug);
./mirac_network/network-test.cpp:71:            g_message("message: %s", msg.c_str());
./mirac_network/network-test.cpp:94:        g_message("connection from: %s", ctx->GetPeerAddress().c_str());
./mirac_network/network-test.cpp:131:        g_message("connection success to: %s", ctx->GetPeerAddress().c_str());
./mirac_network/network-test.cpp:156:        g_message("bound to port %hu", net_listen->GetHostPort());
./mirac_network/network-test.cpp:171:        g_error("exception: %s", x.what());
./mirac_network/mirac-broker.cpp:91:            got_message (msg);
./mirac_network/mirac-network.cpp:109:        throw MiracException(gai_strerror(ec), __FUNCTION__);
./mirac_network/mirac-network.cpp:164:            throw MiracException(gai_strerror(ec), __FUNCTION__);
./mirac_network/mirac-network.cpp:213:        throw MiracException(gai_strerror(ec), __FUNCTION__);
./p2p/connman-client.cpp:83:        g_clear_error (&error);
./p2p/connman-client.cpp:110:        g_clear_error (&error);
./p2p/connman-client.cpp:125:        g_clear_error(&error);
./p2p/connman-client.cpp:146:        g_clear_error (&error);
./p2p/connman-client.cpp:289:        g_clear_error (&error);
./p2p/connman-client.cpp:319:        g_clear_error (&error);
./p2p/connman-peer.cpp:108:        g_clear_error (&error);
./p2p/connman-peer.cpp:124:        g_clear_error (&error);
./p2p/connman-peer.cpp:138:        g_clear_error (&error);
./sink/sink.cpp:34:void Sink::got_message(const std::string& message) {
./sink/sink.h:45:  virtual void got_message(const std::string& message) override;

== environment() ==

== privileged() ==
./mirac_network/mirac-network.cpp:114:         * on other platforms use either fcntl() or ioctl(h, FIONBIO, 1) */
./mirac_network/mirac-network.cpp:144:    if (ioctl(ch, FIONBIO, &nonblock))
./mirac_network/mirac-network.cpp:145:        throw MiracException(errno, "ioctl(FIONBIO)", __FUNCTION__);
./mirac_network/mirac-network.cpp:181:     * on other platforms use either fcntl() or ioctl(h, FIONBIO, 1) */

== networking() ==
./mirac_network/mirac-network.cpp:113:        /* note, the SOCK_NONBLOCK is specific to Linux 2.6.27+,
./mirac_network/mirac-network.cpp:116:            addr_res->ai_socktype | SOCK_NONBLOCK, addr_res->ai_protocol);
./mirac_network/mirac-network.cpp:160:        addr_hint.ai_socktype = SOCK_STREAM;
./mirac_network/mirac-network.cpp:180:    /* note, the SOCK_NONBLOCK is specific to Linux 2.6.27+,
./mirac_network/mirac-network.cpp:183:        addr->ai_socktype | SOCK_NONBLOCK, addr->ai_protocol);
./mirac_network/mirac-network.cpp:229:    if (saddr->sa_family == AF_INET)
./mirac_network/mirac-network.cpp:235:    else if (saddr->sa_family == AF_INET6)
./desktop_source/source-app.h:46:    bool connect(uint peer_index);
./desktop_source/source-app.cpp:65:bool SourceApp::connect(uint peer_index)
./desktop_source/source-app.cpp:73:    it->second->connect ();
./desktop_source/main.cpp:51:        app->connect(std::stoi(command.substr(8)));
./mirac_network/network-test.cpp:152:        std::unique_ptr<MiracNetwork> net_listen(new MiracNetwork);
./mirac_network/mirac-broker.cpp:64:gboolean MiracBroker::try_connect (gpointer data_ptr)
./mirac_network/mirac-broker.cpp:67:    broker->try_connect();
./mirac_network/mirac-broker.cpp:154:void MiracBroker::try_connect()
./mirac_network/mirac-broker.cpp:201:    try_connect();
./mirac_network/mirac-network.cpp:115:        handle = socket(addr_res->ai_family,
./mirac_network/mirac-network.cpp:118:            throw MiracException(errno, "socket()", __FUNCTION__);
./mirac_network/mirac-network.cpp:122:	if (bind(handle, bind_addr->ai_addr, bind_addr->ai_addrlen) == 0)
./mirac_network/mirac-network.cpp:125:            throw MiracException(errno, "bind()", __FUNCTION__);
./mirac_network/mirac-network.cpp:131:    if (listen(handle, 1))
./mirac_network/mirac-network.cpp:132:        throw MiracException(errno, "listen()", __FUNCTION__);
./mirac_network/mirac-network.cpp:182:    handle = socket(addr->ai_family,
./mirac_network/mirac-network.cpp:185:        throw MiracException(errno, "socket()", __FUNCTION__);
./mirac_network/mirac-network.cpp:186:    if (connect(handle, addr->ai_addr, addr->ai_addrlen))
./mirac_network/mirac-network.cpp:190:        throw MiracException(errno, "connect()", __FUNCTION__);
./mirac_network/mirac-gst-sink.cpp:59:      g_signal_connect(gst_elem, "source-setup", G_CALLBACK(_set_udp_caps), NULL);
./p2p/connman-client.cpp:293:    g_signal_connect(proxy_, "g-signal",
./p2p/connman-peer.h:49:        void connect();
./p2p/connman-peer.h:50:        void disconnect();
./p2p/connman-peer.cpp:142:    g_signal_connect (proxy_, "g-signal",
./p2p/connman-peer.cpp:226:void Peer::connect()
./p2p/connman-peer.cpp:238:void Peer::disconnect()

== http:// ==

== encryption ==

== sql() ==

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./desktop_source/source-app.cpp:93:    // TODO InformationElement could have constructors for this stuff...
./libwds/rtsp/tests/tests.cpp:613:  // TODO test insensitivity of triggers and method list
./libwds/rtsp/formats3d.cpp:43:  // TODO Auto-generated destructor stub
./libwds/common/video_format.cpp:31:// FIXME : find a better place for log functions initialization.
./libwds/public/connector_type.h:29:  // TODO : Add the rest of connector types.
./libwds/sink/session_state.cpp:76:    // FIXME : take timeout value from session.
./libwds/sink/cap_negotiation_state.cpp:59:  // FIXME : resolve clashes between wds exported and internal rtsp type names.
./libwds/sink/cap_negotiation_state.cpp:70:          // FIXME: declare that we support absolutely every audio codec/format,
./mirac_network/mirac-broker.cpp:231:  return "127.0.0.1";  // FIXME : return the actual local IP address.
./p2p/connman-client.cpp:42:    /* TODO should get the p2p object path
./p2p/connman-client.cpp:88:        /* TODO: warn if P2P is not enabled. Also, don't set
./p2p/connman-peer.h:48:        /* TODO add error handling for these -- maybe through observer.on_error? */
./p2p/connman-client.h:54:        /* TODO error / finished handling */
./p2p/connman-peer.cpp:145:    /* TODO check the ip address in case it's up to date already */
./p2p/information-element.cpp:120:        /* FIXME : exception ? */
./p2p/information-element.cpp:132:       /* FIXME : exception ? */
./sink/sink-app.cpp:65:    // TODO port number is a lie -- we should start the sink first, then 
./sink/sink-app.cpp:68:    // TODO InformationElement could have constructors for this stuff...
./sink/gst_sink_media_manager.cpp:84:  // TODO: get the actual screen size of the system

== unsafe input mechanisms ==

