#!/usr/bin/python
import glob, sys, os

EXIT_FAIL = 1
EXIT_OKAY = 0

def update_state(cve,pkg,rel,state,notes):
    output = file(cve+".new",'w')
    for line in file(cve).readlines():
        if line.startswith('%s_%s:' % (rel, pkg)):
            line = '%s_%s: %s (%s)\n' % (rel, pkg, state, notes)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def load_cve(cve):
    code = EXIT_OKAY

    data = dict()
    affected = dict()
    upstream = None
    lastfield = None
    for line in file(cve).readlines():
        line = line.rstrip()

        # Ignore blank/commented lines
        if len(line) == 0 or line.startswith('#'):
            continue
        if line.startswith(' '):
            data[lastfield] += '\n%s' % (line[1:])
            continue

        try:
            field, value = line.split(':',1)
        except ValueError, e:
            print >>sys.stderr, "%s: bad line '%s' (%s)" % (cve, line, e)
            code = EXIT_FAIL
            continue

        lastfield = field = field.strip()
        value = value.strip()
        if field == 'Candidate':
            data.setdefault(field,value)
            if value != "" and not value.startswith('CVE-') and not value.startswith('UEM-'):
                print >>sys.stderr, "%s: unknown Candidate '%s'" % (cve, value)
                code = EXIT_FAIL
        elif field == 'Priority':
            data.setdefault(field,value)
            if not value in ['untriaged','unimportant','low','medium','high','critical']:
                print >>sys.stderr, "%s: unknown Priority '%s'" % (cve, value)
                code = EXIT_FAIL
        elif '_' in field:
            try:
                release, pkg = field.split('_',1)
            except ValueError:
                print >>sys.stderr, "%s: bad field with '_': '%s'" % (cve, field)
                code = EXIT_FAIL
                continue
            try:
                info = value.split(' ',1)
            except ValueError:
                print >>sys.stderr, "%s: missing state for '%s': '%s'" % (cve, field, value)
                code = EXIT_FAIL
                continue
            state = info[0]
            if state == '':
                state = 'needs-triage'

            if len(info) < 2:
                notes = ""
            else:
                notes = info[1].strip()
            if notes.startswith('('):
                notes = notes[1:]
            if notes.endswith(')'):
                notes = notes[:-1]

            # Work-around for old-style of only recording released versions
            if notes == '' and state[0] in ('0123456789'):
                notes = state
                state = 'released'

            if state not in ['needs-triage','needed','pending','released','deferred','DNE','ignored','not-affected']:
                print >>sys.stderr, "%s: %s_%s has unknown state: '%s'" % (cve, release, pkg, state)
                code = EXIT_FAIL

            affected.setdefault(pkg,dict())
            affected[pkg].setdefault(release,[state,notes])
        elif field == 'upstream':
            if value != "":
                upstream = value
        elif not field in ['References','Description','Ubuntu-Description','Notes','Bugs','Assigned-to']:
            print >>sys.stderr, "%s: unknown field '%s'" % (cve, field)
            code = EXIT_FAIL
        else:
            data.setdefault(field,value)

    # verify/fix missing upstreams listed for each pkg
    pkgs = sorted(affected.keys())
    if len(pkgs) > 1 and upstream != None:
            print >>sys.stderr, "%s: single upstream defined when multiple pkgs listed (%s)" % (cve, " ".join(pkgs))
            code = EXIT_FAIL
    if not (len(pkgs) == 1 and upstream != None):
        append = ''
        for pkg in pkgs:
            if not 'upstream' in affected[pkg].keys():
                append += 'upstream_%s: \n' % (pkg)
        if append != '':
            print >>sys.stderr, "%s: adding missing 'upstream' for: %s" % (cve, ", ".join(pkgs))
            file(cve,'a').write(append)

    data['pkgs'] = affected
        
    return code, data
