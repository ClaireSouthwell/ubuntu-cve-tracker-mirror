#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Fetch the USN database and pass it as the first argument
#  wget http://people.canonical.com/~ubuntu-security/usn/database.pickle
#  ./scripts/sync-bugs-kernel.py database.pickle
#
# This script is intended to sync state between the tracker and LP, as defined
# in the README.
#
import sys, os, os.path, optparse, glob
import cve_lib
import urlparse
from lp_lib import UCTLaunchpad

parser = optparse.OptionParser()
parser.add_option("--cve", help="Limit processing to a comma-separated list of CVEs", metavar="CVE[,CVE...]", default=None)
parser.add_option("-u", "--update", help="Update CVEs and LP bugs with state changes", action='store_true')
parser.add_option("-v", "--verbose", help="Report logic while processing USNs", action='store_true')
parser.add_option("-d", "--debug", help="Report additional debugging while processing USNs", action='store_true')
parser.add_option("--allow-missing-bugs", help="Do not create missing bugs", action='store_true')
parser.add_option("--allow-missing-tasks", help="Do not create missing tasks", action='store_true')
(opt, args) = parser.parse_args()

uctlp = UCTLaunchpad(opt)

config = cve_lib.read_config()
ktools = config.get('kernel_team_tools_path',None)
if not ktools:
    raise ValueError, "'kernel_team_tools_path' missing in ~/.ubuntu-cve-tracker.conf"

if opt.cve:
    cves = ['active/%s' % (x) for x in opt.cve.split(',')]
else:
    cves = glob.glob('active/CVE-*')

# This doesn't actually work because LP is stupid
def slow_bug_search(cve):
    return None
    if opt.verbose:
        print >>sys.stderr, "Finding LP bugs for %s ..." % (cve)
    for task in uctlp.ubuntu.searchTasks(
                    search_text=cve,
                    status=["New","Confirmed","Triaged","In Progress","Fix Committed","Fix Released"],
                    omit_targeted=False,
                    omit_duplicates=True):
        print task.bug.title


def load_kernel_bugs():
    bugs = dict()
    if opt.verbose:
        print >>sys.stderr, "Finding open LP bugs for kernel ..."
    for task in uctlp.ubuntu.searchTasks(
                    tags=['kernel-cve-tracker','kernel-cve-tracking-bug'],
                    tags_combinator='Any',
                    omit_targeted=False,
                    omit_duplicates=True):
        if not task.bug.title.startswith('CVE-'):
            continue
        cve = task.bug.title[0:13]
        bugs[cve] = task.bug
    if opt.verbose:
        print >>sys.stderr, "\tfound %d" % (len(bugs))
    return bugs

def create_kernel_bug(data):
    if opt.debug:
        print >>sys.stderr, "Creating LP bug for %s ..." % (data['Candidate'])
    return None

def set_task_status(taskdict, src, release, state):
    if not opt.update:
        if opt.verbose:
            print >>sys.stderr, "\twant to update status %s %s %s" % (src, release, state)
        return
    task = taskdict[src][release]
    if task.status != state:
        if opt.verbose:
            print '\t%s,%s: update status => %s' % (src,release,state)
        task.status=state
        uctlp.save(task)

def set_bug_description(bug, description):
    if not opt.update:
        if opt.verbose:
            print >>sys.stderr, "\twant to update description [%s]" % (description)
        return
    description = description.strip()
    if bug.description != description:
        if opt.verbose:
            print >>sys.stderr, "\tdescription update [%s]" % (description)
        bug.description = description
        uctlp.save(bug)

def sync_to_bug(bug, tasks, data):
    if opt.verbose:
        print >>sys.stderr, "\tsync to bug"
    return

def sync_from_bug(bug, tasks, data):
    if opt.verbose:
        print >>sys.stderr, "\tsync from bug"
    return

def sync_new_bug(bug, tasks, data):
    if opt.verbose:
        print >>sys.stderr, "\tsync new bug"
    shas = []
    for src in data['pkgs']:
        if not src in cve_lib.kernel_srcs:
            continue

        if not tasks.has_key(src):
            if opt.allow_missing_tasks:
                continue
            else:
                raise IndexError, "bug %s missing task for %s" % (bug.id, src)

        for rel in data['pkgs'][src]:
            release = rel
            if release == 'devel':
                release = cve_lib.devel_release
            if release in ['','upstream']:
                continue

            state = data['pkgs'][src][rel][0]
            if tasks[src][release].status != 'New':
                continue
            if state in ['DNE','not-affected']:
                set_task_status(tasks, src, release, 'Invalid')
            elif state == 'pending':
                set_task_status(tasks, src, release, 'Fix Committed')
            elif state == 'released':
                set_task_status(tasks, src, release, 'Fix Released')

        if data.has_key('Patches_%s' % (src)):
            for line in data['Patches_%s' % (src)].splitlines():
                if ':' not in line:
                    continue
                field, value = line.strip().split(':',1)
                field = field.strip()
                if not field in ['upstream','break-fix']:
                    continue
                value = value.strip()
                sha = None
                if field == 'upstream':
                    sha = value
                    if '/' in sha:
                        sha = value.split('/')[-1]
                if field == 'break-fix' and ' ' in value:
                    sha = value.split(' ',1)[1]
                if sha:
                    shas.append(sha)

    description = "Description needed\n\n";
    for sha in shas:
        description += "Fixed-by: %s\n" % (sha)
    set_bug_description(bug, description)

def generate_task_map(bug):
    tasks = dict()
    for task in bug.bug_tasks:
        package, project, release = uctlp.extract_task(task)
        if project.lower() != 'ubuntu':
            print >>sys.stderr, "WARNING: bug %d has task not in ubuntu project" % (bug.id)
            continue
        if release == None:
            # The release-less place-holder
            continue
        package = package.lower()
        tasks.setdefault(package, dict())
        release = release.lower()
        tasks[package].setdefault(release, task)
    return tasks

def refresh_task_packages(tasks):
    refresh = False
    for src in cve_lib.kernel_srcs:
        if not tasks.has_key(src):
            if opt.allow_missing_tasks:
                continue
            else:
                print >>sys.stderr, "\tWARNING: missing task for '%s'" % (src)
            if opt.update:
                if opt.verbose:
                    print >>sys.stderr, "\tadding task for '%s'" % (src)
                bug.addTask(target=uctlp.ubuntu.getSourcePackage(name=src))
                refresh = True
    return refresh


def sync_kernel_bug(bug, data):
    if opt.verbose:
        if opt.update:
            print >>sys.stderr, "Syncing LP bug %s with %s ..." % (bug, data['Candidate'])
        else:
            print >>sys.stderr, "Pretending to sync LP bug %s with %s ..." % (bug, data['Candidate'])

    # Generate task mapping dict(src -> dict( rel -> task ) )
    tasks = generate_task_map(bug)
    if refresh_task_packages(tasks):
        tasks = generate_task_map(bug)

    if bug.description == 'Placeholder':
        # New bug, overwrite stuff
        sync_new_bug(bug, tasks, data)
    else:
        # Active bug, overwrite what we can, then pull back the rest
        sync_to_bug(bug, tasks, data)
        sync_from_bug(bug, tasks, data)

    return None

# Find only open kernel CVEs
info = dict()
for filename in cves:
    cve = os.path.basename(filename)
    data = cve_lib.load_cve(filename)
    for src in cve_lib.kernel_srcs:
        if not src in data['pkgs']:
            continue
        found = False
        for rel in data['pkgs'][src]:
            if rel == "upstream":
                continue
            if not data['pkgs'][src][rel][0] in cve_lib.status_closed:
                #print "Want %s (%s: %s)" % (cve, src, data['pkgs'][src][rel][0])
                info.setdefault(cve, data)
                found = True
                break
        if found:
            break

# Load LP bugs
buglist = dict()
if not opt.cve:
    buglist = load_kernel_bugs()

# Load kernel CVEs
for cve in sorted(info.keys()):
    # Load bug list
    bugs = []
    bugs_remote = []
    for uri in info[cve]['Bugs'].splitlines():
        uri = uri.strip()
        if uri == "":
            continue
        o = urlparse.urlparse(uri)
        if o.netloc.endswith('launchpad.net'):
            bugs.append(int(uri.split('/')[-1]))
        else:
            bugs_remote.append(uri)

    # Find or create bug
    if len(bugs) == 0:
        if not buglist.has_key(cve):
            found = slow_bug_search(cve)
            if not found:
                found = create_kernel_bug(info[cve])
            if found:
                buglist[cve] = found
        if buglist.has_key(cve):
            bugs = [buglist[cve].id]
        else:
            if opt.allow_missing_bugs:
                if opt.verbose:
                    print "%s: bug needed" % (cve)
                continue
            else:
                raise IndexError, "%s: bug missing!" % (cve)
    elif len(bugs) == 1:
        if not buglist.has_key(cve):
            # Link manually created or closed bugs
            buglist[cve] = uctlp.lp.bugs[bugs[0]]
        if bugs[0] != buglist[cve].id:
            # FIXME: automatically handle duplicates here instead of bailing
            print >>sys.stderr, "%s: bug mismatch! (tracker:%d LP:%d)" % (cve, bugs[0], buglist[cve].id)
            continue
    else:
        # Bail on multiple bugs
        print >>sys.stderr, "%s: more than 1 LP bug: %s" % (cve, " ".join(["%d" % (x) for x in bugs]))
        continue
    bug = bugs[0]

    print "%s: LP: #%d" % (cve, bug)

    # Rebuild bug list
    text = "\n".join(bugs_remote+['https://launchpad.net/bugs/%d' % (bug)])
    text = text.strip()
    if text != info[cve]['Bugs'].strip():
        print "\t'Bugs' field needs updating ..."
        if opt.update:
            cve_lib.update_multiline_field('active/%s' % (cve), 'Bugs', text)

    # Synchronize with LP
    sync_kernel_bug(buglist[cve], info[cve])
