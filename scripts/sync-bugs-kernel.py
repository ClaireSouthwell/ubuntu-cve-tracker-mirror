#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Fetch the USN database and pass it as the first argument
#  wget http://people.canonical.com/~ubuntu-security/usn/database.pickle
#  ./scripts/sync-bugs-kernel.py database.pickle
#
# This script is intended to sync state between the tracker and LP, as defined
# in the README.
#
import sys, os, os.path, optparse, glob
import cve_lib
import urlparse
from lp_lib import UCTLaunchpad

parser = optparse.OptionParser()
parser.add_option("--cve", help="Limit processing to a comma-separated list of CVEs", metavar="CVE[,CVE...]", default=None)
parser.add_option("-u", "--update", help="Update CVEs and LP bugs with state changes", action='store_true')
parser.add_option("-v", "--verbose", help="Report logic while processing USNs", action='store_true')
parser.add_option("-d", "--debug", help="Report additional debugging while processing USNs", action='store_true')
parser.add_option("--allow-missing", help="Do not create missing bugs", action='store_true')
(opt, args) = parser.parse_args()

uctlp = UCTLaunchpad(opt)

config = cve_lib.read_config()
ktools = config.get('kernel_team_tools_path',None)
if not ktools:
    raise ValueError, "'kernel_team_tools_path' missing in ~/.ubuntu-cve-tracker.conf"

if opt.cve:
    cves = ['active/%s' % (x) for x in opt.cve.split(',')]
else:
    cves = glob.glob('active/CVE-*')

# This doesn't actually work because LP is stupid
def slow_bug_search(cve):
    return None
    if opt.verbose:
        print >>sys.stderr, "Finding LP bugs for %s ..." % (cve)
    for task in uctlp.ubuntu.searchTasks(
                    search_text=cve,
                    status=["New","Confirmed","Triaged","In Progress","Fix Committed","Fix Released"],
                    omit_targeted=False,
                    omit_duplicates=True):
        print task.bug.title


def load_kernel_bugs():
    bugs = dict()
    if opt.verbose:
        print >>sys.stderr, "Finding open LP bugs for kernel ..."
    for task in uctlp.ubuntu.searchTasks(
                    tags=['kernel-cve-tracker','kernel-cve-tracking-bug'],
                    tags_combinator='Any',
                    omit_targeted=False,
                    omit_duplicates=True):
        if not task.bug.title.startswith('CVE-'):
            continue
        cve = task.bug.title[0:13]
        bugs[cve] = task.bug
    if opt.verbose:
        print >>sys.stderr, "\tfound %d" % (len(bugs))
    return bugs

def create_kernel_bug(data):
    if opt.debug:
        print >>sys.stderr, "Creating LP bug for %s ..." % (data['Candidate'])
    return None

def sync_kernel_bug(bug, data):
    return None
    if opt.verbose:
        if opt.update:
            print >>sys.stderr, "Syncing LP bug %s with %s ..." % (bug, data['Candidate'])
        else:
            print >>sys.stderr, "Pretending to sync LP bug %s with %s ..." % (bug, data['Candidate'])
    return None

# Find only open kernel CVEs
info = dict()
for filename in cves:
    cve = os.path.basename(filename)
    data = cve_lib.load_cve(filename)
    for src in cve_lib.kernel_srcs:
        if not src in data['pkgs']:
            continue
        found = False
        for rel in data['pkgs'][src]:
            if rel == "upstream":
                continue
            if not data['pkgs'][src][rel][0] in cve_lib.status_closed:
                #print "Want %s (%s: %s)" % (cve, src, data['pkgs'][src][rel][0])
                info.setdefault(cve, data)
                found = True
                break
        if found:
            break

# Load LP bugs
buglist = load_kernel_bugs()

# Load kernel CVEs
for cve in sorted(info.keys()):
    # Load bug list
    bugs = []
    bugs_remote = []
    for uri in info[cve]['Bugs'].splitlines():
        uri = uri.strip()
        if uri == "":
            continue
        o = urlparse.urlparse(uri)
        if o.netloc.endswith('launchpad.net'):
            bugs.append(int(uri.split('/')[-1]))
        else:
            bugs_remote.append(uri)

    # Find or create bug
    if len(bugs) == 0:
        if not buglist.has_key(cve):
            found = slow_bug_search(cve)
            if not found:
                found = create_kernel_bug(info[cve])
            if found:
                buglist[cve] = found
        if buglist.has_key(cve):
            bugs = [buglist[cve].id]
        elif opt.allow_missing:
            if opt.verbose:
                print "%s: bug needed" % (cve)
            continue
    elif len(bugs) == 1:
        if not buglist.has_key(cve):
            # Link manually created or closed bugs
            buglist[cve] = uctlp.lp.bugs[bugs[0]]
        if bugs[0] != buglist[cve].id:
            # FIXME: automatically handle duplicates here instead of bailing
            print >>sys.stderr, "%s: bug mismatch! (tracker:%d LP:%d)" % (cve, bugs[0], buglist[cve].id)
            continue
    else:
        # Bail on multiple bugs
        print >>sys.stderr, "%s: more than 1 LP bug: %s" % (cve, " ".join(["%d" % (x) for x in bugs]))
        continue
    bug = bugs[0]

    print "%s: LP: #%d" % (cve, bug)

    # Rebuild bug list
    text = "\n".join(bugs_remote+['https://launchpad.net/bugs/%d' % (bug)])
    text = text.strip()
    if text != info[cve]['Bugs'].strip():
        print "\t'Bugs' field needs updating ..."
        if opt.update:
            cve_lib.update_multiline_field('active/%s' % (cve), 'Bugs', text)

    # Synchronize with LP
    sync_kernel_bug(bug, info[cve])
