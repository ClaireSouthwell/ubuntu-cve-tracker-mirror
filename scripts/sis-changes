#!/usr/bin/env python
# Copyright 2007-2008, Canonical, Ltd.
# Author: Kees Cook <kees@ubuntu.com>
#         Jamie Strandboge <jamie@canonical.com>
# License: GPLv3
#
# Extract list of changes file links from a given LP name, pkg, version
import sys, time, os.path
import urllib2, cookielib
import libxml2
import optparse
from launchpadbugs import http_connection

cookie_processor = http_connection.LPCookieProcessor()
cookie_file = os.path.expanduser('~/.cookies')
if not os.path.exists(cookie_file):
    print >>sys.stderr, "Please make a symlink from ~/.cookies to your Firefox cookies file"
    sys.exit(1)
# Deref the symlink since sqlite3 doesn't like opening symlinks and
# python-launchpad-bugs uses the filename suffix to determine how to open
# a given cookie filename.
cookie_file = os.readlink(cookie_file)
cookie_processor.load_file(cookie_file)
opener = urllib2.build_opener(cookie_processor)

# slience parse warnings (from launchpad-python-bugs)
def noerr(ctx, str):
    pass
libxml2.registerErrorHandler(noerr, None)

def xmlurl(url):
    # Get the HTML
    try:
        doc = opener.open(url).read()
        # Parse into XML tree
        return libxml2.htmlParseDoc(doc,None)
    except:
        print >>sys.stderr, "Failed: %s" % (url)
        raise

parser = optparse.OptionParser()
parser.add_option("--dsc", help="Toggle fetching source .dsc files (default is True)", action='store_false', default=True)
parser.add_option("--action", help="What action to take: 'changes'(default), 'check-build'", metavar="NAME", action='store', default='changes')
parser.add_option("--group", help="Which group's PPA to exame (default is 'ubuntu-security')", metavar="GROUP", action='store', default='ubuntu-security')
parser.add_option("--debug", help="Verbose processing output", action='store_true')
(opt, args) = parser.parse_args()

if len(args)<1:
    print "Usage: %s SRCPKG..." % (sys.argv[0])
    sys.exit(1)

release_list = [ 'dapper', 'edgy', 'feisty', 'gutsy', 'hardy' ]
arch_list = [ 'amd64', 'i386', 'lpia', 'sparc', 'powerpc', 'hppa', 'ia64' ]
releases = {
        'dapper': {
                'required': [ 'amd64', 'i386', 'sparc', 'powerpc' ],
                'expected': [ 'ia64', 'hppa' ],
                'bonus': [ ],
                },
        'edgy': {
                'required': [ 'amd64', 'i386', 'sparc', 'powerpc' ],
                'expected': [ ],
                'bonus': [ 'ia64', 'hppa' ],
                },
        'feisty': {
                'required': [ 'amd64', 'i386', 'sparc' ],
                'expected': [ 'powerpc' ],
                'bonus': [ 'hppa' ],
                },
        'gutsy': {
                'required': [ 'amd64', 'i386', 'sparc' ],
                'expected': [ 'powerpc', 'hppa', 'lpia' ],
                'bonus': [ ],
                },
        'hardy': {
                'required': [ 'amd64', 'i386', 'lpia' ],
                'expected': [ 'powerpc', 'hppa', 'sparc' ],
                'bonus': [ 'ia64' ],
                },
}

base_url = 'https://edge.launchpad.net'
ppa_url = '%s/~%s/+archive' % (base_url, opt.group)
ppa_xml = xmlurl(ppa_url)
try:
    packages_list = ppa_xml.xpathEval("//table[@id='packages_list']")[0]
except:
    print >>sys.stderr, "Failed:\n" + ppa_xml.content
    raise

def normalize_url(url):
    if url.startswith('/'):
        url = base_url + url
    return url

# pkg -> { release, release -> { version } }
pkgs = dict()
def load_pkg_details_from_xml(pkgs, xml):
    name = xml.xpathEval('self::tr/td[1]')[0].content.strip().lower()
    pkg, version = name.split(' - ')
    rel  = xml.xpathEval('self::tr/td[6]')[0].content.strip().lower()
    if rel not in release_list:
        raise ValueError, "Unknown release '%s':\n" % (rel) + head.content
    detail = xml.xpathEval('self::tr/following-sibling::tr[1]')[0]

    pkgs.setdefault(pkg, dict())
    pkgs[pkg].setdefault(rel, dict())
    if opt.debug:
        print >>sys.stderr, "Source(%s): %s %s" % (rel, pkg, version)

    # Source details
    pkgs[pkg][rel].setdefault('source', dict())
    pkgs[pkg][rel]['source'].setdefault('version', version)
    src_changes = xml.xpathEval('self::tr//a[contains(@href,"_source.changes")]')[0].prop('href')
    pkgs[pkg][rel]['source'].setdefault('changes', src_changes)
    if opt.debug:
        print >>sys.stderr, "Source(%s) changes: %s" % (rel, src_changes)

    # Build details
    #for build_a in detail.xpathEval('self::tr//ul/li/a[contains(@href,"/+archive/+build/")]'):
    for build_li in detail.xpathEval('self::tr//h3[.="Builds"]/following-sibling::ul[1]//li'):
        build_a = build_li.xpathEval('self::li/a')[0]
        build_url = normalize_url(build_a.prop('href'))
        arch = build_a.content.strip().lower()
        pkgs[pkg][rel].setdefault(arch, dict())
        pkgs[pkg][rel][arch].setdefault('build', build_url)

        build_img = build_li.xpathEval('self::li/img')[0]
        state = build_img.prop('src').split('-')[1]
        pkgs[pkg][rel][arch].setdefault('build_state', state)

        if opt.debug:
            print >>sys.stderr, "Build(%s,%s) %s URL: %s" % (rel, arch, state, build_url)

    # Diff
    for diff_a in detail.xpathEval('self::tr//h3[.="Available diffs"]/following-sibling::ul[1]//a'):
        diff_url = normalize_url(diff_a.prop('href'))
        pkgs[pkg][rel]['source'].setdefault('ancestor-diff', diff_url)
        if opt.debug:
            print >>sys.stderr, "Diff(%s) URL: %s" % (rel, diff_url)

    # Files
    for file_a in detail.xpathEval('self::tr//h3[.="Download files from Librarian"]/following-sibling::ul[1]//a'):
        file_url = normalize_url(file_a.prop('href'))
        if file_url.endswith('deb'):
            arch = file_url.split('_').pop().split('.')[0]
            pkgs[pkg][rel][arch].setdefault('binaries', dict())
            name = file_url.split('_')[-3].split('/').pop()
            pkgs[pkg][rel][arch]['binaries'].setdefault(name, file_url)
            if opt.debug:
                print >>sys.stderr, "Binary(%s,%s) URL: %s" % (rel, arch, diff_url)
        else:
            if file_url.endswith('.diff.gz'):
                pkgs[pkg][rel]['source'].setdefault('diff', file_url)
            elif file_url.endswith('.dsc'):
                pkgs[pkg][rel]['source'].setdefault('dsc', file_url)
            elif file_url.endswith('.tar.gz'):
                pkgs[pkg][rel]['source'].setdefault('orig', file_url)
            else:
                raise ValueError, "Unknown downloadable file from %s %s '%s'" % (pkg, version, file_url)
            if opt.debug:
                print >>sys.stderr, "Source(%s) URL: %s" % (rel, file_url)

for pkg_tr in packages_list.xpathEval('//tbody/tr[@class = "ppa_package_row"]'):
    load_pkg_details_from_xml(pkgs, pkg_tr)

if opt.action == 'changes':
    for pkg in args:
        if not pkgs.has_key(pkg):
            raise ValueError, "Source package '%s' not found in PPA" % (pkg)

        for rel in sorted(pkgs[pkg].keys()):
            version = pkgs[pkg][rel]['source']['version']
            if ':' in version and not version.endswith(':'):
                # strip out epoch, if it exists
                version = version[(version.find(':')+1):]

            if opt.dsc:
                dsc_url = packages_list.xpathEval('//a[contains(@href,"/%s_%s.dsc")]' % (pkg, version))[0].prop('href')
                print dsc_url
            print pkgs[pkg][rel]['source']['changes']

            for arch in sorted(pkgs[pkg][rel].keys()):
                if arch == 'source':
                    continue
                if opt.debug:
                    print >>sys.stderr, "Loading build log for %s %s %s" % (pkg,rel,arch)
                build_xml = xmlurl(pkgs[pkg][rel][arch]['build'])

                changes_url = build_xml.xpathEval('//a[contains(@href,"/%s_%s_")]' % (pkg, version))[0].prop('href')
                print changes_url

elif opt.action == 'check-build':
    EXIT_OKAY = 0
    EXIT_FAIL = 1
    exit_code = EXIT_OKAY
    for pkg in args:
        if not pkgs.has_key(pkg):
            raise ValueError, "Source package '%s' not found in PPA" % (pkg)
        found = dict()

        for rel in sorted(pkgs[pkg].keys()):
            found.setdefault(rel,dict())
            for arch in arch_list:
                found[rel].setdefault(arch,False)
                if pkgs[pkg][rel].has_key(arch):
                    state = pkgs[pkg][rel][arch]['build_state']
                    if state == 'success':
                        found[rel][arch] = True

        code = EXIT_OKAY
        report_rel = []

        for rel in release_list:
            complete = 1
            # Skip missing source.changes
            if not rel in found.keys():
                continue
            for arch in arch_list:
                if arch in releases[rel]['required'] and not found[rel][arch]:
                    print >>sys.stderr, 'ERROR: %s missing for %s (%s)' % (arch, rel, pkgs[pkg][rel][arch]['build_state'])
                    code = EXIT_FAIL
                    complete = 0
            for arch in arch_list:
                if arch in releases[rel]['expected'] and not found[rel][arch]:
                    print >>sys.stderr, 'WARN: %s missing for %s (%s)' % (arch, rel, pkgs[pkg][rel][arch]['build_state'])
            for arch in arch_list:
                if arch in releases[rel]['bonus'] and found[rel][arch]:
                    print >>sys.stderr, 'BONUS: %s found for %s' % (arch, rel)
            if complete:
                report_rel.append(rel)

        if code == EXIT_OKAY:
            print "OK: " + " ".join(report_rel)
        else:
            if len(report_rel):
                print "READY: " + " ".join(report_rel)
            print "FAIL: not all releases ready"
            exit_code = EXIT_FAIL
    sys.exit(exit_code)

