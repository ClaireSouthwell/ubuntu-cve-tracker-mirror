#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, sys, cPickle, subprocess
from source_map import version_compare

# API interface (for get_release_version)
lp = None
ubuntu = None
archive = None
release = dict()
series = dict()

# Searches all pockets for the first known version of a package. (Since
# packages can be added to -updates post-release, we need to check all
# pockets.) To find a version for a specific pocket, just override the list.
def get_release_version(rel, pkg, key='release', pockets=['Release','Updates','Security','Proposed'], opt=object):
    global lp, ubuntu, archive, release, series
    if not release.has_key(rel) or not release[rel].has_key(pkg) or not release[rel][pkg].has_key(key):
        if archive == None:
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "Starting LP API ..."
            import lpl_common
            lp = lpl_common.connect() #beta=opt.beta, uri=opt.uri)
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "\tauthenticated ..."
            ubuntu = lp.distributions['ubuntu']
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "\tUbuntu distribution found ..."
            archive = ubuntu.archives[0]
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "\tUbuntu archive found."
        if not series.has_key(rel):
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "API: getSeries(%s) ..." % (rel)
            series[rel] = ubuntu.getSeries(name_or_version=rel)
        release.setdefault(rel, dict())
        release[rel].setdefault(pkg, dict())
        for pocket in pockets:
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "API: getPublishedSources(%s, %s, %s) ..." % (rel, pocket, pkg)
            pkgs = archive.getPublishedSources(source_name=pkg, distro_series=series[rel], pocket=pocket, status='Published', exact_match=True)
            if len(pkgs) < 1:
                if hasattr(opt, 'debug') and opt.debug:
                    print >>sys.stderr, "\tDNE"
                continue
            release[rel][pkg][key] = pkgs[0].source_package_version
            if hasattr(opt, 'debug') and opt.debug:
                print >>sys.stderr, "\t%s" % (release[rel][pkg][key])
            break
    release[rel][pkg].setdefault(key, "~")
    return release[rel][pkg][key]

def load_database(db_filename='database.pickle'):
    '''Load usn database'''
    filename = os.path.expanduser(db_filename)
    if not os.path.isfile(filename):
        return {}
    return cPickle.load(open(filename))

def save_database(database, db_filename='database.pickle'):
    '''Save usn database'''
    filename = os.path.expanduser(db_filename)
    cPickle.dump(database, open(filename, 'w'), -1)

def get_reverted(filename='reverted-CVEs.txt'):
    '''Get reverted USNs'''
    reverted = dict()
    if os.path.exists(filename):
        for line in open(filename):
            elements = line.rstrip().split(' ')
            usn = elements.pop(0)
            reverted.setdefault(usn,set())
            for cve in elements:
                reverted[usn].add(cve)

    return reverted

def packages_dict(db, packages, releases=None, opt=object):
    '''Produce a list of packages that refer back to USNs'''
    pkgs = dict()
    for usn in sorted(db, cmp=version_compare):
        # This USN is ancient and lacks any CVE information
        if not db[usn].has_key('cves'):
            if (hasattr(opt, 'debug') and opt.debug):
                print "%s lacks CVEs" % (usn)
            continue

        for rel in db[usn]['releases']:
            # Ignore old USNs
            if not db[usn]['releases'][rel].has_key('sources'):
                continue

            if releases and not rel in releases:
                continue

            # Look at fixed packages
            for pkg in packages:
                if not db[usn]['releases'][rel]['sources'].has_key(pkg):
                    continue

                pkgs.setdefault(pkg, dict())
                version = db[usn]['releases'][rel]['sources'][pkg]['version']
                if pkgs[pkg].has_key(version):
                    raise IndexError, "Saw %s %s twice!" % (pkg, version)
                pkgs[pkg][version] = usn
    return pkgs

def _update_usn_description(db, usn):
    db[usn]['description'] = subprocess.check_output(['%s/pull-usn-desc.py' % (os.path.dirname(sys.argv[0])),'--prioritize'] + db[usn]['cves'])
    if 'XXX' in db[usn]['description']:
        raise ValueError, "Missing descriptions in USN %s:\n%s" % (usn, db[usn]['description'])

def del_cves(db, usn, rm_cves=[]):
    cves = set(db[usn]['cves'])
    cves.difference_update(rm_cves)
    db[usn]['cves'] = sorted(cves)
    _update_usn_description(db, usn)

def add_cves(db, usn, new_cves=[]):
    db[usn]['cves'] = sorted(set(db[usn]['cves'] + new_cves))
    _update_usn_description(db, usn)
