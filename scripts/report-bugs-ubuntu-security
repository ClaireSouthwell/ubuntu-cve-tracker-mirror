#!/usr/bin/env python
# Copyright 2011, Canonical, Ltd.
# Author: Jamie Strandboge <jamie@canonical.com>
# License: GPLv3
#
# Report items for the security team to sponsor. Used for reporting based on
# https://wiki.ubuntu.com/SecurityTeam/SponsorsQueue
#
# $ report-bugs-for-eol

import cve_lib
from cgi import escape
from types import *
import cPickle
import optparse
import os
import re
import subprocess
import sys
import time

parser = optparse.OptionParser()
parser.add_option("--debug", help="Verbose processing output", action='store_true')
parser.add_option("--html", help="HTML output", action='store_true')
parser.add_option("--show-private", help="Don't redact private fields (warning-- do not publish results publicly", action='store_true')
parser.add_option("--target", help="Into which directory to write the data files", metavar="DIR", action='store')
parser.add_option("--team", help="Find bugs for team", metavar="TEAM", action='store', default='ubuntu-security')
parser.add_option("--limit", help="Limit number of bugs", metavar="NUM", action='store', default=None)
parser.add_option("--report-type", help="Report type. Specify 'help' for details", metavar="TYPE", action='store', default=None)
parser.add_option("--bug-cache", help="Cached pickle file for bugs (warning-- private bug data stored)", metavar="FILE", action='store')

(opt, args) = parser.parse_args()


#
# Helpers
#
def debug(s):
    '''Print debug message'''
    if opt.debug:
        print >>sys.stderr, "DEBUG: %s" % (s)

def get_bug_data(task, bug_id=None, bug_target_name=None):
    '''This is expensive and should be called only once per bug/task combination'''
    data = {}
    if bug_id != None:
        data['bug_id'] = bug_id
    else:
        data['bug_id'] = task.bug.id
    data['bug_status'] = task.status
    data['bug_private'] = task.bug.private
    data['bug_security'] = task.bug.security_related

    data['bug_summary'] = task.bug.title
    data['bug_priority'] = task.importance
    if bug_target_name != None:
        data['bug_source'] = bug_target_name
    else:
        data['bug_source'] = task.bug_target_name

#    # these are private
#    data['bug_summary'] = ''
#    data['bug_source'] = ''
#    data['bug_priority'] = ''
#
#    if not data['bug_private']:
#        # Fill in private fields for public bugs
#        data['bug_summary'] = task.bug.title
#        data['bug_priority'] = task.importance
#        if bug_target_name != None:
#            data['bug_source'] = bug_target_name
#        else:
#            data['bug_source'] = task.bug_target_name

    return data

def print_header(title, html, intro=''):
    out = ""
    if html:
        out = '''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>%s</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Canonical Ltd, Jamie Strandboge" />
<meta name="description" content="%s" />
<meta name="copyright" content="Canonical Ltd" />
<link rel="StyleSheet" href="toplevel.css" type="text/css" />
</head>

<body>
<div id="container">
<h2>%s</h2>
''' % (title, title, title)
    else:
        out = "= %s =\n" % title

    if intro != '':
        if html:
            out += '<p class="intro">%s</p>' % intro
        else:
            out += '== Introduction ==\n%s\n\n' % intro

    if not html:
        out += "== Bug list ==\n"

    return out

def print_footer(html):
    out = ""
    if html:
        out = '''
<p class='note'><a href="https://code.launchpad.net/~ubuntu-security/ubuntu-cve-tracker/master">Updated</a>: %s</p>
</div>
<div id="footer">
&copy; Canonical Ltd. 2007-%s
</div>
</body>
</html>
''' % (time.strftime('%Y-%m-%d %H:%M:%S %Z'), time.strftime('%Y'))

    return out

def write_row(bug, html, table_header=False):
    order = ['bug_id', 'bug_summary', 'bug_source', 'bug_priority', 'bug_status', 'bug_security', 'bug_private']
    private_fields = ['bug_summary', 'bug_source', 'bug_priority']
    if opt.show_private:
        private_fields = []

    out = ""
    if html:
        out = "<tr>"
    else:
        out += "|"

    if table_header:
        for h in order:
            t = h.split('_')[1].title()
            if opt.html:
                out += "<th>%s</td>" % t
            else:
                out += " %s |" % t
    else:
        for c in order:
            # Convert everything to a string here
            contents = ""
            if type(bug[c]) is IntType:
                contents = str(bug[c])
            elif type(bug[c]) is BooleanType:
                contents = "N"
                if bug[c]:
                    contents = "Y"
            elif type(bug[c]) is UnicodeType:
                # we could do better, but this is at least safe
                contents = bug[c].encode("ascii", "ignore")
            elif type(bug[c]) is StringType:
                contents = bug[c]
            else:
                contents = "Skipping unknown type '%s'" % str(type(bug[c]))

            # Redact sensitive info
            if bug['bug_private'] and c in private_fields:
                contents = "(private)"

            if opt.html:
                contents = escape(contents)
                if c == 'bug_id':
                    contents = "<a href='https://launchpad.net/bugs/%s'>%s</a>" % (int(bug[c]), int(bug[c]))
                out += '<td>%s</td>\n' % contents
            else:
                out += ' %s |' % contents

    if html:
        out += "</tr>\n"
    else:
        out += "\n"

    return out



def print_bugs(bugs, html, sort_priority=False):
    '''Output a collection of bugs'''
    #keys = bugs.keys()
    #try:
    #    keys.sort(key=int)
    #except:
    #    keys.sort()

    keys = sorted(bugs.keys(), key=lambda k: int(k.split(':')[0]))

    out = ""

    if html:
        out += "<p>Number bugs: %d</p>\n" % len(keys)
        out += '<table>'
    else:
        out += "Number bugs: %d\n" % len(keys)

    out += write_row(None, html, table_header=True)

    for k in keys:
        out += write_row(bugs[k], html)

    if html:
        out += "\n</table>"

    return out

def report_all():
    title = "Bugs for %s" % opt.team
    output = print_header(title, opt.html)
    output += print_bugs(all_bugs, opt.html)
    output += print_footer(opt.html)
    return output

def report_not_ubuntu():
    title = "Bugs for %s without an Ubuntu task" % opt.team
    intro = "These are bugs for which there is only a non-Ubuntu task remaining. The ubuntu-security team should not track these, but individual members may want to track them on their own. These can be unsubscribed by using UQT/responses/security/unsub-security"
    output = print_header(title, opt.html, intro)

    _bugs = {}
    for k in other_bugs.keys():
        if ubuntu_bugs.has_key(k):
            continue
        if other_bugs[k]['bug_source'] == "launchpad":
            debug("Skipping 'launchpad' bug '%s'" % str(k))
            continue
        _bugs['%s' % k] = other_bugs[k]
    output += print_bugs(_bugs, opt.html)

    output += print_footer(opt.html)
    return output

def report_ubuntu_only():
    title = "Bugs for %s without an Ubuntu task" % opt.team
    intro = "This list of bugs contains bugs where the ubuntu-security team is subscribed, but only lists one open task per bug (as opposed to all tasks per release). It also excludes kernel bugs since those are handled via the new kernel cadence where they have different reports for bugs."
    output = print_header(title, opt.html, intro)

    _bugs = {}
    for k in ubuntu_bugs.keys():
        if skipped_bugs.has_key(k):
            debug("Skipping '%s' (%s)" % (str(k), ubuntu_bugs[k]['bug_source']))
            continue
        _bugs['%s' % k] = ubuntu_bugs[k]
    output += print_bugs(_bugs, opt.html)

    output += print_footer(opt.html)
    return output


#
# End helpers
#

#
# Main
#
valid_reports = ['all', 'not-ubuntu', 'ubuntu-only']
if opt.report_type == None:
    print >>sys.stderr, "Need to specify --report-type"
    sys.exit(1)
elif opt.report_type == "help" or opt.report_type not in valid_reports:
    print '''Valid report types are:
 all		All bugs with team subscribed
 not-ubuntu	Bugs with team subscribed but no Ubuntu tasks
 ubuntu-only	Bugs with team subscribed with Ubuntu tasks, skipping certain
                bugs (eg, kernel and LP itself)
'''
    sys.exit(0)

skipped_sources = set(['launchpad', 'usn-website-content']) | cve_lib.kernel_srcs

all_bugs = {}
ubuntu_bugs = {}
other_bugs = {}
skipped_bugs = {}

# Try to load the cached database
bug_database = None
bug_database_fn = ""
if opt.bug_cache:
    bug_database_fn = os.path.expanduser(opt.bug_cache)
    if not os.path.isfile(bug_database_fn):
        print >>sys.stderr, "'%s' does not exist. Skipping load" % bug_database_fn
    else:
        # Load pickle database
        print >>sys.stderr, "Loading bugs from cache..."
        bug_database = cPickle.load(open(bug_database_fn))
        all_bugs = bug_database['all_bugs']
        ubuntu_bugs = bug_database['ubuntu_bugs']
        other_bugs = bug_database['other_bugs']
        skipped_bugs = bug_database['skipped_bugs']
        print >>sys.stderr, "done"

# Connect to LP only if cached db not available
if bug_database == None:
    # Connect to Launchpad
    try:
        import lpl_common
    except:
        print >>sys.stderr, "lpl_common.py seems to be missing.  Please create a symlink from $UQT/common/lpl_common.py to $UCT/scripts/"
        sys.exit(1)

    # Load configuration
    cve_lib.read_config()

    # API interface
    debug("Team: %s" % opt.team)
    print >>sys.stderr, "Connecting to LP ...",
    lp = lpl_common.connect()

    # Get authenticated URL fetcher
    opener = lpl_common.opener_with_cookie(cve_lib.config["plb_authentication"])
    if not opener:
        raise ValueError, "Could not open cookies"

    team = lp.people[opt.team]
    print >>sys.stderr, "done"

    print >>sys.stderr, "Loading bugs from LP (takes a while)..."
    task_collection = team.searchTasks(bug_subscriber=team, omit_targeted=False)

    count = 0
    for task in task_collection:
        bugid = task.bug.id
        target = task.bug_target_name

        bug_data = get_bug_data(task, bugid, target)
        all_bugs['%s:%s' % (bugid, target)] = bug_data

        count += 1
        debug("%d, %s" % (bugid, target))
        if 'Ubuntu' in target:
            ubuntu_bugs[bugid] = bug_data
            if target in skipped_sources:
                skipped_bugs[bugid] = True
        else:
            other_bugs[bugid] = bug_data

        debug("bug count: %d" % count)
        if opt.limit != None and opt.limit.isdigit() and count >= int(opt.limit):
            break
    print >>sys.stderr, "done (loaded %d bugs, %d could be skipped)" % (count, len(skipped_bugs))

    # Create the cache if it doesn't exist
    if opt.bug_cache and not os.path.exists(bug_database_fn):
        print >>sys.stderr, "Saving cache to '%s'. To update cache, remove this file." % (opt.bug_cache)
        bug_database = {}
        bug_database['all_bugs'] = all_bugs
        bug_database['ubuntu_bugs'] = ubuntu_bugs
        bug_database['other_bugs'] = other_bugs
        bug_database['skipped_bugs'] = skipped_bugs
        cPickle.dump(bug_database, open(bug_database_fn, 'w'), -1)

# Now that we have the bugs, report on them
if opt.report_type == "all":
    print report_all()
elif opt.report_type == "not-ubuntu":
    print report_not_ubuntu()
elif opt.report_type == "ubuntu-only":
    print report_ubuntu_only()
elif opt.report_type == "priority":
    print report_priority()

sys.exit(0)

