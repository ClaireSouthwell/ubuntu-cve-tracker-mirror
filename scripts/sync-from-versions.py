#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# This script will load the package versions from the current devel release
# and scan for any upstream_PKG versions that have been exceeded, and then
# mark the devel_PKG as not-affected.
#
import sys, os, os.path
import optparse, glob

import cve_lib
import source_map

import warnings
warnings.filterwarnings('ignore', 'apt API not stable yet', FutureWarning)
import apt

parser = optparse.OptionParser()
parser.add_option("-u", "--update", dest="update", help="Update CVEs with released package versions", action='store_true')
(opt, args) = parser.parse_args()

pkgs = source_map.load()

cves = glob.glob('active/CVE-*')
if os.path.islink('embargoed'):
    cves += glob.glob('embargoed/CVE-*')
    cves += glob.glob('embargoed/EMB-*')

for filename in cves:
    cve = os.path.basename(filename)
    try:
        data = cve_lib.load_cve(filename)
    except ValueError, e:
        if not cve.startswith('EMB'):
            print >>sys.stderr, e
        continue
    for src in data['pkgs']:
        if data['pkgs'][src].has_key('devel') and data['pkgs'][src].has_key('upstream'):
            upstream_state, upstream_notes = data['pkgs'][src]['upstream']
            # Skip bad released versions
            if upstream_state != 'released' or upstream_notes == "" or ' ' in upstream_notes or ',' in upstream_notes:
                continue

            state, notes = data['pkgs'][src]['devel']
            if not pkgs[cve_lib.devel_release].has_key(src):
                continue
            curver = pkgs[cve_lib.devel_release][src]['version']
            # Strip epoch for upstream comparison
            if ':' in curver:
                curver = curver[curver.find(':')+1:]
            if not state in ['released','DNE','not-affected'] and apt.VersionCompare(upstream_notes, curver) < 0:

                print '%s: %s upstream (%s) < %s (%s)' % (cve, src, upstream_notes, cve_lib.devel_release, curver)

                if opt.update:
                    cve_lib.update_state(filename,src,'devel','not-affected',pkgs[cve_lib.devel_release][src]['version'])
                    pass

        # Look for CVEs marked "pending" for a version that is in the archive already
        for release in cve_lib.releases:
            rel = release
            if rel == 'devel':
                rel = cve_lib.devel_release
            if data['pkgs'][src].has_key(release) and pkgs.has_key(rel) and pkgs[rel].has_key(src):
                state, notes = data['pkgs'][src][release]
                curver = pkgs[rel][src]['version']
                if state == 'pending' and notes != '' and apt.VersionCompare(notes, curver) <= 0:
                    print '%s: %s pending (%s) <= %s (%s)' % (cve, src, notes, rel, curver)

                    if opt.update:
                        cve_lib.update_state(filename,src,release,'released',notes)
