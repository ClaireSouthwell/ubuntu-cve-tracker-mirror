Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./src/libsodium/crypto_generichash/blake2/ref/blake2b-compress-avx2.h:19:    memcpy(&v, p, sizeof v);
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:135:  memcpy( P->salt, salt, BLAKE2B_SALTBYTES );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:141:  memcpy( P->personal, personal, BLAKE2B_PERSONALBYTES );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:246:    memcpy( block, key, keylen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:287:    memcpy( block, key, keylen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:304:      memcpy( S->buf + left, in, fill ); /* Fill buffer */
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:308:      memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, BLAKE2B_BLOCKBYTES ); /* Shift buffer left */
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:315:      memcpy( S->buf + left, in, inlen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:336:    memcpy( S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:345:  memcpy( out, &S->h[0], outlen );
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:353:    memcpy( out, buffer, outlen );
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:421:    memcpy(&val, &stream.rnd32[stream.rnd32_outleft], sizeof val);
./src/libsodium/crypto_auth/hmacsha512256/cp/hmac_hmacsha512256.c:37:    memcpy(out, out0, 32);
./src/libsodium/crypto_sign/ed25519/ref10/keypair.c:73:    memcpy(curve25519_sk, h, crypto_scalarmult_curve25519_BYTES);
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:59:    memcpy(sm, sig, 32);
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:60:    memcpy(sm + 32 + mlen, sig + 32, 32);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:195:    memcpy(&out, in, sizeof (limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:200:    memcpy(out, &in, sizeof (limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:315:  memcpy(origx, x, 5 * sizeof(limb));
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:319:  memcpy(origxprime, xprime, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:324:  memcpy(origxprime, xxprime, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:374:  memcpy(nqpqx, q, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:408:  memcpy(resultx, nqx, sizeof(limb) * 5);
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:409:  memcpy(resultz, nqz, sizeof(limb) * 5);
./src/libsodium/crypto_pwhash/argon2/argon2.c:106:    out = (uint8_t *) malloc(hashlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:137:        memcpy(hash, out, hashlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:195:    ctx.ad = (uint8_t *) malloc(ctx.adlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:196:    ctx.salt = (uint8_t *) malloc(ctx.saltlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:197:    ctx.out = (uint8_t *) malloc(ctx.outlen);
./src/libsodium/crypto_pwhash/argon2/argon2.c:204:    out = (uint8_t *) malloc(ctx.outlen);
./src/libsodium/crypto_pwhash/argon2/argon2-encoding.c:358:    memcpy(str, &tmp[i], (sizeof tmp) - i);
./src/libsodium/crypto_pwhash/argon2/argon2-encoding.c:382:        memcpy(dst, str, pp_len + 1);                                          \
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:44:    memcpy(dst->v, src->v, sizeof(uint64_t) * ARGON2_QWORDS_IN_BLOCK);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:89:    *region = (block_region *)malloc(sizeof(block_region));  /*2. Try to allocate region*/
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:104:    memcpy(&memory, &base, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:109:    memcpy(&memory, &base, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:115:    } else if ((base = malloc(memory_size + 63)) != NULL) {
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:118:        memcpy(&memory, &aligned, sizeof memory);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c:153:        (uint64_t *)malloc(sizeof(uint64_t) * (instance->segment_length));
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:55:        memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:60:            memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:65:            memcpy(out, out_buffer, crypto_generichash_blake2b_BYTES_MAX / 2);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:70:        memcpy(in_buffer, out_buffer, crypto_generichash_blake2b_BYTES_MAX);
./src/libsodium/crypto_pwhash/argon2/blake2b-long.c:74:        memcpy(out, out_buffer, toproduce);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:145:        (uint64_t *)malloc(sizeof(uint64_t) * instance->segment_length);
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:172:    memcpy(state, ((instance->region->memory + prev_offset)->v), ARGON2_BLOCK_SIZE);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/crypto_scrypt-common.c:169:    memcpy(dst, setting, prefixlen + saltlen);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:64:        memcpy(&hctx, &PShctx, sizeof(crypto_auth_hmacsha256_state));
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:68:        memcpy(T, U, 32);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c:85:        memcpy(&buf[i * 32], T, clen);
./src/libsodium/crypto_pwhash/scryptsalsa208sha256/scrypt_platform.c:56:    else if ((base = (uint8_t *) malloc(size + 63)) != NULL) {
./src/libsodium/crypto_box/crypto_box_seal.c:34:    memcpy(c, epk, crypto_box_PUBLICKEYBYTES);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:534:    memcpy(H, ctx->H, sizeof H);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:538:    memcpy(&n2[0], npub, 3 * 4);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:544:        memcpy(&fb[0], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:546:        memcpy(&fb[8], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:678:    memcpy(&n2[0], npub, 3 * 4);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:685:        memcpy(&fb[0], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:687:        memcpy(&fb[8], &x, sizeof x);
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:690:    memcpy(H, ctx->H, sizeof H);
./src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c:103:    memcpy(&iv_low, iv, 4);
./src/libsodium/crypto_stream/chacha20/vec/stream_chacha20_vec.c:104:    memcpy(&iv_high, iv + 4, 4);
./src/libsodium/sodium/utils.c:527:_sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:529:    return malloc(size > (size_t) 0U ? size : (size_t) 1U);
./src/libsodium/sodium/utils.c:533:_sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:559:    memcpy(unprotected_ptr + unprotected_size, canary, sizeof canary);
./src/libsodium/sodium/utils.c:566:    memcpy(canary_ptr, canary, sizeof canary);
./src/libsodium/sodium/utils.c:567:    memcpy(base_ptr, &unprotected_size, sizeof unprotected_size);
./src/libsodium/sodium/utils.c:576:sodium_malloc(const size_t size)
./src/libsodium/sodium/utils.c:580:    if ((ptr = _sodium_malloc(size)) == NULL) {
./src/libsodium/sodium/utils.c:599:    return sodium_malloc(total_size);
./src/libsodium/sodium/utils.c:624:    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);
./src/libsodium/sodium/utils.c:660:    memcpy(&unprotected_size, base_ptr, sizeof unprotected_size);
./src/libsodium/include/sodium/utils.h:70:/* WARNING: sodium_malloc() and sodium_allocarray() are not general-purpose
./src/libsodium/include/sodium/utils.h:93: * sodium_malloc() can be used to allocate any libsodium data structure,
./src/libsodium/include/sodium/utils.h:97: * either 357 or 361 bytes. For this reason, when using sodium_malloc() to
./src/libsodium/include/sodium/utils.h:100: * state = sodium_malloc((crypto_generichash_statebytes() + (size_t) 63U)
./src/libsodium/include/sodium/utils.h:105:void *sodium_malloc(const size_t size)
./src/libsodium/include/sodium/private/common.h:14:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:34:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:53:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:69:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:86:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:107:    memcpy(&w, src, sizeof w);
./src/libsodium/include/sodium/private/common.h:123:    memcpy(dst, &w, sizeof w);
./src/libsodium/include/sodium/private/common.h:141:    memcpy(dst, &w, sizeof w);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:65:    memcpy(&tmp, m, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:80:    if (bytes &  8) { memcpy(dst, src, 8); src += 8; dst += 8; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:81:    if (bytes &  4) { memcpy(dst, src, 4); src += 4; dst += 4; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:82:    if (bytes &  2) { memcpy(dst, src, 2); src += 2; dst += 2; }
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:105:    memcpy(&t0, key, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:106:    memcpy(&t1, key + 8, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:120:    memcpy(&st->pad[0], key + 16, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:121:    memcpy(&st->pad[1], key + 24, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:607:        memcpy(&h, &st->pad[0], 16);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:622:    memcpy(&mac[0], &h0, 8);
./src/libsodium/crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:623:    memcpy(&mac[8], &h1, 8);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:95:    memcpy(S, state, 32);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:203:    memcpy(state->state, sha256_initstate, sizeof sha256_initstate);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:222:        memcpy(&state->buf[r], in, inlen);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:225:    memcpy(&state->buf[r], in, 64 - r);
./src/libsodium/crypto_hash/sha256/cp/hash_sha256.c:235:    memcpy(state->buf, in, inlen); /* inlen < 64 */
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:95:    memcpy(S, state, 64);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:225:    memcpy(state->state, sha512_initstate, sizeof sha512_initstate);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:252:        memcpy(&state->buf[r], src, inlen);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:255:    memcpy(&state->buf[r], src, 128 - r);
./src/libsodium/crypto_hash/sha512/cp/hash_sha512.c:265:    memcpy(state->buf, src, inlen); /* inlen < 128 */
./src/libsodium/randombytes/randombytes.c:79:                        var buf = new Uint32Array(1);

== files() ==
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:133:randombytes_salsa20_random_random_dev_open(void)
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:147:        fd = open(*device, O_RDONLY);
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:238:         randombytes_salsa20_random_random_dev_open()) == -1) {
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:111:randombytes_sysrandom_random_dev_open(void)
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:125:        fd = open(*device, O_RDONLY);
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:208:         randombytes_sysrandom_random_dev_open()) == -1) {
./src/libsodium/crypto_sign/ed25519/ref10/obsolete.c:66:int crypto_sign_edwards25519sha512batch_open(unsigned char *m,
./src/libsodium/crypto_sign/ed25519/ref10/open.c:128:crypto_sign_ed25519_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/crypto_sign/crypto_sign.c:56:crypto_sign_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/crypto_sign/crypto_sign.c:60:    return crypto_sign_ed25519_open(m, mlen_p, sm, smlen, pk);
./src/libsodium/crypto_box/crypto_box_seal.c:46:crypto_box_seal_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_box/crypto_box.c:103:crypto_box_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_box/crypto_box.c:107:    return crypto_box_curve25519xsalsa20poly1305_open(m, c, clen, n, pk, sk);
./src/libsodium/crypto_box/curve25519xsalsa20poly1305/ref/box_curve25519xsalsa20poly1305.c:24:int crypto_box_curve25519xsalsa20poly1305_open(
./src/libsodium/crypto_box/curve25519xsalsa20poly1305/ref/after_curve25519xsalsa20poly1305.c:21:  return crypto_secretbox_xsalsa20poly1305_open(m,c,clen,n,k);
./src/libsodium/crypto_secretbox/xsalsa20poly1305/ref/box_xsalsa20poly1305.c:20:int crypto_secretbox_xsalsa20poly1305_open(
./src/libsodium/crypto_secretbox/crypto_secretbox.c:49:crypto_secretbox_open(unsigned char *m, const unsigned char *c,
./src/libsodium/crypto_secretbox/crypto_secretbox.c:53:    return crypto_secretbox_xsalsa20poly1305_open(m, c, clen, n, k);
./src/libsodium/include/sodium/crypto_box_curve25519xsalsa20poly1305.h:58:int crypto_box_curve25519xsalsa20poly1305_open(unsigned char *m,
./src/libsodium/include/sodium/crypto_secretbox_xsalsa20poly1305.h:44:int crypto_secretbox_xsalsa20poly1305_open(unsigned char *m,
./src/libsodium/include/sodium/crypto_box.h:127:int crypto_box_seal_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_box.h:149:int crypto_box_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_secretbox.h:75:int crypto_secretbox_open(unsigned char *m, const unsigned char *c,
./src/libsodium/include/sodium/crypto_sign_ed25519.h:36:int crypto_sign_ed25519_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/include/sodium/crypto_sign.h:56:int crypto_sign_open(unsigned char *m, unsigned long long *mlen_p,
./src/libsodium/include/sodium/crypto_sign_edwards25519sha512batch.h:38:int crypto_sign_edwards25519sha512batch_open(unsigned char *m,

== logging() ==

== environment() ==

== privileged() ==

== networking() ==
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:106:safe_read(const int fd, void * const buf_, size_t size)
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:114:        while ((readnb = read(fd, buf, size)) < (ssize_t) 0 &&
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:296:               safe_read(stream.random_data_source_fd, m0,
./src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c:302:        safe_read(stream.random_data_source_fd, m0,
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:85:safe_read(const int fd, void * const buf_, size_t size)
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:93:        while ((readnb = read(fd, buf, size)) < (ssize_t) 0 &&
./src/libsodium/randombytes/sysrandom/randombytes_sysrandom.c:283:        safe_read(stream.random_data_source_fd, buf, size) != (ssize_t) size) {
./src/libsodium/sodium/utils.c:437:_mprotect_readwrite(void *ptr, size_t size)
./src/libsodium/sodium/utils.c:626:    _mprotect_readwrite(base_ptr, total_size);
./src/libsodium/sodium/utils.c:679:sodium_mprotect_readwrite(void *ptr)
./src/libsodium/include/sodium/utils.h:122:int sodium_mprotect_readwrite(void *ptr);

== http:// ==
./src/libsodium/crypto_generichash/blake2/ref/blake2b-load-sse2.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:11:   [CC0](http://creativecommons.org/publicdomain/zero/1.0), the
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:13:   the [Apache Public License 2.0](http://www.apache.org/licenses/LICENSE-2.0),
./src/libsodium/crypto_generichash/blake2/ref/blake2b-ref.c:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2-impl.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_generichash/blake2/ref/blake2b-load-sse41.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:8: * http://code.google.com/p/curve25519-donna/
./src/libsodium/crypto_scalarmult/curve25519/donna_c64/curve25519_donna_c64.c:15: *   http://cr.yp.to/ecdh.html
./src/libsodium/crypto_pwhash/argon2/argon2-impl.h:11:   this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-core.h:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2.h:9: * with this software. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-core.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.
./src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ssse3.c:11: * <http://creativecommons.org/publicdomain/zero/1.0/>.

== encryption ==
./src/libsodium/crypto_generichash/blake2/ref/blake2.h:12:   [OpenSSL Licence](https://www.openssl.org/source/license.html), or
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:205:   <https://software.intel.com/sites/default/files/managed/72/cc/clmul-wp-rev-2.02-2014-04-20.pdf>
./src/libsodium/crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:316:   <https://software.intel.com/sites/default/files/managed/72/cc/clmul-wp-rev-2.02-2014-04-20.pdf>
./src/libsodium/sodium/core.c:17:# warning Use releases available at https://download.libsodium.org/libsodium/releases/ instead.

== sql() ==

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/libsodium/crypto_stream/aes128ctr/portable/common.h:460:  shufb(x, ROTB) /* TODO: Make faster */

== unsafe input mechanisms ==

