#!/usr/bin/python

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# (C) 2005-2007 Canonical. Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader
import shutil, subprocess

destdir = "."

# settings for automatic CVE database evaluation
cvexml_url="http://cve.mitre.org/cve/downloads/allitems.xml"

ignore_strings = ["** REJECT **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS",
    "Cisco", "ActiveX"]


###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def subtract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)

###################

def get_archive_map(rootdir, cachefile = None):
    """Generate a archive map from a Debian-style package archive directory.

    rootdir: path to archive root path
    cachefile: path to a cache file (created if not existing)
    return: mapping: package -> release -> (component, version, path)
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}
    currpkg = None
    currversion = None
    currdir = None

    for release in os.listdir(rootdir + "/dists"):
        if release.split('-')[0] in obsolete_releases:
            continue
        for comp in os.listdir(rootdir + "/dists/" + release):
            compdir = rootdir + "/dists/" + release + "/" + comp
            if not os.path.isdir(compdir):
                continue
            srcfile = compdir + "/source/Sources.gz"
            if not os.path.exists(srcfile):
                print >> sys.stderr, 'ERROR: Sources file %s does not exist, ignoring' % srcfile
                continue
            #print >> sys.stderr, "Scanning", srcfile

            for line in gzip.open(srcfile):
                line = line.strip()
                if not line:
                    if (not currpkg) or (not currversion) or (not currdir):
                        print >> sys.stderr, "Error: end of package record without all data available"
                        sys.exit(1)
                    map.setdefault(currpkg, {})[release] = (comp, currversion, currdir)
                    currpkg = None
                    currversion = None
                    currdir = None
                    continue

                attr = line.split(":", 1)

                if len(attr) < 2:
                    continue

                if attr[0] == "Package":
                    if currpkg:
                        print >> sys.stderr, "Error: read two Packages: lines in a row"
                        sys.exit(1)
                    currpkg = attr[1].strip()

                if attr[0] == "Version":
                    if currversion:
                        print >> sys.stderr, "Error: read two Version: lines in a row"
                        sys.exit(1)
                    currversion = attr[1].strip()
                    # remove epochs
                    colpos = currversion.find(':')
                    if colpos >= 0:
                        currversion = currversion[colpos+1:]

                if attr[0] == "Directory":
                    if currdir:
                        print >> sys.stderr, "Error: read two Directory: lines in a row"
                        sys.exit(1)
                    currdir = attr[1].strip()

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def parse_CVEs(url):
    """Return a list of all CVE numbers mentioned in the given URL."""

    list = []
    cvere = re.compile("((?:CAN|can|CVE|cve)-\d\d\d\d-\d\d\d\d)")
    try:
        text = cache_urllib.urlopen(url).read().splitlines()
        for line in text:
            comment = line.find('#')
            if comment != -1:
                line = line[:comment]
            for cve in cvere.finditer(line):
                list.append(cve.group().upper().replace('CAN', 'CVE', 1))
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

###################

class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore):
        self.curr_cve = None
        self.curr_desc = None
        self.curr_refs = []
        self.curr_chars = ""
        self.ignore = ignore

    def startElement(self, name, attrs):
        if name == "item":
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
        if name == "desc" or name == "ref":
            self.curr_chars = ""
        if name == "ref":
            self.curr_url = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
        if name == "ref":
            self.curr_refs += [(self.curr_chars.encode("ascii", "replace"),self.curr_url)]

        if name == "item":
            self.handle_cve()

    def handle_cve(self):
        # Skip CVEs we know about already
        if self.curr_cve in self.ignore:
            return

        # Skip stuff older than 2005
        if int(self.curr_cve.split("-")[1]) < 2005:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        response = 'skip'
        reason = ""
        # Skip CVEs that are obviously not about Ubuntu
        for s in ignore_strings:
            if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
                response = 'ignore'
                reason = s

        print '%s' % (self.curr_cve)
        for ref in self.curr_refs:
            print ' %s' % (ref[0]),
            if ref[1]:
                print ' %s' % (ref[1]),
            print
        print '%s' % (self.curr_desc)
        info = ''
        while info == "" or not info[0] in ['i','a','s','q']:
            print 'A)dd to tracker, I)gnore forever, S)kip for now, or Q)uit? [%s] ' % (response),
            info = sys.stdin.readline().strip().lower()
            if info == "":
                info = response

        if info.startswith('q'):
            sys.exit(0)
        elif info.startswith('a'):
            # Add to tracker from 00boilerplate
            src = '%s/active/00boilerplate'%(destdir)
            dst = '%s/active/%s'%(destdir,self.curr_cve)
            shutil.copy(src,dst)
            editor = os.getenv('EDITOR','vi')
            subprocess.call([editor,dst])
        elif info.startswith('i'):
            info = ""
            while info == "":
                print 'Reason to be ignored? ',
                if reason != "":
                    print '[%s] ' % (reason),
                info = sys.stdin.readline().strip()
                if info == "":
                    info = reason
            # Append to ignore list
            file('%s/ignored/not-for-us.txt'%(destdir),'a').write('%s # %s\n'%(self.curr_cve,info))
        print ''

# CVEIgnoreList is a list of all CVEs we know about already.  These will be
# ignoreda when checking MITRE for new CVEs
CVEIgnoreList  = parse_CVEs(destdir + "/ignored/not-for-us.txt")
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/ignored/") if cve.startswith('CVE-')]
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/retired/") if cve.startswith('CVE-')]
CVEIgnoreList += [cve for cve in os.listdir(destdir + "/active/") if cve.startswith('CVE-')]

parser = xml.sax.make_parser()
parser.setContentHandler(CVEHandler(CVEIgnoreList))
if len(sys.argv) == 2:
    cvexml_url = sys.argv[1]
print >>sys.stderr, 'Loading %s ...'%(cvexml_url)
parser.parse(urllib.urlopen(cvexml_url))
