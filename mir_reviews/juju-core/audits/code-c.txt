Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./src/gopkg.in/mgo.v2/internal/sasl/sasl.c:45:	sasl_callback_t *cb = malloc(4 * sizeof(sasl_callback_t));
./src/gopkg.in/mgo.v2/internal/sasl/sasl.c:49:	sasl_secret_t *secret = (sasl_secret_t*)malloc(sizeof(sasl_secret_t) + len);
./src/gopkg.in/mgo.v2/internal/sasl/sasl.c:54:	strcpy((char *)secret->data, password);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:60:	*buffer = malloc(out_bufs[0].cbBuffer);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:62:	memcpy(*buffer, out_bufs[0].pvBuffer, *buffer_length);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:78:	char *msg = malloc((sizes.cbSecurityTrailer + msgSize + sizes.cbBlockSize) * sizeof(char));
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:83:	memcpy(&msg[sizes.cbSecurityTrailer + 4], user_plus_realm, user_plus_realm_length);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:110:	*buffer = malloc(*buffer_length);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:112:	memcpy(*buffer, wrapBufs[0].pvBuffer, wrapBufs[0].cbBuffer);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:113:	memcpy(*buffer + wrapBufs[0].cbBuffer, wrapBufs[1].pvBuffer, wrapBufs[1].cbBuffer);
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:114:	memcpy(*buffer + wrapBufs[0].cbBuffer + wrapBufs[1].cbBuffer, wrapBufs[2].pvBuffer, wrapBufs[2].cbBuffer);

== files() ==

== logging() ==
./src/gopkg.in/mgo.v2/internal/sasl/sasl_windows.c:103:	status = call_sspi_encrypt_message(context, SECQOP_WRAP_NO_ENCRYPT, &wrapBufDesc, 0);
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.c:24:SECURITY_STATUS SEC_ENTRY call_sspi_encrypt_message(PCtxtHandle phContext, unsigned long fQOP, PSecBufferDesc pMessage, unsigned long MessageSeqNo)
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.h:19:SECURITY_STATUS SEC_ENTRY call_sspi_encrypt_message(PCtxtHandle phContext, unsigned long fQOP, PSecBufferDesc pMessage, unsigned long MessageSeqNo);
./src/golang.org/x/crypto/otr/libotr_test_helper.c:27:void inject_message(void *opdata, const char *accountname, const char *protocol, const char *recipient, const char *message) {
./src/golang.org/x/crypto/otr/libotr_test_helper.c:37:int display_otr_message(void *opdata, const char *accountname, const char *protocol, const char *username, const char *msg) {
./src/golang.org/x/crypto/otr/libotr_test_helper.c:69:void log_message(void *opdata, const char *message) {
./src/golang.org/x/crypto/otr/libotr_test_helper.c:122:    perror("creating temp file");
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:27:void inject_message(void *opdata, const char *accountname, const char *protocol, const char *recipient, const char *message) {
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:37:int display_otr_message(void *opdata, const char *accountname, const char *protocol, const char *username, const char *msg) {
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:69:void log_message(void *opdata, const char *message) {
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:122:    perror("creating temp file");

== environment() ==
./src/golang.org/x/crypto/otr/libotr_test_helper.c:114:  if (getenv("TMP")) {
./src/golang.org/x/crypto/otr/libotr_test_helper.c:115:    tmpdir = getenv("TMP");
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:114:  if (getenv("TMP")) {
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:115:    tmpdir = getenv("TMP");

== privileged() ==

== networking() ==
./src/golang.org/x/crypto/otr/libotr_test_helper.c:124:  write(fd, kPrivateKeyData, sizeof(kPrivateKeyData)-1);
./src/golang.org/x/crypto/otr/libotr_test_helper.c:128:  otrl_privkey_read(userstate, private_key_file);
./src/golang.org/x/crypto/otr/libotr_test_helper.c:162:      write(1, newmessage, strlen(newmessage));
./src/golang.org/x/crypto/otr/libotr_test_helper.c:163:      write(1, "\n", 1);
./src/golang.org/x/crypto/otr/libotr_test_helper.c:166:      write(1, "?OTRv2?\n", 8);
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:124:  write(fd, kPrivateKeyData, sizeof(kPrivateKeyData)-1);
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:128:  otrl_privkey_read(userstate, private_key_file);
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:162:      write(1, newmessage, strlen(newmessage));
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:163:      write(1, "\n", 1);
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:166:      write(1, "?OTRv2?\n", 8);

== http:// ==
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.c:7://   http://www.apache.org/licenses/LICENSE-2.0
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.h:7://   http://www.apache.org/licenses/LICENSE-2.0

== encryption ==
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.c:3://   https://github.com/christkv/kerberos/tree/master/lib/win32/kerberos_sspi.c
./src/gopkg.in/mgo.v2/internal/sasl/sspi_windows.h:3://   https://github.com/christkv/kerberos/tree/master/lib/win32/kerberos_sspi.h

== sql() ==

== tmp() ==
./src/golang.org/x/crypto/otr/libotr_test_helper.c:113:  const char *tmpdir = "/tmp";
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:113:  const char *tmpdir = "/tmp";

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/golang.org/x/crypto/otr/libotr_test_helper.c:119:  snprintf(private_key_file, sizeof(private_key_file), "%s/libotr_test_helper_privatekeys-XXXXXX", tmpdir);
./src/code.google.com/p/go.crypto/otr/libotr_test_helper.c:119:  snprintf(private_key_file, sizeof(private_key_file), "%s/libotr_test_helper_privatekeys-XXXXXX", tmpdir);

== unsafe input mechanisms ==

