#!/usr/bin/env python

# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2012 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import datetime
import os
import re
import sys
import optparse
import cve_lib
import time

import source_map
map = source_map.load()
releases = cve_lib.releases

priorities = dict()
for p in ['untriaged'] + cve_lib.priorities:
    priorities.setdefault(p, dict())

packages = dict()
assignees = dict()
pkg_assignees = dict()
embargoed_packages = dict()
deferred_packages = dict()
pockets = { 'supported' : dict(),
            'universe' : dict(),
            'partner' : dict() }

points = { 'negligible' : 0,
           'untriaged' : 5,
           'low' : 10,
           'medium' : 50,
           'high' : 100,
           'critical' : 200 }

# medium and higher get a point bump if older than too_old
too_old_packages = dict()
too_old = 30
too_old_bump = 200	# bump for medium, high is this * 2, critical this * 4, low this / 5
today = time.time()

info = dict()

parser = optparse.OptionParser()
parser.add_option("-S", "--skip-devel", help="Show only those CVEs *not* in the current devel release", action="store_true")
parser.add_option("-D", "--only-devel", help="Show only those CVEs in the current devel release", action="store_true")
parser.add_option("-m", "--only-supported", help="Show only those CVEs that are supported", action="store_true")
parser.add_option("-u", "--not-supported", help="Show only those CVEs that aren't supported", action="store_true")
parser.add_option("-t", "--totals", help="Display totals", action="store_true")
parser.add_option("-p", "--packages", help="Report only on the given packages", action="append", type="string")
parser.add_option("-P", "--pkgfamily", help="Perform pkg family renamings (use argument multiple times for 'linux' and/or 'xen')", action="append", default=[])
parser.add_option("-X", "--exclude", help="Ignore specified packages", action="append", type="string")
parser.add_option("-r", "--release", help="Report only for the given releases", action="append", type="string")
parser.add_option("-d", "--debug", help="Report debug information while loading", action="store_true")
parser.add_option("-a", "--show-assigned", help="Show CVE assignments", action="store_true")
parser.add_option("--by-assignee", help="Show CVE assignments organized by assignee", action="store_true")
parser.add_option("--assignee", help="Show CVE assignments for assignee", action="append", type="string")
parser.add_option("--deferred-days", help="Don't show deferred items within NUM days", metavar="NUM", action="store", type="string")
(opt, args) = parser.parse_args()

releases = cve_lib.releases
for eol in cve_lib.eol_releases:
    if eol in releases:
        releases.remove(eol)

if opt.skip_devel and cve_lib.devel_release != '':
    releases.remove(cve_lib.devel_release)

if opt.only_devel:
    releases = [cve_lib.devel_release]

if opt.release:
    releases = opt.release

(cves, uems) = cve_lib.get_cve_list()
(table, priority, cves, namemap, cveinfo) = cve_lib.load_table(cves, uems, opt)
date_pat = re.compile(r'^20[0-9][0-9]-[01][0-9]-[0-3][0-9]$')
if opt.deferred_days != None:
    deferred_today = datetime.datetime(int(datetime.date.today().year),
                                       int(datetime.date.today().month),
                                       int(datetime.date.today().day))
    deferred_delta = datetime.timedelta(days=int(opt.deferred_days))

for cve in sorted(cves):
    if not table.has_key(cve):
        continue

    # Load CVE if it isn't already cached
    if not info.has_key(cve):
        info.setdefault(cve, cve_lib.load_cve(cve_lib.find_cve(cve)))

    for pkg in sorted(table[cve].keys()):
        if opt.exclude and pkg in opt.exclude:
            continue

        supported = False
        partner = False
        universe = False
        found = False
        for r in releases:
            if table[cve][pkg].has_key(r):
                if table[cve][pkg][r] in ['needed','deferred','pending','needs-triage','active']:
                    if opt.deferred_days != None and table[cve][pkg][r] == 'deferred':
                        if table[cve][pkg].has_key("%s_comment" % r) and date_pat.search(table[cve][pkg]["%s_comment" % r]):
                            t = table[cve][pkg]["%s_comment" % r].split('-')
                            deferred_date = datetime.datetime(int(t[0]), int(t[1]), int(t[2]))
                            if deferred_today - deferred_delta > deferred_date:
                                deferred_packages[pkg] = 1
                            else:
                                continue
                    found = True
                    if cve_lib.is_supported(map, namemap[pkg][r], r, cveinfo[cve]):
                        supported = True
                    if cve_lib.is_partner(map, namemap[pkg][r], r):
                        partner = True
                    if cve_lib.is_universe(map, namemap[pkg][r], r, cveinfo[cve]):
                        universe = True

        if not found:
            continue

        if opt.only_supported and not supported and not partner:
            continue

        if opt.not_supported and (supported or partner):
            continue

        if supported:
            if pockets['supported'].has_key(pkg):
                pockets['supported'][pkg] += 1
            else:
                pockets['supported'][pkg] = 1
        if partner:
            if pockets['partner'].has_key(pkg):
                pockets['partner'][pkg] += 1
            else:
                pockets['partner'][pkg] = 1
        if universe:
            if pockets['universe'].has_key(pkg):
                pockets['universe'][pkg] += 1
            else:
                pockets['universe'][pkg] = 1

        if packages.has_key(pkg):
            packages[pkg] += 1
        else:
            packages[pkg] = 1

        p = priority[cve]['default']
        if priority[cve].has_key(pkg):
            p = priority[cve][pkg]

        if priorities[p].has_key(pkg):
            priorities[p][pkg] += 1
        else:
            priorities[p][pkg] = 1

        if os.path.islink('embargoed') and os.path.exists(os.path.join("embargoed", cve)):
            embargoed_packages[pkg] = 1

        if p in ['low', 'medium', 'high', 'critical']:
            try:
                if cve_lib.cve_age(cve, info[cve]['PublicDate'], today) > too_old:
                    if too_old_packages.has_key(pkg):
                        if too_old_packages[pkg].has_key(p):
                            too_old_packages[pkg][p] += 1
                        else:
                            too_old_packages[pkg][p] = 1
                    else:
                        too_old_packages[pkg] = dict()
                        too_old_packages[pkg][p] = 1
            except ValueError:
                continue

        if cveinfo[cve].has_key('Assigned-to') and cveinfo[cve]['Assigned-to'] != "":
            if opt.show_assigned:
                if not pkg_assignees.has_key(pkg):
                    pkg_assignees[pkg] = []
                if cveinfo[cve]['Assigned-to'] not in pkg_assignees[pkg]:
                    pkg_assignees[pkg].append(cveinfo[cve]['Assigned-to'])
            if opt.by_assignee:
                if not assignees.has_key(cveinfo[cve]['Assigned-to']):
                    assignees[cveinfo[cve]['Assigned-to']] = dict()
                if not assignees[cveinfo[cve]['Assigned-to']].has_key(pkg):
                    assignees[cveinfo[cve]['Assigned-to']][pkg] = []
                assignees[cveinfo[cve]['Assigned-to']][pkg].append(cve)


if opt.by_assignee:
    people = assignees.keys()
    people.sort()
    for p in people:
        if opt.assignee and p not in opt.assignee:
            continue
        sys.stdout.write("%s:\n" % p)
        pkgs = assignees[p].keys()
        pkgs.sort()
        for pkg in pkgs:
            sys.stdout.write("  %s:\n" % pkg)
            cves_p = assignees[p][pkg]
            cves_p.sort()
            for c in cves_p:
                sys.stdout.write("    %s\n" % c)
        sys.stdout.write("\n")
    sys.exit(0)

sys.stdout.write("Weight\tPackage Counts\n")
sys.stdout.write("---------------------------------------------------------------------\n")
for pkg in sorted(packages.keys()):
    if opt.show_assigned and opt.assignee:
        if not pkg_assignees.has_key(pkg):
            continue
        found = False
        for p in opt.assignee:
            if p in pkg_assignees[pkg]:
                found = True
        if not found:
            continue

    score = 0
    for p in ['untriaged'] + cve_lib.priorities:
        if priorities[p].has_key(pkg):
            score += priorities[p][pkg] * points[p]

    if too_old_packages.has_key(pkg):
        bump = 1
        for p in ['low', 'medium', 'high', 'critical']:
            if not too_old_packages[pkg].has_key(p):
                continue
            if p == 'high':
                bump += too_old_packages[pkg][p] * too_old_bump * 2
            elif p == 'critical':
                bump += too_old_packages[pkg][p] * too_old_bump * 4
            elif p == 'low':
                bump += too_old_packages[pkg][p] * too_old_bump / 5
            else:
                bump += too_old_packages[pkg][p] * too_old_bump
        score += bump

    if opt.totals:
        sys.stdout.write("%s: %s"%(pkg, packages[pkg]))
    else:
        sys.stdout.write("%s\t%s: %s total" % (str(score), pkg, str(packages[pkg])))
        for p in ['untriaged'] + cve_lib.priorities:
            if priorities[p].has_key(pkg):
                sys.stdout.write(", %s %s" % (str(priorities[p][pkg]), p))

    extra_info = []
    if pockets['partner'].has_key(pkg):
        extra_info.append('PARTNER')
    elif pockets['supported'].has_key(pkg):
        extra_info.append('SUPPORTED')
    if embargoed_packages.has_key(pkg):
        extra_info.append('EMBARGOED')
    if deferred_packages.has_key(pkg):
        extra_info.append('CHECKDEFERRED')

    if len(extra_info) > 0:
        sys.stdout.write(" (%s)" % ",".join(extra_info))

    if opt.show_assigned and pkg_assignees.has_key(pkg):
        pkg_assignees[pkg].sort()
        sys.stdout.write(" (%s)" % ",".join(pkg_assignees[pkg]))

    sys.stdout.write("\n")

