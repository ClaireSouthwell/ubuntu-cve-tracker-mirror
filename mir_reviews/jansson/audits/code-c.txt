Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./src/memory.c:23:void *jsonp_malloc(size_t size)
./src/memory.c:48:    new_str = jsonp_malloc(len + 1);
./src/memory.c:52:    memcpy(new_str, str, len);
./src/value.c:53:    json_object_t *object = jsonp_malloc(sizeof(json_object_t));
./src/value.c:343:    json_array_t *array = jsonp_malloc(sizeof(json_array_t));
./src/value.c:351:    array->table = jsonp_malloc(array->size * sizeof(json_t *));
./src/value.c:430:    memcpy(&dest[dpos], &src[spos], count * sizeof(json_t *));
./src/value.c:446:    new_table = jsonp_malloc(new_size * sizeof(json_t *));
./src/value.c:657:    string = jsonp_malloc(sizeof(json_string_t));
./src/value.c:799:    json_integer_t *integer = jsonp_malloc(sizeof(json_integer_t));
./src/value.c:851:    real = jsonp_malloc(sizeof(json_real_t));
./src/strconv.c:22:    localeconv() and the call to sprintf() or strtod(), the result may
./src/dump.c:133:                    sprintf(seq, "\\u%04X", codepoint);
./src/dump.c:146:                    sprintf(seq, "\\u%04X\\u%04X", first, last);
./src/dump.c:314:                keys = jsonp_malloc(size * sizeof(struct object_key));
./src/strbuffer.c:26:    strbuff->value = jsonp_malloc(strbuff->size);
./src/strbuffer.c:89:        new_value = jsonp_malloc(new_size);
./src/strbuffer.c:93:        memcpy(new_value, strbuff->value, strbuff->length);
./src/strbuffer.c:100:    memcpy(strbuff->value + strbuff->length, data, size);
./src/jansson_private.h:25:   available as __va_copy. If not, memcpy() should do the trick. */
./src/jansson_private.h:30:#define va_copy(a, b)  memcpy(&(a), &(b), sizeof(va_list))
./src/jansson_private.h:87:void* jsonp_malloc(size_t size);
./src/hashtable.c:158:    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));
./src/hashtable.c:188:    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));
./src/hashtable.c:244:        pair = jsonp_malloc(offsetof(pair_t, key) + len + 1);
./src/hashtable.c:250:        strcpy(pair->key, key);
./src/error.c:28:        strcpy(error->source, source);
./src/error.c:31:        strcpy(error->source, "...");
./src/error.c:32:        strcpy(error->source + 3, source + extra);
./src/load.c:378:    t = jsonp_malloc(lex->saved_text.length + 1);
./test/suites/api/test_memory_funcs.c:25:static void *my_malloc(size_t size)
./test/suites/api/test_memory_funcs.c:28:    return malloc(size);
./test/suites/api/test_memory_funcs.c:53:static void *secure_malloc(size_t size)
./test/suites/api/test_memory_funcs.c:56:    void *ptr = malloc(size + 8);
./test/suites/api/test_dump_callback.c:24:    memcpy(s->buf + s->off, buffer, len);
./test/suites/api/test_dump_callback.c:49:    s.buf = malloc(s.cap);
./test/suites/api/test_load_callback.c:27:        memcpy(buf, s->buf + s->off, buflen);
./test/bin/json_process.c:77:    buf = malloc(fsize+1);
./test/bin/json_process.c:134:    sprintf(filename, "%s%c%s", path, dir_sep, fname);
./test/bin/json_process.c:169:    sprintf(filename, "%s%cinput", test_path, dir_sep);
./test/bin/json_process.c:175:    sprintf(filename, "%s%cenv", test_path, dir_sep);
./test/bin/json_process.c:226:        sprintf(errstr, "%d %d %d\n%s\n",
./doc/github_commits.c:46:    memcpy(result->data + result->pos, ptr, size * nmemb);
./doc/github_commits.c:65:    data = malloc(BUFFER_SIZE);

== files() ==
./src/dump.c:444:    FILE *output = fopen(path, "w");
./src/hashtable_seed.c:63:    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise
./src/hashtable_seed.c:64:       fall back to fopen() */
./src/hashtable_seed.c:71:    urandom = open("/dev/urandom", O_RDONLY);
./src/hashtable_seed.c:80:    urandom = fopen("/dev/urandom", "rb");
./src/load.c:1038:    fp = fopen(path, "rb");
./test/bin/json_process.c:135:    file = fopen(filename, "rb");
./test/bin/json_process.c:141:        file = fopen(filename, "rb");
./test/bin/json_process.c:170:    if (!(infile = fopen(filename, "rb"))) {
./test/bin/json_process.c:176:    conffile = fopen(filename, "rb");

== logging() ==
./src/pack_unpack.c:109:static void set_error(scanner_t *s, const char *source, const char *fmt, ...)
./src/pack_unpack.c:144:            set_error(s, "<args>", "NULL string argument");
./src/pack_unpack.c:151:            set_error(s, "<args>", "Invalid UTF-8 %s", purpose);
./src/pack_unpack.c:165:            set_error(s, "<args>", "NULL string argument");
./src/pack_unpack.c:184:            set_error(s, "<internal>", "Out of memory");
./src/pack_unpack.c:197:        set_error(s, "<args>", "Invalid UTF-8 %s", purpose);
./src/pack_unpack.c:219:            set_error(s, "<format>", "Unexpected end of format string");
./src/pack_unpack.c:224:            set_error(s, "<format>", "Expected format 's', got '%c'", token(s));
./src/pack_unpack.c:246:            set_error(s, "<internal>", "Unable to add key \"%s\"", key);
./src/pack_unpack.c:272:            set_error(s, "<format>", "Unexpected end of format string");
./src/pack_unpack.c:281:            set_error(s, "<internal>", "Unable to append to array");
./src/pack_unpack.c:341:            set_error(s, "<format>", "Unexpected format character '%c'",
./src/pack_unpack.c:363:        set_error(s, "<internal>", "Out of memory");
./src/pack_unpack.c:368:        set_error(s, "<validation>", "Expected object, got %s",
./src/pack_unpack.c:380:            set_error(s, "<format>", "Expected '}' after '%c', got '%c'",
./src/pack_unpack.c:386:            set_error(s, "<format>", "Unexpected end of format string");
./src/pack_unpack.c:397:            set_error(s, "<format>", "Expected format 's', got '%c'", token(s));
./src/pack_unpack.c:403:            set_error(s, "<args>", "NULL object key");
./src/pack_unpack.c:421:                set_error(s, "<validation>", "Object item not found: %s", key);
./src/pack_unpack.c:453:            set_error(s, "<validation>", "%li object item(s) left unpacked", unpacked);
./src/pack_unpack.c:471:        set_error(s, "<validation>", "Expected array, got %s", type_name(root));
./src/pack_unpack.c:480:            set_error(s, "<format>", "Expected ']' after '%c', got '%c'",
./src/pack_unpack.c:487:            set_error(s, "<format>", "Unexpected end of format string");
./src/pack_unpack.c:498:            set_error(s, "<format>", "Unexpected format character '%c'",
./src/pack_unpack.c:510:                set_error(s, "<validation>", "Array index %lu out of range",
./src/pack_unpack.c:528:        set_error(s, "<validation>", "%li array item(s) left unpacked", diff);
./src/pack_unpack.c:547:                set_error(s, "<validation>", "Expected string, got %s",
./src/pack_unpack.c:558:                    set_error(s, "<args>", "NULL string argument");
./src/pack_unpack.c:567:                        set_error(s, "<args>", "NULL string length argument");
./src/pack_unpack.c:584:                set_error(s, "<validation>", "Expected integer, got %s",
./src/pack_unpack.c:599:                set_error(s, "<validation>", "Expected integer, got %s",
./src/pack_unpack.c:614:                set_error(s, "<validation>", "Expected true or false, got %s",
./src/pack_unpack.c:629:                set_error(s, "<validation>", "Expected real, got %s",
./src/pack_unpack.c:644:                set_error(s, "<validation>", "Expected real or integer, got %s",
./src/pack_unpack.c:674:                set_error(s, "<validation>", "Expected null, got %s",
./src/pack_unpack.c:681:            set_error(s, "<format>", "Unexpected format character '%c'",
./src/pack_unpack.c:714:        set_error(&s, "<format>", "Garbage after format string");
./src/pack_unpack.c:776:        set_error(&s, "<format>", "Garbage after format string");
./src/hashtable.h:52: * Returns 0 on success, -1 on error (out of memory).
./src/load.c:1042:                  path, strerror(errno));
./test/suites/api/test_pack.c:233:    check_error("Expected format 's', got '1'", "<format>", 3, 1, 4);
./test/suites/api/test_pack.c:238:    check_error("Unexpected format character '}'", "<format>", 1, 2, 2);
./test/suites/api/test_pack.c:242:    check_error("Expected format 's', got ']'", "<format>", 1, 2, 2);
./test/suites/api/test_pack.c:247:    check_error("Unexpected end of format string", "<format>", 1, 2, 2);
./test/suites/api/test_pack.c:252:    check_error("Unexpected end of format string", "<format>", 1, 2, 2);
./test/suites/api/test_pack.c:257:    check_error("Garbage after format string", "<format>", 1, 4, 4);
./test/suites/api/test_pack.c:261:    check_error("Garbage after format string", "<format>", 1, 2, 2);
./test/suites/api/test_pack.c:266:    check_error("NULL string argument", "<args>", 1, 1, 1);
./test/suites/api/test_pack.c:271:    check_error("Unexpected format character '+'", "<format>", 1, 1, 1);
./test/suites/api/test_pack.c:276:    check_error("NULL or empty format string", "<format>", -1, -1, 0);
./test/suites/api/test_pack.c:281:    check_error("NULL string argument", "<args>", 1, 2, 2);
./test/suites/api/test_pack.c:286:    check_error("Expected format 's', got '{'", "<format>", 1, 3, 3);
./test/suites/api/test_pack.c:291:    check_error("Unexpected format character '}'", "<format>", 1, 19, 19);
./test/suites/api/test_pack.c:296:    check_error("Unexpected format character '}'", "<format>", 1, 21, 21);
./test/suites/api/test_pack.c:301:    check_error("Invalid UTF-8 object key", "<args>", 1, 2, 2);
./test/suites/api/test_pack.c:306:    check_error("Invalid UTF-8 string", "<args>", 1, 4, 4);
./test/suites/api/test_unpack.c:147:    check_error("Unexpected format character 'z'", "<format>", 1, 1, 1);
./test/suites/api/test_unpack.c:151:    check_error("NULL root value", "<root>", -1, -1, 0);
./test/suites/api/test_unpack.c:158:    check_error("Unexpected format character '}'", "<format>", 1, 2, 2);
./test/suites/api/test_unpack.c:164:    check_error("Expected format 's', got ']'", "<format>", 1, 2, 2);
./test/suites/api/test_unpack.c:171:    check_error("Unexpected end of format string", "<format>", 1, 2, 2);
./test/suites/api/test_unpack.c:178:    check_error("Unexpected end of format string", "<format>", 1, 2, 2);
./test/suites/api/test_unpack.c:185:    check_error("Garbage after format string", "<format>", 1, 4, 4);
./test/suites/api/test_unpack.c:191:    check_error("Garbage after format string", "<format>", 1, 2, 2);
./test/suites/api/test_unpack.c:198:    check_error("NULL or empty format string", "<format>", -1, -1, 0);
./test/suites/api/test_unpack.c:205:    check_error("NULL string argument", "<args>", 1, 1, 1);
./test/suites/api/test_unpack.c:213:    check_error("Expected string, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:217:    check_error("Expected null, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:221:    check_error("Expected true or false, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:225:    check_error("Expected integer, got string", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:229:    check_error("Expected integer, got string", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:233:    check_error("Expected real, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:237:    check_error("Expected real or integer, got string", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:241:    check_error("Expected array, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:245:    check_error("Expected object, got integer", "<validation>", 1, 1, 1);
./test/suites/api/test_unpack.c:254:    check_error("Array index 1 out of range", "<validation>", 1, 3, 3);
./test/suites/api/test_unpack.c:261:    check_error("NULL object key", "<args>", 1, 2, 2);
./test/suites/api/test_unpack.c:268:    check_error("Object item not found: baz", "<validation>", 1, 3, 3);
./test/suites/api/test_unpack.c:284:    check_error("1 array item(s) left unpacked", "<validation>", 1, 5, 5);
./test/suites/api/test_unpack.c:291:    check_error("1 array item(s) left unpacked", "<validation>", 1, 4, 4);
./test/suites/api/test_unpack.c:304:    check_error("1 object item(s) left unpacked", "<validation>", 1, 10, 10);
./test/suites/api/test_unpack.c:317:    check_error("Expected ']' after '!', got 'i'", "<format>", 1, 4, 4);
./test/suites/api/test_unpack.c:321:    check_error("Expected ']' after '*', got 'i'", "<format>", 1, 4, 4);
./test/suites/api/test_unpack.c:327:    check_error("Expected '}' after '!', got 's'", "<format>", 1, 5, 5);
./test/suites/api/test_unpack.c:331:    check_error("Expected '}' after '*', got 's'", "<format>", 1, 5, 5);
./test/suites/api/test_unpack.c:338:    check_error("1 object item(s) left unpacked", "<validation>", 1, 7, 7);
./test/suites/api/test_unpack.c:345:    check_error("1 array item(s) left unpacked", "<validation>", 1, 5, 5);
./test/suites/api/test_unpack.c:398:    check_error("1 object item(s) left unpacked", "<validation>", 1, 8, 8);
./test/suites/api/util.h:33:#define check_error(text_, source_, line_, column_, position_)          \
./test/suites/api/test_load.c:43:    check_error("duplicate object key near '\"foo\"'", "<string>", 1, 16, 16);
./test/suites/api/test_load.c:55:    check_error("end of file expected near 'garbage'", "<string>", 1, 18, 18);
./doc/github_commits.c:87:        fprintf(stderr, "%s\n", curl_easy_strerror(status));

== environment() ==
./test/bin/json_process.c:247:    value = getenv(name);
./test/bin/json_process.c:299:    if(getenv("HASHSEED"))

== privileged() ==

== networking() ==
./src/dump.c:41:    if(fwrite(buffer, size, 1, dest) != 1)
./src/hashtable_seed.c:63:    /* Use unbuffered I/O if we have open(), close() and read(). Otherwise
./src/hashtable_seed.c:75:    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);
./src/hashtable_seed.c:84:    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);
./src/hashtable_seed.c:260:                SwitchToThread();
./test/bin/json_process.c:78:    ret = fread(buf, 1, fsize, file);
./test/bin/json_process.c:322:            count = fread(buffer + used, 1, size - used, stdin);

== http:// ==
./src/lookup3.h:107:used http://burtleburtle.net/bob/hash/avalanche.html to choose 

== encryption ==
./test/suites/api/test_dump.c:167:    json_object_set_new(json, "url", json_string("https://github.com/akheron/jansson"));
./test/suites/api/test_dump.c:170:    if(!result || strcmp(result, "{\"url\": \"https://github.com/akheron/jansson\"}"))
./doc/github_commits.c:16:#define URL_FORMAT   "https://api.github.com/repos/%s/%s/commits"

== sql() ==

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/load.c:374:         - a single \uXXXX escape (length 6) is converted to at most 3 bytes
./src/load.c:375:         - two \uXXXX escapes (length 12) forming an UTF-16 surrogate pair
./test/suites/api/test_equal.c:180:    /* TODO: There's no negative test case here */

== unsafe input mechanisms ==

