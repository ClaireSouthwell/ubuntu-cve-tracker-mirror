#!/usr/bin/env python
# Copyright 2011-2013, Canonical, Ltd.
# Author: Jamie Strandboge <jamie@canonical.com>
# License: GPLv3
#
# Report items for the security team to sponsor. Used for reporting based on
# https://wiki.ubuntu.com/SecurityTeam/SponsorsQueue
#
# $ report-bugs-for-eol
# $ report-bugs-for-eol --include-linux
# $ report-bugs-for-eol --bug-cache=~/tmp/bugs/bug.cache

import cPickle
import cve_lib
import optparse
import os
import re
import sys

parser = optparse.OptionParser()
parser.add_option("--debug", help="Verbose processing output", action='store_true')
parser.add_option("--team", help="Find bugs for team", metavar="TEAM", action='store', default='ubuntu-security')
parser.add_option("--bug-cache", help="Cached pickle file for bugs (warning-- private bug data stored)", metavar="FILE", action='store')
parser.add_option("--bug-status", help="Specify bug status", metavar="STATUS", action='store', default=None)
parser.add_option("--include-linux", help="Include linux kernels", action='store_true')

(opt, args) = parser.parse_args()

def debug(s):
    '''Print debug message'''
    if opt.debug:
        print >>sys.stderr, "DEBUG: %s" % (s)

def print_bugs(bugs, status=None, tags=[], include_linux=False):
    '''Output a collection of bugs'''
    keys = bugs.keys()
    keys.sort()
    is_eol_out = []
    is_eol_skipped = []
    for id in keys:
        bugid = bugs[id]['bug_id']

        bug_target_name = bugs[id]['bug_target_name']
        if not ' (' in bug_target_name:
            print >>sys.stderr, "Skipping target name=%s (LP: #%d)" % (bug_target_name, bugid)
            continue

        release = "ubuntu"
        if ':' in id:
            release = id.split(':')[1]

        pkg, target = bug_target_name.split(' (',1)
        if not pkg.startswith('linux') and release in lts_releases:
            debug("Skipping LP: #%d ('%s' should not be skipped for LTS releases '%s')" % (bugid, pkg, release))
            continue # for LTS releases, we only care about the backport kernels
                     # (all other packages should not be considered)

        tstatus = bugs[id]['bug_status']
        if status:
           if tstatus != status:
               debug("Skipping LP: #%d (%s != %s)" % (bugid, tstatus, status))
               continue

        target = target.split(')')[0]
        if ' ' in target:
            target, targeted_to = target.split(' ',1)

        if target and target.lower() != 'ubuntu':
            debug('skipping target "%s" (%s) (LP: #%d)' % (target, pkg, bugid))
            continue

        if tstatus in ['Fix Released', 'Invalid', "Won't Fix"]:
            debug('skipping (pkg:%s status:%s LP: #%d)' % (pkg, tstatus, bugid))
            continue

        if not re.match(r'^[a-z0-9][a-z0-9+\.\-]+$', pkg):
            print >>sys.stderr, "Bad package name '%s' (LP: #%d)" % (pkg, bugid)
            continue

        print "https://launchpad.net/bugs/%d %d %s %s %s" % (bugid, bugid, pkg, release, tstatus)

        if not include_linux and pkg.startswith('linux'):
            is_eol_skipped.append("%s:%s:%s (%s)" % (bugid, pkg, release, tstatus))
        elif pkg.startswith('linux'):
            if '-lts-' in pkg and pkg.split('-')[-1] in cve_lib.eol_releases:
                is_eol_out.append("%s:%s:%s" % (bugid, pkg, release))
            elif release in cve_lib.eol_releases:
                is_eol_out.append("%s:%s:%s" % (bugid, pkg, release))
            else:
                is_eol_skipped.append("%s:%s:%s (%s)" % (bugid, pkg, release, tstatus))
        else:
            is_eol_out.append("%s:%s:%s" % (bugid, pkg, release))

    return (is_eol_out, is_eol_skipped)


#
# Main
#

lts_releases = []
for r in cve_lib.releases:
    if r not in cve_lib.eol_releases and 'LTS' in cve_lib.release_names[r]:
        lts_releases.append(r)

bugs = None
bug_database_fn = ""
if opt.bug_cache:
    bug_database_fn = os.path.expanduser(opt.bug_cache)
    if not os.path.isfile(bug_database_fn):
        print >>sys.stderr, "'%s' does not exist. Skipping load" % bug_database_fn
    else:
        # Load pickle database
        print >>sys.stderr, "Loading bugs from cache..."
        bugs = cPickle.load(open(bug_database_fn))
        print >>sys.stderr, "done"


# Connect to LP only if cached db not available
if bugs == None:
    if opt.bug_cache and os.path.exists(bug_database_fn):
        print >>sys.stderr, "'%s' exists, aborting" % opt.bug_cache
        sys.exit(1)

    #
    # Connect to Launchpad
    #
    try:
        import lpl_common
    except:
        print >>sys.stderr, "lpl_common.py seems to be missing.  Please create a symlink from $UQT/common/lpl_common.py to $UCT/scripts/"
        sys.exit(1)

    # Load configuration
    cve_lib.read_config()

    # API interface
    print >>sys.stderr, "Connecting to LP ...",
    lp = lpl_common.connect()

    # Get authenticated URL fetcher
    opener = lpl_common.opener_with_cookie(cve_lib.config["plb_authentication"])
    if not opener:
        raise ValueError, "Could not open cookies"

    ubuntu = lp.distributions['ubuntu']
    debug("Distribution: %s" % ubuntu)
    team = lp.people[opt.team]
    debug("Team: %s" % team)
    print >>sys.stderr, "done"

    # get bugs for a specific series, then for 'Ubuntu' if we haven't already added
    # the bug
    print >>sys.stderr, "Loading bugs for eol releases (%s) and LTS releases (kernel backports for %s)..." % (", ".join(cve_lib.eol_releases), ", ".join(lts_releases)),

    bugs = {}
    for rel in cve_lib.eol_releases + lts_releases:
        series = ubuntu.getSeries(name_or_version=rel)
        if series.active and rel not in lts_releases: # skip current non-LTS releases
            debug('Skipping release "%s" (active, non-LTS)' % rel)
            continue
        obj = series

        task_collection = obj.searchTasks(bug_subscriber=team, omit_targeted=False)

        for task in task_collection:
            bugid = task.bug.id
            if rel != 'ubuntu' or not bugs.has_key(bugid):
                data = {}
                data['bug_id'] = bugid
                data['bug_status'] = task.status
                data['bug_target_name'] = task.bug_target_name
                bugs["%d:%s" % (bugid, rel)] = data
    print >>sys.stderr, "done"


    if opt.bug_cache and not os.path.exists(bug_database_fn):
        print >>sys.stderr, "Saving cache to '%s'. To update cache, remove this file" % (opt.bug_cache)
        cPickle.dump(bugs, open(bug_database_fn, 'w'), -1)

#print bugs

(out, skipped) = print_bugs(bugs, status=opt.bug_status, include_linux=opt.include_linux)
print '''
You can retire these automatically with:
$UQT/responses/security/is-eol %s

The following were skipped:
 %s
''' % (" ".join(out), "\n ".join(skipped))

sys.exit(0)

