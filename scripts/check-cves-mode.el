;;; check-cves-mode.el --- major mode for working with the output of check-cves         -*- lexical-binding: t; -*-

;; Copyright (c) 2018 Alex Murray

;; Author: Alex Murray <alex.murray@canonical.com>
;; Maintainer: Alex Murray <alex.murray@canonical.com>
;; URL: https://launchpad.net/ubuntu-cve-tracker
;; Version: 0.1
;; Package-Requires: ((emacs "24.4"))

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;;; Setup

;; (require 'check-cves-mode)

;;; Code:

(defvar check-cves-mode-keywords '("add" "edit" "ignore" "skip"))

(defvar check-cves-mode-priorities '("negligible" "low" "medium" "high" "critical"))

(defvar check-cves-mode-cve-id-regexp "^\\(CVE-[[:digit:]]\\{4\\}-[[:digit:]]\\{4,\\}\\)")

(defvar check-cves-mode-font-lock-defaults
  `(((,(regexp-opt check-cves-mode-keywords 'words) . font-lock-keyword-face)
     (,(regexp-opt check-cves-mode-priorities 'words) . font-lock-type-face)
     ;; CVE Ids
     (,check-cves-mode-cve-id-regexp 1 font-lock-variable-name-face t))))

(defvar check-cves-mode-syntax-table
  (let ((table (make-syntax-table)))
    ;; # is comment start
    (modify-syntax-entry ?# "<" table)
    ;; newline finishes comment line
    (modify-syntax-entry ?\n ">" table)
    table))

;;;###autoload
(defun check-cves-mode-next (arg)
  "Jump to the next CVE.
The prefix argument ARG specifies how many CVEs to move.
A negative argument means move backward that many keywords."
  (interactive "p")
  (if (< arg 0)
      (check-cves-mode-previous (- arg))
    (while (and (> arg 0)
                (not (eobp))
                (let ((case-fold-search nil))
                  (when (looking-at check-cves-mode-cve-id-regexp)
                    (goto-char (match-end 0)))
                  (or (re-search-forward check-cves-mode-cve-id-regexp nil t)
                      (user-error "No more matches"))))
      (goto-char (match-beginning 0))
      (cl-decf arg))))

;;;###autoload
(defun check-cves-mode-previous (arg)
  "Jump to the previous CVE.
The prefix argument ARG specifies how many keywords to move.
A negative argument means move forward that many keywords."
  (interactive "p")
  (if (< arg 0)
      (check-cves-mode-next (- arg))
    (while (and (> arg 0)
                (not (bobp))
                (let ((case-fold-search nil)
                      (start (point)))
                  (re-search-backward (concat check-cves-mode-cve-id-regexp "\\=") nil t)
                  (or (re-search-backward check-cves-mode-cve-id-regexp nil t)
                      (progn (goto-char start)
                             (user-error "No more matches")))))
      (goto-char (match-beginning 0))
      (cl-decf arg))))

;;;###autoload
(defun check-cves-mode-modify (action)
  "Modify the current CVE with ACTION."
  (save-excursion
    (beginning-of-line)
    (re-search-forward (concat check-cves-mode-cve-id-regexp "\\(.*\\)$") nil t)
    (replace-match (concat " " action) t nil nil 2)))

(defvar check-cves-mode-packages
  (split-string
   (shell-command-to-string "apt-cache pkgnames")))

(defvar check-cves-mode-source-packages
  (split-string
   (shell-command-to-string "grep Source: /var/lib/apt/lists/*Packages | awk '{print $2}' | sort | uniq")))

(defun check-cves-mode-prompt-for-packages (&optional binary)
  "Prompt user for a list of source or optionally BINARY packages."
  (let ((chosen nil)
        (pkg))
    (while (progn
             (setq pkg (completing-read "Package: "
                                        (if binary
                                            check-cves-mode-packages
                                          check-cves-mode-source-packages)))
             (not (string= pkg "")))
      (push pkg chosen))
    chosen))

(defun check-cves-mode-add-or-edit (add-or-edit &optional priority packages)
  "ADD-OR-EDIT the current CVE with PRIORITY against PACKAGES."
  (unless priority
    (setq priority (completing-read "Priority: " check-cves-mode-priorities)))
  (unless packages
    (setq packages (check-cves-mode-prompt-for-packages)))
  (check-cves-mode-modify (concat add-or-edit " " priority " "
                                  (mapconcat #'identity packages " "))))

;;;###autoload
(defun check-cves-mode-add ()
  "Add the current CVE."
  (interactive)
  (check-cves-mode-add-or-edit "add"))

;;;###autoload
(defun check-cves-mode-edit ()
  "Edit the current CVE."
  (interactive)
  (check-cves-mode-add-or-edit "edit"))

(defvar check-cves-mode-ignore-history
  nil
  "History for ignore reasons.")

;;;###autoload
(defun check-cves-mode-ignore (reason)
  "Ignore the current CVE with REASON."
  (interactive
   ;; find potential completion lines
   (save-excursion
     ;; find the CVE ID
     (beginning-of-line)
     (re-search-forward (concat check-cves-mode-cve-id-regexp "\\(.*\\)$") nil t)
     (let ((cve (substring-no-properties (match-string 1)))
           (reasons nil))
       (while (re-search-backward (concat "^# " cve " ignore \"\\(.*\\)\"$") nil t)
         (push (match-string 1) reasons))
       (list (completing-read "Reason: " reasons nil nil (first reasons) 'check-cves-mode-ignore-history)))))
  (check-cves-mode-modify (concat "ignore " reason))
  (add-to-list 'check-cves-mode-ignore-history reason))

;;;###autoload
(defun check-cves-mode-skip ()
  "Skip the current CVE."
  (interactive)
  (check-cves-mode-modify "skip"))

;;;###autoload
(defun check-cves-mode-occur ()
  "Use `occur' to find all CVEs."
  (interactive)
  (occur check-cves-mode-cve-id-regexp))

(defun check-cves-mode-completion-at-point ()
  "`completion-at-point' function for check-cves-mode."
  ;; see what we should complete
  (let ((candidates))
    (save-excursion
      (beginning-of-line)
      (setq candidates
            (cond ((looking-at (concat check-cves-mode-cve-id-regexp " "
                                       (regexp-opt (list ("add" "edit"))) " "
                                       (regexp-opt check-cves-mode-priorities)))
                   (setq candidates check-cves-mode-source-packages))
                  ((looking-at (concat check-cves-mode-cve-id-regexp " "
                                       (regexp-opt (list ("add" "edit")))))
                   (setq candidates check-cves-mode-priorities))
                  ((looking-at check-cves-mode-cve-id-regexp)
                   (setq candidates check-cves-mode-keywords))
                  (t nil))))
    (let ((bounds (bounds-of-thing-at-point 'symbol)))
      (list (car bounds) ; start
            (cdr bounds) ; end
            candidates
            :company-docsig #'identity))))

(defvar check-cves-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "M-n") #'check-cves-mode-next)
    (define-key map (kbd "M-p") #'check-cves-mode-previous)
    (define-key map (kbd "M-a") #'check-cves-mode-add)
    (define-key map (kbd "M-e") #'check-cves-mode-edit)
    (define-key map (kbd "M-i") #'check-cves-mode-ignore)
    (define-key map (kbd "M-s") #'check-cves-mode-skip)
    map)
  "Keymap for `check-cves-mode'.")

(define-derived-mode check-cves-mode text-mode "CVE"
  "check-cves-mode is a major mode for editing CVE files."
  :syntax-table check-cves-mode-syntax-table
  (setq font-lock-defaults check-cves-mode-font-lock-defaults)
  (add-to-list 'completion-at-point-functions #'check-cves-mode-completion-at-point)
  (setq comment-start "#")
  (setq comment-end ""))

;;;###autoload
(add-to-list 'auto-mode-alist '("check-cves\\..*\\'" . check-cves-mode))

(provide 'check-cves-mode)
;;; check-cves-mode.el ends here
