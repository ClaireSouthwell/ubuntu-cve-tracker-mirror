#!/usr/bin/python
import glob, sys, optparse

EXIT_FAIL = 1
EXIT_OKAY = 0

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose", dest="verbose", help="Enable verbose reporting", action='store_true')
(options, args) = parser.parse_args()

code = EXIT_OKAY

if len(args) == 0:
    for dir in ['active','retired','ignored']:
        args += sorted(glob.glob('%s/CVE-*' % (dir)))

for cve in args:
    if options.verbose:
        print cve
    affected = dict()
    upstream = None
    for line in file(cve).readlines():
        line = line.rstrip()

        # Ignore section continuations or blank/commented lines
        if len(line) == 0 or line.startswith(' ') or line.startswith('#'):
            continue

        try:
            field, value = line.split(':',1)
        except ValueError, e:
            print >>sys.stderr, "%s: bad line '%s' (%s)" % (cve, line, e)
            code = EXIT_FAIL
            continue

        field = field.strip()
        value = value.strip()
        if field == 'Candidate':
            if value != "" and not value.startswith('CVE-'):
                print >>sys.stderr, "%s: unknown Candidate '%s'" % (cve, value)
                code = EXIT_FAIL
        elif field == 'Priority':
            if not value in ['untriaged','very-low','low','medium','high','critical']:
                print >>sys.stderr, "%s: unknown Priority '%s'" % (cve, value)
                code = EXIT_FAIL
        elif '_' in field:
            try:
                release, pkg = field.split('_',1)
            except ValueError:
                print >>sys.stderr, "%s: bad field with '_': '%s'" % (cve, field)
                code = EXIT_FAIL
                continue
            try:
                info = value.split(' ',1)
            except ValueError:
                print >>sys.stderr, "%s: missing state for '%s': '%s'" % (cve, field, value)
                code = EXIT_FAIL
                continue
            state = info[0]
            if len(info) < 2:
                notes = ""
            else:
                notes = info[1].strip()
            if notes.startswith('('):
                notes = notes[1:]
            if notes.endswith(')'):
                notes = notes[:-1]
            affected.setdefault(pkg,dict())
            affected[pkg].setdefault(release,[state,notes])
        elif field == 'upstream':
            if value != "":
                upstream = value
        elif not field in ['References','Description','Ubuntu-Description','Notes','Bugs','Assigned-to']:
            print >>sys.stderr, "%s: unknown field '%s'" % (cve, field)
            code = EXIT_FAIL

    # verify/fix missing upstreams listed for each pkg
    pkgs = sorted(affected.keys())
    if len(pkgs) > 1 and upstream != None:
            print >>sys.stderr, "%s: single upstream defined when multiple pkgs listed (%s)" % (cve, " ".join(pkgs))
            code = EXIT_FAIL
    if not (len(pkgs) == 1 and upstream != None):
        append = ''
        for pkg in pkgs:
            if not 'upstream' in affected[pkg].keys():
                append += 'upstream_%s: \n' % (pkg)
        if append != '':
            print >>sys.stderr, "%s: adding missing 'upstream' for: %s" % (cve, ", ".join(pkgs))
            file(cve,'a').write(append)
        

sys.exit(code)
