#!/usr/bin/python
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# Reports CVEs that are not reported in USNs correctly
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Fetch the USN database first. Override location with --database
#  wget http://people.canonical.com/~ubuntu-security/usn/database.pickle
#
import cPickle, sys, os, os.path, optparse, usn_lib, cve_lib, glob
from source_map import version_compare

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose", dest="verbose", help="Report specific CVEs", action='store_true')
parser.add_option("-D", "--database", help="Specify location of USN data (default 'database.pickle')", default="database.pickle")
parser.add_option("-R", "--reverted", help="Specify location of reverted CVE list (default 'reverted-CVEs.txt')", default="reverted-CVEs.txt")
parser.add_option("-p", "--packages", help="Comma separated list of packages to examine (default is all kernel source packages)", default=None)
parser.add_option("-d", "--debug", dest="debug", help="Report additional debugging while processing USNs", action='store_true')
(opt, args) = parser.parse_args()

if opt.packages == None:
    opt.packages = cve_lib.kernel_srcs
else:
    opt.packages = set(opt.packages.split(','))

reverted = usn_lib.get_reverted(opt.reverted)
db       = usn_lib.load_database(opt.database)

# Find all CVE paths
cvelist = []
cves = dict()
check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
for dir in check_dirs:
    for cvefile in sorted(glob.glob('%s/CVE-*' % (dir))):
        cvelist += [cvefile]

# Load and keep only kernel CVEs
for cvefile in cvelist:
    cve = cvefile.split('/').pop()
    info = cve_lib.load_cve(cvefile)
    keep = False
    for pkg in opt.packages:
        if pkg in info['pkgs']:
            keep = True
            break
    if keep:
        cves[cve] = info

# Create a list of pkg versions
pkgs = dict()
for usn in sorted(db, cmp=version_compare):
    # This USN is ancient and lacks any CVE information
    if not db[usn].has_key('cves'):
        if (opt.debug):
            print "%s lacks CVEs" % (usn)
        continue

    for rel in db[usn]['releases']:
        # Ignore old USNs
        if not db[usn]['releases'][rel].has_key('sources'):
            continue

        # Look at fixed packages
        for pkg in opt.packages:
            if not db[usn]['releases'][rel]['sources'].has_key(pkg):
                continue

            pkgs.setdefault(pkg, dict())
            version = db[usn]['releases'][rel]['sources'][pkg]['version']
            if pkgs[pkg].has_key(version):
                raise IndexError, "Saw %s %s twice!" % (pkg, version)
            pkgs[pkg][version] = usn


# Looks at all USNs and see if CVEs are mis-marked
for usn in sorted(db, cmp=version_compare):
    # This USN is ancient and lacks any CVE information
    if not db[usn].has_key('cves'):
        if (opt.debug):
            print "%s lacks CVEs" % (usn)
        continue

    # cves[cve]
    # 'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
    # db[usn]
    # 'releases', rel, 'sources', pkg, 'version'
    for rel in db[usn]['releases']:
        # Ignore old USNs
        if not db[usn]['releases'][rel].has_key('sources'):
            continue
        # Look at fixed packages
        for pkg in opt.packages:
            if not db[usn]['releases'][rel]['sources'].has_key(pkg):
                continue

            # Find versions fixed
            for cve in db[usn]['cves']:
                if not cve.startswith('CVE-'):
                    continue
                if not cve in cves:
                    # Must depend on CVEs being accurate, so if it's missing, it's missing
                    #print "USN %s: mentions unloaded %s" % (usn, cve)
                    continue

                # If not mentioned in the CVE, it wasn't vulnerable
                if not cves[cve]['pkgs'].has_key(pkg):
                    continue

                # If release not mentioned in the CVE,it wasn't vulnerable
                if not cves[cve]['pkgs'][pkg].has_key(rel):
                    continue

                if cves[cve]['pkgs'][pkg][rel][0] == 'pending':
                    print "USN %s: %s in %s is still pending for %s (fixed in %s)" % (usn, pkg, rel, cve, db[usn]['releases'][rel]['sources'][pkg]['version'])
                    continue

                if cves[cve]['pkgs'][pkg][rel][0] == 'released':
                    fixed = cves[cve]['pkgs'][pkg][rel][1]
                    if fixed == db[usn]['releases'][rel]['sources'][pkg]['version']:
                        continue

                    # If "fixed" is in a published USN, we have a definitive mismatch.
                    # Hardcoded exceptions...
                    if fixed in pkgs[pkg]:
                        if cve == 'CVE-2008-3831' and pkg == 'linux' and usn == '679-1':
                            continue
                        print "USN %s: in %s source %s version mismatch (USN is %s, %s shows %s, expected in USN %s)" % (usn, rel, pkg, db[usn]['releases'][rel]['sources'][pkg]['version'], cve, cves[cve]['pkgs'][pkg][rel][1], pkgs[pkg][fixed])
                        continue

                    # If "fixed" is between USN versions, find the first USN fix is >fixed
                    for ver in (sorted(pkgs[pkg], cmp=version_compare)):
                        if version_compare(ver, fixed) > 0:
                            if pkgs[pkg][ver] != usn:
                                print "USN %s: in %s source %s version mismatched offset (USN is %s, %s shows %s, expected in USN %s)" % (usn, rel, pkg, db[usn]['releases'][rel]['sources'][pkg]['version'], cve, cves[cve]['pkgs'][pkg][rel][1], pkgs[pkg][ver])
                            break

