#!/usr/bin/python
# -*- coding: utf-8 -*-
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2011 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import glob, sys, os, re, cache_urllib, datetime, time
import codecs

# common to all scripts
releases      = ['dapper','edgy','feisty','gutsy','hardy','intrepid','jaunty','karmic','lucid','maverick','natty','oneiric','precise']
eol_releases  = ['dapper','edgy','feisty','gutsy','intrepid','jaunty','karmic']
devel_release = 'precise'
# you can generate a reasonably accurate release stamp via
# $ echo "(($(date -r  /path/to/ubuntu/archive/dists/$release/Release.gpg +%s) / 3600 ) + 1) * 3600" | /usr/bin/bc
release_stamps = {
    'warty':    1098748800,
    'hoary':    1112918400,
    'breezy':   1129075200,
    'dapper':   1149120000,
    'edgy':     1161864000,
    'feisty':   1176984000,
    'gutsy':    1192708800,
    'hardy':    1209038400,
    'intrepid': 1225368000,
    'jaunty':   1240488000,
    'karmic':   1256817600,
    'lucid':    1272565800,
    'maverick': 1286706600,
    'natty':    1303822800,
    'oneiric':  1318446000,
}
release_names = {
    'warty': 'Ubuntu 4.10 (Warty Warthog)',
    'hoary': 'Ubuntu 5.04 (Hoary Hedgehog)',
    'breezy': 'Ubuntu 5.10 (Breezy Badger)',
    'dapper': 'Ubuntu 6.06 LTS (Dapper Drake)',
    'edgy': 'Ubuntu 6.10 (Edgy Eft)',
    'feisty': 'Ubuntu 7.04 (Feisty Fawn)',
    'gutsy': 'Ubuntu 7.10 (Gutsy Gibbon)',
    'hardy': 'Ubuntu 8.04 LTS (Hardy Heron)',
    'intrepid': 'Ubuntu 8.10 (Intrepid Ibex)',
    'jaunty': 'Ubuntu 9.04 (Jaunty Jackalope)',
    'karmic': 'Ubuntu 9.10 (Karmic Koala)',
    'lucid': 'Ubuntu 10.04 LTS (Lucid Lynx)',
    'maverick': 'Ubuntu 10.10 (Maverick Meerkat)',
    'natty': 'Ubuntu 11.04 (Natty Narwhal)',
    'oneiric': 'Ubuntu 11.10 (Oneiric Ocelot)',
    'precise': 'Ubuntu 12.04 LTS (Precise Pangolin)',
}
valid_tags = ['universe-binary', 'apparmor', 'stack-protector', 'fortify-source', 'symlink-restriction', 'hardlink-restriction', 'heap-protector', 'pie']
# eol and unsupported kernel_srcs
#                   'linux-source-2.6.15',
#                   'linux-ti-omap',
#                   'linux-linaro',
#                   'linux-qcm-msm',
kernel_srcs = set(['linux',
                   'linux-ec2',
                   'linux-fsl-imx51',
                   'linux-mvl-dove',
                   'linux-ti-omap4',
                   'linux-lts-backport-maverick',
                   'linux-lts-backport-natty',
                   'linux-lts-backport-oneiric'])
kernel_topic_branches = kernel_srcs.difference(['linux'])

# for sanity, try to keep these in alphabetical order
description_overrides = {
    'acpid': 'Advanced Configuration and Power Interface daemon',
    'apache2': 'Apache HTTP server',
    'clamav': 'Anti-virus utility for Unix',
    'colord': 'Service to manage device colour profiles',
    'curl': 'HTTP, HTTPS, and FTP client and client libraries',
    'dovecot': 'IMAP and POP3 email server',
    'dhcp3': 'DHCP server and client',
    'eucalyptus': 'Elastic Utility Computing Architecture',
    'firefox': 'Mozilla Open Source web browser',
    'freetype': 'FreeType 2 is a font engine library',
    'icedtea-web': 'A web browser plugin to execute Java applets',
    'isc-dhcp': 'DHCP server and client',
    'jasper': 'Library for manipulating JPEG-2000 files',
    'kde4libs': 'KDE 4 core applications and libraries',
    'kdeutils': 'KDE general-purpose utilities',
    'krb5': 'MIT Kerberos Network Authentication Protocol',
    'libarchive': 'Library to read/write archive files',
    'libmodplug': 'Library for mod music based on ModPlug',
    'libpng': 'PNG (Portable Network Graphics) file library',
    'libsoup2.4': 'HTTP client/server library for GNOME',
    'libvirt': 'Libvirt virtualization toolkit',
    'libxfont': 'X11 font rasterisation library',
    'linux': 'Linux kernel',
    'linux-ec2': 'Linux kernel for EC2',
    'linux-fsl-imx51': 'Linux kernel for IMX51',
    'linux-linaro': 'Linux kernel for ARM',
    'linux-lts-backport-maverick': 'Linux kernel backport from Maverick',
    'linux-lts-backport-natty': 'Linux kernel backport from Natty',
    'linux-lts-backport-oneiric': 'Linux kernel backport from Oneiric',
    'linux-mvl-dove': 'Linux kernel for DOVE',
    'linux-qcm-msm': 'Linux kernel for MSM',
    'linux-source-2.6.15': 'Linux kernel',
    'linux-ti-omap': 'Linux kernel for OMAP',
    'linux-ti-omap4': 'Linux kernel for OMAP4',
    'nbd': 'Network Block Device protocol',
    'open-iscsi': 'Open Source iSCSI implementation',
    'openjdk-6': 'Open Source Java implementation',
    'openjdk-6b18': 'Open Source Java implementation',
    'network-manager': 'Network connection manager',
    'nova': 'OpenStack Compute cloud infrastructure',
    'pam': 'Pluggable Authentication Modules',
    'php5': 'HTML-embedded scripting language interpreter',
    'postgresql-8.3': 'Object-relational SQL database',
    'postgresql-8.4': 'Object-relational SQL database',
    'puppet': 'Centralized configuration management',
    'qemu-kvm': 'Machine emulator and virtualizer',
    'rampart': 'Apache web services security engine',
    'samba': 'SMB/CIFS file, print, and login server for Unix',
    'thunderbird': 'Mozilla Open Source mail and newsgroup client',
    'vsftpd': 'FTP server written for security',
    'xorg-server': 'X.Org X server',
    'xulrunner-1.9.2': 'Mozilla Gecko runtime environment',
}

# "arch_list" is all the physical architectures buildable
# "official_architectures" includes everything that should be reported on
official_architectures = ['amd64', 'armel', 'armhf', 'i386', 'lpia', 'powerpc', 'sparc']
arch_list = official_architectures + [ 'hppa', 'ia64' ]
official_architectures = [ 'source', 'all' ] + official_architectures

# The build expectations per release, per arch
release_expectations = {
        'dapper': {
                'required': [ 'amd64', 'i386', 'sparc', 'powerpc' ],
                'expected': [ 'ia64', 'hppa' ],
                'bonus': [ ],
                },
        'edgy': {
                'required': [ 'amd64', 'i386', 'sparc', 'powerpc' ],
                'expected': [ ],
                'bonus': [ 'ia64', 'hppa' ],
                },
        'feisty': {
                'required': [ 'amd64', 'i386', 'sparc' ],
                'expected': [ 'powerpc' ],
                'bonus': [ 'hppa' ],
                },
        'gutsy': {
                'required': [ 'amd64', 'i386', 'sparc' ],
                'expected': [ 'powerpc', 'hppa', 'lpia' ],
                'bonus': [ ],
                },
        'hardy': {
                'required': [ 'amd64', 'i386', 'lpia' ],
                'expected': [ 'powerpc', 'hppa', 'sparc' ],
                'bonus': [ 'ia64' ],
                },
        'intrepid': {
                'required': [ 'amd64', 'i386', 'lpia' ],
                'expected': [ 'powerpc', 'hppa', 'sparc' ],
                'bonus': [ 'ia64' ],
                },
        'jaunty': {
                'required': [ 'amd64', 'i386' ],
                'expected': [ 'lpia', 'powerpc', 'hppa', 'sparc', 'armel' ],
                'bonus': [ 'ia64' ],
                },
        'karmic': {
                'required': [ 'amd64', 'i386', 'armel' ],
                'expected': [ 'lpia', 'powerpc', 'sparc' ],
                'bonus': [ 'ia64' ],
                },
        'lucid': {
                'required': [ 'amd64', 'i386', 'armel' ],
                'expected': [ 'powerpc', 'sparc' ],
                'bonus': [ 'ia64' ],
                },
        'maverick': {
                'required': [ 'amd64', 'i386', 'armel' ],
                'expected': [ 'powerpc' ],
                'bonus': [ ],
                },
        'natty': {
                'required': [ 'amd64', 'i386', 'armel' ],
                'expected': [ 'powerpc' ],
                'bonus': [ ],
                },
        'oneiric': {
                'required': [ 'amd64', 'i386', 'armel' ],
                'expected': [ 'powerpc' ],
                'bonus': [ ],
                },
        #'precise': {
        #        'required': [ 'amd64', 'i386', 'armel', 'armhf' ],
        #        'expected': [ 'powerpc' ],
        #        'bonus': [ ],
        #        },
}

# components in the archive
components = ['main','restricted','universe','multiverse']

# non-overlapping release package name changes, first-match wins
pkg_aliases = {
    'linux': [ 'linux-source-2.6.15' ],
    'xen': [ 'xen-3.3', 'xen-3.2', 'xen-3.1' ],
    'eglibc': [ 'glibc' ],
    'qemu-kvm': [ 'kvm' ],
}

# alternate names for packages in graphs
pkg_alternates = {
    'linux-source-2.6.15': 'linux',
    'linux-source-2.6.17': 'linux',
    'linux-source-2.6.20': 'linux',
    'linux-source-2.6.22': 'linux',
    'linux-restricted-modules-2.6.15': 'linux',
    'linux-backports-modules-2.6.15': 'linux',
    'linux-restricted-modules-2.6.17': 'linux',
    'linux-restricted-modules-2.6.20': 'linux',
    'linux-backports-modules-2.6.20': 'linux',
    'linux-restricted-modules-2.6.22': 'linux',
    'linux-backports-modules-2.6.22': 'linux',
    'linux-ubuntu-modules-2.6.22': 'linux',
    'linux-restricted-modules-2.6.24': 'linux',
    'linux-backports-modules-2.6.24': 'linux',
    'linux-ubuntu-modules-2.6.24': 'linux',
    'linux-restricted-modules': 'linux',
    'linux-backports-modules-2.6.27': 'linux',
    'linux-backports-modules-2.6.28': 'linux',
    'linux-backports-modules-2.6.31': 'linux',
    'xen-3.1': 'xen',
    'xen-3.2': 'xen',
    'xen-3.3': 'xen',
    'firefox-3.0': 'firefox',
    'firefox-3.5': 'firefox',
    'xulrunner-1.9': 'firefox',
    'xulrunner-1.9.1': 'firefox',
    'xulrunner-1.9.2': 'firefox',
    'ruby1.8': 'ruby',
    'ruby1.9': 'ruby',
    'python2.4': 'python',
    'python2.5': 'python',
    'python2.6': 'python',
    'openoffice.org-amd64': 'openoffice.org',
    'gnutls12': 'gnutls',
    'gnutls13': 'gnutls',
    'gnutls26': 'gnutls',
    'postgresql-8.1': 'postgresql',
    'postgresql-8.2': 'postgresql',
    'postgresql-8.3': 'postgresql',
    'compiz-fusion-plugins-main': 'compiz',
    'mysql-dfsg-5.0': 'mysql',
    'mysql-dfsg-5.1': 'mysql',
    'mysql-5.1': 'mysql',
    'gst-plugins-base0.10': 'gstreamer',
    'gst-plugins-good0.10': 'gstreamer',
    'mozilla-thunderbird': 'thunderbird',
    'openjdk-6b18': 'openjdk-6',
}


# update whenever an LTS moves from fully supported to partially
# supported
lts_partial_supported_releases = ['hardy']

# The CVE states considered "closed"
status_closed = set(['released', 'not-affected', 'ignored', 'DNE'])
# Possible CVE priorities
priorities = [ 'negligible', 'low', 'medium', 'high', 'critical' ]

active_dir = "active"
retired_dir = "retired"
ignored_dir = "ignored"
embargoed_dir = "embargoed"
cve_dirs = [active_dir, retired_dir, ignored_dir]
if os.path.islink(embargoed_dir):
    cve_dirs.append(embargoed_dir)
supported_pkgs = dict()

EXIT_FAIL = 1
EXIT_OKAY = 0

config = {}

def parse_CVEs_from_uri(url):
    """Return a list of all CVE numbers mentioned in the given URL."""

    list = []
    cvere = re.compile("((?:CAN|can|CVE|cve)-\d\d\d\d-(\d|N)(\d|N)(\d|N)\d)")
    try:
        text = cache_urllib.urlopen(url).read().splitlines()
        for line in text:
            comment = line.find('#')
            if comment != -1:
                line = line[:comment]
            for cve in cvere.finditer(line):
                list.append(cve.group().upper().replace('CAN', 'CVE', 1))
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

def read_config():
    '''Read in and do basic validation on config file'''
    try:
        from configobj import ConfigObj
    except:
        # Dapper lacks this class, so reimplement it quickly
        class ConfigObj(dict):
            def __init__(self, filepath):
                for line in open(filepath).readlines():
                    line = line.strip()
                    if line.startswith('#') or len(line)==0:
                        continue
                    name, stuff = line.strip().split('=',1)
                    self[name] = eval(stuff)
            def __attr__(self, name):
                return self.stuff[name]
    config_file = os.path.join(os.path.expanduser("~"), ".ubuntu-cve-tracker.conf")

    if not os.path.exists(config_file):
        raise ValueError, "Could not find '%s'" % (config_file)

    # FIXME: Why does this need to be defined as "global" when other globals
    # like "releases" and "EXIT_OKAY" don't need it??
    global config
    config = ConfigObj(config_file)

    # Validate required arguments
    if not config.has_key("plb_authentication"):
        raise ValueError, "Could not find 'plb_authentication' entry in %s." % (config_file)
    if not os.path.exists(config["plb_authentication"]):
        raise ValueError, "Could not find file specified by 'plb_authentication' in %s." % (config_file)
    return config

def drop_dup_release(cve,rel):
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    saw = set()
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if line.startswith('%s_' % (rel)):
            pkg = line.split('_')[1].split(':')[0]
            if not pkg in saw:
                output.write(line)
                saw.add(pkg)
        else:
            output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def clone_release(cve,pkg,oldrel,newrel):
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if line.startswith('%s_%s:' % (oldrel,pkg)):
            newline = line.replace('%s_%s:'%(oldrel,pkg),'%s_%s:'%(newrel,pkg),1)
            output.write(newline)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def update_state(cve,pkg,rel,state,notes):
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if line.startswith('%s_%s:' % (rel, pkg)):
            line = '%s_%s: %s (%s)\n' % (rel, pkg, state, notes)
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

def prepend_field(cve, field, value):
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    output.write('%s: %s\n' % (field, value))
    output.write(codecs.open(cve, encoding="utf-8").read())
    output.close()
    os.rename(cve+'.new',cve)

def update_field(cve,field,value=None):
    found = False
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if line.startswith('%s:' % (field)):
            found = True
            if value == None:
                continue
            else:
                output.write('%s: %s\n' % (field, value))
        else:
            output.write(line)
    output.close()
    os.rename(cve+'.new',cve)
    # Do we actually need to add it instead?
    if not found and value:
        prepend_field(cve, field, value)

def drop_field(cve,field):
    update_field(cve, field)

def add_reference(cve,url):
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    in_references = False
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if in_references and not line.startswith(' '):
            output.write(' ' + url + '\n')
            in_references = False
        elif in_references and url in line:
            # skip if already there
            print >>sys.stderr, "Skipped adding reference for '%s' (already present)" % (cve)
            output.close()
            os.unlink(cve+'.new')
            return False
        elif not in_references and line.startswith('References:'):
            in_references = True
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

    return True

def add_patch(cve,pkg,url,type="patch"):
    patch_header = "Patches_%s:" % (pkg)
    in_patch = False

    output = codecs.open(cve+".new",'w', encoding="utf-8")
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if in_patch and not line.startswith(' '):
            output.write(' ' + type + ': ' + url + '\n')
            in_patch = False
        elif in_patch and url in line:
            # skip if already there
            print >>sys.stderr, "Skipped adding debdiff for '%s' (already present)" % (cve)
            output.close()
            os.unlink(cve+'.new')
            return False
        elif not in_patch and line.startswith(patch_header):
            in_patch = True
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)

    return True

def update_multiline_field(cve, field, text):
    update = ""
    text = text.rstrip()
    # this is a multi-line entry -- it must start with a newline
    if not text.startswith('\n'):
        text = '\n' + text
    output = codecs.open(cve+".new",'w', encoding="utf-8")
    skip = 0
    for line in codecs.open(cve, encoding="utf-8").readlines():
        if skip and line.startswith(' '):
            continue
        skip = 0
        if line.startswith('%s:' % (field)):
            prefix = '%s:' % (field)
            for textline in text.split('\n'):
                wanted = '%s%s\n' % (prefix,textline)
                output.write(wanted)
                prefix = ' '
                update += wanted
            skip = 1
            continue
        output.write(line)
    output.close()
    os.rename(cve+'.new',cve)
    return update

# This returns the list of open CVEs and embargoed CVEs (which are included
# in the first list).
def get_cve_list():
    cves = [elem for elem in os.listdir(active_dir) \
           if re.match('^CVE-\d+-(\d|N)+$',elem)]

    uems = []
    if os.path.islink(embargoed_dir):
        uems = [elem for elem in os.listdir(embargoed_dir) \
               if re.match('^[\w-]*$',elem)]
        for cve in uems:
            if cve in cves:
                print >>sys.stderr, "Duplicated CVE (in embargoed): %s" % (cve)
        cves = cves + uems

    return (cves, uems)

def contextual_priority(cveinfo, pkg=None, rel=None):
    '''Return the priority based on release, then package, then global'''
    if pkg:
        pkg_p = 'Priority_%s' % (pkg)
        if rel:
            rel_p = '%s_%s' % (pkg_p, rel)
            if cveinfo.has_key(rel_p):
                return 2, cveinfo[rel_p]
        if cveinfo.has_key(pkg_p):
            return 1, cveinfo[pkg_p]
    return 0, cveinfo.get('Priority','untriaged')

def find_cve(cve):
    '''Return filepath for a given CVE'''
    for dir in cve_dirs:
        filename = os.path.join(dir, cve)
        if os.path.exists(filename):
            return filename
    raise ValueError, "Cannot locate path for '%s'" % (cve)

def load_cve(cve, strict=False):
    '''Loads a given CVE into:
       dict( fields...
             'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
           )
    '''

    msg = ''
    code = EXIT_OKAY

    data = dict()
    data.setdefault('tags',dict())
    affected = dict()
    lastfield = None
    fields_seen = []
    if not os.path.exists(cve):
        raise ValueError, "File does not exist: '%s'" % (cve)
    for line in codecs.open(cve, encoding="utf-8").readlines():
        line = line.rstrip()

        # Ignore blank/commented lines
        if len(line) == 0 or line.startswith('#'):
            continue
        if line.startswith(' '):
            try:
                data[lastfield] += '\n%s' % (line[1:])
            except KeyError, e:
                msg += "%s: bad line '%s' (%s)\n" % (cve, line, e)
                code = EXIT_FAIL
            continue

        try:
            field, value = line.split(':',1)
        except ValueError, e:
            msg += "%s: bad line '%s' (%s)\n" % (cve, line, e)
            code = EXIT_FAIL
            continue

        lastfield = field = field.strip()
        if field in fields_seen:
            msg += "%s: repeated field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            fields_seen.append(field)
        value = value.strip()
        if field == 'Candidate':
            data.setdefault(field,value)
            if value != "" and not value.startswith('CVE-') and not value.startswith('UEM-') and not value.startswith('EMB-'):
                msg += "%s: unknown Candidate '%s' (must be /(CVE|UEM|EMB)-/)\n" % (cve, value)
                code = EXIT_FAIL
        elif 'Priority' in field:
            # For now, throw away comments on Priority fields
            if ' ' in value:
                value = value.split()[0]
            if 'Priority_' in field:
                try:
                    foo, pkg = field.split('_',1)
                except ValueError:
                    msg += "%s: bad field with 'Priority_': '%s'\n" % (cve, field)
                    code = EXIT_FAIL
                    continue
            data.setdefault(field,value)
            if not value in ['untriaged'] + priorities:
                msg += "%s: unknown Priority '%s'\n" % (cve, value)
                code = EXIT_FAIL
        elif 'Patches_' in field:
            '''These are raw fields'''
            try:
                foo, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with 'Patches_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            data.setdefault(field,value)
        elif 'Tags_' in field:
            '''These are processed into the "tags" hash'''
            try:
                foo, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with 'Tags_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            data['tags'].setdefault(pkg, set())
            for word in value.strip().split(' '):
                if word not in valid_tags:
                    msg += "%s: bad '%s': '%s'\n" % (cve, word, field)
                    code = EXIT_FAIL
                    continue
                data['tags'][pkg].add(word)
        elif '_' in field:
            try:
                release, pkg = field.split('_',1)
            except ValueError:
                msg += "%s: bad field with '_': '%s'\n" % (cve, field)
                code = EXIT_FAIL
                continue
            if not release in releases + ['upstream', 'devel'] and not release in eol_releases:
                msg += "%s: bad release '%s'\n" % (cve, release)
                code = EXIT_FAIL
                continue
            try:
                info = value.split(' ',1)
            except ValueError:
                msg += "%s: missing state for '%s': '%s'\n" % (cve, field, value)
                code = EXIT_FAIL
                continue
            state = info[0]
            if state == '':
                state = 'needs-triage'

            if len(info) < 2:
                notes = ""
            else:
                notes = info[1].strip()
            if notes.startswith('('):
                notes = notes[1:]
            if notes.endswith(')'):
                notes = notes[:-1]

            # Work-around for old-style of only recording released versions
            if notes == '' and state[0] in ('0123456789'):
                notes = state
                state = 'released'

            if state not in ['needs-triage','needed','active','pending','released','deferred','DNE','ignored','not-affected']:
                msg += "%s: %s_%s has unknown state: '%s'\n" % (cve, release, pkg, state)
                code = EXIT_FAIL

            # Verify "released" kernels have version notes
            #if state == 'released' and pkg in kernel_srcs and notes == '':
            #    msg += "%s: %s_%s has state '%s' but lacks version note\n" % (cve, release, pkg, state)
            #    code = EXIT_FAIL

            # Verify "active" states have an Assignee
            if state == 'active' and data['Assigned-to'].strip() == "":
                msg += "%s: %s_%s has state '%s' but lacks 'Assigned-to'\n" % (cve, release, pkg, state)
                code = EXIT_FAIL

            affected.setdefault(pkg,dict())
            affected[pkg].setdefault(release,[state,notes])
        elif not field in ['References','Description','Ubuntu-Description','Notes','Bugs','Assigned-to','Approved-by','PublicDate','PublicDateAtUSN','CRD','Discovered-by']:
            msg += "%s: unknown field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        else:
            data.setdefault(field,value)

    # Check for required fields
    for field in ['Candidate','PublicDate','Description']:
        if not data.has_key(field):
            msg += "%s: missing field '%s'\n" % (cve, field)
            code = EXIT_FAIL
        nonempty = ['Candidate']
        if strict:
            nonempty += ['PublicDate']
        if field in nonempty and data[field].strip() == "":
            msg += "%s: required field '%s' is empty\n" % (cve, field)
            code = EXIT_FAIL

    # Fill in defaults for missing fields
    if not data.has_key('Priority'):
        data.setdefault('Priority','untriaged')
    # Perform override fields
    if data.has_key('PublicDateAtUSN'):
        data['PublicDate'] = data['PublicDateAtUSN']
    if data.has_key('CRD'):
        data['PublicDate'] = data['CRD']

    pkgs = sorted(affected.keys())
    # this check isn't safe due to the "ignored" cves.
    if False and len(pkgs) == 0:
            msg += "%s: no packages affected?!\n" % (cve)
            code = EXIT_FAIL
    # check for missing upstreams
    append = ''
    for pkg in pkgs:
        if not 'upstream' in affected[pkg].keys():
            append += 'upstream_%s: \n' % (pkg)
    if append != '':
        print >>sys.stderr, "%s: adding missing 'upstream' for: %s" % (cve, ", ".join(pkgs))
        open(cve,'a').write(append)

    data['pkgs'] = affected

    if code != EXIT_OKAY:
        raise ValueError, msg.strip()
    return data

def load_all(cves, uems):
    table = dict()
    priority = dict()
    listcves = []
    for cve in cves:
        priority.setdefault(cve, dict())
        cvedir = active_dir
        if cve in uems:
            cvedir = embargoed_dir
        cvefile = os.path.join(cvedir, cve)
        info = load_cve(cvefile)
        table.setdefault(cve, info)
    return table

# supported options
#  pkgfamily = rename linux-source-* packages to "linux", or "xen-*" to "xen"
#  packages = list of packages to pay attention to
#  debug = bool, display debug information
def load_table(cves, uems, opt=None):
    table = dict()
    priority = dict()
    listcves = []
    cveinfo = dict()
    namemap = dict()
    for cve in cves:
        table.setdefault(cve, dict())
        priority.setdefault(cve, dict())
        cvedir = active_dir
        if cve in uems:
            cvedir = embargoed_dir
        cvefile = os.path.join(cvedir, cve)
        info = load_cve(cvefile)
        cveinfo[cve] = info

        # Allow for Priority overrides
        priority[cve]['default'] = 'untriaged'
        try:
            priority[cve]['default'] = info['Priority']
        except:
            priority[cve]['default'] = 'untriaged'

        for package in info['pkgs']:
            pkg = package
            realpkg = pkg
            # special-case the kernel, since it is per-release
            if opt and 'linux' in opt.pkgfamily:
                if pkg in ['linux-source-2.6.15','linux-source-2.6.20','linux-source-2.6.22']:
                 pkg = 'linux'
            # special-case xen, since it is per-release
            if opt and 'xen' in opt.pkgfamily:
                if pkg in ['xen-3.0','xen-3.1','xen-3.2', 'xen-3.3']:
                 pkg = 'xen'
            if opt and opt.packages and pkg not in opt.packages:
                continue
            table[cve].setdefault(pkg,dict())
            namemap.setdefault(pkg,dict())
            for release in info['pkgs'][package]:
                rel = release
                if rel == 'devel':
                    rel = devel_release
                status = info['pkgs'][package][release][0]

                if opt and 'linux' in opt.pkgfamily and status == 'DNE':
                    continue
                if opt and 'xen' in opt.pkgfamily:
                    if status == 'DNE':
                        continue
                    # Skip xen-3.1 for non-gutsy when using pkgfamily override
                    if realpkg == 'xen-3.1' and rel != 'gutsy':
                        continue
                table[cve][pkg].setdefault(rel,status)
                namemap[pkg].setdefault(rel,realpkg)

            field = 'Priority_' + pkg
            if info.has_key(field):
                priority[cve][pkg] = info[field]
            if opt and opt.debug:
                print >>sys.stderr, "Loaded '%s'" % (pkg)

        # Ignore CVEs that have no packages we're interested in
        if len(table[cve])!=0:
            listcves.append(cve)
    updated_cves = listcves
    return (table, priority, updated_cves, namemap, cveinfo)

def is_supported(map, pkg, rel, cvedata=None):
    if not supported_pkgs.has_key(rel):
        supported_pkgs.setdefault(rel, set())
        # check if partially supported
        if rel in lts_partial_supported_releases:
            supported_fn = os.path.join(os.path.dirname(os.path.dirname(sys.argv[0])),'%s-supported.txt' % (rel))
            if os.path.exists(supported_fn):
                for p in open(supported_fn).readlines():
                    if p.startswith('#'):
                        continue
                    supported_pkgs[rel].add(p.strip())

    # Allow for a tagged override to declare a pkg (from the perspective of
    # a given CVE item) to be unsupported.
    if cvedata and cvedata['tags'].has_key(pkg) and 'universe-binary' in cvedata['tags'][pkg]:
        return False
    # Look for component or if we have a partially supported release, and if
    # partially supported only support those packages that are supported
    if map[rel].has_key(pkg) and \
       (map[rel][pkg]['section'] == 'main' or \
        map[rel][pkg]['section'] == 'restricted') and \
       (len(supported_pkgs[rel]) == 0 or pkg in supported_pkgs[rel]):
        return True
    return False

def any_supported(map, pkg, releases, cvedata):
    for rel in releases:
        if is_supported(map, pkg, rel, cvedata):
            return True
    return False

def is_partner(map, pkg, rel):
    if map[rel].has_key(pkg) and \
       (map[rel][pkg]['pocket'] == 'commercial' or \
        map[rel][pkg]['section'] == 'partner'):
        return True
    return False

def any_partner(map, pkg, releases):
    for rel in releases:
        if is_partner(map, pkg, rel):
            return True
    return False

def is_universe(map, pkg, rel, cvedata):
    if is_supported(map, pkg, rel, cvedata) or is_partner(map, pkg, rel):
        return False
    return True

def any_universe(map, pkg, releases, cvedata):
    for rel in releases:
        if is_universe(map, pkg, rel, cvedata):
            return True
    return False

def load_debian_cves(filename, verbose=True):
    cve = None
    debian = dict()

    cvelist = open(filename)
    if verbose:
        print "Loading %s ..." % (filename)
    count = 0
    for line in cvelist:
        count += 1
        line = line.rstrip()
        try:
            if line == "":
                continue
            if line.startswith('\t'):
                if not cve:
                    continue
                line = line.lstrip()
                if line.startswith('['):
                    continue
                if line.startswith('{'):
                    continue
                if line.startswith('-'):
                    info = line[1:].lstrip().split(' ',1)
                    pkg = info[0]
                    line = ""
                    if len(info)>1:
                        line = info[1]

                    info = line.lstrip().split(' ',1)
                    state = info[0]
                    if state == "":
                        state = "<unfixed>"
                    line = ""
                    if len(info)>1:
                        line = info[1]

                    priority = "needs-triage"
                    bug = None
                    note = None
                    if '(' in line and ')' in line:
                        info = line.split('(')[1].split(')')[0]
                        bits = info.split(';')
                        for bit in bits:
                            bit = bit.strip()
                            if bit.startswith('#'):
                                bug = bit[1:]
                            else:
                                priority = bit
                    else:
                        note = line
                    if priority == 'unimportant':
                        priority = 'negligible'

                    debian[cve]['pkgs'].setdefault(pkg,{'priority':priority,'bug':bug,'note':note,'state':state})

                    debian[cve]['state'] = 'FOUND'
                if line.startswith('RESERVED'):
                    debian[cve]['state'] = 'RESERVED'
                if line.startswith('REJECTED'):
                    debian[cve]['state'] = 'REJECTED'
                if line.startswith('NOT-FOR-US'):
                    debian[cve]['state'] = line
                if line.startswith('NOTE'):
                    debian[cve]['note']+=[line]
                if line.startswith('TODO'):
                    if not line.endswith('TODO: check'):
                        debian[cve]['note']+=[line]
            else:
                cve = line.split().pop(0)
                debian.setdefault(cve,{'pkgs':dict(), 'state':None, 'note':[], 'desc':" ".join(line.split()[1:])})
        except:
            print >>sys.stderr, "Error parsing line %d: '%s'" % (count, line)
            raise
    return debian

def load_ignored_reasons(filename):
    '''Load CVEs from a list of form "CVE-YYYY-NNNN # Reason"'''

    ignored = dict()

    for line in open(filename):
        line = line.strip()
        if len(line)==0 or line.startswith('#'):
            continue
        reason = "Ignored"
        if line.startswith('CVE') and '#' in line:
            line, reason = line.split('#',1)
        reason = reason.strip()
        if reason.startswith('DNE -') or reason.startswith('NFU -'):
            reason = reason[5:].lstrip('-')
        reason = reason.strip()
        if ' ' in line:
            cves = line.split(' ')
        else:
            cves = [line]
        for cve in cves:
            if len(cve)==0:
                continue
            ignored.setdefault(cve, reason)

    return ignored

def debian_truncate(desc):
    i = 0
    while i<len(desc) and (i<60 or desc[i]!=' '):
        i += 1
    if i == len(desc):
        return desc
    return desc[:i] + " ..."

def prepend_debian_cve(filename, cve, desc):
    '''This is prefix the Debian CVE list with a new CVE and
       truncated description with a TODO: check marker'''

    input = open(filename)
    output = file (filename+".new",'w')

    print "Prepending %s ..." % (cve)
    output.write(cve)
    if len(desc)>0:
        output.write(' (%s)' % (debian_truncate(desc)))
    output.write('\n\tTODO: check\n')
    output.write(input.read())
    input.close()
    output.close()
    os.rename(filename+".new",filename)

def update_debian_todo_cves(ignored, known, filename, debian_sources, verbose=False, update=True):
    '''This will replace any "TODO: check" entries with
    knowledge from the Ubuntu CVE Tracker'''

    input = open(filename)
    if update:
        if verbose:
            print "Updating %s ..." % (filename)
        output = file (filename+".new",'w')
    else:
        if verbose:
            print "Dry run ..."
        output = file ('/dev/null','w')
    cves = dict()

    count = 0
    cve = None
    for line in input:
        count += 1
        line = line.rstrip('\n')
        if line.startswith('CVE'):
            cve = line.split().pop(0)
            todo = True
        elif line.startswith('\t'):
            if todo and (line == '\tTODO: check' or line == '\tRESERVED'):
                if ignored.has_key(cve):
                    print >>output, "\tNOT-FOR-US: %s" % (ignored[cve])
                    todo = False
                    if verbose:
                        print "%s: NFU" % (cve)
                    continue
                if cve in known:
                    if not cves.has_key(cve):
                        cves[cve] = load_cve('active/%s' % (cve))
                    pkgs = cves[cve]['pkgs']
                    # HACK: Debian package name fix-ups
                    if 'linux' in pkgs:
                        pkgs = ['linux-2.6']
                    for src in pkgs:
                        # Skip packages not in Debian
                        if src not in debian_sources:
                            continue
                        print >>output, "\t- %s <unfixed>" % (src)
                        if verbose:
                            print "%s: %s" % (cve, src)
                        todo = False
                    # If the CVE is known to Ubuntu but doesn't hit anything, leave it alone
                    if todo:
                        print >>output, line
                    continue
        elif line.startswith('begin') or line.startswith('end'):
            pass
        else:
            raise ValueError, "Error parsing line %d: '%s'" % (count, line)
        print >>output, line
    input.close()
    output.close()
    if update:
        os.rename(filename+".new",filename)

def save_debian_cves(debian, filename):
    raise ValueError, "This code does not work yet"
    out = open(filename,'w')

    for cve in reversed(sorted(debian.keys())):
        title = cve
        if debian[cve]['desc']:
            title += " " + debian[cve]['desc']
        print >>out, title
        pkgs = sorted(debian[cve]['pkgs'].keys())
        for pkg in pkgs:
            print >>out, "\t- %s %s" % (pkg, debian[cve]['pkgs'][pkg]['state']),
            items = []
            priority = debian[cve]['pkgs'][pkg]['priority']
            if priority == "needs-triage":
                priority = None
            if priority:
                items += [priority]
            if debian[cve]['pkgs'][pkg]['bug']:
                items += ['#' + debian[cve]['pkgs'][pkg]['bug']]
            if len(items):
                print >>out, "(%s)" % (";".join(items))
            else:
                print >>out, ""
        if len(pkgs) == 0:
            if not debian[cve]['state']:
                print >>out, "\tTODO: check"
            else:
                print >>out, "\t%s\n" % (debian[cve]['state']),
        for line in debian[cve]['note']:
            print >>out, "\t%s" % (line)

def cve_age(cve, open_date, close_stamp, oldest=None):
    # 'oldest' is a timestamp that is used to add a lower bound to
    # dates in "open_date" and "close_stamp"
    if open_date == 'unknown' or len(open_date)==0:
        raise ValueError, "%s: empty PublicDate" % (cve)
    date = open_date
    # CRDs are traditionally 1400UTC, so use this unless something else
    # is specified.
    time = '14:00:00'
    if ' ' in date:
        tmp = date
        date = tmp.split()[0]
        time = tmp.split()[1]
    year, mon, day = [int(x) for x in date.split('-')]
    hour, minute, second = [int(x) for x in time.split(':')]
    open_obj = datetime.datetime(year, mon, day, hour, minute, second)
    close_obj = datetime.datetime.utcfromtimestamp(int(close_stamp))
    if oldest:
        oldest = datetime.datetime.utcfromtimestamp(oldest)
        if open_obj < oldest:
            open_obj = oldest
        if close_obj < oldest:
            close_obj = oldest
    delta = close_obj - open_obj
    return delta.days

def recursive_rm(dirPath):
    '''recursively remove directory'''
    names = os.listdir(dirPath)
    for name in names:
        path = os.path.join(dirPath, name)
        if not os.path.isdir(path):
            os.unlink(path)
        else:
            recursive_rm(path)
    os.rmdir(dirPath)

def lts_unsupported(map, cvepath, pkg, contents=""):
    '''check if package is EOL for a particular release, and if so, update the
       cve. Note, this is not used for EOLing an entire release, but rather
       making sure the the CVEs represent reality for situations for LTS
       releases, where only part of a release is active (eg, server is
       supported for 5 years and desktop 3)'''

    updated = contents
    for rel in lts_partial_supported_releases:
	# if no package or not in main or restricted, we don't need to change
        # anything
        if not map.has_key(rel) or not map[rel].has_key(pkg) or map[rel][pkg]['section'] in ['universe', 'multiverse'] or is_partner(map, pkg, rel):
            continue

        if contents == "":
            if os.path.exists(cvepath) and not is_supported(map, pkg, rel, None):
                try:
                    data = load_cve(cvepath)
                except ValueError, e:
                    print >>sys.stderr, e
                    return
                if not data['pkgs'][pkg].has_key(rel):
                    continue
                state, notes = data['pkgs'][pkg][rel]
                if not state in ['released','DNE','not-affected','ignored','pending']:
                    if state in ['needed', 'needs-triage', 'deferred']:
                        state = 'ignored'
                    print >>sys.stderr, "%s: ignoring EOL '%s' for %s" % (os.path.basename(cvepath), pkg, rel)
                    update_state(cvepath, pkg, rel, state, 'reached end-of-life')
                    updated = codecs.open(cvepath, encoding="utf-8").readlines()
        else:
            tmp = ""
            line = ""
            for line in contents.splitlines():
                if line.startswith('%s_%s:' % (rel, pkg)) and not is_supported(map, pkg, rel, None):
                    state = line.split(':')[1].strip().split()[0]
                    if not state in ['released','DNE','not-affected','ignored','pending']:
                        if state in ['needed', 'needs-triage']:
                            state = 'ignored'
                        line = '%s_%s: %s (%s)' % (rel, pkg, state, 'reached end-of-life')
                tmp += line + "\n"
            updated = tmp

    return updated

# Usage:
# config = ConfigObj(os.path.expanduser("~/.ubuntu-cve-tracker.conf"))
# cve_lib.check_mirror_timestamp(config)
# cve_lib.check_mirror_timestamp(config, mirror='packages_mirror')
def check_mirror_timestamp(config, mirror=None):
    mirrors = ['packages_mirror', 'partner_mirror']
    if mirror != None:
        mirrors = [mirror]
    for m in mirrors:
        if not config.has_key(m):
            continue
        a = config[m]

        secs = 86400
        if m == 'partner_mirror':
            secs = 86400 * 7

        if os.path.exists(a + ".timestamp") and time.mktime(time.localtime()) - os.stat(a + ".timestamp").st_mtime > secs:
            print >>sys.stderr, "WARNING: '%s' is older than %d day(s). Please run '$UCT/scripts/packages-mirror -t'." % (a, secs / 86400)

def oldest_supported_release():
    '''Get oldest non-eol release'''
    for r in releases:
        if r not in eol_releases:
            return r
