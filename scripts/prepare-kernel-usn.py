#!/usr/bin/python
#
# Author: Kees Cook <kees@ubuntu.com>
# Author: Marc Deslauriers <marc.deslauriers@ubuntu.com>
# Author: Steve Beattie <sbeattie@ubuntu.com>
# Copyright: 2011,2012,2017 Canonical, Ltd
# License: GPLv3
#
# Walk through the steps to do a standard kernel publication using the
# CVE statuses populated in UCT ahead of time. This handles steps 1
# through 5 of:
# https://wiki.ubuntu.com/SecurityTeam/UpdatePublication
#
# This script is still in the testing phase...

from __future__ import print_function

import argparse
import glob
import os
import shutil
import subprocess
import sys
import tempfile

import cve_lib
import usn_lib
from source_map import version_compare
from lp_lib import UCTLaunchpad

try:
    from itertools import zip_longest
except ImportError:  # XXX python2 fallback
    from itertools import izip_longest as zip_longest

database = "database.pickle"
reserved_usn = False
uct_script_dir = os.path.join(os.environ['UCT'], 'scripts')


def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter(iterable)] * n
    return zip_longest(*args, fillvalue=fillvalue)


def get_usn_versions(kernel_map, release, uctlp):
    new_map = []
    pkgs = map(lambda (x, y): x, args.kernel)
    #print(pkgs)
    usndb = usn_lib.USNdb(pkgs, database, args.release, args)
    for (pkg, ver) in kernel_map:
        usns = usndb.get_usns(pkg, release)
        if not usns:
            new_map.append((pkg, ver, uctlp.get_earliest_version(release, pkg)))
        else:
            new_map.append((pkg, ver, usns[0]))
    #print(new_map)
    return new_map


def debug(message):
    global args

    if args.debug:
        print(message)


def get_latest_usn_version(release, kernel):
    # XXX - replace this with (a) usn_lib.py api call
    return subprocess.check_output(['./scripts/report-latest-usn-version', '-r', release, kernel], universal_newlines=True).rstrip()


def display_pending_cves(release, kernel, last_usn, version, extra_cves=None):
    # XXX - convert to an api call (report-pending-fixes is python)
    if extra_cves:
        extra_cves_arg = ','.join(extra_cves)
    else:
        extra_cves_arg = ''
    return subprocess.call(['./scripts/report-pending-fixes', '-D', '-r', release, kernel, last_usn, version, '-a', extra_cves_arg], universal_newlines=True)


def get_pending_cves(release, kernel, last_usn, version):
    # XXX - convert to an api call (report-pending-fixes is python)
    cves = subprocess.check_output(['./scripts/report-pending-fixes', '-r', release, kernel, last_usn, version], universal_newlines=True)
    cves = cves.strip()
    if cves == '':
        return []
    return cves.split('\n')


def get_next_usn(release, kernels):
    return subprocess.check_output(['ssh', 'people.canonical.com', '~ubuntu-security/bin/get-next-usn', release, " ".join(kernels)]).rstrip()


def check_upload(usn):
    subprocess.check_call(['ssh', 'people.canonical.com', '~ubuntu-security/bin/check-upload', usn])


class Kernel(object):
    def __init__(self, name, version):
        self.name = name
        self.version = version
        self.meta = None


class Kernels(dict):
    # expects a list of (kernel, version) pairs
    def __init__(self, kern_list):
        if kern_list:
            for kernel, version in kern_list:
                self[kernel] = Kernel(kernel, version)


class KernelVersionAction(argparse.Action):

    #def __init__(self, option_strings, dest, nargs=None, **kwargs):
    #    if nargs is None:
    #        raise ValueError("nargs required")
    #    super(KernelVersionAction, self).__init__(option_strings, dest, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        #print('%r %r %r' % (namespace, values, option_string))
        if not len(values) % 2 == 0:
            raise ValueError("Must enter kernel and versions in pairs")
        pairs = list(grouper(values, 2))
        setattr(namespace, self.dest, pairs)


parser = argparse.ArgumentParser(description='Script to prepare kernel USNS')
parser.add_argument('-i', '--ignore', action='append', help='CVE to ignore (can repeat)')
parser.add_argument('-a', '--add', action='append', help='CVE not in changes to add (can repeat)')
parser.add_argument('-n', '--dry-run', action='store_true', help='Dry Run')
parser.add_argument('-d', '--debug', action='store_true', help='Debugging mode')

group = parser.add_mutually_exclusive_group(required=False)
group.add_argument('-u', '--usn', action='store', help='Use specific USN')
group.add_argument('-f', '--fetch', action='store_true', help='Fetch a new USN number')

parser.add_argument('-e', '--include-eol', action='store_true', help='Include EoL releases')
parser.add_argument('-s', '--skip-binary-check', action='store_true', help='Skip binary package build check')
parser.add_argument('-b', '--bypass-usn-check', action='store_true', help='Bypass checks for a USN already existing for the specified kernel')
parser.add_argument('-r', '--regression', action='store_true', help='Treat as a regression')
parser.add_argument('-p', '--pocket', action='store', default='Security', help='Treat USN as a binary pocket copy from RELEASE')
parser.add_argument('-P', '--ppa', action='store', default='ubuntu', help='Use kernels from PPA rather than the Ubuntu archive')
parser.add_argument('release', action='store', nargs=1,  help='Release name (e.g. xenial)')
parser.add_argument('kernel', action=KernelVersionAction, nargs='+',  help='Kernel source package name and versions; e.g. "linux 4.4.0-42.62"')
args = parser.parse_args()

if not args.dry_run and not args.fetch and args.usn is None:
    print('''No USN specified. Must choose one of the following:
'-n'     dry-run
'-f'     fetch new USN
'-u USN' specific USN''', file=sys.stderr)
    exit(1)

release = args.release[0]

#uctlp = UCTLaunchpad(args)
#pkgs = get_usn_versions(args.kernel, release, uctlp)
cves = set()
if args.add:
    cves.update(args.add)
kernels = Kernels(args.kernel)
meta_kernels = set()

for kernel in sorted(kernels):
    version = kernels[kernel].version

    last_usn_version = get_latest_usn_version(release, kernel)
    debug("%s %s" % (kernel, last_usn_version))

    rc = display_pending_cves(release, kernel, last_usn_version, version, args.add)
    if not rc == 0:
        print("Incomplete descriptions detected, please fix.")
        exit(1)

    # Don't need to pass additional cves if any here due to them already
    # being added to the cves set()
    pending_cves = set(get_pending_cves(release, kernel, last_usn_version, version))
    if len(pending_cves) > 0:
        cves.update(pending_cves)
    debug("%s %s" % (kernel, " ".join(cves)))

    kernels[kernel].meta = cve_lib.meta_kernels.get_meta(release, kernel)
    debug("%s %s" % (kernel, kernels[kernel].meta))

    if last_usn_version == version and not args.bypass_usn_check:
        print("A USN already exists for %s kernel version %s!" % (kernel, version), file=sys.stderr)
        print("Try using report-mismatched-cve-fixes.py to fix", file=sys.stderr)
        print("... or use --bypass-usn-check if you know what you're doing!", file=sys.stderr)
        exit(1)

if not args.usn:
    if args.dry_run:
        usn = 'N-1'
    elif args.fetch:
        usn = get_next_usn(release, kernels)
        reserved_usn = True
    else:
        raise("Something's gone horribly wrong")
else:
    usn = args.usn

changes_dir = None
try:
    debug("USN=%s" % usn)

    usn_script = os.path.join(os.environ['HOME'], 'new-usn-%s-%s-%s.sh' % (release, "-".join(kernels), usn))
    debug("USN script is %s" % usn_script)

    changes_dir = os.path.join(tempfile.mkdtemp(prefix='prepare-kernal-usn-'), "usn-%s-%s" % (release, "-".join(kernels)))
    debug('changes dir is %s' % changes_dir)

    # sis-changes command
    cmd = [os.path.join(uct_script_dir, 'sis-changes')]
    if args.include_eol:
        cmd.append('--include-eol')
    if args.skip_binary_check:
        cmd.append('--skip-build-check')
    cmd += ['--ppa', args.ppa, '--pocket', args.pocket, '-r', release, '--download', changes_dir]
    for kernel in kernels:
        cmd += [kernel, kernels[kernel].meta]

    debug("%s" % " ".join(cmd))
    subprocess.check_call(cmd)

    os.chdir(changes_dir)
    generate_usn_regex = r'^linux-image-(\d|generic|virtual|lowlatency|power|omap|raspi2|snapdragon|highbank|aws)'

    # sis-generate-usn command
    cmd = [os.path.join(uct_script_dir, 'sis-generate-usn'), '--kernel-mode', '--no-new-warn']
    if args.ignore:
        cmd += ['--ignore-cves', ','.join(args.ignore)]

    if len(cves) == 0:
        if not args.regression:
            print("INFO no cves found, is this a regression?")
    else:
        cmd += ['--cves', ','.join(cves)]

    cmd += ['--filter-bins', generate_usn_regex, usn]
    cmd += glob.glob('*.changes')

    debug("%s" % " ".join(cmd))
    with open(usn_script, 'w') as f:
        subprocess.check_call(cmd, stdout=f, universal_newlines=True)

    # invoke editor
    if 'EDITOR' in os.environ:
        cmd = [os.environ['EDITOR']]
    else:
        cmd = ['vi']
    cmd.append(usn_script)
    subprocess.check_call(cmd, universal_newlines=True)

    if not args.dry_run:
        subprocess.check_call(['bash', usn_script], universal_newlines=True)
        check_upload(usn)

except:
    if reserved_usn:
        print("Please re-use %s! Reserved for %s %s!" % (usn, release, ",".join(kernels)))
    raise
finally:
    if changes_dir and os.path.isdir(changes_dir):
        shutil.rmtree(changes_dir)

debug(args)
print('USN script is %s' % usn_script)
print('SRCPKG="%s"' % " ".join(kernels))
print('USN=%s' % usn)
