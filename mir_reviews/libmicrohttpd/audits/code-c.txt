Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==
./src/testspdy/test_proxies.c:119:		execlp ("../examples/minimal_example", "minimal_example", port_s, NULL);
./src/testspdy/test_proxies.c:146:		execlp ("../spdy2http/microspdy2http", "microspdy2http", "-v4rtT", "10", "-p", port_s, NULL);
./src/testspdy/test_proxies.c:172:		execlp ("../examples/mhd2spdy", "mhd2spdy", "-vosb", url, "-p", port_s, NULL);
./src/testspdy/test_proxies.c:201:    p = popen(cmd, "r");
./src/testspdy/test_request_response_with_callback.c:247:    FILE *p = popen(cmd, "r");
./src/testspdy/test_misc.c:90:		execlp("spdycat", "spdycat","-anv",uri,NULL );
./src/testspdy/test_session_timeout.c:305:	execlp ("openssl", "openssl", "s_client", "-connect", uri, NULL);
./src/examples/mhd2spdy_structures.c:79:  if (0 != (ret = regexec(preg, full_uri, nmatch, pmatch, 0)))
./src/testcurl/test_get_response_cleanup.c:73:  execlp ("curl", "curl", "-s", "-N", "-o", "/dev/null", "-GET", url, NULL);
./src/testcurl/gauger.h:38:            execvp("gauger", (char*const*) __gauger_v);	\
./src/testcurl/gauger.h:68:            execvp("gauger",__gauger_v);\
./src/spdy2http/proxy.c:242:  if (0 != (ret = regexec(preg, full_uri, nmatch, pmatch, 0)))
./src/testzzuf/socat.c:93:  execvp ("zzuf", args);

== memory_management() ==
./src/microspdy/daemon.c:193:	if (NULL == (daemon = malloc (sizeof (struct SPDY_Daemon))))
./src/microspdy/daemon.c:260:		if (NULL == (servaddr6 = malloc (addrlen)))
./src/microspdy/daemon.c:292:		if (NULL == (servaddr4 = malloc (addrlen)))
./src/microspdy/structures.c:46:	if(NULL == (pair = malloc(sizeof(struct SPDY_NameValue))))
./src/microspdy/structures.c:85:		if (NULL == (container->value = malloc(sizeof(char *))))
./src/microspdy/structures.c:116:		if(NULL == (pair = malloc(sizeof(struct SPDY_NameValue))))
./src/microspdy/structures.c:126:		if (NULL == (pair->value = malloc(sizeof(char *))))
./src/microspdy/structures.c:160:		if (NULL == (temp_value = malloc((pair->num_values + 1) * sizeof(char *))))
./src/microspdy/structures.c:164:		memcpy(temp_value, pair->value, pair->num_values * sizeof(char *));
./src/microspdy/structures.c:323:			if(NULL == (response_to_queue = malloc(sizeof(struct SPDYF_Response_Queue))))
./src/microspdy/structures.c:330:			if(NULL == (data_frame = malloc(sizeof(struct SPDYF_Data_Frame))))
./src/microspdy/structures.c:380:	if(NULL == (response_to_queue = malloc(sizeof(struct SPDYF_Response_Queue))))
./src/microspdy/structures.c:388:		if(NULL == (data_frame = malloc(sizeof(struct SPDYF_Data_Frame))))
./src/microspdy/structures.c:404:		if(NULL == (control_frame = malloc(sizeof(struct SPDYF_Control_Frame))))
./src/microspdy/structures.c:498:	if(NULL == (*stream = malloc(size)))
./src/microspdy/structures.c:505:	memcpy(*stream, &num_pairs, 4);
./src/microspdy/structures.c:516:      memcpy(*stream + offset, &temp, 4);
./src/microspdy/structures.c:539:      memcpy(*stream + value_offset, &value_size, 4);
./src/microspdy/structures.c:573:	memcpy(&num_pairs, stream, 4);
./src/microspdy/structures.c:582:			memcpy(&name_size, stream + offset, 4);
./src/microspdy/structures.c:594:			memcpy(&value_size, stream + offset, 4);
./src/microspdy/applicationlayer.c:83:	if(NULL==(request = malloc(sizeof(struct SPDY_Request))))
./src/microspdy/applicationlayer.c:410:	if(NULL == (response = malloc(sizeof(struct SPDY_Response))))
./src/microspdy/applicationlayer.c:417:	if(NULL == (all_headers = malloc(num_hdr_containers * sizeof(struct SPDY_NameValue *))))
./src/microspdy/applicationlayer.c:428:		ret = asprintf(&fullstatus, "%i", status);
./src/microspdy/applicationlayer.c:430:		ret = asprintf(&fullstatus, "%i %s", status, statustext); 
./src/microspdy/applicationlayer.c:455:		if(NULL == (response->data = malloc(size)))
./src/microspdy/applicationlayer.c:460:		memcpy(response->data, data, size);
./src/microspdy/session.c:219:		memcpy(&last_good_stream_id, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/session.c:223:		memcpy(&status_int, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/session.c:289:    memcpy(&stream_id, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/session.c:293:    memcpy(&status_int, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/session.c:435:	memcpy(&control_frame, response_queue->control_frame, sizeof(control_frame));
./src/microspdy/session.c:463:	if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:483:	memcpy(session->write_buffer + session->write_buffer_offset,&control_frame,sizeof(struct SPDYF_Control_Frame));
./src/microspdy/session.c:488:	memcpy(session->write_buffer + session->write_buffer_offset, &stream_id_nbo, 4);
./src/microspdy/session.c:492:	memcpy(session->write_buffer + session->write_buffer_offset, compressed_headers, compressed_headers_size);
./src/microspdy/session.c:526:	memcpy(&control_frame, response_queue->control_frame, sizeof(control_frame));
./src/microspdy/session.c:534:	if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:546:	memcpy(session->write_buffer + session->write_buffer_offset,&control_frame,sizeof(struct SPDYF_Control_Frame));
./src/microspdy/session.c:551:	memcpy(session->write_buffer + session->write_buffer_offset, &last_good_stream_id, 4);
./src/microspdy/session.c:555:	memcpy(session->write_buffer + session->write_buffer_offset, response_queue->data, 4);
./src/microspdy/session.c:581:	memcpy(&data_frame, response_queue->data_frame, sizeof(data_frame));
./src/microspdy/session.c:591:		if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:603:		memcpy(session->write_buffer + session->write_buffer_offset,&data_frame,sizeof(struct SPDYF_Data_Frame));
./src/microspdy/session.c:607:		memcpy(session->write_buffer + session->write_buffer_offset, response_queue->data, response_queue->data_size);
./src/microspdy/session.c:619:		if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:724:		memcpy(session->write_buffer + session->write_buffer_offset,
./src/microspdy/session.c:750:	memcpy(&control_frame, response_queue->control_frame, sizeof(control_frame));
./src/microspdy/session.c:756:	if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:768:	memcpy(session->write_buffer + session->write_buffer_offset,&control_frame,sizeof(struct SPDYF_Control_Frame));
./src/microspdy/session.c:772:	memcpy(session->write_buffer + session->write_buffer_offset, response_queue->data, 8);
./src/microspdy/session.c:795:	memcpy(&control_frame, response_queue->control_frame, sizeof(control_frame));
./src/microspdy/session.c:801:	if(NULL == (session->write_buffer = malloc(total_size)))
./src/microspdy/session.c:813:	memcpy(session->write_buffer + session->write_buffer_offset,&control_frame,sizeof(struct SPDYF_Control_Frame));
./src/microspdy/session.c:817:	memcpy(session->write_buffer + session->write_buffer_offset, response_queue->data, 8);
./src/microspdy/session.c:1190:				if(NULL == (control_frame = malloc(sizeof(struct SPDYF_Control_Frame))))
./src/microspdy/session.c:1197:				memcpy(control_frame,
./src/microspdy/session.c:1225:				if(NULL == (data_frame = malloc(sizeof(struct SPDYF_Data_Frame))))
./src/microspdy/session.c:1232:				memcpy(data_frame,
./src/microspdy/session.c:1414:	if (NULL == (session = malloc (sizeof (struct SPDY_Session))))
./src/microspdy/session.c:1435:	if (NULL == (session->read_buffer = malloc (session->read_buffer_size)))
./src/microspdy/session.c:1442:	if (NULL == (session->addr = malloc (addr_len)))
./src/microspdy/session.c:1447:	memcpy (session->addr, addr, addr_len);
./src/microspdy/session.c:1625:	if(NULL == (response_to_queue = malloc(sizeof(struct SPDYF_Response_Queue))))
./src/microspdy/session.c:1631:	if(NULL == (control_frame = malloc(sizeof(struct SPDYF_Control_Frame))))
./src/microspdy/session.c:1638:	if(NULL == (data = malloc(4)))
./src/microspdy/session.c:1679:	if(NULL == (response_to_queue = malloc(sizeof(struct SPDYF_Response_Queue))))
./src/microspdy/session.c:1685:	if(NULL == (control_frame = malloc(sizeof(struct SPDYF_Control_Frame))))
./src/microspdy/session.c:1692:	if(NULL == (data = malloc(8)))
./src/microspdy/session.c:1731:	if(NULL == (response_to_queue = malloc(sizeof(struct SPDYF_Response_Queue))))
./src/microspdy/session.c:1737:	if(NULL == (control_frame = malloc(sizeof(struct SPDYF_Control_Frame))))
./src/microspdy/session.c:1744:	if(NULL == (data = malloc(8)))
./src/microspdy/compression.c:306:			memcpy((*dest) + ((*dest_size) - have), out, have);
./src/microspdy/compression.c:434:			memcpy((*dest) + ((*dest_size) - have), out, have);
./src/microspdy/stream.c:51:    memcpy(&stream_id, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/stream.c:77:    memcpy(&assoc_stream_id, session->read_buffer + session->read_buffer_beginning, 4);
./src/microspdy/stream.c:90:	if(NULL == (stream = malloc(sizeof(struct SPDYF_Stream))))
./src/testspdy/test_new_connection.c:151:  dst = malloc(len+1);
./src/testspdy/test_new_connection.c:154:  memcpy(dst, s, len);
./src/testspdy/test_new_connection.c:894:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testspdy/test_notls.c:130:  dst = malloc(len+1);
./src/testspdy/test_notls.c:133:  memcpy(dst, s, len);
./src/testspdy/test_notls.c:436:		strcpy(rcvbuf + rcvbuf_c,(char*)data);
./src/testspdy/test_notls.c:852:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testspdy/test_notls.c:853:	if(NULL == (rcvbuf = malloc(strlen(RESPONSE_BODY)+1)))
./src/testspdy/test_proxies.c:118:    asprintf(&port_s, "%i", mhd_port);
./src/testspdy/test_proxies.c:143:    //asprintf(&url, "127.0.0.1:%i", mhd_port);
./src/testspdy/test_proxies.c:144:    asprintf(&port_s, "%i", spdy2http_port);
./src/testspdy/test_proxies.c:169:    asprintf(&url, "http://127.0.0.1:%i", spdy2http_port);
./src/testspdy/test_proxies.c:170:    asprintf(&port_s, "%i", mhd2spdy_port);
./src/testspdy/test_proxies.c:199:		asprintf (&cmd, "curl --proxy http://127.0.0.1:%i http://127.0.0.1:%i/", mhd2spdy_port, mhd_port);
./src/testspdy/test_request_response_with_callback.c:274:	asprintf(&cmd1, "spdycat https://127.0.0.1:%i/ | md5sum",port);
./src/testspdy/test_request_response_with_callback.c:275:	asprintf(&cmd2, "md5sum " DATA_DIR "spdy-draft.txt");
./src/testspdy/test_misc.c:89:		asprintf(&uri,"https://127.0.0.1:%i/",port);
./src/testspdy/test_request_response.c:133:  dst = malloc(len+1);
./src/testspdy/test_request_response.c:136:  memcpy(dst, s, len);
./src/testspdy/test_request_response.c:421:		strcpy(rcvbuf + rcvbuf_c,(char*)data);
./src/testspdy/test_request_response.c:908:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testspdy/test_request_response.c:909:	if(NULL == (rcvbuf = malloc(strlen(RESPONSE_BODY)+1)))
./src/testspdy/test_session_timeout.c:304:	asprintf (&uri, "127.0.0.1:%i", port);
./src/examples/mhd2spdy_structures.h:290:au_malloc(size_t size);
./src/examples/querystring_example.c:56:  me = malloc (snprintf (NULL, 0, fmt, "q", val) + 1);
./src/examples/querystring_example.c:59:  sprintf (me, fmt, "q", val);
./src/examples/benchmark_https.c:96:  struct timeval *tv = malloc (sizeof (struct timeval));
./src/examples/spdy_response_with_callback.c:125:			asprintf(&html,"<html>"
./src/examples/spdy_response_with_callback.c:131:			asprintf(&html,"<html>"
./src/examples/spdy_event_loop.c:190:	asprintf(data,"%s%s: %s\n", *data,name,value[i]);
./src/examples/spdy_event_loop.c:193:	asprintf(data,"%s%s: \n", *data,name);
./src/examples/spdy_event_loop.c:222:			asprintf(&html,"body{color:green;}");
./src/examples/spdy_event_loop.c:224:			asprintf(&html,"body{color:red;}");
./src/examples/spdy_event_loop.c:234:		asprintf(&data,"Priority: %i\nHTTP headers, scheme: %s\n\n%s %s %s\nHost: %s\n", priority,scheme,method,path,version,host);
./src/examples/spdy_event_loop.c:240:			asprintf(&html,"<html>"
./src/examples/spdy_event_loop.c:246:			asprintf(&html,"<html><link href=\"main.css\" rel=\"stylesheet\" type=\"text/css\" />"
./src/examples/spdy_event_loop.c:263:	asprintf(&pathcls, "%s (daemon%i)",path,NULL==cls ? 1 : 2);
./src/examples/spdy_fileserver.c:87:    char * buf = malloc(RFC1123_TIME_LEN+1);
./src/examples/spdy_fileserver.c:95:    memcpy(buf, DAY_NAMES[tm.tm_wday], 3);
./src/examples/spdy_fileserver.c:96:    memcpy(buf+8, MONTH_NAMES[tm.tm_mon], 3);
./src/examples/spdy_fileserver.c:176:		asprintf(&fname,"%s%s",basedir,path);
./src/examples/spdy_fileserver.c:204:				if(-1 == asprintf(&fsize, "%zd", filesize)
./src/examples/mhd2spdy_spdy.c:105:		if(NULL == (newbody = malloc(proxy->received_body_size - length)))
./src/examples/mhd2spdy_spdy.c:110:		memcpy(newbody, proxy->received_body + length, proxy->received_body_size - length);
./src/examples/mhd2spdy_spdy.c:112:	memcpy(buf, proxy->received_body, ret);
./src/examples/mhd2spdy_spdy.c:446:		proxy->http_body = au_malloc(len);
./src/examples/mhd2spdy_spdy.c:455:	memcpy(proxy->http_body + proxy->http_body_size, data, len);
./src/examples/mhd2spdy_spdy.c:768:  if(NULL == (connection = au_malloc(sizeof(struct SPDY_Connection))))
./src/examples/post_example.c:172:  ret = calloc (1, sizeof (struct Session));
./src/examples/post_example.c:319:  reply = malloc (strlen (MAIN_PAGE) + strlen (session->value_1) + 1);
./src/examples/post_example.c:362:  reply = malloc (strlen (SECOND_PAGE) + strlen (session->value_1) + strlen (session->value_2) + 1);
./src/examples/post_example.c:480:      memcpy (&session->value_1[off],
./src/examples/post_example.c:490:      memcpy (&session->value_2[off],
./src/examples/post_example.c:555:      request = calloc (1, sizeof (struct Request));
./src/examples/demo.c:316:  if (NULL == (rdc.buf = malloc (rdc.buf_len)))
./src/examples/demo.c:444:  buf = malloc (old_len + size + 1);
./src/examples/demo.c:447:  memcpy (buf, *ret, old_len);
./src/examples/demo.c:450:  memcpy (&buf[old_len], data, size);
./src/examples/demo.c:741:	  if (NULL == (uc = malloc (sizeof (struct UploadContext))))
./src/examples/demo_https.c:317:  if (NULL == (rdc.buf = malloc (rdc.buf_len)))
./src/examples/demo_https.c:445:  buf = malloc (old_len + size + 1);
./src/examples/demo_https.c:448:  memcpy (buf, *ret, old_len);
./src/examples/demo_https.c:451:  memcpy (&buf[old_len], data, size);
./src/examples/demo_https.c:741:	  if (NULL == (uc = malloc (sizeof (struct UploadContext))))
./src/examples/benchmark.c:96:  struct timeval *tv = malloc (sizeof (struct timeval));
./src/examples/mhd2spdy_http.c:40:  if(NULL == (http_uri = au_malloc(sizeof(struct HTTP_URI ))))
./src/examples/mhd2spdy_http.c:125:		if(NULL == (newbody = au_malloc(proxy->http_body_size - max)))
./src/examples/mhd2spdy_http.c:130:		memcpy(newbody, proxy->http_body + max, proxy->http_body_size - max);
./src/examples/mhd2spdy_http.c:132:	memcpy(buffer, proxy->http_body, ret);
./src/examples/mhd2spdy_http.c:193:    if(NULL == (proxy = au_malloc(sizeof(struct Proxy))))
./src/examples/mhd2spdy_http.c:271:  if(NULL == (spdy_headers.nv = au_malloc(((spdy_headers.num + 5) * 2 + 1) * sizeof(char *))))
./src/examples/mhd2spdy_http.c:336:      memcpy(&tmp,nv[i+1],3);
./src/examples/mhd2spdy_structures.c:82:  *uri = au_malloc(sizeof(struct URI));
./src/examples/mhd2spdy_structures.c:88:  asprintf(&((*uri)->scheme), "%.*s",pmatch[2].rm_eo - pmatch[2].rm_so, &full_uri[pmatch[2].rm_so]);
./src/examples/mhd2spdy_structures.c:89:  asprintf(&((*uri)->host_and_port), "%.*s",pmatch[4].rm_eo - pmatch[4].rm_so, &full_uri[pmatch[4].rm_so]);
./src/examples/mhd2spdy_structures.c:90:  asprintf(&((*uri)->path), "%.*s",pmatch[5].rm_eo - pmatch[5].rm_so, &full_uri[pmatch[5].rm_so]);
./src/examples/mhd2spdy_structures.c:91:  asprintf(&((*uri)->path_and_more), "%.*s",pmatch[9].rm_eo - pmatch[5].rm_so, &full_uri[pmatch[5].rm_so]);
./src/examples/mhd2spdy_structures.c:92:  asprintf(&((*uri)->query), "%.*s",pmatch[7].rm_eo - pmatch[7].rm_so, &full_uri[pmatch[7].rm_so]);
./src/examples/mhd2spdy_structures.c:93:  asprintf(&((*uri)->fragment), "%.*s",pmatch[9].rm_eo - pmatch[9].rm_so, &full_uri[pmatch[9].rm_so]);
./src/examples/mhd2spdy_structures.c:111:  asprintf(&((*uri)->host), "%.*s", (int)(colon - (*uri)->host_and_port), (*uri)->host_and_port);
./src/examples/mhd2spdy_structures.c:131:void *au_malloc(size_t size)
./src/examples/mhd2spdy_structures.c:135:  new_memory = malloc(size);
./src/examples/mhd2spdy_structures.c:152:		*dst = malloc(src_size);
./src/examples/mhd2spdy_structures.c:158:	memcpy(*dst + *dst_size, src, src_size);
./src/testcurl/https/tls_test_common.c:78:  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))
./src/testcurl/https/tls_test_common.c:156:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/https/tls_test_common.c:272:  if (NULL == (doc_path = malloc (doc_path_len)))
./src/testcurl/https/tls_test_common.c:304:  if (sprintf (url, "%s:%d%s/%s", "https://127.0.0.1", port,
./src/testcurl/https/tls_test_common.c:324:  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))
./src/testcurl/https/tls_test_common.c:398:  key->data = malloc (key->size);
./src/testcurl/https/tls_test_common.c:404:  memcpy (key->data, srv_key_pem, key->size);
./src/testcurl/https/tls_test_common.c:406:  cert->data = malloc (cert->size);
./src/testcurl/https/tls_test_common.c:413:  memcpy (cert->data, srv_self_signed_cert_pem, cert->size);
./src/testcurl/https/test_https_sni.c:69:  host = malloc (sizeof (struct Hosts));
./src/testcurl/https/test_https_sni.c:190:  if (NULL == (cbc.buf = malloc (sizeof (char) * len)))
./src/testcurl/https/test_tls_options.c:48:  if (NULL == (cbc.buf = malloc (sizeof (char) * 256)))
./src/testcurl/https/test_https_session_info.c:102:  if (NULL == (cbc.buf = malloc (sizeof (char) * 255)))
./src/testcurl/test_iplimit.c:70:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_process_arguments.c:56:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_postform.c:80:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/perf_get.c:147:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/perf_get.c:191:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:251:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:310:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:379:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_get_sendfile.c:70:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_get_sendfile.c:475:  sourcefile = malloc (strlen (tmp) + 32);
./src/testcurl/test_get_sendfile.c:476:  sprintf (sourcefile,
./src/testcurl/test_large_put.c:77:  memcpy (stream, &put_buffer[*pos], wrt);
./src/testcurl/test_large_put.c:89:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_large_put.c:467:  put_buffer = malloc (PUT_SIZE);
./src/testcurl/test_callback.c:70:  struct callback_closure *cbc = calloc(1, sizeof(struct callback_closure));
./src/testcurl/test_post_loop.c:67:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_post_loop.c:133:      sprintf (url, "http://127.0.0.1:1080/hw%d", i);
./src/testcurl/test_post_loop.c:197:      sprintf (url, "http://127.0.0.1:1081/hw%d", i);
./src/testcurl/test_post_loop.c:262:      sprintf (url, "http://127.0.0.1:1081/hw%d", i);
./src/testcurl/test_post_loop.c:345:      sprintf (url, "http://127.0.0.1:1082/hw%d", i);
./src/testcurl/perf_get_concurrent.c:173:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_post.c:86:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_post.c:509:  memcpy(p, data->buffer + data->pos, required);
./src/testcurl/test_termination.c:108:  sprintf (url, "http://127.0.0.1:%d", PORT);
./src/testcurl/test_digestauth.c:65:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_put_chunked.c:65:  memcpy (stream, &("Hello123"[*pos]), wrt);
./src/testcurl/test_put_chunked.c:77:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/gauger.h:27:            sprintf(__gauger_s,"%Lf", (long double) (value));\
./src/testcurl/gauger.h:55:            sprintf(__gauger_s,"%Lf", (long double) (value));\
./src/testcurl/test_parse_cookies.c:56:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_digestauth_with_arguments.c:64:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_timeout.c:95:  memcpy (stream, &("Hello123"[*pos]), wrt);
./src/testcurl/test_timeout.c:115:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_quiesce.c:65:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_process_headers.c:63:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_urlparse.c:65:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_get_chunked.c:64:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_get_chunked.c:120:  responseptr = malloc (sizeof (struct MHD_Response *));
./src/testcurl/test_get.c:72:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testcurl/test_long_header.c:115:  url = malloc (VERY_LONG);
./src/testcurl/test_long_header.c:123:  memcpy (url, "http://127.0.0.1:1080/", strlen ("http://127.0.0.1:1080/"));
./src/testcurl/test_long_header.c:186:  url = malloc (VERY_LONG);
./src/testcurl/test_concurrent_stop.c:112:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_put.c:64:  memcpy (stream, &("Hello123"[*pos]), wrt);
./src/testcurl/test_put.c:76:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/spdy2http/proxy.c:245:  *uri = malloc(sizeof(struct URI));
./src/spdy2http/proxy.c:251:  asprintf(&((*uri)->scheme),
./src/spdy2http/proxy.c:255:  asprintf(&((*uri)->host_and_port), "%.*s",
./src/spdy2http/proxy.c:258:  asprintf(&((*uri)->path),
./src/spdy2http/proxy.c:262:  asprintf(&((*uri)->path_and_more),
./src/spdy2http/proxy.c:266:  asprintf(&((*uri)->query),
./src/spdy2http/proxy.c:270:  asprintf(&((*uri)->fragment),
./src/spdy2http/proxy.c:282:      asprintf(&(uri->host_and_port_for_connecting), "%s:80", uri->host_and_port);
./src/spdy2http/proxy.c:287:      asprintf(&(uri->host_and_port_for_connecting), "%s:443", uri->host_and_port);
./src/spdy2http/proxy.c:305:  asprintf(&((*uri)->host), "%.*s", (int)(colon - (*uri)->host_and_port), (*uri)->host_and_port);
./src/spdy2http/proxy.c:318:		*dst = malloc(src_size);
./src/spdy2http/proxy.c:324:	memcpy(*dst + *dst_size, src, src_size);
./src/spdy2http/proxy.c:345:		if(NULL == (newbody = malloc(*src_size - max_size)))
./src/spdy2http/proxy.c:347:		memcpy(newbody, *src + ret, *src_size - ret);
./src/spdy2http/proxy.c:349:	memcpy(dst, *src, ret);
./src/spdy2http/proxy.c:376:  if(NULL == (session_alive = malloc(sizeof(bool))))
./src/spdy2http/proxy.c:705:		proxy->http_body = malloc(realsize);
./src/spdy2http/proxy.c:714:	memcpy(proxy->http_body + proxy->http_body_size, contents, realsize);
./src/spdy2http/proxy.c:770:		if(NULL == (newbody = malloc(proxy->received_body_size - max)))
./src/spdy2http/proxy.c:775:		memcpy(newbody, proxy->received_body + max, proxy->received_body_size - max);
./src/spdy2http/proxy.c:777:	memcpy(ptr, proxy->received_body, ret);
./src/spdy2http/proxy.c:804:	if(NULL == (line = malloc(line_len)))//no recovery
./src/spdy2http/proxy.c:861:	if(NULL == (proxy = malloc(sizeof(struct Proxy))))
./src/spdy2http/proxy.c:882:      ret = asprintf(&(proxy->url),"%s://%s%s", scheme, glob_opt.http_backend, path);
./src/spdy2http/proxy.c:884:      ret = asprintf(&(proxy->url),"%s://%s%s", scheme, host, path);
./src/spdy2http/proxy.c:901:      ret = asprintf(&(proxy->url),"%s://%s%s", uri->scheme, glob_opt.http_backend, uri->path_and_more);
./src/microhttpd/daemon.c:278:      memcpy (&key->addr.ipv4, &addr4->sin_addr, sizeof(addr4->sin_addr));
./src/microhttpd/daemon.c:288:      memcpy (&key->addr.ipv6, &addr6->sin6_addr, sizeof(addr6->sin6_addr));
./src/microhttpd/daemon.c:322:  if (NULL == (key = malloc (sizeof(*key))))
./src/microhttpd/daemon.c:1389:  if (NULL == (connection = malloc (sizeof (struct MHD_Connection))))
./src/microhttpd/daemon.c:1425:  if (NULL == (connection->addr = malloc (addrlen)))
./src/microhttpd/daemon.c:1441:  memcpy (connection->addr, addr, addrlen);
./src/microhttpd/daemon.c:1912: *        not handle the connection (i.e. malloc() failed, etc).
./src/microhttpd/daemon.c:2434:    p = malloc(sizeof (struct pollfd) * (2 + num_connections));
./src/microhttpd/daemon.c:3655:  if (NULL == (daemon = malloc (sizeof (struct MHD_Daemon))))
./src/microhttpd/daemon.c:3769:      daemon->nnc = malloc (daemon->nonce_nc_size * sizeof (struct MHD_NonceNc));
./src/microhttpd/daemon.c:4215:      daemon->worker_pool = malloc (sizeof (struct MHD_Daemon)
./src/microhttpd/daemon.c:4226:          memcpy (d, daemon, sizeof (struct MHD_Daemon));
./src/microhttpd/daemon.c:4227:          /* Adjust pooling params for worker daemons; note that memcpy()
./src/microhttpd/daemon.c:4830:  *ppmtx = malloc (sizeof (MHD_mutex_));
./src/microhttpd/postprocessor.c:317:  if (NULL == (ret = malloc (sizeof (struct MHD_PostProcessor) + buffer_size + 1)))
./src/microhttpd/postprocessor.c:377:          memcpy (&buf[pp->buffer_pos], &post_data[poff], equals);
./src/microhttpd/postprocessor.c:391:          memcpy (xbuf, pp->xbuf, pp->xbuf_pos);
./src/microhttpd/postprocessor.c:414:          memcpy (&xbuf[xoff], &post_data[poff], delta);
./src/microhttpd/postprocessor.c:431:              memcpy (pp->xbuf, &xbuf[delta], xoff - delta);
./src/microhttpd/postprocessor.c:611:      *destination = malloc (vlen);
./src/microhttpd/postprocessor.c:615:      memcpy (*destination, &spos[klen + 2], vlen - 1);
./src/microhttpd/postprocessor.c:850:      memcpy (&buf[pp->buffer_pos], &post_data[poff], max);
./src/microhttpd/response.c:73:  if (NULL == (hdr = malloc (sizeof (struct MHD_HTTP_Header))))
./src/microhttpd/response.c:254:  if (NULL == (response = malloc (sizeof (struct MHD_Response) + block_size)))
./src/microhttpd/response.c:510:  if (NULL == (response = malloc (sizeof (struct MHD_Response))))
./src/microhttpd/response.c:521:      if (NULL == (tmp = malloc (size)))
./src/microhttpd/response.c:527:      memcpy (tmp, data, size);
./src/microhttpd/test_postprocessor.c:170:  memcpy (&xdata[3], FORM_DATA, size);
./src/microhttpd/tsearch.c:44:	q = malloc(sizeof(node_t));		/* T5: key not found */
./src/microhttpd/md5.c:85:      memcpy(ctx->buffer + have, input, need);
./src/microhttpd/md5.c:103:    memcpy(ctx->buffer + have, input, len);
./src/microhttpd/md5.c:173:  memcpy(in, block, sizeof(in));
./src/microhttpd/base64.c:41:  result = dest = malloc(in_len / 4 * 3 + 1);
./src/microhttpd/memorypool.c:91:  pool = malloc (sizeof (struct MemoryPool));
./src/microhttpd/memorypool.c:110:      pool->memory = malloc (max);
./src/microhttpd/memorypool.c:243:      memcpy (ret, old, old_size);
./src/microhttpd/test_postprocessor_large.c:73:  memcpy (data, "key=", 4);
./src/microhttpd/basicauth.c:124:  header = (char*)malloc(hlen);
./src/microhttpd/digestauth.c:278:	      memcpy (dest,
./src/microhttpd/digestauth.c:337:      strcpy(connection->daemon->nnc[off].nonce,
./src/microhttpd/digestauth.c:777:    uri = malloc (left + 1);
./src/microhttpd/digestauth.c:908:    header = malloc(hlen + 1);
./src/microhttpd/connection.c:445:      memcpy (&connection->write_buffer[sizeof (cbuf)],
./src/microhttpd/connection.c:468:      strcpy (connection->write_buffer, "0\r\n");
./src/microhttpd/connection.c:486:  memcpy (&connection->write_buffer[sizeof (cbuf) - cblen], cbuf, cblen);
./src/microhttpd/connection.c:487:  memcpy (&connection->write_buffer[sizeof (cbuf) + ret], "\r\n", 2);
./src/microhttpd/connection.c:585:      sprintf (date,
./src/microhttpd/connection.c:679:      sprintf (code,
./src/microhttpd/connection.c:809:            = sprintf (content_length_buf,
./src/microhttpd/connection.c:859:      memcpy (data, code, off);
./src/microhttpd/connection.c:864:      memcpy (&data[off],
./src/microhttpd/connection.c:872:      memcpy (&data[off],
./src/microhttpd/connection.c:880:      memcpy (&data[off],
./src/microhttpd/connection.c:888:      memcpy (&data[off],
./src/microhttpd/connection.c:899:      off += sprintf (&data[off],
./src/microhttpd/connection.c:905:      strcpy (&data[off], date);
./src/microhttpd/connection.c:908:  memcpy (&data[off], "\r\n", 2);
./src/microhttpd/connection.c:1321:  memcpy (cpy, hdr, strlen (hdr) + 1);
./src/microhttpd/connection.c:1855:      memcpy (&last[last_len], tmp, tmp_len + 1);
./src/testzzuf/test_put_large.c:68:  memcpy (stream, &put_buffer[*pos], wrt);
./src/testzzuf/test_put_large.c:80:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_put_large.c:372:  put_buffer = malloc (PUT_SIZE);
./src/testzzuf/test_post_form.c:73:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_post.c:75:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_put_chunked.c:60:  memcpy (stream, &("Hello123"[*pos]), wrt);
./src/testzzuf/test_put_chunked.c:72:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_get_chunked.c:55:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_get_chunked.c:111:  responseptr = malloc (sizeof (struct MHD_Response *));
./src/testzzuf/test_get.c:57:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/testzzuf/test_long_header.c:123:      url = malloc (VERY_LONG);
./src/testzzuf/test_long_header.c:126:      memcpy (url, "http://localhost:11081/",
./src/testzzuf/test_long_header.c:183:      url = malloc (VERY_LONG);
./src/testzzuf/test_put.c:60:  memcpy (stream, &("Hello123"[*pos]), wrt);
./src/testzzuf/test_put.c:72:  memcpy (&cbc->buf[cbc->pos], ptr, size * nmemb);
./src/include/autoinit_funcs.h:40:     somePtr = malloc(100);
./src/include/microhttpd.h:1612: *        not handle the connection (i.e. `malloc()` failed, etc).
./src/include/microhttpd.h:2045:   * Buffer is heap-allocated with `malloc()` (or equivalent) and
./src/include/microhttpd.h:2054:   * on the stack or non-`malloc()` allocated) and only valid during the
./doc/examples/largepost.c:158:      con_info = malloc (sizeof (struct connection_info_struct));
./doc/examples/simplepost.c:78:          answerstring = malloc (MAXANSWERSIZE);
./doc/examples/simplepost.c:125:      con_info = malloc (sizeof (struct connection_info_struct));
./doc/examples/sessions.c:16:asprintf (char **resultp, const char *format, ...)
./doc/examples/sessions.c:31:    result = (char *) malloc (sizeof (char *) * len);
./doc/examples/sessions.c:194:  ret = calloc (1, sizeof (struct Session));
./doc/examples/sessions.c:340:  if (-1 == asprintf (&reply,
./doc/examples/sessions.c:382:  if (-1 == asprintf (&reply,
./doc/examples/sessions.c:496:      memcpy (&session->value_1[off],
./doc/examples/sessions.c:507:      memcpy (&session->value_2[off],
./doc/examples/sessions.c:572:      request = calloc (1, sizeof (struct Request));
./doc/examples/tlsauthentication.c:36:  tmp = malloc (length * 2);
./doc/examples/tlsauthentication.c:101:  buffer = malloc (size);
./doc/examples/tlsauthentication.c:131:  headervalue = malloc (strlen (strbase) + strlen (realm) + 1);
./doc/examples/tlsauthentication.c:135:  strcpy (headervalue, strbase);
./doc/examples/tlsauthentication.c:170:  expected = malloc (strlen (username) + 1 + strlen (password) + 1);
./doc/examples/tlsauthentication.c:174:  strcpy (expected, username);

== files() ==
./src/testspdy/test_proxies.c:110:		devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_proxies.c:135:		devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_proxies.c:161:		devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_proxies.c:190:		devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_proxies.c:201:    p = popen(cmd, "r");
./src/testspdy/test_request_response_with_callback.c:132:		FILE *fd = fopen(DATA_DIR "spdy-draft.txt","r");
./src/testspdy/test_request_response_with_callback.c:247:    FILE *p = popen(cmd, "r");
./src/testspdy/test_misc.c:81:		devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_session_timeout.c:281:	/*devnull = open("/dev/null", O_RDONLY);
./src/testspdy/test_session_timeout.c:287:	devnull = open("/dev/null", O_WRONLY);
./src/testspdy/test_session_timeout.c:295:	devnull = open("/dev/null", O_WRONLY);
./src/examples/spdy_response_with_callback.c:104:		FILE *fd = fopen(DATA_DIR "spdy-draft.txt","r");
./src/examples/digest_auth_example.c:103:  fd = open("/dev/urandom", O_RDONLY);
./src/examples/spdy_fileserver.c:179:			if(NULL == (fd = fopen(fname,"r"))
./src/examples/fileserver_example_external_select.c:74:    file = fopen (&url[1], "rb");
./src/examples/fileserver_example_dirs.c:106:    file = fopen (&url[1], "rb");
./src/examples/https_fileserver_example.c:142:    file = fopen (&url[1], "rb");
./src/examples/fileserver_example.c:79:    file = fopen (&url[1], "rb");
./src/examples/demo.c:550:      uc->fd = open (fn,
./src/examples/demo.c:699:	fd = open (&url[1], O_RDONLY);
./src/examples/demo.c:862:  magic = magic_open (MAGIC_MIME_TYPE);
./src/examples/demo_https.c:551:      uc->fd = open (fn,
./src/examples/demo_https.c:699:	fd = open (&url[1], O_RDONLY);
./src/examples/demo_https.c:911:  magic = magic_open (MAGIC_MIME_TYPE);
./src/testcurl/https/tls_test_common.c:37:  if (NULL == (cert_fd = fopen (ca_cert_file_name, "wb+")))
./src/testcurl/test_get_sendfile.c:99:  fd = open (sourcefile, O_RDONLY);
./src/testcurl/test_get_sendfile.c:480:  f = fopen (sourcefile, "w");
./src/testcurl/test_digestauth.c:148:  fd = open("/dev/urandom", O_RDONLY);
./src/testcurl/test_digestauth_with_arguments.c:143:  fd = open("/dev/urandom", O_RDONLY);
./doc/examples/responseheaders.c:36:  if ( (-1 == (fd = open (FILENAME, O_RDONLY))) ||
./doc/examples/largepost.c:93:      if (NULL != (fp = fopen (filename, "rb")))
./doc/examples/largepost.c:101:      con_info->fp = fopen (filename, "ab");
./doc/examples/tlsauthentication.c:70:  fp = fopen (filename, "rb");
./doc/examples/tlsauthentication.c:97:  fp = fopen (filename, "rb");

== logging() ==
./src/microspdy/io_openssl.c:195:		ret = SSL_get_error(session->io_context, n);
./src/microspdy/io_openssl.c:231:		ret = SSL_get_error(session->io_context, n);
./src/microspdy/session.h:149: * @return SPDY_NO on error (not enough memory) or
./src/microspdy/session.h:201: * @return SPDY_NO on error (not enough memory or the user calback for
./src/microspdy/session.h:216: * @return SPDY_NO on error (zlib state is broken; the session MUST be
./src/microspdy/session.h:231: * @return SPDY_NO on error (not enough memory; by specification the
./src/microspdy/session.h:245: * @return SPDY_NO on error (not enough memory). If
./src/microspdy/session.h:259: * @return SPDY_NO on error (not enough memory). If
./src/microspdy/internal.h:68: * @param msg error message (const char *)
./src/microspdy/internal.h:78: * @param msg message to print on error (const char *)
./src/microspdy/internal.h:181: * @param msg message (const char *)
./src/testspdy/test_new_connection.c:185:          spdylay_strerror(error_code));
./src/testspdy/test_new_connection.c:232:  ERR_clear_error();
./src/testspdy/test_new_connection.c:235:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_new_connection.c:264:  ERR_clear_error();
./src/testspdy/test_new_connection.c:267:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_new_connection.c:502:    dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:504:  ERR_clear_error();
./src/testspdy/test_new_connection.c:507:    dief("SSL_connect", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:528:    dief("getaddrinfo", gai_strerror(rv));
./src/testspdy/test_new_connection.c:552:    dief("fcntl", strerror(errno));
./src/testspdy/test_new_connection.c:556:    dief("fcntl", strerror(errno));
./src/testspdy/test_new_connection.c:569:    dief("setsockopt", strerror(errno));
./src/testspdy/test_new_connection.c:677:    dief("SSL_CTX_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:682:    dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:713:      dief("poll", strerror(errno));
./src/testspdy/test_notls.c:164:          spdylay_strerror(error_code));
./src/testspdy/test_notls.c:479:    dief("getaddrinfo", gai_strerror(rv));
./src/testspdy/test_notls.c:493:    dief("connect", strerror(errno));
./src/testspdy/test_notls.c:504:    dief("fcntl1", strerror(errno));
./src/testspdy/test_notls.c:508:    dief("fcntl2", strerror(errno));
./src/testspdy/test_notls.c:521:    dief("setsockopt", strerror(errno));
./src/testspdy/test_notls.c:650:      dief("poll", strerror(errno));
./src/testspdy/test_request_response.c:167:          spdylay_strerror(error_code));
./src/testspdy/test_request_response.c:214:  ERR_clear_error();
./src/testspdy/test_request_response.c:217:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_request_response.c:246:  ERR_clear_error();
./src/testspdy/test_request_response.c:249:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_request_response.c:490:    dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:492:  ERR_clear_error();
./src/testspdy/test_request_response.c:495:    dief("SSL_connect", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:516:    dief("getaddrinfo", gai_strerror(rv));
./src/testspdy/test_request_response.c:540:    dief("fcntl", strerror(errno));
./src/testspdy/test_request_response.c:544:    dief("fcntl", strerror(errno));
./src/testspdy/test_request_response.c:557:    dief("setsockopt", strerror(errno));
./src/testspdy/test_request_response.c:664:    dief("SSL_CTX_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:669:    dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:700:      dief("poll", strerror(errno));
./src/examples/digest_auth_example.c:108:	       strerror (errno));
./src/examples/digest_auth_example.c:119:		   strerror (errno));
./src/examples/mhd2spdy.c:109:    PRINT_INFO2("SSL_CTX_new %s", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:61:          spdylay_strerror(error_code));
./src/examples/mhd2spdy_spdy.c:166:    ERR_clear_error();
./src/examples/mhd2spdy_spdy.c:169:      int err = SSL_get_error(connection->ssl, rv);
./src/examples/mhd2spdy_spdy.c:237:    ERR_clear_error();
./src/examples/mhd2spdy_spdy.c:240:      int err = SSL_get_error(connection->ssl, rv);
./src/examples/mhd2spdy_spdy.c:559:    spdy_dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:561:  ERR_clear_error();
./src/examples/mhd2spdy_spdy.c:564:    PRINT_INFO2("SSL_connect %s", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:593:    spdy_dief("getaddrinfo", gai_strerror(rv));
./src/examples/mhd2spdy_spdy.c:622:    spdy_dief("fcntl", strerror(errno));
./src/examples/mhd2spdy_spdy.c:627:    spdy_dief("fcntl", strerror(errno));
./src/examples/mhd2spdy_spdy.c:642:    spdy_dief("setsockopt", strerror(errno));
./src/examples/mhd2spdy_spdy.c:748:      spdy_dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/examples/fileserver_example_dirs.c:119:		    strerror (errno));
./src/examples/post_example.c:175:      fprintf (stderr, "calloc error: %s\n", strerror (errno));
./src/examples/post_example.c:558:	  fprintf (stderr, "calloc error: %s\n", strerror (errno));
./src/examples/demo.c:562:		   strerror (errno));
./src/examples/demo.c:575:	       strerror (errno));
./src/examples/demo.c:717:	  /* internal error (i.e. out of memory) */
./src/examples/demo.c:831:             "Failed to install SIGPIPE handler: %s\n", strerror (errno));
./src/examples/demo_https.c:563:		   strerror (errno));
./src/examples/demo_https.c:576:	       strerror (errno));
./src/examples/demo_https.c:717:	  /* internal error (i.e. out of memory) */
./src/examples/demo_https.c:830:             "Failed to install SIGPIPE handler: %s\n", strerror (errno));
./src/testcurl/https/test_https_get_select.c:185:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/https/test_https_get_select.c:217:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/tls_test_common.c:40:               ca_cert_file_name, strerror (errno));
./src/testcurl/https/tls_test_common.c:47:               ca_cert_file_name, strerror (errno));
./src/testcurl/https/tls_test_common.c:54:               strerror (errno));
./src/testcurl/https/tls_test_common.c:118:               curl_easy_strerror (errornum));
./src/testcurl/https/tls_test_common.c:247:               curl_easy_strerror (errornum));
./src/testcurl/https/tls_test_common.c:280:               strerror (errno));
./src/testcurl/https/test_https_get.c:111:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_https_get_parallel_threads.c:160:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_empty_response.c:165:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/https/test_empty_response.c:194:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_https_sni.c:91:               gnutls_strerror (ret));
./src/testcurl/https/test_https_sni.c:114:               gnutls_strerror (ret));
./src/testcurl/https/test_https_sni.c:225:               curl_easy_strerror (errornum));
./src/testcurl/https/test_https_sni.c:258:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_https_time_out.c:56:      fprintf (stderr, "Failed to create socket: %s\n", strerror (errno));
./src/testcurl/https/test_https_get_parallel.c:144:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_tls_options.c:51:               strerror (errno));
./src/testcurl/https/test_tls_options.c:111:      fprintf (stderr, "Error: %s\n", strerror (errno));
./src/testcurl/https/test_https_session_info.c:152:               curl_easy_strerror (errornum));
./src/testcurl/test_iplimit.c:258:                         curl_easy_strerror (errornum));
./src/testcurl/test_process_arguments.c:210:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_postform.c:213:               curl_easy_strerror (errornum));
./src/testcurl/test_postform.c:269:               curl_easy_strerror (errornum));
./src/testcurl/test_postform.c:326:               curl_easy_strerror (errornum));
./src/testcurl/test_postform.c:449:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/perf_get.c:222:		   curl_easy_strerror (errornum));
./src/testcurl/perf_get.c:282:		   curl_easy_strerror (errornum));
./src/testcurl/perf_get.c:342:		   curl_easy_strerror (errornum));
./src/testcurl/perf_get.c:461:			    __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_get_sendfile.c:151:               curl_easy_strerror (errornum));
./src/testcurl/test_get_sendfile.c:201:               curl_easy_strerror (errornum));
./src/testcurl/test_get_sendfile.c:252:               curl_easy_strerror (errornum));
./src/testcurl/test_get_sendfile.c:365:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_get_sendfile.c:449:               curl_easy_strerror (errornum));
./src/testcurl/test_large_put.c:185:               curl_easy_strerror (errornum));
./src/testcurl/test_large_put.c:243:               curl_easy_strerror (errornum));
./src/testcurl/test_large_put.c:305:               curl_easy_strerror (errornum));
./src/testcurl/test_large_put.c:429:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_callback.c:181:			    __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_post_loop.c:155:                   curl_easy_strerror (errornum));
./src/testcurl/test_post_loop.c:219:                   curl_easy_strerror (errornum));
./src/testcurl/test_post_loop.c:284:                   curl_easy_strerror (errornum));
./src/testcurl/test_post_loop.c:412:		       strerror (errno));
./src/testcurl/test_post_loop.c:428:                            __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_get_response_cleanup.c:76:	   strerror (errno));
./src/testcurl/perf_get_concurrent.c:205:			   curl_easy_strerror (errornum));
./src/testcurl/perf_get_concurrent.c:322:		   strerror (errno));
./src/testcurl/test_post.c:201:               curl_easy_strerror (errornum));
./src/testcurl/test_post.c:255:               curl_easy_strerror (errornum));
./src/testcurl/test_post.c:310:               curl_easy_strerror (errornum));
./src/testcurl/test_post.c:427:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_post.c:596:               curl_easy_strerror (errornum), errornum);
./src/testcurl/test_post.c:605:      fprintf(stderr, "curl_easy_getinfo failed: '%s'\n", curl_easy_strerror(errornum));
./src/testcurl/test_digestauth.c:153:              strerror(errno));
./src/testcurl/test_digestauth.c:163:                  strerror(errno));
./src/testcurl/test_digestauth.c:217:               curl_easy_strerror (errornum));
./src/testcurl/test_put_chunked.c:172:               curl_easy_strerror (errornum));
./src/testcurl/test_put_chunked.c:228:               curl_easy_strerror (errornum));
./src/testcurl/test_put_chunked.c:286:               curl_easy_strerror (errornum));
./src/testcurl/test_put_chunked.c:407:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/gauger.h:69:            perror("gauger");\
./src/testcurl/test_parse_cookies.c:211:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_digestauth_with_arguments.c:148:		   strerror(errno));
./src/testcurl/test_digestauth_with_arguments.c:158:			   strerror(errno));
./src/testcurl/test_digestauth_with_arguments.c:212:               curl_easy_strerror (errornum));
./src/testcurl/test_quiesce.c:214:               curl_easy_strerror (errornum));
./src/testcurl/test_quiesce.c:245:               curl_easy_strerror (errornum));
./src/testcurl/test_quiesce.c:389:                          __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_process_headers.c:183:               curl_easy_strerror (errornum));
./src/testcurl/test_process_headers.c:232:               curl_easy_strerror (errornum));
./src/testcurl/test_process_headers.c:282:               curl_easy_strerror (errornum));
./src/testcurl/test_process_headers.c:394:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_urlparse.c:160:               curl_easy_strerror (errornum));
./src/testcurl/test_get_chunked.c:187:               curl_easy_strerror (errornum));
./src/testcurl/test_get_chunked.c:229:               curl_easy_strerror (errornum));
./src/testcurl/test_get_chunked.c:272:               curl_easy_strerror (errornum));
./src/testcurl/test_get_chunked.c:377:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_get.c:145:               curl_easy_strerror (errornum));
./src/testcurl/test_get.c:195:               curl_easy_strerror (errornum));
./src/testcurl/test_get.c:246:               curl_easy_strerror (errornum));
./src/testcurl/test_get.c:359:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/testcurl/test_get.c:443:               curl_easy_strerror (errornum));
./src/testcurl/test_get.c:589:               curl_easy_strerror (errornum));
./src/testcurl/test_put.c:162:               curl_easy_strerror (errornum));
./src/testcurl/test_put.c:218:               curl_easy_strerror (errornum));
./src/testcurl/test_put.c:276:               curl_easy_strerror (errornum));
./src/testcurl/test_put.c:397:                        __LINE__, curl_easy_strerror (msg->data.result));
./src/microhttpd/daemon.c:491:         really understand the error (not listed in GnuTLS
./src/microhttpd/daemon.c:574:                  gnutls_strerror (ret));
./src/microhttpd/daemon.c:3300:			  gnutls_strerror (ret));
./src/microhttpd/postprocessor.c:267: * @return NULL on error (out of memory, unsupported encoding),
./src/microhttpd/response.c:51: * @return #MHD_NO on error (i.e. invalid header or content format).
./src/microhttpd/response.c:99: * @return #MHD_NO on error (i.e. invalid header or content format).
./src/microhttpd/response.c:119: * @return #MHD_NO on error (i.e. invalid footer or content format).
./src/microhttpd/response.c:139: * @return #MHD_NO on error (no such header known)
./src/microhttpd/response.c:240: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:392: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:417: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:455: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:476: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:497: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/response.c:549: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/microhttpd/internal.h:92: * @param msg error message (const char *)
./src/microhttpd/internal.h:99: * @param msg error message (const char *)
./src/microhttpd/connection.c:293: * @param emsg error message (can be NULL)
./src/microhttpd/connection.c:296:connection_close_error (struct MHD_Connection *connection,
./src/microhttpd/connection.c:313:#define CONNECTION_CLOSE_ERROR(c, emsg) connection_close_error (c, emsg)
./src/microhttpd/connection.c:315:#define CONNECTION_CLOSE_ERROR(c, emsg) connection_close_error (c, NULL)
./src/microhttpd/connection.c:1773: * @return #MHD_YES on success, #MHD_NO on error (malformed @a line)
./src/microhttpd/connection.c:2891: * @return #MHD_NO on error (i.e. reply already sent),
./src/testzzuf/test_put_chunked.c:216:               curl_easy_strerror (errornum));
./src/testzzuf/socat.c:72:      fprintf (stderr, "fork failed: %s\n", strerror (errno));
./src/testzzuf/socat.c:94:  fprintf (stderr, "execution of `zzuf' failed: %s\n", strerror (errno));
./src/testzzuf/socat.c:107:        fprintf (stderr, "Failed to killpg: %s\n", strerror (errno));
./src/include/microhttpd.h:209:#define _MHD_DEPR_MACRO(msg) __pragma(message(__FILE__ "(" _MHD_STRMACRO(__LINE__)"): warning: " msg))
./src/include/microhttpd.h:1881: * @return #MHD_NO on error (i.e. reply already sent),
./src/include/microhttpd.h:1996: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2016: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2071: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2088: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2106: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2127: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2156: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2295: * @return NULL on error (i.e. invalid arguments, out of memory)
./src/include/microhttpd.h:2321: * @return #MHD_NO on error (i.e. invalid header or content format),
./src/include/microhttpd.h:2337: * @return #MHD_NO on error (i.e. invalid footer or content format).
./src/include/microhttpd.h:2352: * @return #MHD_NO on error (no such header known)
./src/include/microhttpd.h:2412: * @return NULL on error (out of memory, unsupported encoding),
./src/include/platform_interface.h:119: *                            description string of last socket error (W32) */
./src/include/platform_interface.h:121:#define MHD_socket_last_strerr_() strerror(errno)
./src/include/platform_interface.h:126:/* MHD_strerror_ is strerror (both non-W32/W32) */
./src/include/platform_interface.h:128:#define MHD_strerror_(errnum) strerror((errnum))
./src/include/platform_interface.h:177: *                            description string of last pipe error (MHD_DONT_USE_PIPES) */
./src/include/platform_interface.h:179:#define MHD_pipe_last_strerror_() strerror(errno)
./src/platform/w32functions.c:187:  return strerror(errnum);
./doc/examples/sessions.c:197:      fprintf (stderr, "calloc error: %s\n", strerror (errno));
./doc/examples/sessions.c:575:	  fprintf (stderr, "calloc error: %s\n", strerror (errno));
./doc/examples/sessions.c:766:		     strerror (errno));

== environment() ==
./src/testcurl/test_get_sendfile.c:471:  if ( (NULL == (tmp = getenv ("TMPDIR"))) &&
./src/testcurl/test_get_sendfile.c:472:       (NULL == (tmp = getenv ("TMP"))) &&
./src/testcurl/test_get_sendfile.c:473:       (NULL == (tmp = getenv ("TEMP"))) )

== privileged() ==

== networking() ==
./src/microspdy/daemon.c:139:			case SPDY_DAEMON_OPTION_SOCK_ADDR:
./src/microspdy/daemon.c:250:		&& NULL != daemon->address && AF_INET6 != daemon->address->sa_family)
./src/microspdy/daemon.c:266:		servaddr6->sin6_family = AF_INET6;
./src/microspdy/daemon.c:272:  if(AF_INET6 == daemon->address->sa_family)
./src/microspdy/daemon.c:274:    afamily = PF_INET6;
./src/microspdy/daemon.c:278:    afamily = PF_INET;
./src/microspdy/daemon.c:298:		servaddr4->sin_family = AF_INET;
./src/microspdy/daemon.c:304:	afamily = PF_INET;
./src/microspdy/daemon.c:307:	daemon->socket_fd = socket (afamily, SOCK_STREAM, 0);
./src/microspdy/daemon.c:381:	if(!(SPDY_DAEMON_OPTION_SOCK_ADDR & daemon->options))
./src/testspdy/test_new_connection.c:524:  hints.ai_family = AF_UNSPEC;
./src/testspdy/test_new_connection.c:525:  hints.ai_socktype = SOCK_STREAM;
./src/testspdy/test_new_connection.c:847:	if(AF_INET == addr->sa_family)
./src/testspdy/test_new_connection.c:850:		if(NULL == inet_ntop(AF_INET, &(addr4->sin_addr), ipstr, sizeof(ipstr)))
./src/testspdy/test_new_connection.c:859:	else if(AF_INET6 == addr->sa_family)
./src/testspdy/test_new_connection.c:862:		if(NULL == inet_ntop(AF_INET6, &(addr6->sin6_addr), ipstr, sizeof(ipstr)))
./src/testspdy/test_notls.c:475:  hints.ai_family = AF_UNSPEC;
./src/testspdy/test_notls.c:476:  hints.ai_socktype = SOCK_STREAM;
./src/testspdy/test_request_response.c:512:  hints.ai_family = AF_UNSPEC;
./src/testspdy/test_request_response.c:513:  hints.ai_socktype = SOCK_STREAM;
./src/examples/spdy_event_loop.c:71:	if(AF_INET == addr->sa_family)
./src/examples/spdy_event_loop.c:74:		if(NULL == inet_ntop(AF_INET, &(addr4->sin_addr), ipstr, sizeof(ipstr)))
./src/examples/spdy_event_loop.c:82:	else if(AF_INET6 == addr->sa_family)
./src/examples/spdy_event_loop.c:85:		if(NULL == inet_ntop(AF_INET6, &(addr6->sin6_addr), ipstr, sizeof(ipstr)))
./src/examples/spdy_event_loop.c:315:	addr4.sin_family = AF_INET;
./src/examples/spdy_event_loop.c:325:	//SPDY_DAEMON_OPTION_SOCK_ADDR,  (struct sockaddr *)&addr4,
./src/examples/spdy_event_loop.c:335:	addr6.sin6_family = AF_INET6;
./src/examples/spdy_event_loop.c:345:	//SPDY_DAEMON_OPTION_SOCK_ADDR,  (struct sockaddr *)&addr6,
./src/examples/mhd2spdy_spdy.c:587:  hints.ai_family = AF_UNSPEC;
./src/examples/mhd2spdy_spdy.c:588:  hints.ai_socktype = SOCK_STREAM;
./src/testcurl/https/test_https_time_out.c:53:  sd = socket (AF_INET, SOCK_STREAM, 0);
./src/testcurl/https/test_https_time_out.c:61:  sa.sin_family = AF_INET;
./src/testcurl/test_get_sendfile.c:403:  addr.sin_family = AF_INET;
./src/testcurl/test_get_sendfile.c:412:                        MHD_OPTION_SOCK_ADDR, &addr,
./src/testcurl/test_get_sendfile.c:424:  if (addr.sin_family != AF_INET)
./src/testcurl/test_options.c:69: * Test daemon initialization with the MHD_OPTION_SOCK_ADDR option
./src/testcurl/test_options.c:81:  daemon_ip_addr.sin_family = AF_INET;
./src/testcurl/test_options.c:87:  daemon_ip_addr6.sin6_family = AF_INET6;
./src/testcurl/test_options.c:93:                        NULL, NULL, &ahc_echo, NULL, MHD_OPTION_SOCK_ADDR,
./src/testcurl/test_options.c:103:                        NULL, NULL, &ahc_echo, NULL, MHD_OPTION_SOCK_ADDR,
./src/testcurl/test_get.c:397:  addr.sin_family = AF_INET;
./src/testcurl/test_get.c:406:                        MHD_OPTION_SOCK_ADDR, &addr,
./src/testcurl/test_get.c:418:  if (addr.sin_family != AF_INET)
./src/testcurl/test_get.c:471:    fd = socket (PF_INET, SOCK_STREAM, 0);
./src/testcurl/test_get.c:479:    sin.sin_family = AF_INET;
./src/spdy2http/proxy.c:1035:    hints.ai_family = AF_INET;
./src/spdy2http/proxy.c:1036:    hints.ai_socktype = SOCK_STREAM;
./src/spdy2http/proxy.c:1058:                SPDY_DAEMON_OPTION_SOCK_ADDR,
./src/microhttpd/daemon.c:27:#if defined(MHD_WINSOCK_SOCKETS)
./src/microhttpd/daemon.c:77:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:113:#ifndef SOCK_CLOEXEC
./src/microhttpd/daemon.c:114:#define SOCK_CLOEXEC 0
./src/microhttpd/daemon.c:184:   * Address family. AF_INET or AF_INET6 for now.
./src/microhttpd/daemon.c:277:      key->family = AF_INET;
./src/microhttpd/daemon.c:287:      key->family = AF_INET6;
./src/microhttpd/daemon.c:636:#ifdef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:644:#else  /* ! MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:647:#endif /* ! MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:1060:#else  /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:1063:#endif /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:1107:#else  /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:1110:#endif /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:1316:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:1463:#if !defined(MHD_WINSOCK_SOCKETS)
./src/microhttpd/daemon.c:1842:#ifdef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:1962:#ifdef HAVE_SOCK_NONBLOCK
./src/microhttpd/daemon.c:1963:  nonblock = SOCK_NONBLOCK;
./src/microhttpd/daemon.c:1972:  s = accept4 (fd, addr, &addrlen, SOCK_CLOEXEC | nonblock);
./src/microhttpd/daemon.c:1997:#if !defined(HAVE_ACCEPT4) || HAVE_ACCEPT4+0 == 0 || !defined(HAVE_SOCK_NONBLOCK) || SOCK_CLOEXEC+0 == 0
./src/microhttpd/daemon.c:3185:        case MHD_OPTION_SOCK_ADDR:
./src/microhttpd/daemon.c:3405:		case MHD_OPTION_SOCK_ADDR:
./src/microhttpd/daemon.c:3480: * Create a listen socket, if possible with SOCK_CLOEXEC flag set.
./src/microhttpd/daemon.c:3483: * @param domain socket domain (i.e. PF_INET)
./src/microhttpd/daemon.c:3484: * @param type socket type (usually SOCK_STREAM)
./src/microhttpd/daemon.c:3491:  int ctype = type | SOCK_CLOEXEC;
./src/microhttpd/daemon.c:3494:  /* use SOCK_STREAM rather than ai_socktype: some getaddrinfo
./src/microhttpd/daemon.c:3497:  if ( (MHD_INVALID_SOCKET == fd) && (EINVAL == MHD_socket_errno_) && (0 != SOCK_CLOEXEC) )
./src/microhttpd/daemon.c:3622:#elif defined(MHD_WINSOCK_SOCKETS)
./src/microhttpd/daemon.c:3624:#endif /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:3673:#if defined(MHD_WINSOCK_SOCKETS) || defined(CYGWIN)
./src/microhttpd/daemon.c:3712:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:3839:				   PF_INET6, SOCK_STREAM, 0);
./src/microhttpd/daemon.c:3842:				   PF_INET, SOCK_STREAM, 0);
./src/microhttpd/daemon.c:3967:	      servaddr6.sin6_family = AF_INET6;
./src/microhttpd/daemon.c:3978:	      servaddr4.sin_family = AF_INET;
./src/microhttpd/daemon.c:3996:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:4078:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:4183:#if !defined(MHD_WINSOCK_SOCKETS)
./src/microhttpd/daemon.c:4202:#if !defined(MHD_WINSOCK_SOCKETS)
./src/microhttpd/daemon.c:4212:#endif /* MHD_WINSOCK_SOCKETS */
./src/microhttpd/daemon.c:4244:#ifndef MHD_WINSOCK_SOCKETS
./src/microhttpd/daemon.c:4405:#if MHD_WINSOCK_SOCKETS
./src/include/microhttpd.h:188:#define MHD_WINSOCK_SOCKETS 1
./src/include/microhttpd.h:723:  MHD_OPTION_SOCK_ADDR = 6,
./src/include/microspdy.h:368:  SPDY_DAEMON_OPTION_SOCK_ADDR = 2,
./src/include/platform_interface.h:87:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:102:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:112:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:120:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:127:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:134:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:141:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:149:#if !defined(MHD_WINSOCK_SOCKETS)
./src/include/platform_interface.h:151:#else  /* MHD_WINSOCK_SOCKETS */
./src/include/platform_interface.h:153:#endif /* MHD_WINSOCK_SOCKETS */
./src/include/platform_interface.h:162:#define MHD_pipe_(fdarr) socketpair(AF_LOCAL, SOCK_STREAM, 0, (fdarr))
./src/include/platform.h:63:#define _OPEN_SYS_SOCK_IPV6
./src/include/platform.h:184:#define MHD_WINSOCK_SOCKETS 1
./src/platform/w32functions.c:573:      listen_s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/platform/w32functions.c:577:      listen_addr.sin_family = AF_INET;
./src/platform/w32functions.c:585:          SOCKET client_s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./w32/VS2013/MHD_config.h:61:/* Define to 1 if you have the declaration of `SOCK_NONBLOCK', and to 0 if you
./w32/VS2013/MHD_config.h:63:#define HAVE_DECL_SOCK_NONBLOCK 0
./src/microspdy/io_openssl.c:189:	int n = SSL_read(session->io_context,
./src/microspdy/io_openssl.c:225:	int n = SSL_write(session->io_context,
./src/microspdy/io_openssl.c:266:SPDYF_openssl_before_write(struct SPDY_Session *session)
./src/microspdy/io_openssl.c:275:SPDYF_openssl_after_write(struct SPDY_Session *session, int was_written)
./src/microspdy/daemon.c:104:		SPDYF_session_write(session,true);
./src/microspdy/daemon.c:307:	daemon->socket_fd = socket (afamily, SOCK_STREAM, 0);
./src/microspdy/daemon.c:333:	if (-1 == bind (daemon->socket_fd, daemon->address, addrlen))
./src/microspdy/daemon.c:339:	if (listen (daemon->socket_fd, 20) < 0)
./src/microspdy/daemon.c:513:				SPDYF_session_read(pos);
./src/microspdy/daemon.c:527:				if(SPDY_NO == SPDYF_session_write(pos, false))
./src/microspdy/io_openssl.h:151:SPDYF_openssl_before_write(struct SPDY_Session *session);
./src/microspdy/io_openssl.h:163:SPDYF_openssl_after_write(struct SPDY_Session *session, int was_written);
./src/microspdy/io_raw.c:97:	int n = read(session->socket_fd, 
./src/microspdy/io_raw.c:126:	int n = write(session->socket_fd, 
./src/microspdy/io_raw.c:160:SPDYF_raw_before_write(struct SPDY_Session *session)
./src/microspdy/io_raw.c:179:SPDYF_raw_after_write(struct SPDY_Session *session, int was_written)
./src/microspdy/session.c:866:SPDYF_session_read (struct SPDY_Session *session)
./src/microspdy/session.c:981:SPDYF_session_write (struct SPDY_Session *session,
./src/microspdy/session.c:992:  if(SPDY_NO == session->fio_before_write(session))
./src/microspdy/session.c:1047:						SPDYF_session_write(session,true);
./src/microspdy/session.c:1133:			SPDYF_stream_set_flags_on_write(queue_head);
./src/microspdy/session.c:1150:	return session->fio_after_write(session, i>0 ? SPDY_YES : SPDY_NO);
./src/microspdy/session.c:1170:		SPDYF_session_write(session,true);
./src/microspdy/session.c:1258:				//SPDYF_session_write(session,false);
./src/microspdy/stream.h:63:SPDYF_stream_set_flags_on_write(struct SPDYF_Response_Queue *response_queue);
./src/microspdy/session.h:44:SPDYF_session_read (struct SPDY_Session *session);
./src/microspdy/session.h:68:SPDYF_session_write (struct SPDY_Session *session,
./src/microspdy/io_raw.h:144:SPDYF_raw_before_write(struct SPDY_Session *session);
./src/microspdy/io_raw.h:156:SPDYF_raw_after_write(struct SPDY_Session *session, int was_written);
./src/microspdy/stream.c:126:SPDYF_stream_set_flags_on_write(struct SPDYF_Response_Queue *response_queue)
./src/testspdy/test_new_connection.c:113:     similar functions like spdylay_session_want_read() and
./src/testspdy/test_new_connection.c:114:     spdylay_session_want_write() but they do not take into account
./src/testspdy/test_new_connection.c:233:  rv = SSL_write(connection->ssl, data, length);
./src/testspdy/test_new_connection.c:265:  rv = SSL_read(connection->ssl, buf, length);
./src/testspdy/test_new_connection.c:424:        fwrite(out, 1, outlen, stdout);
./src/testspdy/test_new_connection.c:430:      fwrite(data, 1, len, stdout);
./src/testspdy/test_new_connection.c:505:  rv = SSL_connect(ssl);
./src/testspdy/test_new_connection.c:531:    fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
./src/testspdy/test_new_connection.c:535:    while((rv = connect(fd, rp->ai_addr, rp->ai_addrlen)) == -1 &&
./src/testspdy/test_new_connection.c:579:  if(spdylay_session_want_read(connection->session) ||
./src/testspdy/test_new_connection.c:583:  if(spdylay_session_want_write(connection->session) ||
./src/testspdy/test_new_connection.c:709:  while(spdylay_session_want_read(connection.session) ||
./src/testspdy/test_new_connection.c:710:        spdylay_session_want_write(connection.session)) {
./src/testspdy/test_notls.c:91:     similar functions like spdylay_session_want_read() and
./src/testspdy/test_notls.c:92:     spdylay_session_want_write() but they do not take into account
./src/testspdy/test_notls.c:212:    rv = write(connection->fd,
./src/testspdy/test_notls.c:253:    rv = read(connection->fd,
./src/testspdy/test_notls.c:422:        fwrite(out, 1, outlen, stdout);
./src/testspdy/test_notls.c:428:      fwrite(data, 1, len, stdout);
./src/testspdy/test_notls.c:482:    fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
./src/testspdy/test_notls.c:486:    while((rv = connect(fd, rp->ai_addr, rp->ai_addrlen)) == -1 &&
./src/testspdy/test_notls.c:531:  if(spdylay_session_want_read(connection->session) ||
./src/testspdy/test_notls.c:535:  if(spdylay_session_want_write(connection->session) ||
./src/testspdy/test_notls.c:646:  while(spdylay_session_want_read(connection.session) ||
./src/testspdy/test_notls.c:647:        spdylay_session_want_write(connection.session)) {
./src/testspdy/test_request_response_with_callback.c:74:	int ret = fread(buffer,1,n,fd);
./src/testspdy/test_request_response.c:95:     similar functions like spdylay_session_want_read() and
./src/testspdy/test_request_response.c:96:     spdylay_session_want_write() but they do not take into account
./src/testspdy/test_request_response.c:215:  rv = SSL_write(connection->ssl, data, length);
./src/testspdy/test_request_response.c:247:  rv = SSL_read(connection->ssl, buf, length);
./src/testspdy/test_request_response.c:407:        fwrite(out, 1, outlen, stdout);
./src/testspdy/test_request_response.c:413:      fwrite(data, 1, len, stdout);
./src/testspdy/test_request_response.c:493:  rv = SSL_connect(ssl);
./src/testspdy/test_request_response.c:519:    fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
./src/testspdy/test_request_response.c:523:    while((rv = connect(fd, rp->ai_addr, rp->ai_addrlen)) == -1 &&
./src/testspdy/test_request_response.c:567:  if(spdylay_session_want_read(connection->session) ||
./src/testspdy/test_request_response.c:571:  if(spdylay_session_want_write(connection->session) ||
./src/testspdy/test_request_response.c:696:  while(spdylay_session_want_read(connection.session) ||
./src/testspdy/test_request_response.c:697:        spdylay_session_want_write(connection.session)) {
./src/examples/mhd2spdy_structures.h:56:   similar functions like spdylay_session_want_read() and
./src/examples/mhd2spdy_structures.h:57:   spdylay_session_want_write() but they do not take into account
./src/examples/spdy_response_with_callback.c:49:	int ret = fread(buffer,1,max,fd);
./src/examples/digest_auth_example.c:114:      len = read(fd, rnd, 8);
./src/examples/mhd2spdy.c:131:      glob_opt.spdy_connection = spdy_connect(spdy2http_uri, spdy2http_uri->port, strcmp("https", spdy2http_uri->scheme)==0);
./src/examples/spdy_event_loop.c:284:  write(0, buf, size);
./src/examples/spdy_fileserver.c:110:	int ret = fread(buffer,1,max,fd);
./src/examples/mhd2spdy_spdy.c:67:spdy_cb_data_source_read(spdylay_session *session, int32_t stream_id, uint8_t *buf, size_t length, int *eof, spdylay_data_source *source, void *user_data)
./src/examples/mhd2spdy_spdy.c:167:    rv = SSL_write(connection->ssl, data, length);
./src/examples/mhd2spdy_spdy.c:181:    rv = write(connection->fd,
./src/examples/mhd2spdy_spdy.c:238:    rv = SSL_read(connection->ssl, buf, length);
./src/examples/mhd2spdy_spdy.c:254:    rv = read(connection->fd,
./src/examples/mhd2spdy_spdy.c:562:  rv = SSL_connect(ssl);
./src/examples/mhd2spdy_spdy.c:597:    fd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
./src/examples/mhd2spdy_spdy.c:600:    while((rv = connect(fd, rp->ai_addr, rp->ai_addrlen)) == -1 &&
./src/examples/mhd2spdy_spdy.c:654:  if(spdylay_session_want_read(connection->session) ||
./src/examples/mhd2spdy_spdy.c:659:  if(spdylay_session_want_write(connection->session) ||
./src/examples/mhd2spdy_spdy.c:680:  if(spdylay_session_want_read(connection->session) ||
./src/examples/mhd2spdy_spdy.c:686:  if(spdylay_session_want_write(connection->session) ||
./src/examples/mhd2spdy_spdy.c:723:spdy_connect(const struct URI *uri,
./src/examples/mhd2spdy_spdy.c:870:      connection = spdy_connect(proxy->uri, port, true);
./src/examples/mhd2spdy_spdy.c:1145:      //PRINT_INFO2("read %i",spdylay_session_want_read(connections[i]->session));
./src/examples/mhd2spdy_spdy.c:1146:      //PRINT_INFO2("write %i",spdylay_session_want_write(connections[i]->session));
./src/examples/fileserver_example_external_select.c:38:  return fread (buf, 1, max, file);
./src/examples/fileserver_example_dirs.c:39:  return fread (buf, 1, max, file);
./src/examples/https_fileserver_example.c:104:  return fread (buf, 1, max, file);
./src/examples/mhd2spdy_spdy.h:31:spdy_connect(const struct URI *uri,
./src/examples/fileserver_example.c:41:  return fread (buf, 1, max, file);
./src/examples/demo.c:569:       (size != (size_t) write (uc->fd, data, size)) )
./src/examples/demo.c:707:      got = read (fd, file_data, sizeof (file_data));
./src/examples/demo_https.c:570:       (size != (size_t) write (uc->fd, data, size)) )
./src/examples/demo_https.c:707:      got = read (fd, file_data, sizeof (file_data));
./src/testcurl/https/test_https_get_select.c:176:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/https/tls_test_common.c:43:  if (fwrite (ca_cert_pem, sizeof (char), strlen (ca_cert_pem) + 1, cert_fd)
./src/testcurl/https/test_empty_response.c:156:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/https/test_https_time_out.c:53:  sd = socket (AF_INET, SOCK_STREAM, 0);
./src/testcurl/https/test_https_time_out.c:67:  ret = connect (sd, (struct sockaddr *) &sa, sizeof (struct sockaddr_in));
./src/testcurl/test_process_arguments.c:201:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_postform.c:440:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/perf_get.c:452:	      msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_get_sendfile.c:356:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_get_sendfile.c:487:  fwrite (TESTSTR, strlen (TESTSTR), 1, f);
./src/testcurl/test_large_put.c:420:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_callback.c:172:	      msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_post_loop.c:419:              msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_post.c:418:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_digestauth.c:158:      len = read(fd, rnd, 8);
./src/testcurl/test_put_chunked.c:398:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_parse_cookies.c:202:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_digestauth_with_arguments.c:153:	  len = read(fd, rnd, 8);
./src/testcurl/test_quiesce.c:380:            msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_process_headers.c:385:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_get_chunked.c:368:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_get.c:350:          msg = curl_multi_info_read (multi, &running);
./src/testcurl/test_get.c:471:    fd = socket (PF_INET, SOCK_STREAM, 0);
./src/testcurl/test_get.c:483:    if (connect (fd, (struct sockaddr *)(&sin), sizeof(sin)) < 0)
./src/testcurl/test_put.c:388:          msg = curl_multi_info_read (multi, &running);
./src/spdy2http/proxy.c:1155:    while ((msg = curl_multi_info_read(multi_handle, &msgs_left))) {
./src/microhttpd/daemon.c:1197:create_thread (MHD_thread_handle_ *thread,
./src/microhttpd/daemon.c:1476:	  if (0 != ioctlsocket (connection->socket_fd, FIONBIO, &flags))
./src/microhttpd/daemon.c:1558:      res_thread_create = create_thread (&connection->pid,
./src/microhttpd/daemon.c:1846:  if (0 != ioctlsocket (sock, FIONBIO, &flags))
./src/microhttpd/daemon.c:2591:MHD_poll_listen_socket (struct MHD_Daemon *daemon,
./src/microhttpd/daemon.c:2662:    return MHD_poll_listen_socket (daemon, may_block);
./src/microhttpd/daemon.c:2939:MHD_select_thread (void *cls)
./src/microhttpd/daemon.c:3488:create_socket (struct MHD_Daemon *daemon,
./src/microhttpd/daemon.c:3496:  fd = socket (domain, ctype, protocol);
./src/microhttpd/daemon.c:3500:    fd = socket(domain, type, protocol);
./src/microhttpd/daemon.c:3519:setup_epoll_to_listen (struct MHD_Daemon *daemon)
./src/microhttpd/daemon.c:3838:	socket_fd = create_socket (daemon,
./src/microhttpd/daemon.c:3841:	socket_fd = create_socket (daemon,
./src/microhttpd/daemon.c:4015:      if (-1 == bind (socket_fd, servaddr, addrlen))
./src/microhttpd/daemon.c:4062:      if (listen (socket_fd, 32) < 0)
./src/microhttpd/daemon.c:4107:      if (MHD_YES != setup_epoll_to_listen (daemon))
./src/microhttpd/daemon.c:4166:	      create_thread (&daemon->pid, daemon, &MHD_select_thread, daemon))))
./src/microhttpd/daemon.c:4189:      /* Coarse-grained count of connections per thread (note error
./src/microhttpd/daemon.c:4210:      if (SOCKET_ERROR == ioctlsocket (socket_fd, FIONBIO, &sk_flags))
./src/microhttpd/daemon.c:4269:	       (MHD_YES != setup_epoll_to_listen (d)) )
./src/microhttpd/daemon.c:4284:		    create_thread (&d->pid, daemon, &MHD_select_thread, d)))
./src/microhttpd/response.c:40:#include <io.h> /* for lseek(), read() */
./src/microhttpd/response.c:346:  n = read (response->fd, buf, max);
./src/microhttpd/response.c:351:  n = read (response->fd, buf, (unsigned int)max);
./src/microhttpd/connection.h:53:MHD_connection_handle_read (struct MHD_Connection *connection);
./src/microhttpd/connection.h:67:MHD_connection_handle_write (struct MHD_Connection *connection);
./src/microhttpd/connection_https.c:97:MHD_tls_connection_handle_read (struct MHD_Connection *connection)
./src/microhttpd/connection_https.c:101:  return MHD_connection_handle_read (connection);
./src/microhttpd/connection_https.c:114:MHD_tls_connection_handle_write (struct MHD_Connection *connection)
./src/microhttpd/connection_https.c:118:  return MHD_connection_handle_write (connection);
./src/microhttpd/connection_https.c:158:	   (MHD_YES != MHD_tls_connection_handle_read (connection)) )
./src/microhttpd/internal.h:1149:   * socket (which we can then 'shutdown' to stop listening).
./src/microhttpd/test_daemon.c:124:testThread ()
./src/microhttpd/test_daemon.c:140:testMultithread ()
./src/microhttpd/test_daemon.c:162:  errorCount += testThread ();
./src/microhttpd/test_daemon.c:163:  errorCount += testMultithread ();
./src/microhttpd/connection.c:323: * this function may close the socket (and return
./src/microhttpd/connection.c:394: * transmission is complete, this function may close the socket (and
./src/microhttpd/connection.c:1659:do_read (struct MHD_Connection *connection)
./src/microhttpd/connection.c:1706:do_write (struct MHD_Connection *connection)
./src/microhttpd/connection.c:2001:MHD_connection_handle_read (struct MHD_Connection *connection)
./src/microhttpd/connection.c:2011:  if (MHD_NO == do_read (connection))
./src/microhttpd/connection.c:2064:MHD_connection_handle_write (struct MHD_Connection *connection)
./src/microhttpd/connection.c:2121:          do_write (connection);
./src/microhttpd/connection.c:2183:          do_write (connection);
./src/microhttpd/connection.c:2197:          do_write (connection);
./src/testzzuf/test_put_large.c:342:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_post_form.c:372:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_post.c:355:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_put_chunked.c:335:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_get_chunked.c:294:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_get.c:277:              curl_multi_info_read (multi, &running);
./src/testzzuf/test_put.c:324:              curl_multi_info_read (multi, &running);
./src/include/microhttpd.h:526:   * Run using an internal thread (or thread pool) doing `select()`.
./src/include/microhttpd.h:560:   * Run using an internal thread (or thread pool) doing `poll()`.
./src/include/microhttpd.h:590:   * Run using an internal thread (or thread pool) doing `epoll()`.
./src/include/microhttpd.h:784:   * option is used, MHD will not open its own listen socket(s). The
./src/include/platform_interface.h:105:#define MHD_socket_close_(fd) closesocket((fd))
./src/include/platform_interface.h:187:#define MHD_pipe_write_(fd, ptr, sz) write((fd), (const void*)(ptr), (sz))
./src/include/platform_interface.h:195:#define MHD_pipe_read_(fd, ptr, sz) read((fd), (void*)(ptr), (sz))
./src/platform/w32functions.c:573:      listen_s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/platform/w32functions.c:580:      if (0 == bind(listen_s, (struct sockaddr*) &listen_addr, c_addinlen)
./src/platform/w32functions.c:581:          && 0 == listen(listen_s, 1)
./src/platform/w32functions.c:585:          SOCKET client_s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
./src/platform/w32functions.c:588:              if (0 == ioctlsocket(client_s, FIONBIO, (u_long*) &opt)
./src/platform/w32functions.c:589:                  && (0 == connect(client_s, (struct sockaddr*) &listen_addr, c_addinlen)
./src/platform/w32functions.c:605:                          && 0 == ioctlsocket(client_s, FIONBIO, (u_long*) &opt)
./src/platform/w32functions.c:606:                          && 0 == ioctlsocket(server_s, FIONBIO, (u_long*) &opt))
./src/platform/w32functions.c:608:                          closesocket(listen_s);
./src/platform/w32functions.c:613:                      closesocket(server_s);
./src/platform/w32functions.c:616:              closesocket(client_s);
./src/platform/w32functions.c:619:      closesocket(listen_s);
./doc/examples/largepost.c:108:      if (!fwrite (data, size, sizeof (char), con_info->fp))
./doc/examples/tlsauthentication.c:108:  if (size != fread (buffer, 1, size, fp))

== http:// ==
./src/microspdy/io_openssl.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/compression.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/daemon.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/applicationlayer.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/structures.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/structures.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/io.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/internal.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/io_openssl.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/io_raw.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/applicationlayer.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/alstructures.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/session.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/compression.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/compression.c:293:			* (See zlib documentation at http://www.zlib.net/zlib_how.html */
./src/microspdy/stream.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/session.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/io_raw.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/stream.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/alstructures.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/io.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/internal.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/microspdy/daemon.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_new_connection.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/common.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_notls.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_daemon_start_stop_many.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_proxies.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_proxies.c:169:    asprintf(&url, "http://127.0.0.1:%i", spdy2http_port);
./src/testspdy/test_proxies.c:199:		asprintf (&cmd, "curl --proxy http://127.0.0.1:%i http://127.0.0.1:%i/", mhd2spdy_port, mhd_port);
./src/testspdy/test_request_response_with_callback.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_misc.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_daemon_start_stop.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_request_response.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/common.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_struct_namevalue.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testspdy/test_session_timeout.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/mhd2spdy_structures.h:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/spdy_response_with_callback.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/mhd2spdy.c:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/mhd2spdy.c:238:    "                          in the form 'http://host:port'. Use 'https'\n"
./src/examples/mhd2spdy_http.h:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/spdy_event_loop.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/spdy_fileserver.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/spdy_fileserver.c:80://taken from http://stackoverflow.com/questions/2726975/how-can-i-generate-an-rfc1123-date-string-from-c-code-win32
./src/examples/mhd2spdy_spdy.h:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/mhd2spdy_http.c:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/examples/mhd2spdy_structures.c:15:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/testcurl/test_iplimit.c:146:          curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_iplimit.c:235:          curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_process_arguments.c:139:                    "http://127.0.0.1:21080/hello+world?k=v+x&hash=%23foo&space=%A0bar");
./src/testcurl/test_postform.c:193:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_postform.c:249:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_postform.c:306:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_postform.c:372:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/testcurl/perf_get.c:191:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:251:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:310:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/perf_get.c:379:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_get_sendfile.c:133:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11080/");
./src/testcurl/test_get_sendfile.c:183:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/");
./src/testcurl/test_get_sendfile.c:234:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/");
./src/testcurl/test_get_sendfile.c:294:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/");
./src/testcurl/test_get_sendfile.c:427:  snprintf(buf, sizeof(buf), "http://127.0.0.1:%hu/",
./src/testcurl/test_large_put.c:163:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_large_put.c:221:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_large_put.c:283:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_large_put.c:354:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/testcurl/test_callback.c:113:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:8000/");
./src/testcurl/test_post_loop.c:133:      sprintf (url, "http://127.0.0.1:1080/hw%d", i);
./src/testcurl/test_post_loop.c:197:      sprintf (url, "http://127.0.0.1:1081/hw%d", i);
./src/testcurl/test_post_loop.c:262:      sprintf (url, "http://127.0.0.1:1081/hw%d", i);
./src/testcurl/test_post_loop.c:345:      sprintf (url, "http://127.0.0.1:1082/hw%d", i);
./src/testcurl/test_get_response_cleanup.c:157:  curl = fork_curl ("http://127.0.0.1:11080/");
./src/testcurl/test_get_response_cleanup.c:182:  curl = fork_curl ("http://127.0.0.1:1081/");
./src/testcurl/test_get_response_cleanup.c:186:  curl = fork_curl ("http://127.0.0.1:1081/");
./src/testcurl/test_get_response_cleanup.c:216:  curl = fork_curl ("http://127.0.0.1:1081/");
./src/testcurl/test_get_response_cleanup.c:243:  curl = fork_curl ("http://127.0.0.1:1082/");
./src/testcurl/perf_get_concurrent.c:173:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_post.c:180:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_post.c:234:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_post.c:289:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_post.c:353:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/testcurl/test_post.c:564:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_termination.c:108:  sprintf (url, "http://127.0.0.1:%d", PORT);
./src/testcurl/test_digestauth.c:200:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1337/bar%20 foo?a=b%20");
./src/testcurl/test_put_chunked.c:150:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11080/hello_world");
./src/testcurl/test_put_chunked.c:206:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11081/hello_world");
./src/testcurl/test_put_chunked.c:264:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11081/hello_world");
./src/testcurl/test_put_chunked.c:332:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11082/hello_world");
./src/testcurl/test_parse_cookies.c:135:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:21080/hello_world");
./src/testcurl/test_digestauth_with_arguments.c:195:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1337/foo?key=value");
./src/testcurl/test_timeout.c:184:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_timeout.c:239:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_quiesce.c:165:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11080/hello_world");
./src/testcurl/test_process_headers.c:165:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:21080/hello_world");
./src/testcurl/test_process_headers.c:214:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:21080/hello_world");
./src/testcurl/test_process_headers.c:264:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:21080/hello_world");
./src/testcurl/test_process_headers.c:323:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:21080/hello_world");
./src/testcurl/test_urlparse.c:142:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11080/hello_world?a=b&c=&d");
./src/testcurl/test_get_chunked.c:172:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_get_chunked.c:214:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_get_chunked.c:257:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_get_chunked.c:309:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/testcurl/test_get.c:127:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11080/hello_world");
./src/testcurl/test_get.c:177:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_get.c:228:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_get.c:288:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/testcurl/test_get.c:421:  snprintf(buf, sizeof(buf), "http://127.0.0.1:%hu/hello_world",
./src/testcurl/test_get.c:568:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:11081/hello_world");
./src/testcurl/test_long_header.c:123:  memcpy (url, "http://127.0.0.1:1080/", strlen ("http://127.0.0.1:1080/"));
./src/testcurl/test_long_header.c:199:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_concurrent_stop.c:112:  sprintf(url, "http://127.0.0.1:%d/hello_world", port);
./src/testcurl/test_put.c:140:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1080/hello_world");
./src/testcurl/test_put.c:196:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_put.c:254:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1081/hello_world");
./src/testcurl/test_put.c:322:  curl_easy_setopt (c, CURLOPT_URL, "http://127.0.0.1:1082/hello_world");
./src/spdy2http/proxy.c:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/spdy2http/proxy.c:31: * - add '/' when a user requests http://example.com . Now this is a bad
./src/microhttpd/daemon.c:1158:	 http://lists.gnu.org/archive/html/libmicrohttpd/2011-02/msg00015.html */
./src/microhttpd/daemon.c:1171:     http://lists.gnu.org/archive/html/libmicrohttpd/2014-10/msg00023.html */
./src/microhttpd/daemon.c:3993:	     (http://msdn.microsoft.com/en-us/library/ms738574%28v=VS.85%29.aspx);
./src/microhttpd/mhd_byteorder.h:17:  If not, see <http://www.gnu.org/licenses/>.
./src/microhttpd/digestauth.c:208: * http://en.wikipedia.org/wiki/Digest_access_authentication
./src/microhttpd/connection.c:1828:         http://www.jmarshall.com/easy/http/ */
./src/testzzuf/test_put_large.c:156:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put_large.c:208:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put_large.c:279:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_post_form.c:190:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_post_form.c:241:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_post_form.c:309:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:1082/hello_world");
./src/testzzuf/test_post.c:172:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_post.c:224:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_post.c:294:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:1082/hello_world");
./src/testzzuf/test_put_chunked.c:147:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11080/hello_world");
./src/testzzuf/test_put_chunked.c:194:  curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put_chunked.c:273:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11082/hello_world");
./src/testzzuf/test_get_chunked.c:142:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_get_chunked.c:183:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_get_chunked.c:241:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_get.c:116:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_get.c:160:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_get.c:221:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_long_header.c:126:      memcpy (url, "http://localhost:11081/",
./src/testzzuf/test_long_header.c:127:              strlen ("http://localhost:11081/"));
./src/testzzuf/test_long_header.c:191:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put.c:141:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put.c:192:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/testzzuf/test_put.c:261:      curl_easy_setopt (c, CURLOPT_URL, "http://localhost:11081/hello_world");
./src/include/autoinit_funcs.h:17: *  <http://www.gnu.org/licenses/>.
./src/include/microhttpd.h:366:/* See also: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html */
./src/include/microhttpd.h:453: * See also: http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4
./src/include/microspdy.h:16:    along with this program.  If not, see <http://www.gnu.org/licenses/>.
./src/include/microspdy.h:265: * http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4
./src/include/platform_interface.h:17:  If not, see <http://www.gnu.org/licenses/>.
./src/include/w32functions.h:17:  If not, see <http://www.gnu.org/licenses/>.
./src/platform/w32functions.c:17:  If not, see <http://www.gnu.org/licenses/>.

== encryption ==
./src/microspdy/io_openssl.c:39: * @return SSL_TLSEXT_ERR_OK to do advertising
./src/microspdy/io_openssl.c:51:	return SSL_TLSEXT_ERR_OK;
./src/microspdy/io_openssl.c:59:    //SSL_load_error_strings();
./src/microspdy/io_openssl.c:61:    SSL_library_init(); //always returns 1
./src/microspdy/io_openssl.c:63:    //OpenSSL_add_all_algorithms();
./src/microspdy/io_openssl.c:70:	//if SSL_load_error_strings was called
./src/microspdy/io_openssl.c:72:    //if OpenSSL_add_all_algorithms was called
./src/microspdy/io_openssl.c:82:    if(NULL == (daemon->io_context = SSL_CTX_new(TLSv1_server_method())))
./src/microspdy/io_openssl.c:89:    //SSL_CTX_set_options(daemon->io_context, SSL_OP_SINGLE_DH_USE);
./src/microspdy/io_openssl.c:93:    // SSL_OP_NO_COMPRESSION disables TLS compression to avoid CRIME attack
./src/microspdy/io_openssl.c:94:    options = SSL_OP_NO_TICKET;
./src/microspdy/io_openssl.c:95:#ifdef SSL_OP_NO_COMPRESSION
./src/microspdy/io_openssl.c:96:    options |= SSL_OP_NO_COMPRESSION;
./src/microspdy/io_openssl.c:97:#elif OPENSSL_VERSION_NUMBER >= 0x00908000L /* workaround for OpenSSL 0.9.8 */
./src/microspdy/io_openssl.c:98:    sk_SSL_COMP_zero(SSL_COMP_get_compression_methods());
./src/microspdy/io_openssl.c:101:    SSL_CTX_set_options(daemon->io_context, options);
./src/microspdy/io_openssl.c:102:    if(1 != SSL_CTX_use_certificate_file(daemon->io_context, daemon->certfile , SSL_FILETYPE_PEM))
./src/microspdy/io_openssl.c:105:		SSL_CTX_free(daemon->io_context);
./src/microspdy/io_openssl.c:108:    if(1 != SSL_CTX_use_PrivateKey_file(daemon->io_context, daemon->keyfile, SSL_FILETYPE_PEM))
./src/microspdy/io_openssl.c:111:		SSL_CTX_free(daemon->io_context);
./src/microspdy/io_openssl.c:114:    SSL_CTX_set_next_protos_advertised_cb(daemon->io_context, &spdyf_next_protos_advertised_cb, NULL);
./src/microspdy/io_openssl.c:115:    if (1 != SSL_CTX_set_cipher_list(daemon->io_context, "HIGH"))
./src/microspdy/io_openssl.c:118:		SSL_CTX_free(daemon->io_context);
./src/microspdy/io_openssl.c:129:    SSL_CTX_free(daemon->io_context);
./src/microspdy/io_openssl.c:138:	if(NULL == (session->io_context = SSL_new(session->daemon->io_context)))
./src/microspdy/io_openssl.c:143:	if(1 != (ret = SSL_set_fd(session->io_context, session->socket_fd)))
./src/microspdy/io_openssl.c:145:		SPDYF_DEBUG("SSL_set_fd %i",ret);
./src/microspdy/io_openssl.c:146:		SSL_free(session->io_context);
./src/microspdy/io_openssl.c:151:	//for non-blocking I/O SSL_accept may return -1
./src/microspdy/io_openssl.c:153:	if(1 != (ret = SSL_accept(session->io_context)))
./src/microspdy/io_openssl.c:155:		SPDYF_DEBUG("SSL_accept %i",ret);
./src/microspdy/io_openssl.c:156:		SSL_free(session->io_context);
./src/microspdy/io_openssl.c:161:	SSL_set_accept_state(session->io_context);
./src/microspdy/io_openssl.c:172:	//SSL_shutdown sends TLS "close notify" as in TLS standard.
./src/microspdy/io_openssl.c:177:	SSL_shutdown(session->io_context);
./src/microspdy/io_openssl.c:179:	SSL_free(session->io_context);
./src/microspdy/io_openssl.c:189:	int n = SSL_read(session->io_context,
./src/microspdy/io_openssl.c:195:		ret = SSL_get_error(session->io_context, n);
./src/microspdy/io_openssl.c:198:			case SSL_ERROR_ZERO_RETURN:
./src/microspdy/io_openssl.c:201:			case SSL_ERROR_WANT_READ:
./src/microspdy/io_openssl.c:202:			case SSL_ERROR_WANT_WRITE:
./src/microspdy/io_openssl.c:205:			case SSL_ERROR_SYSCALL:
./src/microspdy/io_openssl.c:225:	int n = SSL_write(session->io_context,
./src/microspdy/io_openssl.c:231:		ret = SSL_get_error(session->io_context, n);
./src/microspdy/io_openssl.c:234:			case SSL_ERROR_ZERO_RETURN:
./src/microspdy/io_openssl.c:237:			case SSL_ERROR_WANT_READ:
./src/microspdy/io_openssl.c:238:			case SSL_ERROR_WANT_WRITE:
./src/microspdy/io_openssl.c:241:			case SSL_ERROR_SYSCALL:
./src/microspdy/io_openssl.c:259:SSL_pending() takes into account only bytes from the TLS/SSL record that is currently being processed (if any). If the SSL object's read_ahead flag is set, additional protocol bytes may have been read containing more TLS/SSL records; these are ignored by SSL_pending().
./src/microspdy/io_openssl.c:261:	return SSL_pending(session->io_context) > 0 ? SPDY_YES : SPDY_NO;
./src/microspdy/io_openssl.h:27:#ifndef IO_OPENSSL_H
./src/microspdy/io_openssl.h:28:#define IO_OPENSSL_H
./src/microspdy/io.h:156: * something like SSL_pending().
./src/testspdy/test_new_connection.c:233:  rv = SSL_write(connection->ssl, data, length);
./src/testspdy/test_new_connection.c:235:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_new_connection.c:236:    if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/testspdy/test_new_connection.c:237:      connection->want_io = (err == SSL_ERROR_WANT_READ ?
./src/testspdy/test_new_connection.c:265:  rv = SSL_read(connection->ssl, buf, length);
./src/testspdy/test_new_connection.c:267:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_new_connection.c:268:    if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/testspdy/test_new_connection.c:269:      connection->want_io = (err == SSL_ERROR_WANT_READ ?
./src/testspdy/test_new_connection.c:480:  return SSL_TLSEXT_ERR_OK;
./src/testspdy/test_new_connection.c:487:static void init_ssl_ctx(SSL_CTX *ssl_ctx, uint16_t *spdy_proto_version)
./src/testspdy/test_new_connection.c:490:  SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL|SSL_OP_NO_SSLv2);
./src/testspdy/test_new_connection.c:491:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);
./src/testspdy/test_new_connection.c:492:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_RELEASE_BUFFERS);
./src/testspdy/test_new_connection.c:494:  SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb,
./src/testspdy/test_new_connection.c:501:  if(SSL_set_fd(ssl, fd) == 0) {
./src/testspdy/test_new_connection.c:502:    dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:505:  rv = SSL_connect(ssl);
./src/testspdy/test_new_connection.c:507:    dief("SSL_connect", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:658:  SSL_CTX *ssl_ctx;
./src/testspdy/test_new_connection.c:675:  ssl_ctx = SSL_CTX_new(SSLv23_client_method());
./src/testspdy/test_new_connection.c:677:    dief("SSL_CTX_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:680:  ssl = SSL_new(ssl_ctx);
./src/testspdy/test_new_connection.c:682:    dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_new_connection.c:726:  SSL_shutdown(ssl);
./src/testspdy/test_new_connection.c:727:  SSL_free(ssl);
./src/testspdy/test_new_connection.c:728:  SSL_CTX_free(ssl_ctx);
./src/testspdy/test_new_connection.c:896:  SSL_load_error_strings();
./src/testspdy/test_new_connection.c:897:  SSL_library_init();
./src/testspdy/test_request_response.c:215:  rv = SSL_write(connection->ssl, data, length);
./src/testspdy/test_request_response.c:217:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_request_response.c:218:    if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/testspdy/test_request_response.c:219:      connection->want_io = (err == SSL_ERROR_WANT_READ ?
./src/testspdy/test_request_response.c:247:  rv = SSL_read(connection->ssl, buf, length);
./src/testspdy/test_request_response.c:249:    int err = SSL_get_error(connection->ssl, rv);
./src/testspdy/test_request_response.c:250:    if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/testspdy/test_request_response.c:251:      connection->want_io = (err == SSL_ERROR_WANT_READ ?
./src/testspdy/test_request_response.c:468:  return SSL_TLSEXT_ERR_OK;
./src/testspdy/test_request_response.c:475:static void init_ssl_ctx(SSL_CTX *ssl_ctx, uint16_t *spdy_proto_version)
./src/testspdy/test_request_response.c:478:  SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL|SSL_OP_NO_SSLv2);
./src/testspdy/test_request_response.c:479:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);
./src/testspdy/test_request_response.c:480:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_RELEASE_BUFFERS);
./src/testspdy/test_request_response.c:482:  SSL_CTX_set_next_proto_select_cb(ssl_ctx, select_next_proto_cb,
./src/testspdy/test_request_response.c:489:  if(SSL_set_fd(ssl, fd) == 0) {
./src/testspdy/test_request_response.c:490:    dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:493:  rv = SSL_connect(ssl);
./src/testspdy/test_request_response.c:495:    dief("SSL_connect", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:645:  SSL_CTX *ssl_ctx;
./src/testspdy/test_request_response.c:662:  ssl_ctx = SSL_CTX_new(SSLv23_client_method());
./src/testspdy/test_request_response.c:664:    dief("SSL_CTX_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:667:  ssl = SSL_new(ssl_ctx);
./src/testspdy/test_request_response.c:669:    dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/testspdy/test_request_response.c:713:  SSL_shutdown(ssl);
./src/testspdy/test_request_response.c:714:  SSL_free(ssl);
./src/testspdy/test_request_response.c:715:  SSL_CTX_free(ssl_ctx);
./src/testspdy/test_request_response.c:912:  SSL_load_error_strings();
./src/testspdy/test_request_response.c:913:  SSL_library_init();
./src/examples/mhd2spdy_structures.h:156:  SSL_CTX *ssl_ctx;
./src/examples/mhd2spdy.c:105:  SSL_load_error_strings();
./src/examples/mhd2spdy.c:106:  SSL_library_init();
./src/examples/mhd2spdy.c:107:  glob_opt.ssl_ctx = SSL_CTX_new(SSLv23_client_method());
./src/examples/mhd2spdy.c:109:    PRINT_INFO2("SSL_CTX_new %s", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy.c:199:  //TODO SSL_free brakes
./src/examples/mhd2spdy.c:216:  SSL_CTX_free(glob_opt.ssl_ctx);
./src/examples/mhd2spdy_spdy.c:167:    rv = SSL_write(connection->ssl, data, length);
./src/examples/mhd2spdy_spdy.c:169:      int err = SSL_get_error(connection->ssl, rv);
./src/examples/mhd2spdy_spdy.c:170:      if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/examples/mhd2spdy_spdy.c:171:        connection->want_io |= (err == SSL_ERROR_WANT_READ ?
./src/examples/mhd2spdy_spdy.c:238:    rv = SSL_read(connection->ssl, buf, length);
./src/examples/mhd2spdy_spdy.c:240:      int err = SSL_get_error(connection->ssl, rv);
./src/examples/mhd2spdy_spdy.c:241:      if(err == SSL_ERROR_WANT_WRITE || err == SSL_ERROR_WANT_READ) {
./src/examples/mhd2spdy_spdy.c:242:        connection->want_io |= (err == SSL_ERROR_WANT_READ ?
./src/examples/mhd2spdy_spdy.c:530:  return SSL_TLSEXT_ERR_OK;
./src/examples/mhd2spdy_spdy.c:539:spdy_ssl_init_ssl_ctx(SSL_CTX *ssl_ctx,
./src/examples/mhd2spdy_spdy.c:543:  SSL_CTX_set_options(ssl_ctx, SSL_OP_ALL|SSL_OP_NO_SSLv2 | SSL_OP_NO_COMPRESSION);
./src/examples/mhd2spdy_spdy.c:544:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);
./src/examples/mhd2spdy_spdy.c:545:  SSL_CTX_set_mode(ssl_ctx, SSL_MODE_RELEASE_BUFFERS);
./src/examples/mhd2spdy_spdy.c:547:  SSL_CTX_set_next_proto_select_cb(ssl_ctx, spdy_cb_ssl_select_next_proto,
./src/examples/mhd2spdy_spdy.c:558:  if(SSL_set_fd(ssl, fd) == 0)
./src/examples/mhd2spdy_spdy.c:559:    spdy_dief("SSL_set_fd", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:562:  rv = SSL_connect(ssl);
./src/examples/mhd2spdy_spdy.c:564:    PRINT_INFO2("SSL_connect %s", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:746:    ssl = SSL_new(glob_opt.ssl_ctx);
./src/examples/mhd2spdy_spdy.c:748:      spdy_dief("SSL_new", ERR_error_string(ERR_get_error(), NULL));
./src/examples/mhd2spdy_spdy.c:801:    SSL_shutdown(ssl);
./src/examples/mhd2spdy_spdy.c:806:    SSL_free(ssl);
./src/examples/mhd2spdy_spdy.c:833:    SSL_free(connection->ssl);
./src/examples/mhd2spdy_spdy.h:64:spdy_ssl_init_ssl_ctx(SSL_CTX *ssl_ctx,
./src/testcurl/https/tls_test_common.h:125:setup_session (gnutls_session_t * session,
./src/testcurl/https/tls_test_common.h:126:               gnutls_datum_t * key,
./src/testcurl/https/tls_test_common.h:127:               gnutls_datum_t * cert,
./src/testcurl/https/tls_test_common.h:128:               gnutls_certificate_credentials_t * xcred);
./src/testcurl/https/tls_test_common.h:131:teardown_session (gnutls_session_t session,
./src/testcurl/https/tls_test_common.h:132:                  gnutls_datum_t * key,
./src/testcurl/https/tls_test_common.h:133:                  gnutls_datum_t * cert,
./src/testcurl/https/tls_test_common.h:134:                  gnutls_certificate_credentials_t xcred);
./src/testcurl/https/test_https_get_select.c:115:  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);
./src/testcurl/https/test_https_get_select.c:116:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);
./src/testcurl/https/test_https_get_select.c:117:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);
./src/testcurl/https/tls_test_common.c:102:  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, cipher_suite);
./src/testcurl/https/tls_test_common.c:106:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, ver_peer);
./src/testcurl/https/tls_test_common.c:108:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);
./src/testcurl/https/tls_test_common.c:232:  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, cipher_suite);
./src/testcurl/https/tls_test_common.c:235:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);
./src/testcurl/https/tls_test_common.c:236:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);
./src/testcurl/https/tls_test_common.c:388:setup_session (gnutls_session_t * session,
./src/testcurl/https/tls_test_common.c:389:               gnutls_datum_t * key,
./src/testcurl/https/tls_test_common.c:390:               gnutls_datum_t * cert, 
./src/testcurl/https/tls_test_common.c:391:	       gnutls_certificate_credentials_t * xcred)
./src/testcurl/https/tls_test_common.c:396:  gnutls_certificate_allocate_credentials (xcred);
./src/testcurl/https/tls_test_common.c:401:       gnutls_certificate_free_credentials (*xcred);
./src/testcurl/https/tls_test_common.c:409:        gnutls_certificate_free_credentials (*xcred);
./src/testcurl/https/tls_test_common.c:414:  gnutls_certificate_set_x509_key_mem (*xcred, cert, key,
./src/testcurl/https/tls_test_common.c:415:				       GNUTLS_X509_FMT_PEM);
./src/testcurl/https/tls_test_common.c:416:  gnutls_init (session, GNUTLS_CLIENT);
./src/testcurl/https/tls_test_common.c:417:  ret = gnutls_priority_set_direct (*session,
./src/testcurl/https/tls_test_common.c:421:       gnutls_deinit (*session);
./src/testcurl/https/tls_test_common.c:422:       gnutls_certificate_free_credentials (*xcred);
./src/testcurl/https/tls_test_common.c:426:  gnutls_credentials_set (*session, 
./src/testcurl/https/tls_test_common.c:427:			  GNUTLS_CRD_CERTIFICATE, 
./src/testcurl/https/tls_test_common.c:433:teardown_session (gnutls_session_t session,
./src/testcurl/https/tls_test_common.c:434:                  gnutls_datum_t * key,
./src/testcurl/https/tls_test_common.c:435:                  gnutls_datum_t * cert,
./src/testcurl/https/tls_test_common.c:436:                  gnutls_certificate_credentials_t xcred)
./src/testcurl/https/tls_test_common.c:444:  gnutls_deinit (session);
./src/testcurl/https/tls_test_common.c:445:  gnutls_certificate_free_credentials (xcred);
./src/testcurl/https/test_empty_response.c:103:  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);
./src/testcurl/https/test_empty_response.c:104:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);
./src/testcurl/https/test_empty_response.c:105:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);
./src/testcurl/https/test_https_sni.c:36:#if GNUTLS_VERSION_MAJOR >= 3
./src/testcurl/https/test_https_sni.c:47:  gnutls_pcert_st pcrt;
./src/testcurl/https/test_https_sni.c:48:  gnutls_privkey_t key;
./src/testcurl/https/test_https_sni.c:66:  gnutls_datum_t data;
./src/testcurl/https/test_https_sni.c:76:  ret = gnutls_load_file (CERT_FILE, &data);
./src/testcurl/https/test_https_sni.c:85:    gnutls_pcert_import_x509_raw (&host->pcrt, &data, GNUTLS_X509_FMT_PEM,
./src/testcurl/https/test_https_sni.c:91:               gnutls_strerror (ret));
./src/testcurl/https/test_https_sni.c:94:  gnutls_free (data.data);
./src/testcurl/https/test_https_sni.c:96:  ret = gnutls_load_file (KEY_FILE, &data);
./src/testcurl/https/test_https_sni.c:105:  gnutls_privkey_init (&host->key);
./src/testcurl/https/test_https_sni.c:107:    gnutls_privkey_import_x509_raw (host->key,
./src/testcurl/https/test_https_sni.c:108:                                    &data, GNUTLS_X509_FMT_PEM,
./src/testcurl/https/test_https_sni.c:114:               gnutls_strerror (ret));
./src/testcurl/https/test_https_sni.c:117:  gnutls_free (data.data);
./src/testcurl/https/test_https_sni.c:133:sni_callback (gnutls_session_t session,
./src/testcurl/https/test_https_sni.c:134:              const gnutls_datum_t* req_ca_dn,
./src/testcurl/https/test_https_sni.c:136:              const gnutls_pk_algorithm_t* pk_algos,
./src/testcurl/https/test_https_sni.c:138:              gnutls_pcert_st** pcert,
./src/testcurl/https/test_https_sni.c:140:              gnutls_privkey_t * pkey)
./src/testcurl/https/test_https_sni.c:148:  if (GNUTLS_E_SUCCESS !=
./src/testcurl/https/test_https_sni.c:149:      gnutls_server_name_get (session,
./src/testcurl/https/test_https_sni.c:211:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);
./src/testcurl/https/test_https_sni.c:212:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 2);
./src/testcurl/https/test_https_time_out.c:47:test_tls_session_time_out (gnutls_session_t session)
./src/testcurl/https/test_https_time_out.c:65:  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) (intptr_t) sd);
./src/testcurl/https/test_https_time_out.c:76:  ret = gnutls_handshake (session);
./src/testcurl/https/test_https_time_out.c:105:  gnutls_session_t session;
./src/testcurl/https/test_https_time_out.c:106:  gnutls_datum_t key;
./src/testcurl/https/test_https_time_out.c:107:  gnutls_datum_t cert;
./src/testcurl/https/test_https_time_out.c:108:  gnutls_certificate_credentials_t xcred;
./src/testcurl/https/test_https_time_out.c:115:  gnutls_global_init ();
./src/testcurl/https/test_https_time_out.c:116:  gnutls_global_set_log_level (11);
./src/testcurl/https/test_https_time_out.c:143:  gnutls_global_deinit ();
./src/testcurl/https/test_https_session_info.c:58:  if (GNUTLS_TLS1_1 !=
./src/testcurl/https/test_https_session_info.c:63:      if (GNUTLS_TLS1_2 == ret)
./src/testcurl/https/test_https_session_info.c:75:                 GNUTLS_TLS1_1,
./src/testcurl/https/test_https_session_info.c:139:  curl_easy_setopt (c, CURLOPT_SSL_CIPHER_LIST, aes256_sha);
./src/testcurl/https/test_https_session_info.c:141:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYPEER, 0);
./src/testcurl/https/test_https_session_info.c:142:  curl_easy_setopt (c, CURLOPT_SSL_VERIFYHOST, 0);
./src/testcurl/curl_version_check.c:138:      req_ssl_ver = MHD_REQ_CURL_GNUTLS_VERSION;
./src/testcurl/curl_version_check.c:143:      req_ssl_ver = MHD_REQ_CURL_OPENSSL_VERSION;
./src/testcurl/test_options.c:33:const int DEBUG_GNUTLS_LOG_LEVEL = 0;
./src/spdy2http/proxy.c:945:  CURL_SETOPT(proxy->curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);//TODO
./src/spdy2http/proxy.c:946:  CURL_SETOPT(proxy->curl_handle, CURLOPT_SSL_VERIFYHOST, 0L);
./src/microhttpd/daemon.c:437:  res = gnutls_record_recv (connection->tls_session, other, i);
./src/microhttpd/daemon.c:438:  if ( (GNUTLS_E_AGAIN == res) ||
./src/microhttpd/daemon.c:439:       (GNUTLS_E_INTERRUPTED == res) )
./src/microhttpd/daemon.c:449:      /* Likely 'GNUTLS_E_INVALID_SESSION' (client communication
./src/microhttpd/daemon.c:478:  res = gnutls_record_send (connection->tls_session, other, i);
./src/microhttpd/daemon.c:479:  if ( (GNUTLS_E_AGAIN == res) ||
./src/microhttpd/daemon.c:480:       (GNUTLS_E_INTERRUPTED == res) )
./src/microhttpd/daemon.c:510:  gnutls_datum_t key;
./src/microhttpd/daemon.c:511:  gnutls_datum_t cert;
./src/microhttpd/daemon.c:514:#if GNUTLS_VERSION_MAJOR >= 3
./src/microhttpd/daemon.c:517:      gnutls_certificate_set_retrieve_function2 (daemon->x509_cred,
./src/microhttpd/daemon.c:525:      if (gnutls_certificate_set_x509_trust_mem (daemon->x509_cred, &cert,
./src/microhttpd/daemon.c:526:						 GNUTLS_X509_FMT_PEM) < 0)
./src/microhttpd/daemon.c:538:      gnutls_certificate_set_dh_params (daemon->x509_cred,
./src/microhttpd/daemon.c:551:#if GNUTLS_VERSION_NUMBER >= 0x030111
./src/microhttpd/daemon.c:552:        ret = gnutls_certificate_set_x509_key_mem2 (daemon->x509_cred,
./src/microhttpd/daemon.c:554:                                                    GNUTLS_X509_FMT_PEM,
./src/microhttpd/daemon.c:567:        ret = gnutls_certificate_set_x509_key_mem (daemon->x509_cred,
./src/microhttpd/daemon.c:569:                                                   GNUTLS_X509_FMT_PEM);
./src/microhttpd/daemon.c:574:                  gnutls_strerror (ret));
./src/microhttpd/daemon.c:578:#if GNUTLS_VERSION_MAJOR >= 3
./src/microhttpd/daemon.c:601:    case GNUTLS_CRD_CERTIFICATE:
./src/microhttpd/daemon.c:603:          gnutls_certificate_allocate_credentials (&daemon->x509_cred))
./src/microhttpd/daemon.c:604:        return GNUTLS_E_MEMORY_ERROR;
./src/microhttpd/daemon.c:1495:      gnutls_init (&connection->tls_session, GNUTLS_SERVER);
./src/microhttpd/daemon.c:1496:      gnutls_priority_set (connection->tls_session,
./src/microhttpd/daemon.c:1501:        case GNUTLS_CRD_CERTIFICATE:
./src/microhttpd/daemon.c:1502:          gnutls_credentials_set (connection->tls_session,
./src/microhttpd/daemon.c:1503:				  GNUTLS_CRD_CERTIFICATE,
./src/microhttpd/daemon.c:1523:      gnutls_transport_set_ptr (connection->tls_session,
./src/microhttpd/daemon.c:1524:				(gnutls_transport_ptr_t) connection);
./src/microhttpd/daemon.c:1525:      gnutls_transport_set_pull_function (connection->tls_session,
./src/microhttpd/daemon.c:1526:					  (gnutls_pull_func) &recv_param_adapter);
./src/microhttpd/daemon.c:1527:      gnutls_transport_set_push_function (connection->tls_session,
./src/microhttpd/daemon.c:1528:					  (gnutls_push_func) &send_param_adapter);
./src/microhttpd/daemon.c:1531:	  gnutls_certificate_server_set_request (connection->tls_session,
./src/microhttpd/daemon.c:1532:						 GNUTLS_CERT_REQUEST);
./src/microhttpd/daemon.c:2045:	gnutls_deinit (pos->tls_session);
./src/microhttpd/daemon.c:2156:		(0 != gnutls_record_check_pending (pos->tls_session)) )
./src/microhttpd/daemon.c:2172:	    (0 != gnutls_record_check_pending (pos->tls_session)) )
./src/microhttpd/daemon.c:3247:	  daemon->cred_type = (gnutls_credentials_type_t) va_arg (ap, int);
./src/microhttpd/daemon.c:3253:              gnutls_datum_t dhpar;
./src/microhttpd/daemon.c:3255:              if (gnutls_dh_params_init (&daemon->https_mem_dhparams) < 0)
./src/microhttpd/daemon.c:3265:              if (gnutls_dh_params_import_pkcs3 (daemon->https_mem_dhparams, &dhpar,
./src/microhttpd/daemon.c:3266:                                                 GNUTLS_X509_FMT_PEM) < 0)
./src/microhttpd/daemon.c:3272:                  gnutls_dh_params_deinit (daemon->https_mem_dhparams);
./src/microhttpd/daemon.c:3290:	      gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:3291:	      ret = gnutls_priority_init (&daemon->priority_cache,
./src/microhttpd/daemon.c:3294:	      if (GNUTLS_E_SUCCESS != ret)
./src/microhttpd/daemon.c:3300:			  gnutls_strerror (ret));
./src/microhttpd/daemon.c:3308:#if GNUTLS_VERSION_MAJOR < 3
./src/microhttpd/daemon.c:3316:            daemon->cert_callback = va_arg (ap, gnutls_certificate_retrieve_function2 *);
./src/microhttpd/daemon.c:3665:      gnutls_priority_init (&daemon->priority_cache,
./src/microhttpd/daemon.c:3737:      daemon->cred_type = GNUTLS_CRD_CERTIFICATE;
./src/microhttpd/daemon.c:3747:	gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:3764:	    gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:3779:	    gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:3794:	gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:4344:    gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:4578:      gnutls_dh_params_deinit (daemon->https_mem_dhparams);
./src/microhttpd/daemon.c:4583:      gnutls_priority_deinit (daemon->priority_cache);
./src/microhttpd/daemon.c:4585:        gnutls_certificate_free_credentials (daemon->x509_cred);
./src/microhttpd/daemon.c:4742:#if HTTPS_SUPPORT && GNUTLS_VERSION_MAJOR >= 3
./src/microhttpd/daemon.c:4808:#if HTTPS_SUPPORT && GNUTLS_VERSION_NUMBER >= 0x030111
./src/microhttpd/daemon.c:4892:  gnutls_global_init ();
./src/microhttpd/daemon.c:4901:  gnutls_global_deinit ();
./src/microhttpd/connection_https.c:54:      ret = gnutls_handshake (connection->tls_session);
./src/microhttpd/connection_https.c:55:      if (ret == GNUTLS_E_SUCCESS)
./src/microhttpd/connection_https.c:61:      if ( (ret == GNUTLS_E_AGAIN) ||
./src/microhttpd/connection_https.c:62:	   (ret == GNUTLS_E_INTERRUPTED) )
./src/microhttpd/connection_https.c:154:      gnutls_bye (connection->tls_session, GNUTLS_SHUT_RDWR);
./src/microhttpd/connection_https.c:157:      if ( (0 != gnutls_record_check_pending (connection->tls_session)) &&
./src/microhttpd/internal.h:35:#if GNUTLS_VERSION_MAJOR >= 3
./src/microhttpd/internal.h:846:  gnutls_session_t tls_session;
./src/microhttpd/internal.h:1201:  gnutls_priority_t priority_cache;
./src/microhttpd/internal.h:1207:  gnutls_credentials_type_t cred_type;
./src/microhttpd/internal.h:1212:  gnutls_certificate_credentials_t x509_cred;
./src/microhttpd/internal.h:1217:  gnutls_dh_params_t dh_params;
./src/microhttpd/internal.h:1219:#if GNUTLS_VERSION_MAJOR >= 3
./src/microhttpd/internal.h:1224:  gnutls_certificate_retrieve_function2 *cert_callback;
./src/microhttpd/internal.h:1250:  gnutls_dh_params_t https_mem_dhparams;
./src/microhttpd/connection.c:993:	  if (0 == gnutls_record_get_direction (connection->tls_session))
./src/microhttpd/connection.c:2799:      connection->cipher = gnutls_cipher_get (connection->tls_session);
./src/microhttpd/connection.c:2804:      connection->protocol = gnutls_protocol_get_version (connection->tls_session);
./src/microhttpd/connection.c:2806:    case MHD_CONNECTION_INFO_GNUTLS_SESSION:
./src/include/microhttpd.h:772:   * `gnutls_credentials_type_t`.
./src/include/microhttpd.h:894:   * followed by a argument of type `gnutls_certificate_retrieve_function2 *`.
./src/include/microhttpd.h:902:   * to access the SNI data using `gnutls_server_name_get()`.
./src/include/microhttpd.h:1115:   * Cipher algorithm used, of type "enum gnutls_cipher_algorithm".
./src/include/microhttpd.h:1117:  int /* enum gnutls_cipher_algorithm */ cipher_algorithm;
./src/include/microhttpd.h:1120:   * Protocol used, of type "enum gnutls_protocol".
./src/include/microhttpd.h:1122:  int /* enum gnutls_protocol */ protocol;
./src/include/microhttpd.h:1130:   * GNUtls session handle, of type "gnutls_session_t".
./src/include/microhttpd.h:1132:  void * /* gnutls_session_t */ tls_session;
./src/include/microhttpd.h:1135:   * GNUtls client certificate handle, of type "gnutls_x509_crt_t".
./src/include/microhttpd.h:1137:  void * /* gnutls_x509_crt_t */ client_cert;
./src/include/microhttpd.h:1192:  MHD_CONNECTION_INFO_GNUTLS_SESSION,
./src/include/microhttpd.h:1196:   * implemented, deprecated).  Use #MHD_CONNECTION_INFO_GNUTLS_SESSION
./src/include/microhttpd.h:1197:   * to get the `gnutls_session_t` and then call
./src/include/microhttpd.h:1198:   * gnutls_certificate_get_peers().
./src/include/microhttpd.h:1200:  MHD_CONNECTION_INFO_GNUTLS_CLIENT_CERT,
./src/testspdy/test_new_connection.c:742:  if(len < 9 || memcmp("https://", uri, 8) != 0) {
./src/testspdy/test_new_connection.c:894:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testspdy/test_notls.c:674:  if(len < 9 || memcmp("https://", uri, 8) != 0) {
./src/testspdy/test_notls.c:852:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testspdy/test_request_response_with_callback.c:274:	asprintf(&cmd1, "spdycat https://127.0.0.1:%i/ | md5sum",port);
./src/testspdy/test_misc.c:89:		asprintf(&uri,"https://127.0.0.1:%i/",port);
./src/testspdy/test_request_response.c:727:  if(len < 9 || memcmp("https://", uri, 8) != 0) {
./src/testspdy/test_request_response.c:908:	asprintf(&uristr, "https://127.0.0.1:%i/",port);
./src/testcurl/https/test_https_get_select.c:110:  curl_easy_setopt (c, CURLOPT_URL, "https://127.0.0.1:1082/hello_world");
./src/testcurl/https/tls_test_common.c:304:  if (sprintf (url, "%s:%d%s/%s", "https://127.0.0.1", port,
./src/testcurl/https/test_empty_response.c:98:  curl_easy_setopt (c, CURLOPT_URL, "https://127.0.0.1:1082/hello_world");
./src/testcurl/https/test_https_sni.c:274:  error_count += do_get ("https://host1:4233/");
./src/testcurl/https/test_https_sni.c:275:  error_count += do_get ("https://host2:4233/");

== sql() ==

== tmp() ==
./src/testcurl/test_get_sendfile.c:474:    tmp = "/tmp";

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==
./src/microspdy/io_openssl.c:88:	//TODO DH is not enabled for easier debugging
./src/microspdy/io_openssl.c:91:    //TODO here session tickets are disabled for easier debuging with
./src/microspdy/compression.h:62: * 					TODO do we need
./src/microspdy/structures.h:805:	 * TODO it is not clear in the draft what happens when streams are
./src/microspdy/structures.c:30://TODO not for here?
./src/microspdy/structures.c:69:  //TODO there is old code handling value==NULL
./src/microspdy/io_raw.c:29://TODO put in in the right place
./src/microspdy/applicationlayer.c:113:			//TODO can it have more values?
./src/microspdy/applicationlayer.c:150:		//TODO HTTP 400 Bad Request must be answered
./src/microspdy/applicationlayer.c:184: * TODO
./src/microspdy/applicationlayer.c:399:	struct SPDY_NameValue ** all_headers = NULL; //TODO maybe array in stack is enough
./src/microspdy/session.c:67:          //TODO maybe GOAWAY and closing session is appropriate
./src/microspdy/session.c:85:          //TODO no need to create stream if this happens
./src/microspdy/session.c:227:		//TODO do something with last_good
./src/microspdy/session.c:232:		//TODO
./src/microspdy/session.c:316:	//TODO
./src/microspdy/session.c:372:      //TODO send error?
./src/microspdy/session.c:374:      //TODO for now ignore frame
./src/microspdy/session.c:391:    //TODO close in and send rst maybe
./src/microspdy/session.c:456:	//TODO do we need this used_Data
./src/microspdy/session.c:647:			//TODO what?
./src/microspdy/session.c:688:				//TODO send RST_STREAM
./src/microspdy/session.c:934:			//TODO optimize it, memmove more often?
./src/microspdy/session.h:271: * TODO Ignoring frames containing compressed bodies means that the
./src/microspdy/stream.c:58:		//TODO
./src/microspdy/stream.c:155://TODO add function *on_read
./src/testspdy/test_new_connection.c:27://TODO child exits with ret val 1 sometimes
./src/testspdy/test_new_connection.c:429:      /* TODO add support gzip */
./src/testspdy/test_notls.c:427:      /* TODO add support gzip */
./src/testspdy/test_misc.c:21: * @brief  tests a lot of small calls and callbacks. TODO mention what
./src/testspdy/test_request_response.c:412:      /* TODO add support gzip */
./src/examples/mhd2spdy.c:23: *         TODOs:
./src/examples/mhd2spdy.c:199:  //TODO SSL_free brakes
./src/examples/mhd2spdy_spdy.c:94:		return SPDYLAY_ERR_DEFERRED;//TODO SPDYLAY_ERR_DEFERRED should be used
./src/examples/mhd2spdy_spdy.c:307:      //TODO this will ignore RST_STREAMs also for bogus data
./src/examples/mhd2spdy_spdy.c:440:    //TODO handle it better?
./src/examples/mhd2spdy_spdy.c:584:  //TODO checks
./src/examples/mhd2spdy_spdy.c:751:    //TODO non-blocking
./src/examples/mhd2spdy_spdy.c:927:      //PRINT_INFO("TODO drop connection");
./src/examples/mhd2spdy_spdy.c:955:      //PRINT_INFO("TODO drop connection");
./src/examples/mhd2spdy_spdy.c:977:  //, "TODO max num of conn reached; close something"
./src/examples/mhd2spdy_spdy.c:1048:  //, "TODO max num of conn reached; close something"
./src/examples/mhd2spdy_spdy.c:1074:      //TODO POLLRDHUP
./src/examples/https_fileserver_example.c:44:// TODO remove if unused
./src/examples/https_fileserver_example.c:176:      /* TODO check if this is truly necessary -  disallow usage of the blocking /dev/random */
./src/examples/mhd2spdy_http.c:39:  //TODO not freed once in a while
./src/examples/mhd2spdy_http.c:152:  //TODO remove
./src/examples/mhd2spdy_http.c:212:    return MHD_NO; // handled at different place TODO? leaks?
./src/examples/mhd2spdy_http.c:233:        //TODO handle it better?
./src/examples/mhd2spdy_http.c:362:    //TODO
./src/testcurl/https/tls_test_common.h:50:/* TODO rm if unused */
./src/testcurl/https/tls_test_common.c:105:  /* TODO merge into send_curl_req */
./src/testcurl/https/tls_test_common.c:208:/* TODO have test wrap consider a NULL cbc */
./src/testcurl/https/tls_test_common.c:449:/* TODO test_wrap: change sig to (setup_func, test, va_list test_arg) */
./src/testcurl/https/tls_test_keys.h:48:  "u+zRlnKxJtaa5KjJvRzKuvPTLYnJXXXM8Na/Cl+E3F3qvQJm9QlvPyKLCmsAGz+J\n"
./src/testcurl/https/test_https_get_parallel_threads.c:27: * TODO: add test for external select!
./src/testcurl/https/test_https_get_parallel_threads.c:76: * TODO : make client_count a parameter - numver of curl client threads to spawn
./src/testcurl/https/test_https_get_parallel_threads.c:98: * TODO : make client_count a parameter - numver of curl client threads to spawn
./src/testcurl/https/test_https_sni.c:210:  /* TODO merge into send_curl_req */
./src/testcurl/https/test_https_time_out.c:87:  /* TODO better RST trigger */
./src/testcurl/https/test_https_get_parallel.c:76: * TODO : make client_count a parameter - number of curl client threads to spawn
./src/testcurl/https/test_https_get_parallel.c:98: * TODO : make client_count a parameter - numver of curl client threads to spawn
./src/testcurl/test_iplimit.c:24: *         TODO: test parsing of query
./src/testcurl/curl_version_check.c:128:   * TODO use curl version string to assert use of gnutls
./src/testcurl/test_get_chunked.c:24: *         TODO:
./src/testcurl/test_get.c:24: *         TODO: test parsing of query
./src/spdy2http/proxy.c:24: *      TODO:
./src/spdy2http/proxy.c:235:  //TODO memeory checks
./src/spdy2http/proxy.c:375:  //TODO clean this memory
./src/spdy2http/proxy.c:470:    //TODO error?
./src/spdy2http/proxy.c:495:  //TODO bug on ku6.com or amazon.cn
./src/spdy2http/proxy.c:583:      //TODO right?
./src/spdy2http/proxy.c:751:		return CURL_READFUNC_PAUSE;//TODO curl pause should be used
./src/spdy2http/proxy.c:860:  //TODO not freed once in a while
./src/spdy2http/proxy.c:945:  CURL_SETOPT(proxy->curl_handle, CURLOPT_SSL_VERIFYPEER, 0L);//TODO
./src/spdy2http/proxy.c:1169:          //TODO what happens with proxy when the client resets a stream
./src/spdy2http/proxy.c:1216:          //TODO spdy should be notified to send RST_STREAM
./src/microhttpd/postprocessor.c:522: *                otherwise incremented by one (FIXME: quirky API!)
./src/microhttpd/connection.c:1835:      /* FIXME: we might be able to do this better (faster!), as most
./src/include/microspdy.h:705://TODO

== unsafe input mechanisms ==
./src/testcurl/perf_get_concurrent.c:163:do_gets (int port)
./src/testcurl/perf_get_concurrent.c:221:join_gets (pid_t pid)
./src/testcurl/perf_get_concurrent.c:242:  join_gets (do_gets (port));
./src/testcurl/perf_get_concurrent.c:259:  join_gets (do_gets (port));
./src/testcurl/perf_get_concurrent.c:276:  join_gets (do_gets (port));
./src/testcurl/perf_get_concurrent.c:300:  pid = do_gets (port);
./src/testcurl/test_concurrent_stop.c:102:do_gets (int port)
./src/testcurl/test_concurrent_stop.c:157:join_gets (pid_t pid)
./src/testcurl/test_concurrent_stop.c:178:  p = do_gets (port);
./src/testcurl/test_concurrent_stop.c:181:  join_gets (p);
./src/testcurl/test_concurrent_stop.c:200:  p = do_gets (port);
./src/testcurl/test_concurrent_stop.c:203:  join_gets (p);

