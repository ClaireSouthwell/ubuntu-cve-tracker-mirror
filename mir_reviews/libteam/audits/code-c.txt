Running: /home/sarnold/bin/audit-code.sh -c C ./
Scanning './'
== subprocess_spawned() ==

== memory_management() ==
./utils/teamnl.c:487:	th = team_alloc();
./utils/teamdctl.c:1063:	tdc = teamdctl_alloc();
./libteam/team_private.h:105:int port_list_alloc(struct team_handle *th);
./libteam/team_private.h:109:int ifinfo_list_alloc(struct team_handle *th);
./libteam/team_private.h:118:int option_list_alloc(struct team_handle *th);
./libteam/libteam.c:266:	handler_item = malloc(sizeof(struct change_handler_item));
./libteam/libteam.c:371:struct team_handle *team_alloc(void)
./libteam/libteam.c:393:	err = ifinfo_list_alloc(th);
./libteam/libteam.c:396:	err = port_list_alloc(th);
./libteam/libteam.c:399:	err = option_list_alloc(th);
./libteam/libteam.c:403:	th->nl_sock = nl_socket_alloc();
./libteam/libteam.c:407:	th->nl_sock_event = nl_socket_alloc();
./libteam/libteam.c:456:	link = rtnl_link_alloc();
./libteam/libteam.c:527:	link = rtnl_link_alloc();
./libteam/libteam.c:1550:	link = rtnl_link_alloc();
./libteam/libteam.c:1620:	link = rtnl_link_alloc();
./libteam/libteam.c:1676:	memcpy(addr, nl_addr_get_binary_addr(nl_addr), addr_len);
./libteam/ifinfo.c:112:		memcpy(ifinfo->hwaddr, hwaddr, hwaddr_len);
./libteam/ifinfo.c:114:			memcpy(ifinfo->orig_hwaddr, hwaddr, hwaddr_len);
./libteam/ifinfo.c:160:		memcpy(ifinfo->phys_port_id, phys_port_id, phys_port_id_len);
./libteam/ifinfo.c:304:int ifinfo_list_alloc(struct team_handle *th)
./libteam/stringify.c:218:	buf = malloc(numbytes);
./libteam/stringify.c:223:		memcpy(byte_str, str, 3);
./libteam/ports.c:185:	msg = nlmsg_alloc();
./libteam/ports.c:205:int port_list_alloc(struct team_handle *th)
./libteam/nl_updates.h:174:	nla_memcpy(&tmp, nla, sizeof(tmp));
./libteam/options.c:188:	tmp_data = malloc(data_size);
./libteam/options.c:192:	memcpy(tmp_data, data, data_size);
./libteam/options.c:353:	msg = nlmsg_alloc();
./libteam/options.c:373:int option_list_alloc(struct team_handle *th)
./libteam/options.c:728:	msg = nlmsg_alloc();
./examples/team_manual_control.c:189:	th = team_alloc();
./examples/team_monitor.c:124:	th = team_alloc();
./libteamdctl/cli_zmq.c:112:	buf = malloc(ret + 1);
./libteamdctl/cli_zmq.c:113:	memcpy(buf, zmq_msg_data(&msg), ret);
./libteamdctl/cli_zmq.c:128:static int myasprintf(char **p_str, const char *fmt, ...)
./libteamdctl/cli_zmq.c:135:	ret = vasprintf(&newstr, fmt, ap);
./libteamdctl/cli_zmq.c:156:	err = myasprintf(&msg, "%s\n%s\n", TEAMD_ZMQ_REQUEST_PREFIX,
./libteamdctl/cli_zmq.c:164:			err = myasprintf(&msg, "%s%s\n", msg, str);
./libteamdctl/cli_usock.c:104:static int myasprintf(char **p_str, const char *fmt, ...)
./libteamdctl/cli_usock.c:111:	ret = vasprintf(&newstr, fmt, ap);
./libteamdctl/cli_usock.c:133:	newstr = malloc(sizeof(char) * (len + 1));
./libteamdctl/cli_usock.c:166:	err= myasprintf(&msg, "%s\n%s\n", TEAMD_USOCK_REQUEST_PREFIX,
./libteamdctl/cli_usock.c:178:			err = myasprintf(&msg, "%s%s\n", msg, str);
./libteamdctl/libteamdctl.c:149:	strcpy(rcitem->id, id);
./libteamdctl/libteamdctl.c:163:struct teamdctl *teamdctl_alloc(void)
./libteamdctl/libteamdctl.c:496:	sprintf(id, "%s%s", PC_ID_PREFIX, port_devname);
./libteamdctl/cli_dbus.c:181:	ret = asprintf(&cli_dbus->service_name, TEAMD_DBUS_SERVICE ".%s",
./include/team.h:39:struct team_handle *team_alloc(void);
./include/private/misc.h:36:	return calloc(1, size);
./include/private/misc.h:46:		memcpy(dst, src, len);
./include/private/misc.h:59:		sprintf(str, "%02x:", (unsigned char) hwaddr[i]);
./include/private/misc.h:74:	str = malloc(sizeof(char) * hwaddr_str_len(len));
./include/teamdctl.h:36:struct teamdctl *teamdctl_alloc(void);
./teamd/teamd_runner_activebackup.c:166:	memcpy(ab->active_orig_hwaddr,
./teamd/teamd_runner_activebackup.c:568:	info = malloc(sizeof(*info));
./teamd/teamd.c:1205:	ctx->th = team_alloc();
./teamd/teamd.c:1601:	err = asprintf(&ctx->ident, "%s_%s", ctx->argv0, ctx->team_devname);
./teamd/teamd.c:1621:	err = asprintf(&ctx->pid_file, TEAMD_RUN_DIR"%s.pid", ctx->team_devname);
./teamd/teamd_runner_lacp.c:751:	memcpy(sa->sa_data, slow_addr, sizeof(slow_addr));
./teamd/teamd_runner_lacp.c:752:	memcpy(ifr.ifr_name, devname, strlen(devname));
./teamd/teamd_runner_lacp.c:878:	memcpy(actor->system, lacp_port->ctx->hwaddr, ETH_ALEN);
./teamd/teamd_runner_lacp.c:1013:	memcpy(ll_slow.sll_addr, slow_addr, ll_slow.sll_halen);
./teamd/teamd_runner_lacp.c:1015:	memcpy(lacp_port->actor.system, lacp_port->ctx->hwaddr, ETH_ALEN);
./teamd/teamd_runner_lacp.c:1666:	info = malloc(sizeof(*info));
./teamd/teamd_state.c:95:		ret = asprintf(&subpath, "%s.%s", parent_subpath, val_subpath);
./teamd/teamd_state.c:131:		item = malloc(sizeof(*item));
./teamd/teamd_state.c:161:	ret = vasprintf(&val_subpath, fmt, ap);
./teamd/teamd_state.c:198:		ret = asprintf(&path, "$." TEAMD_STATE_PER_PORT_PREFIX "%s%s",
./teamd/teamd_state.c:201:		ret = asprintf(&path, "$%s", subpath);
./teamd/teamd_state.c:355:		ret = asprintf(p_value, "%d", gsc.data.int_val);
./teamd/teamd_state.c:358:		ret = asprintf(p_value, "%s", gsc.data.str_val.ptr);
./teamd/teamd_state.c:363:		ret = asprintf(p_value, "%s",
./teamd/teamd_lw_arp_ping.c:114:	memcpy(addr, &sin.sin_addr, sizeof(*addr));
./teamd/teamd_lw_arp_ping.c:123:	memcpy(&sin.sin_addr, addr, sizeof(*addr));
./teamd/teamd_lw_arp_ping.c:135:		memcpy(&arp_vlan_rpl_flt, arp_vlan_rpl_fprog.filter,
./teamd/teamd_lw_arp_ping.c:234:	memcpy(addr->sll_addr, port_hwaddr, addr->sll_halen);
./teamd/teamd_lw_arp_ping.c:280:	memcpy(ap.sender_mac, ll_my.sll_addr, sizeof(ap.sender_mac));
./teamd/teamd_lw_arp_ping.c:282:	memcpy(ap.target_mac, ll_bcast.sll_addr, sizeof(ap.target_mac));
./teamd/teamd_zmq.c:107:	err = asprintf(&strbuf, "%s\n%s\n%s\n", TEAMD_ZMQ_REPLY_ERR_PREFIX,
./teamd/teamd_zmq.c:122:	err = asprintf(&strbuf, "%s\n%s", TEAMD_ZMQ_REPLY_SUCC_PREFIX,
./teamd/teamd_link_watch.c:60:	memcpy(sa, result->ai_addr, sa_len);
./teamd/teamd_events.c:195:	watch = malloc(sizeof(*watch));
./teamd/teamd_lw_nsna_ping.c:217:	memcpy(nsp.hwaddr, ll_my.sll_addr, sizeof(nsp.hwaddr));
./teamd/teamd_phys_port_check.c:42:	ret = asprintf(&path, "/sys/class/net/%s/device/physfn", ifname);
./teamd/teamd_lw_tipc.c:61:	strcpy(tipc_ppriv->bearer, tipc_bearer);
./teamd/teamd_lw_tipc.c:90:	link = malloc(sizeof(struct tipc_link));
./teamd/teamd_lw_tipc.c:91:	strcpy(link->name, name);
./teamd/teamd_lw_tipc.c:108:	strcpy(name, lnr->linkname);
./teamd/teamd_lw_tipc.c:109:	sprintf(needle, "-%u.%u.%u:", tipc_zone(lnr->peer),
./teamd/teamd_per_port.c:142:static struct port_obj *port_obj_alloc(struct teamd_context *ctx,
./teamd/teamd_per_port.c:188:	port_obj = port_obj_alloc(ctx, ifindex, team_port);
./teamd/teamd_usock.c:136:	err = asprintf(&strbuf, "%s\n%s\n%s\n", TEAMD_USOCK_REPLY_ERR_PREFIX,
./teamd/teamd_usock.c:151:	err = asprintf(&strbuf, "%s\n%s", TEAMD_USOCK_REPLY_SUCC_PREFIX,
./teamd/teamd_usock_common.h:51:	buf = malloc(expected_len + 1);
./teamd/teamd_bpf_chef.c:325:	pa = malloc(sizeof(struct stack_entry));
./teamd/teamd_bpf_chef.c:360:	pl = malloc(sizeof(struct stack_entry));
./teamd/teamd_dbus.c:135:	err = asprintf(&err_code_buf, TEAMD_DBUS_IFACE "%s", err_code);
./teamd/teamd_dbus.c:535:	err = asprintf(&service_name, TEAMD_DBUS_SERVICE ".%s",

== files() ==
./teamd/teamd_runner_lacp.c:1188:	err = teamd_packet_sock_open(&lacp_port->sock,
./teamd/teamd_lw_psr.c:135:	err = psr_ppriv->ops->sock_open(psr_ppriv);
./teamd/teamd_lw_arp_ping.c:128:static int lw_ap_sock_open(struct lw_psr_port_priv *psr_ppriv)
./teamd/teamd_lw_arp_ping.c:143:	return teamd_packet_sock_open(&psr_ppriv->sock,
./teamd/teamd_zmq.c:209:static int teamd_zmq_sock_open(struct teamd_context *ctx)
./teamd/teamd_zmq.c:271:	err = teamd_zmq_sock_open(ctx);
./teamd/teamd.h:351:int teamd_packet_sock_open(int *sock_p, const uint32_t ifindex,
./teamd/teamd_lw_nsna_ping.c:68:static int icmp6_sock_open(int *sock_p)
./teamd/teamd_lw_nsna_ping.c:126:static int lw_nsnap_sock_open(struct lw_psr_port_priv *psr_ppriv)
./teamd/teamd_lw_nsna_ping.c:137:	err = teamd_packet_sock_open(&psr_ppriv->sock,
./teamd/teamd_lw_nsna_ping.c:142:	err = icmp6_sock_open(&nsnap_ppriv->tx_sock);
./teamd/teamd_common.c:84:int teamd_packet_sock_open(int *sock_p, const uint32_t ifindex,
./teamd/teamd_usock.c:295:static int teamd_usock_sock_open(struct teamd_context *ctx)
./teamd/teamd_usock.c:356:	err = teamd_usock_sock_open(ctx);

== logging() ==
./utils/teamnl.c:603:			fprintf(stderr, "Command failed: %s\n", strerror(-err));
./utils/teamdctl.c:885:		       team_devname, strerror(-err));
./utils/teamdctl.c:1073:		pr_err("teamdctl_connect failed (%s)\n", strerror(-err));
./utils/teamdctl.c:1086:		pr_err("command call failed (%s)\n", strerror(-err));
./libteam/team_private.h:90:#  define warn(th, arg...) team_log_cond(th, LOG_WARNING, ## arg)
./libteam/team_private.h:95:#  define warn(th, arg...) team_log_null(th, ## arg)
./libteam/libteam.c:1562:		warn(th, "Failed to set carrier. Kernel probably does not support setting carrier");
./libteam/options.c:337:			err(th, "Failed to update option: %s", strerror(-err));
./examples/team_monitor.c:61:			perror("select()");
./libteamdctl/cli_zmq.c:40:static int cli_zmq_process_msg(struct teamdctl *tdc, char *msg,
./libteamdctl/cli_zmq.c:75:void my_free_msg(void *data, void *hind) {
./libteamdctl/cli_zmq.c:87:		teamd_log_warn("zmq: send failed: %s", strerror(errno));
./libteamdctl/cli_zmq.c:108:		teamd_log_warn("zmq: send failed: %s", strerror(errno));
./libteamdctl/cli_zmq.c:183:	err = cli_zmq_process_msg(tdc, recvmsg, &replystr);
./libteamdctl/cli_usock.c:37:static int cli_usock_process_msg(struct teamdctl *tdc, char *msg,
./libteamdctl/cli_usock.c:201:	err = teamd_usock_recv_msg(cli_usock->sock, &recvmsg);
./libteamdctl/cli_usock.c:205:	err = cli_usock_process_msg(tdc, recvmsg, &replystr);
./libteamdctl/cli_dbus.c:39:static int cli_dbus_check_error_msg(struct teamdctl *tdc, DBusMessage *msg)
./libteamdctl/cli_dbus.c:151:	err = cli_dbus_check_error_msg(tdc, msg);
./libteamdctl/teamdctl_private.h:82:#  define warn(tdc, arg...) teamdctl_log_cond(tdc, LOG_WARNING, ## arg)
./libteamdctl/teamdctl_private.h:87:#  define warn(tdc, arg...) teamdctl_log_null(tdc, ## arg)
./include/linux/tipc.h:193: * Ancillary data objects supported by recvmsg()
./teamd/teamd.c:179:					optarg, strerror(errno));
./teamd/teamd.c:267:		teamd_log_warn("some periodic function calls missed (%" PRIu64 ")",
./teamd/teamd.c:327:				teamd_log_warn("Loop callback failed with: %s",
./teamd/teamd.c:328:					       strerror(-err));
./teamd/teamd.c:693:		teamd_log_warn("Got SIGINT, SIGQUIT or SIGTERM.");
./teamd/teamd.c:980:		teamd_log_warn("Note \"%s\" runner does not select team mode resulting in no functionality!",
./teamd/teamd.c:1027:				teamd_log_warn("Failed to set \"notify_peers_count\". Kernel probably does not support this option yet.");
./teamd/teamd.c:1046:				teamd_log_warn("Failed to set \"notify_peers_interval\". Kernel probably does not support this option yet.");
./teamd/teamd.c:1065:				teamd_log_warn("Failed to set \"mcast_rejoin_count\". Kernel probably does not support this option yet.");
./teamd/teamd.c:1084:				teamd_log_warn("Failed to set \"mcast_rejoin_interval\". Kernel probably does not support this option yet.");
./teamd/teamd.c:1734:			teamd_log_warn("Failed to kill daemon: %s", strerror(errno));
./teamd/teamd.c:1745:			teamd_log_err("Failed: %s", strerror(-err));
./teamd/teamd_runner_lacp.c:302:		teamd_log_warn("%s: Port seems to be loopbacked to the same "
./teamd/teamd_runner_lacp.c:1038:		teamd_log_warn("malformed LACP PDU came.");
./teamd/teamd_zmq.c:86:void my_free_msg(void *data, void *hind) {
./teamd/teamd_zmq.c:97:		teamd_log_warn("zmq: send failed: %s", strerror(errno));
./teamd/teamd_zmq.c:137:static int process_rcv_msg(struct teamd_context *ctx, char *rcv_msg)
./teamd/teamd_zmq.c:192:		err = process_rcv_msg(ctx, zmq_msg_data(&msg));
./teamd/teamd.h:50:#define teamd_log_warn(args...) daemon_log(LOG_WARNING, ##args)
./teamd/teamd_link_watch.c:52:		teamd_log_err("getaddrinfo failed: %s", gai_strerror(err));
./teamd/teamd_link_watch.c:74:		teamd_log_err("getnameinfo failed: %s", gai_strerror(err));
./teamd/teamd_ifinfo_watch.c:41:			teamd_log_warn("Team device removal detected.");
./teamd/teamd_common.c:69:		teamd_log_warn("Kernel does not support accessing skb->vlan_tci from BPF,\n"
./teamd/teamd_phys_port_check.c:116:			teamd_log_warn("%s: device is using the same physical port as device %s. Note that teaming multiple devices which use the same physical port makes no sense.",
./teamd/teamd_per_port.c:419:		teamd_log_warn("%s: Can't get port priority. Using default.",
./teamd/teamd_config.c:43:			teamd_log_warn("Command line config string is present, ignoring given config file.");
./teamd/teamd_hash_func.c:120:			teamd_log_warn("Hash frag named \"%s\" not found.",
./teamd/teamd_usock.c:126:		teamd_log_warn("Usock send failed: %s", strerror(errno));
./teamd/teamd_usock.c:166:static int process_rcv_msg(struct teamd_context *ctx, int sock, char *rcv_msg)
./teamd/teamd_usock.c:211:	err = teamd_usock_recv_msg(acc_conn->sock, &msg);
./teamd/teamd_usock.c:219:	err = process_rcv_msg(ctx, acc_conn->sock, msg);
./teamd/teamd_usock_common.h:40:static inline int teamd_usock_recv_msg(int sock, char **p_str)
./teamd/teamd_dbus.c:138:	dbus_ops_priv->reply = dbus_message_new_error(dbus_ops_priv->message,

== environment() ==
./libteam/libteam.c:384:	env = getenv("TEAM_LOG");
./libteamdctl/libteamdctl.c:176:	env = getenv("TEAMDCTL_LOG");

== privileged() ==
./include/private/misc.h:92:	ret = ioctl(sock, SIOCGIFINDEX, &ifr);
./teamd/teamd_runner_lacp.c:753:	ret = ioctl(lacp_port->sock, add ? SIOCADDMULTI : SIOCDELMULTI, &ifr);
./teamd/teamd_lw_tipc.c:133:	if (ioctl(tipc_ppriv->topsrv_sock, SIOCGETLINKNAME, &lnr) < 0)
./teamd/teamd_usock_common.h:47:	ret = ioctl(sock, SIOCINQ, &expected_len);

== networking() ==
./libteam/libteam.c:117:	case NLE_AF_NOSUPPORT:		return EAFNOSUPPORT;
./libteam/libteam.c:1624:	nl_addr = nl_addr_build(AF_UNSPEC, (void *) addr, addr_len);
./libteam/ifinfo.c:332:		.rtgen_family = AF_UNSPEC,
./libteamdctl/cli_usock.c:49:	if (!strcmp(TEAMD_USOCK_REPLY_SUCC_PREFIX, str)) {
./libteamdctl/cli_usock.c:51:	} else if (!strcmp(TEAMD_USOCK_REPLY_ERR_PREFIX, str)) {
./libteamdctl/cli_usock.c:166:	err= myasprintf(&msg, "%s\n%s\n", TEAMD_USOCK_REQUEST_PREFIX,
./libteamdctl/cli_usock.c:233:	addr.sun_family = AF_UNIX;
./libteamdctl/cli_usock.c:237:	cli_usock->sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
./include/linux/filter.h:14:#define BPF_MAJOR_VERSION 1
./include/linux/filter.h:15:#define BPF_MINOR_VERSION 1
./include/linux/filter.h:38:#define BPF_CLASS(code) ((code) & 0x07)
./include/linux/filter.h:39:#define         BPF_LD          0x00
./include/linux/filter.h:40:#define         BPF_LDX         0x01
./include/linux/filter.h:41:#define         BPF_ST          0x02
./include/linux/filter.h:42:#define         BPF_STX         0x03
./include/linux/filter.h:43:#define         BPF_ALU         0x04
./include/linux/filter.h:44:#define         BPF_JMP         0x05
./include/linux/filter.h:45:#define         BPF_RET         0x06
./include/linux/filter.h:46:#define         BPF_MISC        0x07
./include/linux/filter.h:49:#define BPF_SIZE(code)  ((code) & 0x18)
./include/linux/filter.h:50:#define         BPF_W           0x00
./include/linux/filter.h:51:#define         BPF_H           0x08
./include/linux/filter.h:52:#define         BPF_B           0x10
./include/linux/filter.h:53:#define BPF_MODE(code)  ((code) & 0xe0)
./include/linux/filter.h:54:#define         BPF_IMM         0x00
./include/linux/filter.h:55:#define         BPF_ABS         0x20
./include/linux/filter.h:56:#define         BPF_IND         0x40
./include/linux/filter.h:57:#define         BPF_MEM         0x60
./include/linux/filter.h:58:#define         BPF_LEN         0x80
./include/linux/filter.h:59:#define         BPF_MSH         0xa0
./include/linux/filter.h:62:#define BPF_OP(code)    ((code) & 0xf0)
./include/linux/filter.h:63:#define         BPF_ADD         0x00
./include/linux/filter.h:64:#define         BPF_SUB         0x10
./include/linux/filter.h:65:#define         BPF_MUL         0x20
./include/linux/filter.h:66:#define         BPF_DIV         0x30
./include/linux/filter.h:67:#define         BPF_OR          0x40
./include/linux/filter.h:68:#define         BPF_AND         0x50
./include/linux/filter.h:69:#define         BPF_LSH         0x60
./include/linux/filter.h:70:#define         BPF_RSH         0x70
./include/linux/filter.h:71:#define         BPF_NEG         0x80
./include/linux/filter.h:72:#define		BPF_MOD		0x90
./include/linux/filter.h:73:#define		BPF_XOR		0xa0
./include/linux/filter.h:75:#define         BPF_JA          0x00
./include/linux/filter.h:76:#define         BPF_JEQ         0x10
./include/linux/filter.h:77:#define         BPF_JGT         0x20
./include/linux/filter.h:78:#define         BPF_JGE         0x30
./include/linux/filter.h:79:#define         BPF_JSET        0x40
./include/linux/filter.h:80:#define BPF_SRC(code)   ((code) & 0x08)
./include/linux/filter.h:81:#define         BPF_K           0x00
./include/linux/filter.h:82:#define         BPF_X           0x08
./include/linux/filter.h:84:/* ret - BPF_K and BPF_X also apply */
./include/linux/filter.h:85:#define BPF_RVAL(code)  ((code) & 0x18)
./include/linux/filter.h:86:#define         BPF_A           0x10
./include/linux/filter.h:89:#define BPF_MISCOP(code) ((code) & 0xf8)
./include/linux/filter.h:90:#define         BPF_TAX         0x00
./include/linux/filter.h:91:#define         BPF_TXA         0x80
./include/linux/filter.h:93:#ifndef BPF_MAXINSNS
./include/linux/filter.h:94:#define BPF_MAXINSNS 4096
./include/linux/filter.h:100:#ifndef BPF_STMT
./include/linux/filter.h:101:#define BPF_STMT(code, k) { (unsigned short)(code), 0, 0, k }
./include/linux/filter.h:103:#ifndef BPF_JUMP
./include/linux/filter.h:104:#define BPF_JUMP(code, k, jt, jf) { (unsigned short)(code), jt, jf, k }
./include/linux/filter.h:108: * Number of scratch memory words for: BPF_ST and BPF_STX
./include/linux/filter.h:110:#define BPF_MEMWORDS 16
./include/linux/tipc.h:161:#ifndef AF_TIPC
./include/linux/tipc.h:162:#define AF_TIPC		30
./include/linux/tipc.h:165:#ifndef PF_TIPC
./include/linux/tipc.h:166:#define PF_TIPC		AF_TIPC
./include/linux/tipc.h:209:#define TIPC_SOCK_RECVQ_DEPTH	132	/* Default: none (read only) */
./include/private/misc.h:87:	sock = socket(PF_PACKET, SOCK_DGRAM, 0);
./teamd/teamd_runner_lacp.c:750:	sa->sa_family = AF_UNSPEC;
./teamd/teamd_lw_arp_ping.c:58:	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, OFFSET_ARP_OP_CODE),
./teamd/teamd_lw_arp_ping.c:59:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REPLY, 1, 0),
./teamd/teamd_lw_arp_ping.c:60:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REQUEST, 0, 1),
./teamd/teamd_lw_arp_ping.c:61:	BPF_STMT(BPF_RET + BPF_K, (u_int) -1),
./teamd/teamd_lw_arp_ping.c:62:	BPF_STMT(BPF_RET + BPF_K, 0),
./teamd/teamd_lw_arp_ping.c:71:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT),
./teamd/teamd_lw_arp_ping.c:72:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, 0, 4),
./teamd/teamd_lw_arp_ping.c:73:	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, OFFSET_ARP_OP_CODE),
./teamd/teamd_lw_arp_ping.c:74:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REPLY, 1, 0),
./teamd/teamd_lw_arp_ping.c:75:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REQUEST, 0, 1),
./teamd/teamd_lw_arp_ping.c:76:	BPF_STMT(BPF_RET + BPF_K, (u_int) -1),
./teamd/teamd_lw_arp_ping.c:77:	BPF_STMT(BPF_RET + BPF_K, 0),
./teamd/teamd_lw_arp_ping.c:86:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT),
./teamd/teamd_lw_arp_ping.c:87:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0, 6, 0),
./teamd/teamd_lw_arp_ping.c:88:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, SKF_AD_OFF + SKF_AD_VLAN_TAG),
./teamd/teamd_lw_arp_ping.c:89:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, 0xffff, 0, 4), /* 0xffff will be replaced by vland id */
./teamd/teamd_lw_arp_ping.c:90:	BPF_STMT(BPF_LD + BPF_H + BPF_ABS, OFFSET_ARP_OP_CODE),
./teamd/teamd_lw_arp_ping.c:91:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REPLY, 1, 0),
./teamd/teamd_lw_arp_ping.c:92:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARPOP_REQUEST, 0, 1),
./teamd/teamd_lw_arp_ping.c:93:	BPF_STMT(BPF_RET + BPF_K, (u_int) -1),
./teamd/teamd_lw_arp_ping.c:94:	BPF_STMT(BPF_RET + BPF_K, 0),
./teamd/teamd_lw_arp_ping.c:111:			     AF_INET, hostname);
./teamd/teamd_lw_arp_ping.c:124:	return __str_sockaddr((struct sockaddr *) &sin, sizeof(sin), AF_INET,
./teamd/teamd_usock.h:20:#ifndef _TEAMD_USOCK_H_
./teamd/teamd_usock.h:21:#define _TEAMD_USOCK_H_
./teamd/teamd_usock.h:26:#endif /* _TEAMD_USOCK_H_ */
./teamd/teamd_lw_nsna_ping.c:39:			     AF_INET6, hostname);
./teamd/teamd_lw_nsna_ping.c:49:	return __str_sockaddr((struct sockaddr *) sin6, sizeof(*sin6), AF_INET6,
./teamd/teamd_lw_nsna_ping.c:76:	sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
./teamd/teamd_lw_nsna_ping.c:113:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, OFFSET_NEXT_HEADER),
./teamd/teamd_lw_nsna_ping.c:114:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, IPPROTO_ICMPV6, 0, 3),
./teamd/teamd_lw_nsna_ping.c:115:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, OFFSET_NA_TYPE),
./teamd/teamd_lw_nsna_ping.c:116:	BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ND_NEIGHBOR_ADVERT, 0, 1),
./teamd/teamd_lw_nsna_ping.c:117:	BPF_STMT(BPF_RET + BPF_K, (u_int) -1),
./teamd/teamd_lw_nsna_ping.c:118:	BPF_STMT(BPF_RET + BPF_K, 0),
./teamd/teamd_common.c:34:	BPF_STMT(BPF_LD + BPF_B + BPF_ABS, -1),
./teamd/teamd_common.c:35:	BPF_STMT(BPF_RET + BPF_K, 0),
./teamd/teamd_common.c:94:	sock = socket(PF_PACKET, SOCK_DGRAM, 0);
./teamd/teamd_common.c:107:	ll_my.sll_family = AF_PACKET;
./teamd/teamd_bpf_chef.h:20:#ifndef _TEAMD_BPF_CHEF_H_
./teamd/teamd_bpf_chef.h:21:#define _TEAMD_BPF_CHEF_H_
./teamd/teamd_bpf_chef.h:56:#endif /* _TEAMD_BPF_CHEF_H_ */
./teamd/teamd_lw_tipc.c:151:		.family = AF_TIPC,
./teamd/teamd_lw_tipc.c:164:	priv->topsrv_sock = socket(AF_TIPC, SOCK_SEQPACKET, 0);
./teamd/teamd_usock.c:136:	err = asprintf(&strbuf, "%s\n%s\n%s\n", TEAMD_USOCK_REPLY_ERR_PREFIX,
./teamd/teamd_usock.c:151:	err = asprintf(&strbuf, "%s\n%s", TEAMD_USOCK_REPLY_SUCC_PREFIX,
./teamd/teamd_usock.c:177:	if (strcmp(TEAMD_USOCK_REQUEST_PREFIX, str)) {
./teamd/teamd_usock.c:224:#define USOCK_ACC_CONN_CB_NAME "usock_acc_conn"
./teamd/teamd_usock.c:237:	err = teamd_loop_callback_fd_add(ctx, USOCK_ACC_CONN_CB_NAME, acc_conn,
./teamd/teamd_usock.c:243:	teamd_loop_callback_enable(ctx, USOCK_ACC_CONN_CB_NAME, acc_conn);
./teamd/teamd_usock.c:256:	teamd_loop_callback_del(ctx, USOCK_ACC_CONN_CB_NAME, acc_conn);
./teamd/teamd_usock.c:293:#define USOCK_MAX_CLIENT_COUNT 10
./teamd/teamd_usock.c:305:	sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
./teamd/teamd_usock.c:311:	addr.sun_family = AF_UNIX;
./teamd/teamd_usock.c:330:	listen(sock, USOCK_MAX_CLIENT_COUNT);
./teamd/teamd_usock.c:347:#define USOCK_CB_NAME "usock"
./teamd/teamd_usock.c:359:	err = teamd_loop_callback_fd_add(ctx, USOCK_CB_NAME, ctx,
./teamd/teamd_usock.c:364:	teamd_loop_callback_enable(ctx, USOCK_CB_NAME, ctx);
./teamd/teamd_usock.c:376:	teamd_loop_callback_del(ctx, USOCK_CB_NAME, ctx);
./teamd/teamd_usock_common.h:20:#ifndef _TEAMD_USOCK_COMMON_H_
./teamd/teamd_usock_common.h:21:#define _TEAMD_USOCK_COMMON_H_
./teamd/teamd_usock_common.h:30:#define TEAMD_USOCK_REQUEST_PREFIX	"REQUEST"
./teamd/teamd_usock_common.h:31:#define TEAMD_USOCK_REPLY_ERR_PREFIX	"REPLY_ERROR"
./teamd/teamd_usock_common.h:32:#define TEAMD_USOCK_REPLY_SUCC_PREFIX	"REPLY_SUCCESS"
./teamd/teamd_usock_common.h:93:#endif /* _TEAMD_USOCK_COMMON_H_ */
./teamd/teamd_bpf_chef.c:78:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_B + BPF_ABS, pos))
./teamd/teamd_bpf_chef.c:81:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_H + BPF_ABS, pos))
./teamd/teamd_bpf_chef.c:84:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_W + BPF_ABS, pos))
./teamd/teamd_bpf_chef.c:87:	add_inst(fprog, BPF_STMT(BPF_ST, 0))
./teamd/teamd_bpf_chef.c:90:	add_inst(fprog, BPF_STMT(BPF_STX, 0))
./teamd/teamd_bpf_chef.c:93:	add_inst(fprog, BPF_STMT(BPF_LDX + BPF_W + BPF_MEM, 0))
./teamd/teamd_bpf_chef.c:96:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_B + BPF_ABS,		\
./teamd/teamd_bpf_chef.c:100:	add_inst(fprog, BPF_STMT(BPF_MISC + BPF_TAX, 0));
./teamd/teamd_bpf_chef.c:103:	add_inst(fprog, BPF_STMT(BPF_MISC + BPF_TXA, 0));
./teamd/teamd_bpf_chef.c:106:	add_inst(fprog, BPF_STMT(BPF_RET + BPF_A, 0));
./teamd/teamd_bpf_chef.c:110:		add_inst(fprog, BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K,	\
./teamd/teamd_bpf_chef.c:117:		add_inst(fprog, BPF_JUMP(BPF_JMP + BPF_JA, k, 0, 0));	\
./teamd/teamd_bpf_chef.c:124:		add_inst(fprog, BPF_JUMP(BPF_JMP + BPF_JSET + BPF_K,	\
./teamd/teamd_bpf_chef.c:131:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_B + BPF_ABS,		\
./teamd/teamd_bpf_chef.c:135:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_B + BPF_ABS,		\
./teamd/teamd_bpf_chef.c:139:	add_inst(fprog, BPF_STMT(BPF_LDX + BPF_B + BPF_MSH, pos))
./teamd/teamd_bpf_chef.c:142:	add_inst(fprog, BPF_STMT(BPF_LD + BPF_H + BPF_IND, pos))
./utils/teamnl.c:206:			len = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
./utils/teamdctl.c:1069:	err = teamdctl_connect(tdc, team_devname, addr,
./utils/teamdctl.c:1094:	teamdctl_disconnect(tdc);
./libteam/libteam.c:411:	th->nl_cli.sock_event = nl_cli_alloc_socket();
./libteam/libteam.c:415:	th->nl_cli.sock = nl_cli_alloc_socket();
./libteam/libteam.c:418:	err = nl_cli_connect(th->nl_cli.sock, NETLINK_ROUTE);
./libteam/libteam.c:569:	err = genl_connect(th->nl_sock);
./libteam/libteam.c:575:	err = genl_connect(th->nl_sock_event);
./libteam/libteam.c:626:	nl_cli_connect(th->nl_cli.sock_event, NETLINK_ROUTE);
./libteamdctl/cli_zmq.c:219:	sock = zmq_socket(context, ZMQ_REQ);
./libteamdctl/cli_zmq.c:225:	err = zmq_connect(sock, tdc->addr);
./libteamdctl/cli_zmq.c:227:		err(tdc, "zmq: Failed to connect socket (%s).", tdc->addr);
./libteamdctl/cli_usock.c:237:	cli_usock->sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
./libteamdctl/cli_usock.c:243:	err = connect(cli_usock->sock, (struct sockaddr *) &addr,
./libteamdctl/cli_usock.c:246:		err(tdc, "usock: Failed to connect socket (%s).",
./libteamdctl/libteamdctl.c:298:int teamdctl_connect(struct teamdctl *tdc, const char *team_name,
./libteamdctl/libteamdctl.c:377:void teamdctl_disconnect(struct teamdctl *tdc)
./include/linux/tipc.h:193: * Ancillary data objects supported by recvmsg()
./include/private/misc.h:87:	sock = socket(PF_PACKET, SOCK_DGRAM, 0);
./include/teamdctl.h:45:int teamdctl_connect(struct teamdctl *tdc, const char *team_name,
./include/teamdctl.h:47:void teamdctl_disconnect(struct teamdctl *tdc);
./teamd/teamd.c:255:	ret = read(fd, &exp, sizeof(uint64_t));
./teamd/teamd.c:259:		teamd_log_err("read() failed.");
./teamd/teamd.c:263:		teamd_log_err("read() returned unexpected number of bytes.");
./teamd/teamd.c:383:			err = read(ctrl_fd, &ctrl_byte, 1);
./teamd/teamd.c:400:				teamd_log_err("read() failed.");
./teamd/teamd.c:419:	err = write(ctx->run_loop.ctrl_pipe_w, &ctrl_byte, 1);
./teamd/teamd_runner_lacp.c:1021:	err = teamd_sendto(lacp_port->sock, &lacpdu, sizeof(lacpdu), 0,
./teamd/teamd_runner_lacp.c:1032:	err = teamd_recvfrom(lacp_port->sock, &lacpdu, sizeof(lacpdu), 0,
./teamd/teamd_runner_lacp.c:1103:static int lacp_callback_socket(struct teamd_context *ctx, int events,
./teamd/teamd_lw_psr.c:64:static int lw_psr_callback_socket(struct teamd_context *ctx, int events, void *priv)
./teamd/teamd_lw_arp_ping.c:291:		return teamd_sendto(psr_ppriv->sock, &avp, sizeof(avp),
./teamd/teamd_lw_arp_ping.c:295:		return teamd_sendto(psr_ppriv->sock, &ap, sizeof(ap),
./teamd/teamd_lw_arp_ping.c:311:	err = teamd_recvfrom(psr_ppriv->sock, &ap, sizeof(ap), 0,
./teamd/teamd_zmq.c:222:	sock = zmq_socket(context, ZMQ_REP);
./teamd/teamd_zmq.c:238:	rc = zmq_bind(sock, addr);
./teamd/teamd.h:357:int teamd_sendto(int sockfd, const void *buf, size_t len, int flags,
./teamd/teamd.h:359:int teamd_recvfrom(int sockfd, void *buf, size_t len, int flags,
./teamd/teamd_workq.c:30:static int teamd_workq_callback_socket(struct teamd_context *ctx, int events,
./teamd/teamd_workq.c:40:	ret = read(ctx->workq.pipe_r, bytes, sizeof(bytes));
./teamd/teamd_workq.c:108:	err = write(ctx->workq.pipe_w, &byte, 1);
./teamd/teamd_lw_nsna_ping.c:76:	sock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
./teamd/teamd_lw_nsna_ping.c:222:	err = teamd_sendto(nsnap_ppriv->tx_sock, &nsp, sizeof(nsp), 0,
./teamd/teamd_lw_nsna_ping.c:242:	err = teamd_recvfrom(psr_ppriv->sock, &nap, sizeof(nap), 0,
./teamd/teamd_common.c:94:	sock = socket(PF_PACKET, SOCK_DGRAM, 0);
./teamd/teamd_common.c:110:	ret = bind(sock, (struct sockaddr *) &ll_my, sizeof(ll_my));
./teamd/teamd_common.c:143:int teamd_sendto(int sockfd, const void *buf, size_t len, int flags,
./teamd/teamd_common.c:149:	ret = sendto(sockfd, buf, len, flags, dest_addr, addrlen);
./teamd/teamd_common.c:167:int teamd_recvfrom(int sockfd, void *buf, size_t len, int flags,
./teamd/teamd_common.c:174:	ret = recvfrom(sockfd, buf, len, flags, src_addr, &tmp_addrlen);
./teamd/teamd_lw_tipc.c:117:static int lw_tipc_callback_socket(struct teamd_context *ctx, int events, void *priv)
./teamd/teamd_lw_tipc.c:125:	err = teamd_recvfrom(tipc_ppriv->topsrv_sock, &event, sizeof(event), 0,
./teamd/teamd_lw_tipc.c:164:	priv->topsrv_sock = socket(AF_TIPC, SOCK_SEQPACKET, 0);
./teamd/teamd_lw_tipc.c:180:	err = connect(priv->topsrv_sock, (struct sockaddr *) &sa_topsrv, sizeof(sa_topsrv));
./teamd/teamd_usock.c:305:	sock = socket(AF_UNIX, SOCK_SEQPACKET, 0);
./teamd/teamd_usock.c:323:	err = bind(sock, (struct sockaddr *) &addr,
./teamd/teamd_usock.c:330:	listen(sock, USOCK_MAX_CLIENT_COUNT);
./teamd/teamd_dbus.c:246:	dbus_connection_set_exit_on_disconnect(ctx->dbus.con, FALSE);
./teamd/teamd_dbus.c:378:	err = read(dp->fd_r, &byte, 1);
./teamd/teamd_dbus.c:381:			teamd_log_err("dbus: dispatch, read() failed.");
./teamd/teamd_dbus.c:396:	err = write(dp->fd_w, "a", 1);

== http:// ==

== encryption ==

== sql() ==
./libteamdctl/libteamdctl.c:125:static char *reply_cache_query(struct teamdctl *tdc, const char *id)
./libteamdctl/libteamdctl.c:518:	return reply_cache_query(tdc, "ConfigDump");
./libteamdctl/libteamdctl.c:550:	return reply_cache_query(tdc, "ConfigDumpActual");
./libteamdctl/libteamdctl.c:582:	return reply_cache_query(tdc, "StateDump");

== tmp() ==

== priv_cmds (sudo, gksu, pkexec) ==

== envvars() ==

== webkit() ==

== comments (XXX, FIXME, TODO) ==

== unsafe input mechanisms ==

