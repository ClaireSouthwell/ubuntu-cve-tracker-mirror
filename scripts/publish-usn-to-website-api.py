#! /usr/bin/env python3
# imported from https://github.com/canonical-web-and-design/ubuntu.com/blob/master/webapp/security/fixtures/usns.py

# Standard library
import argparse
import json
import sys
import os
#import re
from datetime import datetime
from http.cookiejar import MozillaCookieJar

# Packages
from macaroonbakery import httpbakery

def guess_binary_links(binary, version, sources):
    '''Guess links to the source package based on binary package and version.
    Keyword Arguments:
    binary -- the name of the binary
    version -- the version of the binary
    sources -- a dictionary of source package names to source package versions
    '''
    match_first = False
    source_match = None
    version_match = None
    source_link = None
    version_link = None

    if not sources:
        # Old USNs may not have any sources listed. We can't make any sort of a
        # guess in this situation.
        return (None, None)
    if len(sources) == 1:
        # There's a many-to-one mapping of binaries to a source package. Use
        # the only possible source package for all binaries.
        match_first = True
    elif not version:
        # There are multiple combinations of possible binary to source package
        # mappings. We can't make an educated guess if we don't have a valid
        # binary package version so don't attempt to construct a link.
        return (None, None)

    for source in sources:
        source_version = sources[source].get('version')
        if match_first or version == source_version:
            source_match = source
            version_match = source_version
            break

    if source_match:
        source_link = 'https://launchpad.net/ubuntu/+source/' + source_match
        if version_match:
            # Be certain to use the source package version rather than the
            # binary package version here or the link will be broken for
            # certain packages
            version_link = source_link + '/' + version_match

    return (source_link, version_link)

parser = argparse.ArgumentParser(description="CLI to post USNs",)
parser.add_argument(
    "--json", action="store", type=str,
    required=True,
    help='path to json file',
    )
parser.add_argument(
    "--action", action="store", type=str,
    default="add",
    choices=['add', 'update', 'remove'],
    help='api action to perform',
    )
parser.add_argument(
    "--endpoint", action="store", type=str,
    #default="https://ubuntu.com/security/notices",
    default="https://staging.ubuntu.com/security/notices",
    #default="http://localhost:8001/security/notices",
    help='api endpoint url',
    )
#parser.add_argument(
    #"--errors", action="store", type=str,
    #default="exit",
    #choices=['continue', 'exit'],
    #help="what to do when the api returns a non-200 status",
    #)

args = parser.parse_args()

if args.action == 'add':
    http_method = 'POST'
elif args.action == 'update':
    http_method = 'PUT'
elif args.action == 'remove':
    sys.exit(f"Error: {args.action} action not implemented yet")
else:
    sys.exit(f"Error: {args.action} action not implemented yet")

client = httpbakery.Client(cookies=MozillaCookieJar(".login"))

# Make a first call to make sure we are logged in
response = client.request(http_method, url=args.endpoint)


with open(args.json) as usn_json:
    payload = json.load(usn_json).items()

    for notice_id, notice in payload:
        # format release_packages
        release_packages = {}

        for codename, packages in notice["releases"].items():
            release_packages[codename] = []
            for name, info in packages["sources"].items():
                release_packages[codename].append(
                    {
                        "name": name,
                        "version": info["version"],
                        "description": info["description"],
                        "is_source": "true"
                    }
                )

            for name, info in packages["binaries"].items():
                source_link, version_link = guess_binary_links(
                    name, info["version"], packages["sources"]
                )
                release_packages[codename].append(
                    {
                        "name": name,
                        "version": info["version"],
                        "is_source": "false",
                        "source_link": source_link,
                        "version_link": version_link,
                    }
                )
        # format CVEs and references
        cves = []
        references = []
        for reference in notice["cves"]:
            if reference.startswith("CVE-"):
                cves.append(reference)
            else:
                references.append(reference)

        # Build endpoint
        endpoint = args.endpoint
        if http_method == "PUT":
            endpoint = f"{args.endpoint}/{notice['id']}"

        response = client.request(
            http_method,
            url=endpoint,
            json={
                "id": notice["id"],
                "description": notice["description"],
                "references": references,
                "cves": cves,
                "release_packages": release_packages,
                "title": notice["title"],
                "published": datetime.fromtimestamp(
                    notice["timestamp"]
                ).isoformat(),
                "summary": notice["summary"],
                "instructions": notice.get("action"),
            },
        )

        print(response, response.text)

        #if args.errors == 'exit' and not re.match("2\d\d",str(response)):
            #sys.exit(1)
