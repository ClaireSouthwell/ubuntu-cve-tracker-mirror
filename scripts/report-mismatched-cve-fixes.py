#!/usr/bin/python
# Author: Kees Cook <kees@ubuntu.com>
# Copyright (C) 2011 Canonical Ltd.
#
# Reports CVEs that are not reported in USNs correctly.
#
# If you're going to use --update, you'll need to fetch the -all database and
# use --database too so you can copy it back after updating it.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
# Fetch the USN database first. Override location with --database
#  wget http://people.canonical.com/~ubuntu-security/usn/database.pickle
#
import cPickle, sys, os, os.path, optparse, usn_lib, cve_lib, glob
from source_map import version_compare
try:
    import lpl_common
except:
    print >>sys.stderr, "lpl_common.py seems to be missing. Please create a symlink from $UQT/common/lpl_common.py to $UCT/scripts/"
    sys.exit(1)

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose", dest="verbose", help="Report specific CVEs", action='store_true')
parser.add_option("-D", "--database", help="Specify location of USN data (default 'database.pickle')", default="database.pickle")
parser.add_option("-R", "--reverted", help="Specify location of reverted CVE list (default 'reverted-CVEs.txt')", default="reverted-CVEs.txt")
parser.add_option("-p", "--packages", help="Comma separated list of packages to examine (default is all kernel source packages)", default=None)
parser.add_option("-d", "--debug", help="Report additional debugging while processing USNs", action='store_true')
parser.add_option("--ignore-mismatched", help="Ignore CVEs reported in the wrong USN", action='store_true')
parser.add_option("--ignore-unreported", help="Ignore CVEs not yet reported in a USN", action='store_true')
parser.add_option("--only-active", help="Only report active CVEs when reporting missing CVEs in a USN", action='store_true')
parser.add_option("-u", "--update", help="Add missing CVEs to local USN database", action='store_true')
(opt, args) = parser.parse_args()

if opt.packages == None:
    opt.packages = cve_lib.kernel_srcs
else:
    opt.packages = set(opt.packages.split(','))

reverted = usn_lib.get_reverted(opt.reverted)
db       = usn_lib.load_database(opt.database)

# API interface
lp = None
ubuntu = None
archive = None
release = dict()
series = dict()

def get_release_version(rel, pkg, key='release', pockets=['Release','Updates','Security','Proposed']):
    global lp, ubuntu, archive, release, series
    if not release.has_key(rel) or not release[rel].has_key(pkg) or not release[rel][pkg].has_key(key):
        if archive == None:
            if opt.debug:
                print >>sys.stderr, "Starting LP API ..."
            lp = lpl_common.connect() #beta=opt.beta, uri=opt.uri)
            if opt.debug:
                print >>sys.stderr, "\tauthenticated ..."
            ubuntu = lp.distributions['ubuntu']
            if opt.debug:
                print >>sys.stderr, "\tUbuntu distribution found ..."
            archive = ubuntu.archives[0]
            if opt.debug:
                print >>sys.stderr, "\tUbuntu archive found."
        if not series.has_key(rel):
            if opt.debug:
                print >>sys.stderr, "API: getSeries(%s) ..." % (rel)
            series[rel] = ubuntu.getSeries(name_or_version=rel)
        release.setdefault(rel, dict())
        release[rel].setdefault(pkg, dict())
        for pocket in pockets:
            if opt.debug:
                print >>sys.stderr, "API: getPublishedSources(%s, %s, %s) ..." % (rel, pocket, pkg)
            pkgs = archive.getPublishedSources(source_name=pkg, distro_series=series[rel], pocket=pocket, status='Published', exact_match=True)
            if len(pkgs) < 1:
                if opt.debug:
                    print >>sys.stderr, "\tDNE"
                continue
            release[rel][pkg][key] = pkgs[0].source_package_version
            if opt.debug:
                print >>sys.stderr, "\t%s" % (release[rel][pkg][key])
            break
    release[rel][pkg].setdefault(key, "~")
    return release[rel][pkg][key]

# Find all CVE paths
cvelist = []
cves = dict()
active = set()
check_dirs = [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]
for dirname in check_dirs:
    if len(args)==0:
        items = glob.glob('%s/CVE-*' % (dirname))
    else:
        items = [y for y in ['%s/%s' % (dirname, x) for x in args] if os.path.exists(y)]
    items = sorted(items)
    for cvefile in items:
        cvelist += [cvefile]

# Load and keep only kernel CVEs
if opt.debug:
    print >>sys.stderr, "Loading CVEs ..."
for cvefile in cvelist:
    state, cve = cvefile.split('/')[-2:]
    info = cve_lib.load_cve(cvefile)
    keep = False
    for pkg in opt.packages:
        if pkg in info['pkgs']:
            keep = True
            break
    if keep:
        cves[cve] = info
        if state == "active":
            active.add(cve)

pkgs = usn_lib.packages_dict(db, opt.packages, opt=opt)

# Looks at all USNs and see if CVEs are reported in the wrong USNs
if not opt.ignore_mismatched:
  for usn in sorted(db, cmp=version_compare):
    # This USN is ancient and lacks any CVE information
    if not db[usn].has_key('cves'):
        if (opt.debug):
            print "%s lacks CVEs" % (usn)
        continue

    # cves[cve]
    # 'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
    # db[usn]
    # 'releases', rel, 'sources', pkg, 'version'
    for rel in db[usn]['releases']:
        # Ignore EOL releases
        if rel in cve_lib.eol_releases:
            continue
        # Ignore old USNs
        if not db[usn]['releases'][rel].has_key('sources'):
            continue
        # Look at fixed packages
        for pkg in opt.packages:
            if not db[usn]['releases'][rel]['sources'].has_key(pkg):
                continue

            # Find versions fixed
            for cve in db[usn]['cves']:
                if not cve.startswith('CVE-'):
                    continue
                if not cve in cves:
                    # Must depend on CVEs being accurate, so if it's missing, it's missing
                    #print "USN %s: mentions unloaded %s" % (usn, cve)
                    continue

                # If not mentioned in the CVE, it wasn't vulnerable
                if not cves[cve]['pkgs'].has_key(pkg):
                    continue

                # If release not mentioned in the CVE,it wasn't vulnerable
                if not cves[cve]['pkgs'][pkg].has_key(rel):
                    continue

                if cves[cve]['pkgs'][pkg][rel][0] == 'pending':
                    # sync-from-usns.py needs to be run...
                    print "USN %s: %s in %s is still pending for %s (fixed in %s)" % (usn, pkg, rel, cve, db[usn]['releases'][rel]['sources'][pkg]['version'])
                    continue

                if cves[cve]['pkgs'][pkg][rel][0] == 'released':
                    fixed = cves[cve]['pkgs'][pkg][rel][1]
                    if fixed == db[usn]['releases'][rel]['sources'][pkg]['version']:
                        continue

                    # If it was fixed in the devel release, there is no USN
                    release_version = get_release_version(rel, pkg)
                    if version_compare(release_version, fixed) >= 0:
                        if opt.debug:
                            print >>sys.stderr, "Skipping %s in %s (fixed in %s, release was %s)" % (pkg, rel, fixed, release_version)
                        continue

                    # If "fixed" is in a published USN, we have a definitive mismatch.
                    if fixed in pkgs[pkg]:
                        if cve == 'CVE-2008-3831' and pkg == 'linux' and usn == '679-1':
                            # Hardcoded exceptions
                            continue
                        print "USN %s: %s in %s version mismatched, exact (USN is %s, %s shows %s, expected in USN %s)" % (usn, pkg, rel, db[usn]['releases'][rel]['sources'][pkg]['version'], cve, cves[cve]['pkgs'][pkg][rel][1], pkgs[pkg][fixed])
                        continue

                    # If "fixed" is between USN versions, find the first USN fix is >fixed
                    for ver in (sorted(pkgs[pkg], cmp=version_compare)):
                        if version_compare(ver, fixed) > 0:
                            if pkgs[pkg][ver] != usn:
                                print "USN %s: %s in %s version mismatched, offset (USN is %s, %s shows %s, expected in USN %s)" % (usn, pkg, rel, db[usn]['releases'][rel]['sources'][pkg]['version'], cve, cves[cve]['pkgs'][pkg][rel][1], pkgs[pkg][ver])
                            break

# Looks at all active CVEs and sees which USN they should have been reported in
if not opt.ignore_unreported:
    # Create a per-CVE list of USNs that mention the CVE
    usns = dict()
    touched = set()
    for usn in sorted(db, cmp=version_compare):
        if not db[usn].has_key('cves'):
            continue
        for cve in db[usn]['cves']:
            if not cve.startswith('CVE-'):
                continue
            usns.setdefault(cve, set())
            usns[cve].add(usn)

    for cve in sorted(cves):
        if opt.only_active and not cve in active:
            continue
        usns.setdefault(cve, set())
        for pkg in opt.packages:
            if not cves[cve]['pkgs'].has_key(pkg):
                continue

            for rel in sorted(cves[cve]['pkgs'][pkg]):
                if rel in cve_lib.eol_releases + ['upstream','devel']:
                    # Ignore non-stable or EOL releases
                    continue
                status = cves[cve]['pkgs'][pkg][rel][0]
                fixed = cves[cve]['pkgs'][pkg][rel][1]
                if not status in ['pending', 'released']:
                    # Skip everything that isn't pending or released
                    continue
                if fixed == "":
                    # Skip pending with no destination version
                    continue
                latest = get_release_version(rel, pkg, key='security', pockets=['Security'])
                if version_compare(fixed, latest) > 0:
                    # Skip stuff fixed in an unreleased version
                    if opt.debug:
                        print >>sys.stderr, "%s: skipping %s in %s (fixed in %s, latest is %s)" % (cve, pkg, rel, fixed, latest)
                    continue

                reported = False
                for usn in sorted(usns[cve], cmp=version_compare):
                    if not db[usn]['releases'].has_key(rel):
                        continue
                    if not db[usn]['releases'][rel].has_key('sources'):
                        continue
                    if not db[usn]['releases'][rel]['sources'].has_key(pkg):
                        continue
                    reported = True
                    break
                if not reported:
                    usn = None
                    # find the first USN reported version is >=fixed
                    for ver in (sorted(pkgs[pkg], cmp=version_compare)):
                        if version_compare(ver, fixed) >= 0:
                            usn = pkgs[pkg][ver]
                            break
                    if usn == None:
                        print "%s for %s in %s (%s %s) needs a USN" % (cve, pkg, rel, status, fixed)
                    else:
                        print "%s for %s in %s (%s %s) should be reported in USN %s" % (cve, pkg, rel, status, fixed, usn)
                        desc = cves[cve].get('Ubuntu-Description','').strip()
                        if len(desc) == 0:
                            raise ValueError, "USN %s needs %s, but it lacks a Ubuntu-Description" % (usn, cve)
                        usn_lib.add_cves(db, usn, [cve])
                        usns[cve].add(usn)
                        touched.add(usn)
    if opt.update:
        usn_lib.save_database(db, opt.database)
        print "Updated: %s" % (" ".join(sorted(touched)))
