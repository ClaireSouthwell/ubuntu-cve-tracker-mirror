#!/usr/bin/env python
# Copyright 2010, Canonical, Ltd.
# Author: Jamie Strandboge <jamie@canonical.com>
# License: GPLv3
#
# Report items for the security team to sponsor. Used for reporting based on
# https://wiki.ubuntu.com/SecurityTeam/SponsorsQueue
#
# $ report-todo-sponsoring					# all open bugs
# $ report-todo-sponsoring --status New				# untriaged bugs
# $ report-todo-sponsoring --syncs				# requested fake syncs
# $ report-todo-sponsoring --has-patch				# bugs with patches
# $ report-todo-sponsoring --tags 'security-verification'	# bugs needing uploading to ubuntu-security-proposed
# $ report-todo-sponsoring --status Confirmed			# bugs requiring action by the security team
# $ report-todo-sponsoring --status 'Fix Committed'		# bugs to possibly pocket copy
# $ report-todo-sponsoring --verification			# bugs tagged for verification
# $ report-todo-sponsoring --full-report			# wikified report for SecurityTeam/SponsorsQueue
#
# To emulate the old pull-in-progress:
# $ report-todo-sponsoring --status 'In Progress' --team ubuntu-security --has-patch
#
# Can use the following bugs for testing:
# https://launchpad.net/bugs/495638
# https://launchpad.net/bugs/503123
# https://launchpad.net/bugs/503126

import cve_lib
import optparse
import re
import subprocess
import sys

parser = optparse.OptionParser()
parser.add_option("--debug", help="Verbose processing output", action='store_true')
parser.add_option("--lpnet", help="Use lpnet instead of edge for LP API", action='store_true')
parser.add_option("--team", help="Find bugs for team", metavar="TEAM", action='store', default='ubuntu-security-sponsors')
parser.add_option("--status", help="Specify status for bugs", metavar="STATUS", action='store', default=None)
parser.add_option("--syncs", help="Show fake sync request bugs", action='store_true')
parser.add_option("--tags", help="Show bugs with tags (space separated list)", metavar="TAGS", action='store', default='')
parser.add_option("--has-patch", help="Show bugs with patches", action='store_true')
parser.add_option("--full-report", help="Full report for sponsorship queue", action='store_true')
parser.add_option("--verification", help="Open bugs tagged for verification", action='store_true')

(opt, args) = parser.parse_args()
use_edge = True
if opt.lpnet:
    use_edge = False

def debug(s):
    '''Print debug message'''
    if opt.debug:
        print >>sys.stderr, "DEBUG: %s" % (s)

def print_bugs(bugs, status=None, tags=[]):
    '''Output a collection of bugs'''
    keys = bugs.keys()
    keys.sort()
    for id in keys:
        task = bugs[id]
        if status:
           if task.status != status:
               debug("Skipping LP: #%d (%s != %s)" % (task.bug.id, task.status, status))
               continue

        if len(tags) > 0:
            found_tag = False
            for t in tags:
                if t in task.bug.tags:
                    found_tag = True
            if not found_tag:
                debug("Skipping LP: #%d (could not find tags '%s')" % (task.bug.id, ' '.join(tags)))
                continue

        cves = []
        if task.bug.cves != None:
            for c in task.bug.cves:
                cves.append("CVE-" + c.sequence)

        if not ' (' in task.bug_target_name:
            print >>sys.stderr, "Skipping target name=%s (LP: #%d)" % (task.bug_target_name, task.bug.id)
            continue

        pkg, target = task.bug_target_name.split(' (',1)
        target = target.split(')')[0]
        if ' ' in target:
            target, targeted_to = target.split(' ',1)

        if target and target.lower() != 'ubuntu':
            debug('skipping target "%s" (%s) (LP: #%d)' % (target, pkg, task.bug.id))
            continue

        if task.status in ['Fix Released', 'Invalid', "Won't Fix"]:
            debug('skipping (pkg:%s status:%s LP: #%d)' % (pkg, task.status, task.bug.id))
            continue

        if not re.match(r'^[a-z0-9][a-z0-9+\.\-]+$', pkg):
            print >>sys.stderr, "Bad package name '%s' (LP: #%d)" % (pkg, task.bug.id)
            continue

        release = "ubuntu"
        if ':' in id:
            release = id.split(':')[1]
        print "=== Source: %s (%s) ===" % (pkg, release)
        print " * Status: %s" % task.status,
        if task.status == "Fix Committed":
            print "(committed on %s)" % str(task.date_fix_committed).split(' ')[0]
        elif task.status == "In Progress":
            print "(marked 'In Progress' on %s)" % str(task.date_in_progress).split(' ')[0]
        else:
            print ""

        if task.bug.tags:
            print " * Tags: %s" % ' '.join(task.bug.tags)
        print " * URL: https://launchpad.net/bugs/%d" % task.bug.id

        if len(cves) > 0:
            print " * CVES:",
            for c in cves:
                print "%s" % (c),
                #filename = "active/%s" % (c)
            print ""

        print ""

#
# Connect to Launchpad
#
try:
    import lpl_common
except:
    print >>sys.stderr, "lpl_common.py seems to be missing.  Please create a symlink from $UQT/common/lpl_common.py to $UCT/scripts/"
    sys.exit(1)

# Load configuration
cve_lib.read_config()

# API interface
print >>sys.stderr, "Connecting to LP ...",
lp = lpl_common.connect(use_edge=use_edge)

# Get authenticated URL fetcher
opener = lpl_common.opener_with_cookie(cve_lib.config["plb_authentication"])
if not opener:
    raise ValueError, "Could not open cookies"

ubuntu = lp.distributions['ubuntu']
debug("Distribution: %s" % ubuntu)
team = lp.people[opt.team]
debug("Team: %s" % team)
print >>sys.stderr, "done"

tags = ''
if opt.syncs:
    tags = 'sync'
elif opt.tags:
    tags = opt.tags
# why didn't this work?
#elif opt.verification:
#    tags = 'security-verification verification-needed verification-failed verification-done'

print >>sys.stderr, "Loading bugs ...",
bugs = {}
# get bugs for a specific series, then for 'Ubuntu' if we haven't already added
# the bug
for rel in cve_lib.releases + ['ubuntu']:
    if rel == 'ubuntu':
        obj = ubuntu
    else:
        series = ubuntu.getSeries(name_or_version=rel)
        if not series.active:
            continue
        obj = series

    if tags == '':
        task_collection = obj.searchTasks(bug_subscriber=team, omit_targeted=False, has_patch=opt.has_patch)
    else:
        task_collection = obj.searchTasks(bug_subscriber=team, omit_targeted=False, tags=tags, has_patch=opt.has_patch)

    for task in task_collection:
        if rel != 'ubuntu' or not bugs.has_key(task.bug.id):
            bugs["%d:%s" % (task.bug.id, rel)] = task
print >>sys.stderr, "done"

if opt.full_report:
    print "== Untriaged =="
    print_bugs(bugs, "New")

    print "\n== Confirmed (need action) =="
    print_bugs(bugs, "Confirmed")

    print "\n== Fix Committed (review for pocket copying) =="
    print_bugs(bugs, "Fix Committed")

    print "\n== Tagged for verification =="
    print_bugs(bugs, tags=["security-verification"])
    print_bugs(bugs, tags=["verification-needed"])
    print_bugs(bugs, tags=["verification-failed"])
    print_bugs(bugs, tags=["verification-done"])

    print "\n== Has patch =="
    subprocess.call([sys.argv[0], '--has-patch'])
else:
    vtags = []
    if opt.verification:
        vtags = tags=["security-verification", "verification-needed", "verification-failed", "verification-done"]
    print_bugs(bugs, opt.status, tags=vtags)

sys.exit(0)

