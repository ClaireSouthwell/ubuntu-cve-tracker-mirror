#!/usr/bin/python

# Generate an overview over fixed and outstanding CVE issues on a mirror with
# packages and changelogs.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# (C) 2005 Canonical. Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader

rookery_archive_root="/srv/archive.ubuntu.com/ubuntu"
rookery_changelog_base = "/srv/changelogs.ubuntu.com/www/changelogs/"
changelog_url_base="http://changelogs.ubuntu.com/changelogs/"

# settings for automatic CAN database evaluation
canxml_url="http://cve.mitre.org/cve/candidates/downloads/full-can.xml"

ignore_strings = ["** REJECT **", "** RESERVED **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS"]

###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def substract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)

###################

def get_archive_map(rootdir, cachefile = None):
    """Generate a archive map from a Debian-style package archive directory.

    rootdir: path to archive root path
    cachefile: path to a cache file (created if not existing)
    return: mapping: package -> release -> (component, version, path)
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}
    currpkg = None
    currversion = None
    currdir = None

    for release in os.listdir(rootdir + "/dists"):
        for comp in os.listdir(rootdir + "/dists/" + release):
            compdir = rootdir + "/dists/" + release + "/" + comp
            if not os.path.isdir(compdir):
                continue
            srcfile = compdir + "/source/Sources.gz"
            #print >> sys.stderr, "Scanning", srcfile

            for line in gzip.open(srcfile):
                line = line.strip()
                if not line:
                    if (not currpkg) or (not currversion) or (not currdir):
                        print >> sys.stderr, "Error: end of package record without all data available"
                        sys.exit(1)
                    map.setdefault(currpkg, {})[release] = (comp, currversion, currdir)
                    currpkg = None
                    currversion = None
                    currdir = None
                    continue

                attr = line.split(":", 1)

                if len(attr) < 2:
                    continue

                if attr[0] == "Package":
                    if currpkg:
                        print >> sys.stderr, "Error: read two Packages: lines in a row"
                        sys.exit(1)
                    currpkg = attr[1].strip()

                if attr[0] == "Version":
                    if currversion:
                        print >> sys.stderr, "Error: read two Version: lines in a row"
                        sys.exit(1)
                    currversion = attr[1].strip()
                    # remove epochs
                    colpos = currversion.find(':')
                    if colpos >= 0:
                        currversion = currversion[colpos+1:]

                if attr[0] == "Directory":
                    if currdir:
                        print >> sys.stderr, "Error: read two Directory: lines in a row"
                        sys.exit(1)
                    currdir = attr[1].strip()

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def parse_cans(url):
    """Return a list of all CAN numbers mentioned in the given URL."""

    list = []
    canre = re.compile("((?:CAN|can)-\d\d\d\d-\d\d\d\d)")
    try:
        for can in canre.finditer(cache_urllib.urlopen(url).read()):
            list.append(can.group().upper())
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

###################

def parse_changelog_version(url):
    """Parse the topmost version of the changelog at given URL."""

    header = re.compile("([a-z0-9-+\.]+)\s+\((.*)\)\s+([a-z-]+)\s*.*;\s*urgency=")

    version = "n/a"
    try:
        f = cache_urllib.urlopen(url)
        m = None
        while True:
            line = f.readline()
            if not line:
                #print >> sys.stderr, "Could not find header line in", url
                return version
            m = header.search(line)
            if m:
                version = m.group(2)
                break

    except IOError:
        print >> sys.stderr, "Could not open", url

    return version

###################

def get_changelog_can_map(rootdir, archive_map, cachefile = None):
    """Generate a CAN map from a Debian-style changelog archive directory.

    rootdir: path to changelog archive root path
    archive_map: archive map (as generated by get_archive_map)
    cachefile: path to a cache file (created if not existing)
    return: mapping: CAN number -> package -> [release]
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}

    orig_dir = os.getcwd()
    os.chdir(rootdir)
    for root, dirs, files in os.walk("."):
        if "changelog" not in files:
            continue

        (pkg, version) = os.path.basename(root).split("_")
        rel = []

        try: pkgmap = archive_map[pkg]
        except: continue

        for maprel, (mapcomp, mapver, mappath) in pkgmap.iteritems():
            if mapver == version:
                rel.append(maprel)

        if not rel:
            continue

        for can in parse_cans(root + "/changelog"):
            merge_list(map.setdefault(can, {}).setdefault(pkg, []), rel)

    os.chdir(orig_dir)

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def get_manual_can_map(file, archive_map):
    """Read a CAN map from a manual override file.

    file: path to file
    archive_map: archive map (as generated by get_archive_map)
    return: mapping: CAN number -> package -> [release]
    """
    map = {}
    for line in open(file):
        fields = line.split()
        can = fields.pop(0)
        pkg = fields.pop(0)
        # if no releases are specified, assume all releases
        if len(fields) == 0:
            fields = archive_map[pkg].keys()
        merge_list(map.setdefault(can, {}).setdefault(pkg, []), fields)

    return map

###################

def merge_can_map(can_map, can_map2, intersection = None):
    """Merge can_map2 into can_map. If intersection is not None, the
    intersecion of can_map and can_map2 will be written into this."""

    for can, pkgmap in can_map2.iteritems():
        for pkg, rels in pkgmap.iteritems():
            relintersect = []
            merge_list(can_map.setdefault(can, {}).setdefault(pkg, []), rels, relintersect)
            if intersection != None and relintersect:
                intersection.setdefault(can,{})[pkg] = relintersect

###################

def substract_can_map(can_map, can_map2):
    """Remove all items from can_map which occur in can_map."""

    for can, pkgmap in can_map2.iteritems():
        for pkg, rels in pkgmap.iteritems():
            if can_map.has_key(can) and can_map[can].has_key(pkg):
                substract_list(can_map[can][pkg], rels)
                if len(can_map[can][pkg]) == 0:
                    del can_map[can][pkg]
                if len(can_map[can]) == 0:
                    del can_map[can]

###################

def get_unfixed_map(archive_map, can_map, nonvuln_map): 
    """Generate a mapping
    of unfixed issues.
    
    return: component -> release -> CAN -> [package]
    """

    fixed_cans = copy.deepcopy(can_map)
    merge_can_map(fixed_cans, nonvuln_map)

    map = {}
    for can, pkgs in fixed_cans.iteritems():
        for pkg, fixedreleases in pkgs.iteritems():
            pkgmap = archive_map[pkg]
            for release in pkgmap.iterkeys():
                if release.find("-security") > 0:
                    continue

                if nonvuln_map.has_key(can) and nonvuln_map[can].has_key(pkg) \
                    and release in nonvuln_map[can][pkg]:
                    continue

                if release not in fixedreleases and (release+"-security") not in fixedreleases:
                    map.setdefault(pkgmap[release][0], {}).setdefault(release, {}). \
                        setdefault(can, []).append(pkg)

    return map

###################

class CANHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore, output):
        self.curr_can = None
        self.curr_desc = None
        self.curr_chars = ""
        self.ignore = ignore
        self.output = output

    def startElement(self, name, attrs):
        if name == "item":
            self.curr_can = attrs['name']
        if name == "desc":
            self.curr_chars = ""

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")

        if name == "item":
            self.handle_can()

    def handle_can(self):
        if self.curr_can in self.ignore:
            return

        parts = self.curr_can.split("-")
        if parts[1] != "2005":
            return

        for s in ignore_strings:
            if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
                return
        print >> self.output, '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td><td>%s</td></tr>' % (
            self.curr_can, self.curr_can, self.curr_desc)

###################

def begin_page(fname, title):
    """Create fname, print a standard page header and opening body/html tags 

    return: file handle"""

    f = open(fname, "w")

    print >> f, """<html>
    <head>
      <title>Ubuntu CVE status - %s</title>
    </head>

    <body>
      <p><a href="fixed.html">[Fixed CANs]</a> 
      <a href="unfixed.html">[Unfixed CANs]</a>
      <a href="unchecked.html">[Unchecked CANs]</a>
      <a href="nonvuln.html">[CANs that do not apply to Ubuntu]</a></p>

      <h1>Ubuntu CVE status</h1>
      <h2>%s</h2>
      <hr />
    """ % (title, title)

    return f

###################

def end_page(out):
    """Print a standard page footer and closing body/html tags to out and
    close out."""

    print >> out, '<p>Automatically generated by <a \
        href="http://people.ubuntu.com/~pitti/arch/martin.pitt@canonical.com--2005/ubuntu-cve--main--1/">ubuntu-cve</a> on', \
        datetime.datetime.now().isoformat(' '), "</p>\n</body></html>"

    out.close()

###################
## main
###################

mypath = os.path.abspath(os.path.dirname(sys.argv[0]))

archive_map = get_archive_map(rookery_archive_root, mypath+"/archive_map.cache")

cache_urllib.set_cache(mypath+"/changelogs.cache")

if len(sys.argv) < 2:
    print >> sys.stderr, "Usage:", sys.argv[0], "<destination directory>"
    sys.exit(1)

destdir = sys.argv[1]

#for pkg, map in archive_map.iteritems():
    #print pkg, ":", " / ".join(["%s->%s,%s" % (r,c,v) for r,(c,v,p) in map.iteritems()])
#sys.exit(0)

CAN = get_changelog_can_map(rookery_changelog_base, archive_map, mypath+"/can_map.cache")
fixedCAN = get_manual_can_map(mypath + "/cve-fixed.txt", archive_map)
nonvulns = get_manual_can_map(mypath + "/cve-nonvulns.txt", archive_map)
redundantFixed = {}
merge_can_map(CAN, fixedCAN, redundantFixed)

if redundantFixed:
    print "CANs in cve-fixed.txt which are mentioned in the changelogs:"
    for can, pkgmap in redundantFixed.iteritems():
        print can, ":", pkgmap

substract_can_map(CAN, nonvulns)

CANDescIgnoreList = parse_cans(mypath + "/cve-ignore.txt")

# Fixed issues 

fixedout = begin_page(destdir + "/fixed.html", "Fixed issues")

print >> fixedout, """<table border="1">
    <tr><th>CVE number</th> <th>Source package (Fixed versions)</th></tr>"""

cankeys = CAN.keys()
cankeys.sort()
cankeys.reverse()
for can in cankeys:
    pkgs = CAN[can]
    print >> fixedout, '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)
    print >> fixedout, '<td><table>'

    for pkg, releases in pkgs.iteritems():
        pkgmap = archive_map[pkg]
        #print pkg, pkgmap
        print >> fixedout, "<tr><td>%s</td><td>(%s)</td></tr>" % (
            pkg,
            ", ".join(['<a href="%s%s/%s_%s/changelog">%s</a>/%s' % (
                changelog_url_base,pkgmap[r][2],pkg,pkgmap[r][1],r,pkgmap[r][0]) for r in releases])
        )
    print >> fixedout, '</table></td></tr>'

print >> fixedout, "  </table>"

end_page(fixedout)

# Unfixed issues

unfixedout = begin_page(destdir + "/unfixed.html", "Unfixed issues")

unfixed = get_unfixed_map(archive_map, CAN, nonvulns)

components = unfixed.keys()
components.sort()

for comp in components:
    print >> unfixedout, "<h2>Unfixed issues in the", comp, "component</h2>"
    for rel in unfixed[comp].iterkeys():
        print >> unfixedout, """<table border="1">
        <tr><th colspan="2">Release: %s</th></tr>
        <tr><th>CVE number</th> <th>Source package</th></tr>
        """ % rel

        canmap = unfixed[comp][rel]
        cankeys = canmap.keys()
        cankeys.sort()
        cankeys.reverse()
        for can in cankeys:
            if can in CANDescIgnoreList:
                continue
            print >> unfixedout, '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)

            print >> unfixedout, "<td><table>"

            for pkg in canmap[can]:
                pkgmap = archive_map[pkg]
                if pkgmap[rel][0] != comp:
                    print >> sys.stderr, "Inconsistency for package", pkg, "-", \
                        pkgmap[rel][0], "in archive map,", comp, "in unfixed map"
                debian_chlog_url = "http://changelogs.debian.net/" + pkg
                debianver = parse_changelog_version(debian_chlog_url)
                debiancans = parse_cans(debian_chlog_url)
                #print >> sys.stderr, pkg, "Debian: ", debianver, debiancans
                if can in debiancans:
                    debian_status = "fixed"
                else:
                    debian_status = "vulnerable"
                if pkgmap.has_key(rel+'-security'):
                    version = pkgmap[rel+'-security'][1]
                else:
                    version = pkgmap[rel][1]
                print >> unfixedout, '<tr><td>%s [Ubuntu: <a href="%s%s/%s_%s/changelog">%s</a>] [Debian: <a href="%s">%s</a>, %s]</td></tr>' % (
                    pkg, 
                    changelog_url_base, pkgmap[rel][2], pkg, version, version,
                    debian_chlog_url, debianver, debian_status
                )

            print >> unfixedout, "</table></td></tr>"

        print >> unfixedout, "</table><p>&nbsp;</p>"

end_page(unfixedout)

# Vulnerabilities that do not apply to Ubuntu

nonvulnout = begin_page(destdir + "/nonvuln.html", "Vulnerabilities that do not apply to Ubuntu")

print >> nonvulnout, """
  <table border="1">
    <tr><th>CVE number</th> <th>Source package (Nonvulnerable releases)</th></tr>
"""

cankeys = nonvulns.keys()
cankeys.sort()
cankeys.reverse()
for can in cankeys:
    pkgs = nonvulns[can]
    print >> nonvulnout, '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)
    print >> nonvulnout, '<td><table>'

    for pkg, releases in pkgs.iteritems():
        pkgmap = archive_map[pkg]
        print >> nonvulnout, "<tr><td>%s</td><td>(%s)</td></tr>" % (
            pkg,
            ", ".join(['<a href="%s%s/%s_%s/changelog">%s</a>/%s' % (
                changelog_url_base,pkgmap[r][2],pkg,pkgmap[r][1],r,pkgmap[r][0]) for r in releases])
        )
    print >> nonvulnout, '</table></td></tr>'

print >> nonvulnout, "  </table>"

end_page(nonvulnout)

# CAN database review

uncheckedout = begin_page(destdir + "/unchecked.html", "Unchecked CANs from the CVE database")

merge_list(CANDescIgnoreList, CAN.keys())
merge_list(CANDescIgnoreList, nonvulns.keys())

print >> uncheckedout, """
  <table border="1">
"""

parser = xml.sax.make_parser()
parser.setContentHandler(CANHandler(CANDescIgnoreList, uncheckedout))
parser.parse(urllib.urlopen(canxml_url))

print >> uncheckedout, "  </table>"

end_page(uncheckedout)
