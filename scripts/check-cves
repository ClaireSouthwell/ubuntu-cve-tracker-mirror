#!/usr/bin/python

# Scan for new CVEs, and report on stdout.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, cache_urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader
import shutil, subprocess
import optparse, configobj
import cve_lib

# load settings, if any
rcfile = os.path.expanduser('~/.check-cves.rc')
if not os.path.exists(rcfile):
    file(rcfile, 'w').write('# Empty config file for check-cves\n')
config = configobj.ConfigObj(rcfile)

parser = optparse.OptionParser()
parser.add_option("-n", "--nvd", help="Parse NVD instead of Mitre XML", action="store_true")
parser.add_option("-r", "--report", help="Just report CVEs that need checking", action="store_true")
parser.add_option("-k", "--known", help="Only report CVEs already known", action="store_true")
parser.add_option("-R", "--refresh", help="Refresh CVE descriptions", action="store_true")
(opt, args) = parser.parse_args()

destdir = "."


ignore_strings = ["** REJECT **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO", "OS X", "Mac OS",
    "Apple QuickTime", "Cisco", "ActiveX", "Joomla!"]

###################

def merge_list(list, list2, intersection = None):
    """Write the union of list and list2 into list. If intersection is not
    None, that list will be filled with the intersection of list and list2."""

    for e in list2:
        if e not in list:
            list.append(e)
        else:
            if intersection != None:
                intersection.append(e)

###################

def subtract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)


###################

def wordwrap(text, width):
    """
    A word-wrap function that preserves existing line breaks
    and most spaces in the text. Expects that existing line
    breaks are posix newlines (\n).
    """
    return reduce(lambda line, word, width=width: '%s%s%s' %
                  (line,
                   ' \n'[(len(line)-line.rfind('\n')-1
                         + len(word.split('\n',1)[0]
                              ) >= width)],
                   word),
                  text.split(' ')
                 )

def _wrap_desc(desc):
    return wordwrap(desc,75).replace(' \n','\n')

def add_CVE_to_tracker(cve, info, package):
    src = '%s/active/00boilerplate'%(destdir)
    if os.path.exists(src + "." + package):
        src = src + "." + package
    dst = '%s/active/%s'%(destdir,cve)
    template = file(src).readlines()
    cve_file = file(dst,'w')
    for line in template:
        line = line.rstrip()
        if line.startswith('Candidate:'):
            print >>cve_file, 'Candidate: %s'%(cve)
        elif info['public'] and line.startswith('PublicDate:'):
            print >>cve_file, 'PublicDate: %s'%(info['public'])
        elif line.startswith('References:'):
            print >>cve_file, 'References:\n http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s'%(cve)
        elif not line.startswith('#'):
            print >>cve_file, line

        if line.startswith('Description:'):
            for desc_line in _wrap_desc(info['desc']).split('\n'):
                print >>cve_file, " %s" % (desc_line)
    cve_file.close()
    return dst

class PercentageFile(object):
    def __init__(self, filename):
        self.size = os.stat(filename)[6]
        self.delivered = 0
        self.f = file(filename)

    def read(self, size=None):
        if size is None:
            data = self.f.read()
        else:
            data = self.f.read(size)

        print >>sys.stdout, '%d%% (%d/%d)\r' % ( (self.delivered * 100) / self.size, self.delivered, self.size ),
        sys.stdout.flush()

        self.delivered += len(data)
        return data

###################

class CVEHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore, config):
        # Config
        self.use_nvd = opt.nvd

        # For per-hit processing
        self.curr_cve = None
        self.curr_desc = None
        self.curr_refs = []
        self.curr_chars = ""
        self.ignore = ignore
        self.num_ignored = 0
        self.num_added = 0
        self.num_skipped = 0
        self.curr_public = None

        # For long-term (human) processing
        self.cve_list = []
        self.cve_data = dict()
        self.saved_ignore_reason = ""
        self.saved_package = ""
        self.debian = None

        # Load debian CVE states, if configured
        if config.has_key('secure-testing-path'):
            self.debian = cve_lib.load_debian_cves(config['secure-testing-path']+'/data/CVE/list')


    def printReport(self):
        print "\n %4d CVEs added" % self.num_added
        print " %4d CVEs ignored" % self.num_ignored
        print " %4d CVEs skipped" % self.num_skipped
        print "---------------------------"
        print "%5d total CVEs triaged" % (self.num_added + self.num_ignored)

    def startElement(self, name, attrs):
        if self.use_nvd:
            self.nvd_startElement(name, attrs)
        else:
            self.mitre_startElement(name, attrs)

    def mitre_startElement(self, name, attrs):
        # New entry
        if name == "item":
            self.curr_cve = attrs['name']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
        if name == "desc" or name == "ref":
            self.curr_chars = ""
        if name == "ref":
            self.curr_url = None
            self.curr_source = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']
            if attrs.has_key('source'):
                self.curr_source = attrs['source']

    def nvd_startElement(self, name, attrs):
        # New entry
        if name == "entry":
            self.curr_cve = attrs['name']
            self.curr_public = attrs['published']
            self.curr_refs = []
            self.curr_url = None
            self.curr_desc = None
            self.curr_desc_ready = False
        if name == "descript" and attrs['source'] == 'cve':
            self.curr_desc_ready = True
        if name == "descript" or name == "ref":
            self.curr_chars = ""
        if name == "ref":
            self.curr_url = None
            self.curr_source = None
            if attrs.has_key('url'):
                self.curr_url = attrs['url']
            if attrs.has_key('source'):
                self.curr_source = attrs['source']

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if self.use_nvd:
            self.nvd_endElement(name)
        else:
            self.mitre_endElement(name)

    def mitre_endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
        if name == "ref":
            self.curr_refs += [(self.curr_source,self.curr_chars.encode("ascii", "replace"),self.curr_url)]
        if name == "item":
            self.handle_cve()

    def nvd_endElement(self, name):
        if name == "descript" and self.curr_desc_ready:
            self.curr_desc = self.curr_chars.encode("ascii", "replace")
            self.curr_desc_ready = False
        if name == "ref":
            self.curr_refs += [(self.curr_source,self.curr_chars.encode("ascii", "replace"),self.curr_url)]
        if name == "entry":
            self.handle_cve()

    def handle_cve(self):
        # Skip CVEs we know about already
        if self.curr_cve in self.ignore:
            return

        # Skip stuff older than 2005
        if int(self.curr_cve.split("-")[1]) < 2005:
            return

        # Check for ** RESERVED **
        s = '** RESERVED **'
        if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
            return

        if self.curr_cve in self.cve_list:
            print >>sys.stderr, "Aborting: saw %s twice!" % (self.curr_cve)

        self.cve_list += [self.curr_cve]
        self.cve_data.setdefault(self.curr_cve,dict())
        self.cve_data[self.curr_cve].setdefault('desc',self.curr_desc)
        self.cve_data[self.curr_cve].setdefault('public',self.curr_public)
        self.cve_data[self.curr_cve].setdefault('refs',[]+self.curr_refs)

    def cves(self):
        return self.cve_list

    def human_process_cve(self, cve):

        # Check if this was once an embargoed issue
        if cve in EmbargoList:
            print '**!!** no longer embargoed **!!**'
            print '==========================details from embargo entry=========================='
            print file(os.path.join('embargoed',cve)).read().rstrip()
            print '=================================end details=================================='
        # Display CVE information
        if self.cve_data[cve]['public']:
            print ' Published: %s' % (self.cve_data[cve]['public'])
        for ref in self.cve_data[cve]['refs']:
            print ' %s: %s' % (ref[0],ref[1]),
            # Do not repeat URL if it matches the contents of the reference
            if ref[2] and ref[1].strip() != ref[2].strip():
                print ' %s' % (ref[2]),
            print
        print '%s' % (self.cve_data[cve]['desc'])
        if self.debian and self.debian.has_key(cve):
            print 'Debian: %s' % (self.debian[cve]['state'])
            if len(self.debian[cve]['note']):
                print "\t" + "\n\t".join(self.debian[cve]['note'])
            for pkg in self.debian[cve]['pkgs']:
                info = []
                if self.debian[cve]['pkgs'][pkg]['priority']:
                    info.append(self.debian[cve]['pkgs'][pkg]['priority'])
                if self.debian[cve]['pkgs'][pkg]['bug']:
                    info.append(self.debian[cve]['pkgs'][pkg]['bug'])
                if self.debian[cve]['pkgs'][pkg]['note']:
                    info.append(self.debian[cve]['pkgs'][pkg]['note'])
                print "\t%s: %s (%s)" % (pkg,self.debian[cve]['pkgs'][pkg]['state'],"; ".join(info))

        response = 'skip'
        reason = ""
        package = ""
        dosearch = True
        # Skip CVEs that are obviously not about Ubuntu
        for s in ignore_strings:
            if self.cve_data[cve]['desc'].find(s) >= 0 and self.cve_data[cve]['desc'].find("Linux") < 0:
                response = 'ignore'
                reason = 'NFU - ' + s
                dosearch = False
        # Default to Debian state, if available
        if self.debian and self.debian.has_key(cve) and self.debian[cve]['state']:
            if self.debian[cve]['state'].startswith('NOT-FOR-US:'):
                response = 'ignore'
                reason = self.debian[cve]['state'].split(':',1)[1].lstrip()
                dosearch = False
            if self.debian[cve]['state'] == 'FOUND':
                response = 'add'
                package = " ".join(self.debian[cve]['pkgs'])
                dosearch = False

        info = ''
        while info == "" or not info[0] in ['i','a','s','q']:
            print 'A)dd to tracker, I)gnore forever, S)kip for now, or Q)uit? [%s] ' % (response),
            info = sys.stdin.readline().strip().lower()
            if info == "":
                info = response

        if info.startswith('q'):
            self.printReport()
            sys.exit(0)
        elif info.startswith('a'):
            self.num_added += 1
            info = ""
            while info == "":
                print 'Package(s) affected? ',
                if package == "":
                    package = self.saved_package
                if package != "":
                    print '[%s] ' % (package),
                info = sys.stdin.readline().strip()
                if info == '':
                    info = package
                self.saved_package = info
            # Add to tracker from 00boilerplate
            dst = add_CVE_to_tracker(cve,self.cve_data[cve], info)
            # Tack on package
            cmd = ['./scripts/active_edit','-c',cve]
            for pkg in info.split():
                cmd += ['-p',pkg]
            cmd += ['--yes']
            subprocess.call(cmd)
            # Spawn editor
            editor = os.getenv('EDITOR','vi')
            subprocess.call([editor,dst])
        elif info.startswith('i'):
            self.num_ignored += 1

            if dosearch:
                query = ''
                while query == "":
                    print "Search ignored ('q' to skip search): ",
                    query = sys.stdin.readline().strip()
                if query != "q":
                    lines = file('%s/ignored/not-for-us.txt'%(destdir),'r').readlines()
                    pat = re.compile(r'' + query, re.IGNORECASE)
                    nfound = 0
                    print "Ignored: "
                    for line in lines:
                        if pat.search(line):
                            nfound += 1
                            print "   " + line,
                    if nfound > 0:
                        reason = query
                    else:
                        print "    (none found)"

            info = ""
            while info == "":
                print 'Reason to be ignored? ',
                if reason == "" and self.saved_ignore_reason != "":
                    reason = self.saved_ignore_reason
                if reason != "":
                    print '[%s] ' % (reason),
                info = sys.stdin.readline().strip()
                if info == "":
                    info = reason
                self.saved_ignore_reason = info
            self.cve_resolved_ignore(cve, info)

        elif info.startswith('s'):
            self.num_skipped += 1
        print ''

    def cve_resolved_ignore(self, cve, reason):
        # Append to ignore list
        file('%s/ignored/not-for-us.txt'%(destdir),'a').write('%s # %s\n'%(cve,reason))

# CVEIgnoreList is a list of all CVEs we know about already.  These will be
# ignored when checking MITRE for new CVEs
CVEIgnoreList  = cve_lib.parse_CVEs_from_uri(destdir + "/ignored/not-for-us.txt")
CVEKnownList   = []
CVEKnownList += [cve for cve in os.listdir(destdir + "/ignored/") if cve.startswith('CVE-')]
CVEKnownList += [cve for cve in os.listdir(destdir + "/retired/") if cve.startswith('CVE-')]
(ActiveList, EmbargoList) = cve_lib.get_cve_list()
CVEKnownList += [cve for cve in ActiveList if cve not in EmbargoList]

if not opt.refresh:
    CVEIgnoreList += CVEKnownList

if opt.known:
    for cve in sorted(CVEIgnoreList):
        print cve
    sys.exit(0)

parser = xml.sax.make_parser()
handler = CVEHandler(CVEIgnoreList,config)
parser.setContentHandler(handler)

if len(args) == 0:
    args.append("http://cve.mitre.org/cve/downloads/allitems.xml")

for uri in args:
    print >>sys.stderr, 'Loading %s ...'%(uri)
    if '://' in uri:
        readable = urllib.urlopen(uri)
    else:
        readable = PercentageFile(uri)
    parser.parse(readable)
    print ''

if opt.refresh:
    for cve in sorted(CVEKnownList):
        desc = ""
        try:
            desc = _wrap_desc(handler.cve_data[cve]['desc'].strip())
        except:
            #print >>sys.stderr, '%s not listed in XML' % (cve)
            continue
        public = handler.cve_data[cve]['public']

        cvefile = ""
        for status in ['active','retired','ignored']:
            check = '%s/%s/%s' % (destdir, status, cve)
            if os.path.exists(check):
                cvefile = check
                break
        if cvefile == "":
            print >>sys.stderr, 'local dirs missing %s?!' % (cve)
            continue

        try:
            data = cve_lib.load_cve(cvefile)
        except ValueError, e:
            print >>sys.stderr, e
            continue

        updated = False
        if data['Description'].strip() != desc:
            cve_lib.update_description(cvefile,desc)
            updated = True
        if public and data.has_key('PublicDate') and data['PublicDate'] != public:
            cve_lib.update_field(cvefile,'PublicDate',public)
            updated = True
        if data.has_key('References') and re.match('^CVE-\d+-\d+$',cve):
            mitre_ref = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=" + cve
            if not mitre_ref in data['References']:
                cve_lib.add_reference(cvefile,mitre_ref)
                updated = True

        if updated:
            print >>sys.stderr, "Refreshed %s" % (cvefile)
    sys.exit(0)

new_cves = handler.cves()
max = len(new_cves)
count = 0
for cve in new_cves:
    count += 1

    if opt.report:
        print cve
        continue

    print '\n***********************************************************************'
    print ' %s    (%d/%d: %d%%)' % (cve, count, max, (count * 100 / max))
    print ' http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s' % (cve)
    print '***********************************************************************'
    handler.human_process_cve(cve)

handler.printReport()
