#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2009 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import warnings
warnings.filterwarnings('ignore', message=r'.*apt_pkg\.TagFile.*', category=DeprecationWarning)

import os, apt_pkg, sys, subprocess, cve_lib
try:
    from configobj import ConfigObj
except:
    # Dapper lacks this class, so reimplement it quickly
    class ConfigObj(dict):
        def __init__(self, filepath):
            for line in file(filepath).readlines():
                line = line.strip()
                if line.startswith('#') or len(line)==0:
                    continue
                name, stuff = line.strip().split('=',1)
                self[name] = eval(stuff)

        def __attr__(self, name):
            return self.stuff[name]

apt_pkg.InitSystem();

def version_compare(one,two):
    return apt_pkg.VersionCompare(one,two)

def _find_sources():
    config = ConfigObj(os.path.expanduser("~/.ubuntu-cve-tracker.conf"))
    if config.has_key('packages_mirror') and config.has_key('partner_mirror'):
        return _find_sources_from_mirror(config['packages_mirror'],config['partner_mirror'])
    else:
        return _find_sources_from_apt()

def load_debian(basedir):
    debian_sources = dict()
    collection = []
    for section in ['main','contrib','non-free']:
        rel = 'testing'
        load_collection( (os.path.join(basedir,'dists', rel, section, 'source', 'Sources.gz'), rel, '', section), debian_sources )
    return debian_sources

def _find_sources_from_mirror(ubuntu,canonical):
    collection = []
    errors = False
    missing = ""

    for rel in cve_lib.releases:
        if rel in cve_lib.eol_releases:
            continue
        # free
        for pocket in ['','-updates','-security']:
            for section in ['main','restricted','universe','multiverse']:
                source = os.path.join(ubuntu, 'dists', rel + pocket, section, 'source', 'Sources')
                if not os.path.exists(source):
                    source += '.gz'
                    if not os.path.exists(source):
                        missing += " %s\n" % (source)
                        errors = True
                        continue
                name = pocket
                if name.startswith('-'):
        	        name = name[1:]
                else:
                    name = ''
                collection += [(source, rel, name, section)]
        # partner
        pocket = ''
        section = 'partner'
        source = os.path.join(canonical, 'dists', rel + pocket, section, 'source', 'Sources')
        if not os.path.exists(source):
            # Only warn about missing partner for devel release
            if rel == cve_lib.devel_release:
                print >>sys.stderr, "WARNING: missing partner mirror element: %s" % (source)
            else:
                missing += " %s\n" % (source)
                errors = True
        else:
            name = pocket
            if name.startswith('-'):
    	        name = name[1:]
            else:
                name = ''
            collection += [(source, rel, name, section)]

    if errors:
        raise NameError, "Missing mirror elements:\n" + missing

    return collection


def _find_sources_from_apt():
  collection = []

  saw = dict()
  lists = '/var/lib/apt/lists'
  for f in os.listdir(lists):
    if not f.endswith('_source_Sources') and not '-commercial_main_binary-' in f:
        continue
    parts = f.split('_')
    parts.pop() # _Sources
    parts.pop() # _source
    section = parts.pop() # _main
    release_real = parts.pop() # _dapper
    saw.setdefault(release_real,True)
    tmp = release_real.split('-')
    release = tmp[0]
    if len(tmp) > 1:
    	pocket = tmp[1]
    else:
        pocket = ''
    collection += [(os.path.join(lists,f), release, pocket, section)]

  # Validate all the sources are available
  errors = False
  missing = ""
  for rel in cve_lib.releases:
    if rel in cve_lib.eol_releases:
        continue
    for pocket in ['','-updates','-security']:
        if not saw.has_key(rel+pocket):
            missing += " deb-src http://archive.ubuntu.com/ubuntu %s%s main restricted universe multiverse\n" % (rel,pocket)
            errors = True
    for pocket in ['-commercial']:
        if rel < 'gutsy' and not saw.has_key(rel+pocket):
            missing += " deb http://archive.canonical.com/ubuntu %s%s main\n" % (rel,pocket)
            errors = True
  if errors:
    raise NameError, "Missing /etc/apt/sources.list lines:\n%s" % (missing)

  return collection

# release -> pkg -> dict( 'section', 'pocket', 'version' )
def load():
    source_map = dict()
    for item in _find_sources():
        load_collection(item, source_map)
    return source_map

def load_collection(item, source_map):
        tagfile, release, pocket, section = item

        tags = None
        if tagfile.endswith('.gz'):
            tags = subprocess.Popen(['/bin/gunzip','-c',tagfile], stdout=subprocess.PIPE).stdout
        else:
            tags = file(tagfile)
        parser = apt_pkg.ParseTagFile(tags)
        while parser.Step():
            pkg = parser.Section['Package']
            source_map.setdefault(release,dict()).setdefault(pkg, {'section': 'unset', 'version': '0', 'pocket': 'unset' })
            source_map[release][pkg]['section'] = section
            if apt_pkg.VersionCompare(parser.Section['Version'],source_map[release][pkg]['version'])>0:
                source_map[release][pkg]['pocket'] = pocket
                source_map[release][pkg]['version'] = parser.Section['Version']
                source_map[release][pkg]['binaries'] = parser.Section['Binary'].split(', ')

        return source_map

def madison(source, pkg):
    answer = dict()
    for rel in cve_lib.releases:
        if rel in cve_lib.eol_releases:
            continue
        if source[rel].has_key(pkg):
            name = rel
            if source[rel][pkg]['pocket'] != '':
                name += '-%s' % (source[rel][pkg]['pocket'])
            name += '/%s' % (source[rel][pkg]['section'])
            answer.setdefault(name, dict())
            answer[name].setdefault(pkg, source[rel][pkg]['version'])
    return answer
