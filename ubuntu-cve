#!/usr/bin/python

# Generate an overview over fixed and outstanding CVE issues on a mirror with
# packages and changelogs.
#
# Author: Martin Pitt <martin.pitt@ubuntu.com>
# (C) 2005 Canonical. Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import os, os.path, re, datetime, sys, gzip, pickle, urllib, copy
import xml.sax, xml.sax.handler, xml.sax.xmlreader

rookery_archive_root="/srv/archive.ubuntu.com/ubuntu"
rookery_changelog_base = "/srv/changelogs.ubuntu.com/www/changelogs/"
changelog_url_base="http://changelogs.ubuntu.com/changelogs/"

# settings for automatic CAN database evaluation
canxml_url="http://cve.mitre.org/cve/candidates/downloads/full-can.xml"

ignore_strings = ["** REJECT **", "** RESERVED **", "Internet Explorer",
    "Windows 98", "Windows 2000", "Windows XP", "Windows Server 2003",
    "Windows NT", "Mercury Board", "ZeroBoard", "AntiVirus", "Microsoft", 
    "SGI IRIX", "FreeBSD", "IBM AIX", "SCO OpenServer"]

###################

def merge_list(list, list2):
    """Write the union of list and list2 into list."""

    for e in list2:
        if e not in list:
            list.append(e)

###################

def substract_list(list, list2):
    """Remove all elements from list which occur in list2."""

    for e in list2:
        if e in list:
            list.remove(e)

###################

def get_archive_map(rootdir, cachefile = None):
    """Generate a archive map from a Debian-style package archive directory.

    rootdir: path to archive root path
    cachefile: path to a cache file (created if not existing)
    return: mapping: package -> release -> (component, version, path)
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}
    currpkg = None
    currversion = None
    currdir = None

    for release in os.listdir(rootdir + "/dists"):
        for comp in os.listdir(rootdir + "/dists/" + release):
            compdir = rootdir + "/dists/" + release + "/" + comp
            if not os.path.isdir(compdir):
                continue
            srcfile = compdir + "/source/Sources.gz"
            #print >> sys.stderr, "Scanning", srcfile

            for line in gzip.open(srcfile):
                line = line.strip()
                if not line:
                    if (not currpkg) or (not currversion) or (not currdir):
                        print >> sys.stderr, "Error: end of package record without all data available"
                        sys.exit(1)
                    map.setdefault(currpkg, {})[release] = (comp, currversion, currdir)
                    currpkg = None
                    currversion = None
                    currdir = None
                    continue

                attr = line.split(":", 1)

                if len(attr) < 2:
                    continue

                if attr[0] == "Package":
                    if currpkg:
                        print >> sys.stderr, "Error: read two Packages: lines in a row"
                        sys.exit(1)
                    currpkg = attr[1].strip()

                if attr[0] == "Version":
                    if currversion:
                        print >> sys.stderr, "Error: read two Version: lines in a row"
                        sys.exit(1)
                    currversion = attr[1].strip()
                    # remove epochs
                    colpos = currversion.find(':')
                    if colpos >= 0:
                        currversion = currversion[colpos+1:]

                if attr[0] == "Directory":
                    if currdir:
                        print >> sys.stderr, "Error: read two Directory: lines in a row"
                        sys.exit(1)
                    currdir = attr[1].strip()

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def parse_cans(url):
    """Return a list of all CAN numbers mentioned in the given URL."""

    list = []
    canre = re.compile("(CAN-\d\d\d\d-\d\d\d\d)")
    try:
        for can in canre.finditer(urllib.urlopen(url).read()):
            list.append(can.group())
    except IOError:
        print >> sys.stderr, "Could not open", url

    return list

###################

def parse_changelog_version(url):
    """Parse the topmost version of the changelog at given URL."""

    header = re.compile("([a-z0-9-+\.]+)\s+\((.*)\)\s+([a-z-]+)\s*.*;\s*urgency=")

    version = "n/a"
    try:
        f = urllib.urlopen(url)
        m = None
        while True:
            line = f.readline()
            if not line:
                #print >> sys.stderr, "Could not find header line in", url
                return version
            m = header.search(line)
            if m:
                version = m.group(2)
                break

    except IOError:
        print >> sys.stderr, "Could not open", url

    return version

###################

def get_changelog_can_map(rootdir, archive_map, cachefile = None):
    """Generate a CAN map from a Debian-style changelog archive directory.

    rootdir: path to changelog archive root path
    archive_map: archive map (as generated by get_archive_map)
    cachefile: path to a cache file (created if not existing)
    return: mapping: CAN number -> package -> [release]
    """

    # read cache if it exists
    if cachefile:
        try:
            return pickle.load(open(cachefile, "rb"))
        except IOError:
            pass

    map = {}

    orig_dir = os.getcwd()
    os.chdir(rootdir)
    for root, dirs, files in os.walk("."):
        if "changelog" not in files:
            continue

        (pkg, version) = os.path.basename(root).split("_")
        rel = []

        try: pkgmap = archive_map[pkg]
        except: continue

        for maprel, (mapcomp, mapver, mappath) in pkgmap.iteritems():
            if mapver == version:
                rel.append(maprel)

        if not rel:
            continue

        for can in parse_cans(root + "/changelog"):
            merge_list(map.setdefault(can, {}).setdefault(pkg, []), rel)

    os.chdir(orig_dir)

    # write cache 
    if cachefile:
        try:
            pickle.dump(map, open(cachefile, "wb"))
        except IOError:
            pass

    return map

###################

def get_manual_can_map(file, archive_map):
    """Read a CAN map from a manual override file.

    file: path to file
    archive_map: archive map (as generated by get_archive_map)
    return: mapping: CAN number -> package -> [release]
    """
    map = {}
    for line in open(file):
        fields = line.split()
        can = fields.pop(0)
        pkg = fields.pop(0)
        # if no releases are specified, assume all releases
        if len(fields) == 0:
            fields = archive_map[pkg].keys()
        merge_list(map.setdefault(can, {}).setdefault(pkg, []), fields)

    return map

###################

def merge_can_map(can_map, can_map2):
    """Merge can_map2 into can_map."""

    for can, pkgmap in can_map2.iteritems():
        for pkg, rels in pkgmap.iteritems():
            merge_list(can_map.setdefault(can, {}).setdefault(pkg, []), rels)

###################

def substract_can_map(can_map, can_map2):
    """Remove all items from can_map which occur in can_map."""

    for can, pkgmap in can_map2.iteritems():
        for pkg, rels in pkgmap.iteritems():
            if can_map.has_key(can) and can_map[can].has_key(pkg):
                substract_list(can_map[can][pkg], rels)
                if len(can_map[can][pkg]) == 0:
                    del can_map[can][pkg]
                if len(can_map[can]) == 0:
                    del can_map[can]

###################

def get_unfixed_map(archive_map, can_map, nonvuln_map): 
    """Generate a mapping
    of unfixed issues.
    
    return: component -> release -> CAN -> [package]
    """

    fixed_cans = copy.deepcopy(can_map)
    merge_can_map(fixed_cans, nonvuln_map)

    map = {}
    for can, pkgs in fixed_cans.iteritems():
        for pkg, fixedreleases in pkgs.iteritems():
            pkgmap = archive_map[pkg]
            for release in pkgmap.iterkeys():
                if release.find("-security") > 0:
                    continue

                if nonvuln_map.has_key(can) and nonvuln_map[can].has_key(pkg) \
                    and release in nonvuln_map[can][pkg]:
                    continue

                if release not in fixedreleases and (release+"-security") not in fixedreleases:
                    map.setdefault(pkgmap[release][0], {}).setdefault(release, {}). \
                        setdefault(can, []).append(pkg)

    return map

###################

class CANHandler(xml.sax.handler.ContentHandler):
    """SAX handler for processing mitre's CVE database XML."""

    def __init__(self, ignore):
        self.curr_can = None
        self.curr_desc = None
        self.curr_chars = ""
        self.ignore = ignore

    def startElement(self, name, attrs):
        if name == "item":
            self.curr_can = attrs['name']
        if name == "desc":
            self.curr_chars = ""

    def characters(self, content):
        self.curr_chars += content

    def endElement(self, name):
        if name == "desc":
            self.curr_desc = self.curr_chars.encode("ascii", "replace")

        if name == "item":
            self.handle_can()

    def handle_can(self):
        if self.curr_can in self.ignore:
            return

        parts = self.curr_can.split("-")
        if parts[1] != "2005":
            return

        for s in ignore_strings:
            if self.curr_desc.find(s) >= 0 and self.curr_desc.find("Linux") < 0:
                return
        print '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td><td>%s</td></tr>' % (
            self.curr_can, self.curr_can, self.curr_desc)


###################
## main
###################

mypath = os.path.abspath(os.path.dirname(sys.argv[0]))

archive_map = get_archive_map(rookery_archive_root, mypath+"/archive_map.cache")

#for pkg, map in archive_map.iteritems():
    #print pkg, ":", " / ".join(["%s->%s,%s" % (r,c,v) for r,(c,v,p) in map.iteritems()])
#sys.exit(0)

CAN = get_changelog_can_map(rookery_changelog_base, archive_map, mypath+"/can_map.cache")
fixedCAN = get_manual_can_map(mypath + "/cve-fixed.txt", archive_map)
nonvulns = get_manual_can_map(mypath + "/cve-nonvulns.txt", archive_map)
merge_can_map(CAN, fixedCAN)
substract_can_map(CAN, nonvulns)

# Header and fixed issues 

print """<html>
<head>
  <title>Ubuntu CVE status</title>
</head>

<body>
  <h1>Ubuntu CVE status</h1>

  <h2>Fixed issues</h2>
  <table border="1">
    <tr><th>CVE number</th> <th>Source package (Fixed versions)</th></tr>
"""

cankeys = CAN.keys()
cankeys.sort()
cankeys.reverse()
for can in cankeys:
    pkgs = CAN[can]
    print '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)
    print '<td><table>'

    for pkg, releases in pkgs.iteritems():
        pkgmap = archive_map[pkg]
        print "<tr><td>%s</td><td>(%s)</td></tr>" % (
            pkg,
            ", ".join(['<a href="%s%s/%s_%s/changelog">%s</a>/%s' % (
                changelog_url_base,pkgmap[r][2],pkg,pkgmap[r][1],r,pkgmap[r][0]) for r in releases])
        )
    print '</table></td></tr>'

print "  </table>"

# Unfixed issues

unfixed = get_unfixed_map(archive_map, CAN, nonvulns)

for comp in unfixed.iterkeys():
    print "<h2>Unfixed issues in the", comp, "component</h2>"
    for rel in unfixed[comp].iterkeys():
        print """<table border="1">
        <tr><th colspan="2">Release: %s</th></tr>
        <tr><th>CVE number</th> <th>Source package</th></tr>
        """ % rel

        canmap = unfixed[comp][rel]
        cankeys = canmap.keys()
        cankeys.sort()
        cankeys.reverse()
        for can in cankeys:
            print '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)

            print "<td><table>"

            for pkg in canmap[can]:
                pkgmap = archive_map[pkg]
                if pkgmap[rel][0] != comp:
                    print >> sys.stderr, "Inconsistency for package", pkg, "-", \
                        pkgmap[rel][0], "in archive map,", comp, "in unfixed map"
                debian_chlog_url = "http://changelogs.debian.net/" + pkg
                debianver = parse_changelog_version(debian_chlog_url)
                debiancans = parse_cans(debian_chlog_url)
                #(debianver,debiancans) = ("n/a", [])
                #print >> sys.stderr, pkg, "Debian: ", debianver, debiancans
                if can in debiancans:
                    debian_status = "fixed"
                else:
                    debian_status = "vulnerable"
                print '<tr><td>%s [Ubuntu: <a href="%s%s/%s_%s/changelog">%s</a>] [Debian: <a href="%s">%s</a>, %s]</td></tr>' % (
                    pkg, 
                    changelog_url_base, pkgmap[rel][2], pkg, pkgmap[rel][1], pkgmap[rel][1],
                    debian_chlog_url, debianver, debian_status
                )

            print "</table></td></tr>"

        print "</table><p>&nbsp;</p>"

# Vulnerabilities that do not apply to Ubuntu

print """
  <h2>Vulnerabilities that do not apply to Ubuntu</h2>
  <table border="1">
    <tr><th>CVE number</th> <th>Source package (Nonvulnerable releases)</th></tr>
"""

cankeys = nonvulns.keys()
cankeys.sort()
cankeys.reverse()
for can in cankeys:
    pkgs = nonvulns[can]
    print '<tr><td><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">%s</a></td>' % (can, can)
    print '<td><table>'

    for pkg, releases in pkgs.iteritems():
        pkgmap = archive_map[pkg]
        print "<tr><td>%s</td><td>(%s)</td></tr>" % (
            pkg,
            ", ".join(['<a href="%s%s/%s_%s/changelog">%s</a>/%s' % (
                changelog_url_base,pkgmap[r][2],pkg,pkgmap[r][1],r,pkgmap[r][0]) for r in releases])
        )
    print '</table></td></tr>'

print "  </table>"

# CAN database review

CANDescIgnoreList = parse_cans(mypath + "/cve-ignore.txt")
merge_list(CANDescIgnoreList, CAN.keys())
merge_list(CANDescIgnoreList, nonvulns.keys())

print """
  <h2>Unchecked CANs from the CVE database</h2>

  <table border="1">
"""

parser = xml.sax.make_parser()
parser.setContentHandler(CANHandler(CANDescIgnoreList))
parser.parse(urllib.urlopen(canxml_url))

print " </table>"

# Footer

print '<p>Automatically generated by <a \
    href="http://people.ubuntu.com/~pitti/arch/martin.pitt@canonical.com--2005/ubuntu-cve--main--1/">ubuntu-cve</a> on', \
    datetime.datetime.now().isoformat(' '), "</p>"

print "</body></html>"
