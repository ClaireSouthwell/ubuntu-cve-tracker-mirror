#!/usr/bin/python

# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2008 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

# Set CVE_ALLOW_NEWER_PKGS=1 to skip new package checks
import glob, sys, optparse, cve_lib, os, re
import usn_lib
import pprint

import source_map
source = source_map.load()

def ever_existed(pkg):
    for rel in cve_lib.releases:
        if rel in cve_lib.eol_releases:
            continue
        if source[rel].has_key(pkg):
            return True
    return False

parser = optparse.OptionParser()
parser.add_option("-v", "--verbose", help="Enable verbose reporting", action='store_true')
parser.add_option("-d", "--debug", help="Enable debug reporting", action='store_true')
parser.add_option("-u", "--usn-db", dest="usndb", help="Enable USN database on DB", metavar="DB")
parser.add_option("-n", "--newer", help="Allow versions newer than what is in the archive", action='store_true')
(opt, args) = parser.parse_args()

all_okay = True

cves = dict()
if opt.usndb:
    usn_db = usn_lib.load_database(opt.usndb)
    reverted = usn_lib.get_reverted()

    # create a dictionary of key=CVE value=USNs
    for usn in usn_db:
        if not usn_db[usn].has_key('cves'):
            continue
        for cve in usn_db[usn]['cves']:
            if not cve.startswith('CVE-'):
                continue
            if reverted.has_key(usn) and cve in reverted[usn]:
                continue
            if not cves.has_key(cve):
                cves[cve] = []
                cves[cve].append(usn)
            else:
                cves[cve].append(usn)

add_path = False
if len(args) == 0:
    for dir in [cve_lib.active_dir, cve_lib.retired_dir, cve_lib.ignored_dir]:
        for cve in sorted(glob.glob('%s/CVE-*' % (dir))):
            if cve in args:
                print >>sys.stderr, "%s: duplicate CVE found" % (cve)
                all_okay = False
            else:
                args += [cve]
    if os.path.islink(cve_lib.embargoed_dir):
        for cve in sorted(glob.glob(cve_lib.embargoed_dir + '/[A-Z0-9-]*')):
            if cve in args:
                print >>sys.stderr, "%s: duplicate CVE found" % (cve)
                all_okay = False
            else:
                args += [cve]
else:
    add_path = True

ignored = cve_lib.parse_CVEs_from_uri('ignored/not-for-us.txt')

for cve in args:
    if add_path:
        if re.match(r'EMB-', cve):
            cve = os.path.join(cve_lib.embargoed_dir, cve)
        else:
            cve = os.path.join(cve_lib.active_dir, cve)

    cve_okay = True
    try:
        data = cve_lib.load_cve(cve)
    except ValueError, e:
        print >>sys.stderr, e
        all_okay = False
        continue

    if os.path.basename(cve) in ignored:
        print >>sys.stderr, "%s: duplicate CVE found in not-for-us.txt" % (cve)
        all_okay = False

    # Verify packages exist for releases
    for pkg in sorted(data['pkgs'].keys()):
        for release in sorted(data['pkgs'][pkg].keys()):
            rel = release
            # Adjust devel release name
            if rel == 'devel':
                rel = 'intrepid'
            # Don't syntax check upstream
            if rel == 'upstream':
                continue
            # Don't syntax check end-of-lifed releases
            if rel in cve_lib.eol_releases:
                continue

            # Skip devel checks on retired CVEs
            if release == 'devel':
                if cve.startswith('retired/'):
                    continue

            # Skip DNE's
            if data['pkgs'][pkg][release][0] == 'DNE':
                if source[rel].has_key(pkg):
                    print >>sys.stderr, "%s: package '%s' DOES exist in '%s'!" % (cve,pkg,rel)
                    cve_okay = False
                continue

            # Check that package exists in a given release
            if not ever_existed(pkg):
                print >>sys.stderr, "%s: unknown package '%s'" % (cve, pkg)
                cve_okay = False
            else:
                if not source[rel].has_key(pkg):
                    print >>sys.stderr, "%s: package '%s' not in '%s'" % (cve, pkg, rel)
                    cve_okay = False
                elif opt.newer == False:
                    # Validate the version is <= version in release
                    if data['pkgs'][pkg][release][0] == 'released':
                        released = data['pkgs'][pkg][release][1]
                        if source_map.version_compare(released,source[rel][pkg]['version'])>0:
                            print >>sys.stderr, "%s: %s has %s > %s (in %s)" % (cve, pkg, released, source[rel][pkg]['version'], rel)
                            cve_okay = False

    # check for CVE reference
    if re.match('^CVE-\d+-\d+$',os.path.basename(cve)):
        found = False
        if data.has_key('References'):
            mitre_ref = "http://cve.mitre.org/cgi-bin/cvename.cgi?name=" + \
                        os.path.basename(cve)
            if mitre_ref in data['References']:
                found = True
        if not found:
            print >>sys.stderr, "WARNING: %s: does not contain reference to %s" % (cve, mitre_ref)
            cve_okay = False

    # check for URLs if using the USN database
    if opt.usndb and not cve.startswith('ignored/') and \
       cves.has_key(os.path.basename(cve)) and \
       len(cves[os.path.basename(cve)]) > 0:
        if data.has_key('References'):
            for usn in cves[os.path.basename(cve)]:
                found = False
                usn_ref = "http://www.ubuntu.com/usn/usn-" + usn
                text = data['References'].strip()
                if len(text) != 0:
                    for line in text.split('\n'):
                        if line == usn_ref:
                            found = True
                if not found:
                    print >>sys.stderr, "%s: does not contain reference to %s" % (cve, usn_ref)
                    cve_okay = False

    # Report on failures
    if not cve_okay:
        all_okay = False
    elif opt.debug:
        pp = pprint.PrettyPrinter(indent=4)
        pp.pprint(data)

if all_okay and opt.verbose:
    print 'OK: %d CVEs' % (len(args))
# Invert boolean for unix exit code
sys.exit(not all_okay)
