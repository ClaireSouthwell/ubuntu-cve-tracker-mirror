#!/usr/bin/python
#
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2012 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

from __future__ import print_function
import glob
import json
import optparse
import os
import re
import signal
import subprocess
import sys

devel_release = "quantal"
releases = ['hardy', 'lucid', 'natty', 'oneiric', 'precise', 'quantal']
seeds_url = 'http://people.canonical.com/~ubuntu-archive/germinate-output'
supported = {
             'hardy':    ['ubuntu', 'kubuntu'],
             'lucid':    ['ubuntu', 'kubuntu'],
             'maverick': ['ubuntu', 'kubuntu'],
             'natty':    ['ubuntu', 'kubuntu'],
             'oneiric':  ['ubuntu', 'kubuntu'],
             'precise':  ['ubuntu', 'kubuntu'],
             'quantal':  ['ubuntu'],
            }

def subprocess_setup():
    # Python installs a SIGPIPE handler by default. This is usually not what
    # non-Python subprocesses expect.
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)

def cmd(command, input = None, stderr = subprocess.STDOUT, stdout = subprocess.PIPE, stdin = None, timeout = None):
    '''Try to execute given command (array) and return its stdout, or return
    a textual error if it failed.'''

    try:
        sp = subprocess.Popen(command, stdin=stdin, stdout=stdout, stderr=stderr, close_fds=True, preexec_fn=subprocess_setup)
    except OSError, e:
        return [127, str(e)]

    out, outerr = sp.communicate(input)
    # Handle redirection of stdout
    if out == None:
        out = ''
    # Handle redirection of stderr
    if outerr == None:
        outerr = ''
    return [sp.returncode,out+outerr]

def recursive_rm(dirPath):
    '''recursively remove directory'''
    names = os.listdir(dirPath)
    for name in names:
        path = os.path.join(dirPath, name)
        if not os.path.isdir(path):
            os.unlink(path)
        else:
            recursive_rm(path)
    os.rmdir(dirPath)

def error(out, do_exit=True):
    '''Print error message and exit'''
    try:
        print("ERROR: %s" % (out), file=sys.stderr)
        sys.stderr.flush()
    except IOError:
        pass

    if do_exit:
        sys.exit(1)

def warn(out):
    '''Print warning message'''
    try:
        print("WARN: %s" % (out), file=sys.stderr)
        sys.stderr.flush()
    except IOError:
        pass

def msg(out, output=sys.stdout, newline=True):
    '''Print message'''
    try:
        if newline:
            print("%s" % (out), file=output)
        else:
            print("%s" % (out), file=output, end="")
        output.flush()
    except IOError:
        pass

def download_seeds(directory, update):
    '''Download manifests'''
    if not update and os.path.isdir(directory):
        msg("INFO: '%s' exists. Using cached entries." % directory)
        return

    if os.path.exists(directory):
        if not os.path.isdir(directory):
            error("'%s' exists but is not a directory. Aborting" % directory)
        msg("Remove '%s'? " % (directory), newline=False)
        ans = sys.stdin.readline()
        if ans.strip().lower().startswith('y'):
            recursive_rm(directory)
        else:
            msg("Aborting")
            sys.exit(0)

    seeds_dir = re.sub(r'^http://', '', seeds_url)

    os.mkdir(directory)
    pwd = os.getcwd()
    os.chdir(directory)
    msg("Downloading seeds directory...", newline=False)
    rc, report = cmd(['wget', '-r', '-np', '-N', '-l', '1', '-R', '*=*', seeds_url])
    if rc != 0:
        error('wget exited non-zero:\n%s' % report)
    msg("done")

    os.chdir(directory + '/%s' % seeds_dir)
    msg("Downloading seeds...")
    seeds = glob.glob('*')
    seeds.sort()
    topdir = os.getcwd()
    for d in seeds:
        if not os.path.isdir(d):
            continue
        os.chdir(os.path.basename(d))
        suburl = url + "/%s/all" % os.path.basename(d)
        msg("  %s" % suburl)
        rc, report = cmd(['wget', '-N', suburl])
        os.chdir(topdir)
        if rc != 0:
            warn('wget exited non-zero:\n%s' % report)
    msg("Done!")

    os.chdir(pwd)
    msg("Files downloaded to '%s'" % directory)

def download_manifests(directory, update):
    '''Download manifests'''
    if not update and os.path.isdir(directory):
        msg("INFO: '%s' exists. Using cached entries." % directory)
        return

    if os.path.exists(directory):
        if not os.path.isdir(directory):
            error("'%s' exists but is not a directory. Aborting" % directory)
        msg("Remove '%s'? " % (directory), newline=False)
        ans = sys.stdin.readline()
        if ans.strip().lower().startswith('y'):
            recursive_rm(directory)
        else:
            msg("Aborting")
            sys.exit(0)

    os.mkdir(directory)
    pwd = os.getcwd()
    os.chdir(directory)
    msg("Downloading manifests...", newline=False)
    rc, report = cmd(['rsync', '-av',
                      'cdimage.ubuntu.com::cdimage/', 'manifests/',
                      '--no-motd', '--delete', '--delete-excluded',
                      '--include', '**/',
                      '--include', '**/current',
                      '--include', '**/[0-9]*/%s*.manifest' % devel_release,
                      '--include', '**/[0-9]*/%s*.list' % devel_release,
                      '--exclude', '**',
                     ])
    if rc != 0:
        error('rsync exited non-zero:\n%s' % report)
    msg("done")

    os.chdir(pwd)
    msg("Files downloaded to '%s'" % directory)

def read_seeds(topdir):
    '''Read in seeds'''
    seeds_dir = os.path.join(topdir, re.sub(r'^http://', '', seeds_url))

    db['src'] = dict()

    for r in releases:
        db['src'][r] = dict()

    db['bin'] = dict()
    for r in releases:
        db['bin'][r] = dict()

    seeds = glob.glob("%s/*" % seeds_dir)
    seeds.sort()
    for s in seeds:
        if not os.path.isdir(s):
            continue
        (seed, release) = os.path.basename(s).split('.')
        if release not in releases:
            warn("skipping %s.%s" % (seed, release))
            continue
        print("Processing %s.%s" % (seed, release))

        pat = re.compile(r'^(\s|Package)')
        f = open(os.path.join(s, 'all'))
        for line in f:
            #print (line)
            if pat.search(line) or line == '':
                continue

            parts = line.split('|')
            if len(parts) < 2:
                continue
            spkg = parts[1].strip()
            if not spkg in db['src'][release]:
                db['src'][release][spkg] = [seed]
            elif not seed in db['src'][release][spkg]:
                db['src'][release][spkg].append(seed)

            bpkg = parts[0].strip()
            if not bpkg in db['bin'][release]:
                db['bin'][release][bpkg] = [seed]
            elif not seed in db['bin'][release][bpkg]:
                db['bin'][release][bpkg].append(seed)

        f.close()

    return db

def _is_supported(pkg_type, db, pkg, rel):
    '''Verify if package is supported'''
    if rel in releases and rel in db[pkg_type] and pkg in db[pkg_type][rel]:
        for seed in db[pkg_type][rel][pkg]:
            if seed in supported[rel]:
                return True
    return False

def _is_flavor(pkg_type, db, pkg, rel, flavor):
    '''Verify package is in flavor'''
    if rel in releases and rel in db[pkg_type] and pkg in db[pkg_type][rel]:
        if flavor in db[pkg_type][rel][pkg]:
            return True
    return False

def check_package(pkg_type, db, pkgs, style):
    '''See if sources are supported'''
    if style == "text":
        fmt = "%-49s %-12s %-12s %s"
    else:
        fmt="%s|%s|%s|%s"

    for r in releases:
        all_seeds = []
        supported_seeds = []
        for p in pkgs:
            found = False
            if p in db[pkg_type][r]:
                for seed in db[pkg_type][r][p]:
                    all_seeds.append(seed)
                    if seed in supported[r]:
                        supported_seeds.append(seed)
                        found = True

            all_seeds.sort()
            supported_seeds.sort()

            status = "unsupported"
            seeds = ""
            if found:
                status = "supported"
                seeds = ",".join(supported_seeds)
            elif len(all_seeds) > 0:
                seeds = ",".join(all_seeds)

            msg(fmt % (p, r, status, seeds))

def dump_packages(db, rels=[], style="machine", flavors=[]):
    '''Dump packages'''
    rels.sort()
    if style == "text":
        fmt = "%-49s %-12s %s"
    else:
        fmt="%s|%s|%s"

    for r in rels:
        if r not in releases:
            warn("skipping %s" % (r))
            continue

        for t in ['src', 'bin']:
            if t == 'src':
                title = "Sources - %s" % r
            else:
                title = "Binaries - %s" % r
            # Delay output so we don't need to for loops
            out = fmt % (title, "Status", "Seed Collection")

            pkgs = db[t][r].keys()
            pkgs.sort()
            for p in pkgs:
                in_flavor = []
                if len(flavors) > 0:
                    for f in flavors:
                        if _is_flavor(t, db, p, r, f):
                            in_flavor.append(f)
                    if len(in_flavor) == 0:
                        continue
                collection = ""
                if len(in_flavor) > 0:
                    in_flavor.sort()
                    collection = ",".join(in_flavor)
                elif len(db[t][r][p]) > 0:
                    collection = ",".join(db[t][r][p])
                status = "unsupported"
                if _is_supported(t, db, p, r):
                    status = "supported"
                out += fmt % (p, status, collection)
                msg(out)
                out = ""

        msg("")


#
# main
#
if __name__ == "__main__":
    parser = optparse.OptionParser()
    parser.add_option("--seeds-directory", dest="seeds_directory", help="Directory containing seed files", metavar="DIR")
    parser.add_option("--force", help="Update seed files", action='store_true')
    parser.add_option("--download", help="Download seed files", action='store_true')
    parser.add_option("-f", "--json-file", help="JSON file to use", metavar="FILE")
    parser.add_option("-s", "--source", help="Check is source package is supported", metavar="SRCPKG", action='append')
    parser.add_option("-b", "--binary", help="Check is binary package is supported", metavar="BINPKG", action='append')
    parser.add_option("--dump", help="Dump support status", action='store_true')
    parser.add_option("--text", help="Output in text formatting", action='store_true')
    parser.add_option("-r", "--release", help="Specify release with --dump", metavar="REL", action='append')
    parser.add_option("--flavor", help="Specify flavor with --dump", metavar="FLAVOR", action='append')

    (opt, args) = parser.parse_args()

    db = dict()

    if opt.download:
        if not opt.seeds_directory:
            error('Must specify --seeds-directory with --download')
        elif not opt.json_file:
            error('Must specify --json-file to write to with --download')
        elif os.path.exists(opt.json_file):
            error("'%s' exists. Aborting" % opt.json_file)

        download_seeds(opt.seeds_directory, opt.force)

        db = read_seeds(opt.seeds_directory)
        json.dump(db, open(opt.json_file, 'w'), -1, encoding="utf-8")
    else:
        if not opt.json_file:
            error('Must specify --json-file to read')
        elif not os.path.exists(opt.json_file) and not opt.seeds_directory:
            error("'%s' does not exist and --seeds-directory not specified. Aborting")
        elif not os.path.exists(opt.json_file):
            db = read_seeds(opt.seeds_directory)
            msg("INFO: creating '%s'" % opt.json_file)
            json.dump(db, open(opt.json_file, 'w'), -1, encoding="utf-8")
        else:
            msg("INFO: reading '%s'" % opt.json_file)
            db = json.load(open(opt.json_file))

    style = "machine"
    if opt.text:
        style = "text"

    if opt.source or opt.binary:
        if opt.source:
            check_package('src', db, opt.source, style)
        if opt.binary:
            check_package('bin', db, opt.binary, style)
    elif opt.dump:
        flavors = []
        if opt.flavor:
            flavors = opt.flavor

        rels = releases
        if opt.release:
            rels = opt.release

        dump_packages(db, rels, style, flavors)

